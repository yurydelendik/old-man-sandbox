{"version":3,"sources":["rust-src:///checkout/src/libcore/fmt/mod.rs","hey.rs","rust-src:///checkout/src/liballoc/heap.rs","rust-src:///checkout/src/libcore/ptr.rs","rust-src:///checkout/src/liballoc/boxed.rs","rust-src:///checkout/src/libstd/panicking.rs","rust-src:///checkout/src/libstd/io/error.rs","rust-src:///checkout/src/liballoc/raw_vec.rs","rust-src:///checkout/src/liballoc/string.rs","rust-src:///checkout/src/liballoc/allocator.rs","rust-src:///checkout/src/libcore/option.rs","rust-src:///checkout/src/libcore/macros.rs","rust-src:///checkout/src/libstd/thread/local.rs","rust-src:///checkout/src/libstd/sys/unix/rwlock.rs","rust-src:///checkout/src/libcore/sync/atomic.rs","rust-src:///checkout/src/libstd/sys_common/thread_local.rs","rust-src:///checkout/src/libstd/sys/unix/thread_local.rs","rust-src:///checkout/src/libstd/sys_common/util.rs","rust-src:///checkout/src/libcore/result.rs","rust-src:///checkout/src/libstd/env.rs","rust-src:///checkout/src/libstd/sys_common/backtrace.rs","rust-src:///checkout/src/liballoc/vec.rs","rust-src:///checkout/src/libcore/slice/mod.rs","rust-src:///checkout/src/libcore/any.rs","rust-src:///checkout/src/libstd/sys_common/thread_info.rs","rust-src:///checkout/src/libstd/ffi/c_str.rs","rust-src:///checkout/src/libcore/cell.rs","rust-src:///checkout/src/libcore/mem.rs","rust-src:///checkout/src/liballoc/arc.rs","rust-src:///checkout/src/libstd/sys/unix/mod.rs","rust-src:///checkout/src/libstd/sys/unix/os.rs","rust-src:///checkout/src/libstd/sys/unix/mutex.rs","rust-src:///checkout/src/libstd/ffi/os_str.rs","rust-src:///checkout/src/libcore/num/mod.rs","rust-src:///checkout/src/libcore/iter/mod.rs","rust-src:///checkout/src/libstd/sys/unix/backtrace/printing/dladdr.rs","rust-src:///checkout/src/libcore/str/mod.rs","rust-src:///checkout/src/libcore/str/pattern.rs","rust-src:///checkout/src/libstd_unicode/char.rs","rust-src:///checkout/src/libcore/iter/iterator.rs","rust-src:///checkout/src/libcore/char.rs","rust-src:///checkout/src/libcore/convert.rs","rust-src:///checkout/src/libstd/sync/mutex.rs","rust-src:///checkout/src/libstd/sync/condvar.rs","rust-src:///checkout/src/libstd/sys/unix/condvar.rs","rust-src:///checkout/src/libcore/cmp.rs","rust-src:///checkout/src/libstd/sys/unix/fd.rs","rust-src:///checkout/src/libstd/sys/unix/stdio.rs","rust-src:///checkout/src/libstd/io/impls.rs","rust-src:///checkout/src/libstd/io/mod.rs","rust-src:///checkout/src/libstd/error.rs","rust-src:///checkout/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs","rust-src:///checkout/src/libcore/ops/arith.rs","rust-src:///checkout/src/libstd/thread/mod.rs","rust-src:///checkout/src/libstd/sys_common/mutex.rs","rust-src:///checkout/src/libstd/sys_common/condvar.rs","rust-src:///checkout/src/libcore/nonzero.rs","rust-src:///checkout/src/libstd/sys/unix/memchr.rs","rust-src:///checkout/src/libcore/fmt/builders.rs","rust-src:///checkout/obj/<assert macros>","rust-src:///checkout/obj/<panic macros>","rust-src:///checkout/src/libcore/clone.rs","rust-src:///checkout/src/liballoc/slice.rs","rust-src:///checkout/src/libstd/sys/unix/os_str.rs","rust-src:///checkout/src/libstd/sys_common/poison.rs","rust-src:///checkout/src/libstd/sys_common/at_exit_imp.rs","rust-src:///checkout/src/libstd/io/lazy.rs","rust-src:///checkout/src/libstd/sys_common/mod.rs","rust-src:///checkout/src/libstd/io/stdio.rs","rust-src:///checkout/src/libstd/sys_common/remutex.rs","rust-src:///checkout/src/libstd/io/buffered.rs","rust-src:///checkout/src/libstd/memchr.rs","rust-src:///checkout/src/libstd/sys_common/memchr.rs","rust-src:///checkout/src/libstd/sync/once.rs","rust-src:///checkout/src/libstd/sys/unix/args.rs","rust-src:///checkout/src/libcore/ops/function.rs","rust-src:///checkout/src/libstd/rt.rs","rust-src:///checkout/src/libcore/iter/range.rs","rust-src:///checkout/src/libpanic_unwind/emcc.rs","rust-src:///checkout/src/libpanic_unwind/lib.rs","rust-src:///checkout/src/libunwind/libunwind.rs","rust-src:///checkout/src/liballoc/oom.rs","rust-src:///checkout/src/liballoc/str.rs","rust-src:///checkout/src/liballoc_system/lib.rs","rust-src:///checkout/src/libstd_unicode/tables.rs","rust-src:///checkout/src/libstd_unicode/lossy.rs","rust-src:///checkout/src/libcore/iter/traits.rs","rust-src:///checkout/src/libcore/panicking.rs","rust-src:///checkout/src/libcore/fmt/num.rs","rust-src:///checkout/src/libcore/char_private.rs","rust-src:///checkout/src/libcore/ops/range.rs"],"names":[],"mappings":"m+PA6TA,0CACA,0CAEA,qBACA,OACA,qBAHA,sEAKA,0CCnUA,uCACA,0DCqIA,SCqfA,WDpZA,IEUA,qBCsTA,gGCjCA,8DACA,ON7OA,QM8OA,mDN1MA,oEM0MA,sCACA,SC0HA,YDtHA,OAPA,EAKA,cArVA,kYAkBA,WAmUA,qBNjPA,IMiPA,sBN7MA,gEM6MA,iBAEA,OAPA,EAIA,qBFIA,8DEDA,uEE/KA,mCRjJA,6FK2TA,SL3TA,UK0TA,uCF7cA,kODsLA,cAGA,YCzLA,ODsLA,OACA,OAvCA,UChJA,ODgJA,SChJA,mBDsLA,cAGA,WAGA,EANA,OACA,OAvCA,SA4CA,mBA5CA,SA4CA,oDENA,gBF1GA,SCqfA,WDpZA,cEUA,gBCsTA,0BE4FA,IJzkBA,+DI8jBA,6BAKA,EAvbA,OEzFA,SC6NA,OAEA,WCxTA,ODsTA,4BAEA,qBH8SA,gBGhTA,OAEA,WCxTA,ODsTA,4BHiTA,yCAEA,iEFxDA,qBAEA,iDOnUA,yCFuCA,eACA,qBEpCA,kBTnEA,0BSmEA,qBTnEA,OE2YA,WLlRA,sEKmRA,6BAEA,GAHA,MAOA,6EQvjBA,wDAoBA,2BApBA,iBAqBA,2BACA,eAyDA,UC20CA,yBTz1BA,sDACA,mESq2BA,yBDx1CA,ORwfA,YAUA,OLnTA,sEK8SA,6BAEA,IQ9kBA,IAyBA,uBD2MA,QP8WA,wBS6yBA,QCzwCA,4BCvHA,Mb4lBA,YS1LA,OAGA,OAHA,YAGA,IAvQA,IVvDA,SCqfA,WDpZA,IUkOA,sBEs9BA,QCzwCA,4BC7HA,WJoKA,kFK9JA,wBCyaA,2Cf9YA,iCc1BA,Ed0BA,4GDsLA,cAGA,YCzLA,ODsLA,OACA,OAvCA,UAyCA,aenNA,mMLoOA,IFuCA,WACA,SEpCA,oBTnEA,2BSmEA,cPiFA,0BOjFA,UEwpCA,mDKxrCA,UCzEA,2DbuCA,Scm8CA,0CCw1BA,mBAKA,uBFv0EA,YEu0EA,MALA,MDx1BA,ECw1BA,cAKA,kCALA,WDx1BA,WdtgCA,oCa5dA,qCb4dA,Qa1dA,oCN2uCA,sBAYA,0BMrwCA,afiMA,SAIA,mDACA,sBACA,0BAEA,yBkB/LA,qClBgMA,gEkBhMA,mBlBkMA,sBEjKA,Scm8CA,6BhBlyCA,UADA,aADA,iBAMA,QO/KA,KAsIA,cP0CA,qCmBhVA,KnBgVA,SKxHA,SAuWA,yCAvWA,8DewMA,kBAicA,SH9BA,kBACA,oBADA,mCV7hBA,UF2BA,sCLgBA,uBAEA,mGSgjCA,SCzwCA,sECvHA,QJiaA,6CFpJA,yBEoJA,cV1TA,UCqfA,kBDpZA,iBUkOA,0BEs9BA,SCzwCA,sEC7HA,eJuaA,QAxLA,uBTpEA,QACA,sCSmEA,gBcmuBA,uBRnPA,kBfnjBA,OuB+7BA,QvBh8BA,SACA,eOoEA,gDLyHA,2BACA,4DAOA,gFAPA,iCACA,2DAQA,4BAPA,yBS0hCA,QCzwCA,sFCvHA,OJiaA,4CFpJA,wCEoJA,aV1TA,SCqfA,eDpZA,sBUkOA,wBEs9BA,QCzwCA,8EC7HA,aJuaA,OAxLA,oBTpEA,QACA,0CSmEA,cADA,mBTnEA,SACA,QwBgXA,exBhXA,QuB+7BA,OAzcA,YAkTA,KAlTA,eR4DA,mBf7rBA,iGE6UA,uDF7UA,ODsLA,cAGA,YCzLA,ODsLA,OACA,OAvCA,WG6LA,QFlMA,sBwBgXA,ITmMA,yBbjXA,yCsB8KA,kBZ/ZA,0BVmPA,2BANA,UAUA,wBAVA,cSkkCA,qBcxrBA,eAmCA,uEvBnaA,iDFnVA,4FDsLA,cAGA,gBG0JA,EFnVA,QDsLA,OACA,OAvCA,cGmMA,IAVA,8FOjEA,sGP8TA,wBLtWA,IKwWA,sBY3lBA,gEjBmPA,IiBlPA,sBjBsRA,gEiBtRA,IYqIA,kB1BnHA,iGDsLA,cAGA,WCzLA,EDyLA,OAHA,OACA,OAvCA,SChJA,mBDsLA,cAGA,WAGA,EANA,OACA,OAvCA,SA4CA,0HiBXA,qBEi0DA,SI5zDA,OKqLA,sDCpWA,QN2XA,OKpBA,M3BiDA,sBsBsRA,OHgHA,eACA,kBADA,IQnbA,+BE2SA,iCVwIA,QQ9aA,mBC3WA,QNqbA,OtBjcA,ODyLA,YCzLA,ODgJA,UAyCA,a4BkLA,kEZ4rBA,qBACA,oBY7rBA,sBZyRA,mCAEA,gDCjdA,EDkdA,OCrdA,OnB8CA,QmB7CA,mDnBiFA,oEmBjFA,8BACA,oDDqdA,gDfzoBA,oBIykBA,IJzkBA,mBWq2CA,QCzwCA,4BCvHA,Mb4lBA,YS1LA,OAGA,OAHA,YAGA,IV9TA,SCqfA,WDpZA,IUkOA,sBEs9BA,QCzwCA,gBC7HA,OJwbA,IG3TA,WC7HA,OJwbA,mBTvZA,oBW24CA,qBcxrBA,YzBntBA,EyBsvBA,IzBtvBA,oFWq2CA,QCzwCA,4BCvHA,MJiaA,qCFpJA,cEoJA,YV1TA,SCqfA,WDpZA,IUkOA,sBEs9BA,QCzwCA,4BC7HA,YJuaA,OAxLA,8CTpEA,gBACA,6DACA,gBA5IA,6CW24CA,qBcxrBA,WAmCA,OlB5jBA,kBChOA,mBCoPA,iBctDA,OAsnBA,eRhFA,kCQmFA,IADA,OvBroBA,OuB+7BA,OArhBA,SRwIA,mBRvjBA,cAqBA,OPhBA,WqBrKA,gEAFA,qBEoLA,OAyxBA,gBRnPA,qBMvtBA,kBrBoKA,OekjBA,Of7rBA,mBW24CA,qBcxrBA,eAmCA,4CJlxBA,gBAIA,oBrBwBA,UqB5BA,gBEm8BA,OAEA,OvB9xBA,wBuBsyBA,gBRnPA,kCfnjBA,OekjBA,OR9eA,sBCrPA,wBagBA,kBVs5CA,qBch4BA,WAEA,GAFA,IzBrXA,WSuEA,IgB8SA,0HbnYA,cCrKA,OACA,2ChBuQA,QgBvQA,mDhB2SA,gEgB3SA,QACA,ODoKA,WAGA,OCzKA,OACA,2ChBuQA,QgBvQA,mDhB2SA,gEgB3SA,QACA,OAgBA,KD2JA,4BAPA,YDiyCA,eCjyCA,mBAcA,IClKA,aDkKA,+DGmpBA,sBACA,gBlBhkBA,QkBgkBA,mDlB5hBA,+DWjSA,moBNoVA,yEADA,0KLlDA,8EKkDA,uCFtTA,uNDsLA,kBAGA,eCzLA,SDsLA,SACA,SAvCA,aAyCA,YGsIA,uDSgmCA,uBThmCA,yBAMA,ELjEA,+EK8DA,sBFlUA,uNDsLA,kBAGA,eCzLA,SDsLA,SACA,SAvCA,aAyCA,YCzLA,KEqUA,E0B9TA,oBXIA,SFqhCA,6CErhCA,gBE0xBA,eACA,UF9vBA,SAwCA,6BjBgZA,amB3PA,MFrLA,MEynCA,0BWzlBA,Q9BpCA,WmBmoBA,0BACA,YAyEA,iCnBzxBA,SmBitBA,YAwEA,iCnBzxBA,SmBktBA,YAuEA,iCnBzxBA,kBmBmtBA,YAsEA,iCA8PA,MWv6BA,U9BpCA,YmBmoBA,iDA2EA,8DA3EA,kPAMA,4BnBrtBA,SmBstBA,YAmEA,2BApEA,6BAqEA,+DArEA,YANA,sBZ54BA,yBUnPA,UAcA,eAhDA,oBpBsPA,+EoBrPA,0HA+CA,SAkBA,epBoLA,+EoBlPA,+GAEA,UEixBA,eACA,UnBtUA,8kBmB4kBA,uBnB5kBA,S+BiwBA,Sd3sCA,0Be1DA,WACA,oCAGA,SVqtBA,SHgHA,sBGoFA,YPpmBA,SAEA,SAFA,kBAEA,eAFA,aE9PA,gBAkGA,yBACA,YAEA,WACA,mBADA,OAFA,KAMA,6EpBuJA,mDoBvJA,4DFw6BA,gCE96BA,uBAWA,kBpBkJA,mDoBlJA,4DFm6BA,iCE96BA,eAcA,cACA,qEF+5BA,gCE91BA,cjBsRA,QiC0xDA,8Bd6KA,eAKA,qCet7DA,QDgwDA,gBjCtxDA,QiC0xDA,6Cd6KA,aAKA,qCczvBA,sBjCntCA,QiC0xDA,6DhBhjEA,oBAGA,4BAHA,ejBsRA,QiC0xDA,8Bd6KA,eAKA,sCet7DA,SDgwDA,mBjCtxDA,SiC0xDA,8Cd6KA,eAKA,wCczvBA,sBjCntCA,SiC0xDA,gEhBhjEA,ejBsRA,QiCwuCA,SjCxuCA,oBmB4kBA,kCnB5kBA,SiCxFA,sDA3BA,mBd+rBA,2BnB5kBA,SiCrGA,SADA,sBATA,6BAiCA,mCd0pBA,2BnB5kBA,SiCrGA,SADA,sBATA,6BAsCA,mBACA,mCdopBA,2BnB5kBA,SiCrGA,SADA,sBAkCA,qBA3CA,6BA2CA,wBEiTA,sBACA,4DlBrfA,4BEm1BA,8CF90BA,uBAGA,Scs7CA,+CACA,SZ5mBA,8BnB5kBA,SiCxFA,sCdoqBA,wBnB5kBA,SiC9EA,cd0pBA,Uc1pBA,UjC8EA,SiCxEA,cdopBA,UcppBA,UjCwEA,SiCxEA,ejCwEA,AiC9EA,cjC8EA,OoCvWA,SL8hDA,sDdt7CA,mCjB+PA,cmB4kBA,yBnB5kBA,KkCQA,iBD0nDA,iCAlmCA,iBAFA,iDACA,QA/HA,yIACA,QC9UA,SlCnFA,UiCwuCA,UAp0BA,sBAGA,cAuHA,EAEA,8BhBjxBA,2BACA,oDACA,sCE2zBA,wBnB5kBA,OiCxFA,2DA3BA,mBd+rBA,uBnB5kBA,OiCrGA,QADA,oBATA,qCAiCA,iCd0pBA,uBnB5kBA,OiCrGA,QADA,oBATA,qCAsCA,mBACA,iCdopBA,uBnB5kBA,OiCrGA,QADA,oBAkCA,qBA3CA,6BA2CA,sBIjEA,4BACA,8BACA,4CAFA,SAKA,sC9B/DA,MAEA,mDUnDA,ajBgPA,aiC41DA,gDhB9jEA,mEjBkOA,mDiCxFA,uCA3BA,mBd+rBA,yBnB5kBA,QiCrGA,SADA,sBATA,6BAiCA,6Bd0pBA,2BnB5kBA,SiCrGA,SADA,sBATA,6BAsCA,mBACA,6BdopBA,qBcjrBA,SADA,gBAkCA,qBA3CA,6BA2CA,kBEiTA,sBACA,sCADA,iDF6iDA,4CAndA,QjCv0CA,UmB4kBA,kDFtyBA,SgBg/DA,iCAEA,yBjCxxDA,UiC0xDA,yCKj3DA,YvB0RA,SAEA,8BAFA,SkBmlDA,iCjCtxDA,aiCwxDA,wBjCxxDA,SiC0xDA,8CAndA,SA+cA,uBAEA,cjCxxDA,QiC0xDA,6DAFA,gCAFA,gBdiLA,eAKA,iDclLA,wCAndA,6BA+cA,yCjCtxDA,SiC0xDA,6CAJA,gBdiLA,kBAKA,qDclLA,+Bd6KA,UAKA,eALA,yBcjLA,uBAEA,cjCxxDA,SiC0xDA,kDAJA,oDdiLA,kBAKA,oDclLA,+Bd6KA,kBAKA,oDclLA,+Bd6KA,kBAKA,oDclLA,+Bd6KA,kBAKA,oDclLA,+Bd6KA,kBAKA,oDclLA,+Bd6KA,kBAKA,oDclLA,+Bd6KA,gBAKA,uCFvoEA,kEjB2LA,ciC0xDA,wCAndA,wBhBlgDA,kEjB2LA,ciC0xDA,wCAndA,wBhBlgDA,kEjB2LA,ciC0xDA,wCAndA,wBhBlgDA,kEjB2LA,ciC0xDA,wCAndA,wBhBlgDA,kEjB2LA,ciC0xDA,wCAndA,wBhBlgDA,kEjB2LA,ciC0xDA,wCAndA,wBhBlgDA,kEjB2LA,ciC0xDA,wCAndA,wBA+cA,cjCtxDA,SiC0xDA,2CAJA,gBdiLA,gBAKA,iCFvoEA,uEjB2LA,aiCwxDA,wBjCxxDA,SiC0xDA,8CAndA,wBA+cA,oBAEA,kBjCxxDA,SiC0xDA,wCd6KA,kBAKA,0CcpLA,iCAEA,8Bd6KA,kBAKA,0CcpLA,iCAEA,8Bd6KA,kBAKA,0CcpLA,iCAEA,8Bd6KA,kBAKA,0CcpLA,iCAEA,8Bd6KA,kBAKA,0CcpLA,iCAEA,8Bd6KA,kBAKA,0CcpLA,iCAEA,8Bd6KA,kBAKA,0CcpLA,iCAEA,8Bd6KA,kBAKA,0CcpLA,iCAEA,8Bd6KA,kBAKA,0CcpLA,iCAEA,8Bd6KA,gBAKA,iCFvoEA,uEjB2LA,aiCwxDA,wBjCxxDA,SiC0xDA,8CAndA,wBhBlgDA,uEjB2LA,aiCwxDA,wBjCxxDA,SiC0xDA,8CAndA,wBhBlgDA,uEjB2LA,aiCwxDA,wBjCxxDA,SiC0xDA,8CAndA,wBhBlgDA,uEjB2LA,aiCwxDA,wBjCxxDA,SiC0xDA,8CAndA,wBhBlgDA,uEjB2LA,aiCwxDA,wBjCxxDA,SiC0xDA,8CAndA,wBhBlgDA,uEjB2LA,aiCwxDA,wBjCxxDA,SiC0xDA,8CAndA,wBhBlgDA,uEjB2LA,aiCwxDA,wBjCxxDA,SiC0xDA,8CAndA,wBhBlgDA,uEjB2LA,aiCwxDA,wBjCxxDA,SiC0xDA,8CAndA,wBhBlgDA,uEjB2LA,aiCwxDA,wBjCxxDA,SiC0xDA,8CAndA,wBhBlgDA,uEjB2LA,aiCwxDA,wBjCxxDA,SiC0xDA,8CAndA,wBdgoBA,0Bc7KA,uCd9sCA,SnB5kBA,SiCxFA,uCA3BA,mBd+rBA,yBnB5kBA,SiCrGA,SADA,sBATA,6BAiCA,6Bd0pBA,yBnB5kBA,SiCrGA,SADA,sBATA,6BAsCA,mBACA,6BdopBA,oBcjrBA,SADA,gBAkCA,qBA3CA,6BA2CA,kBhB9IA,4BACA,4EEwpEA,cFrpEA,2EgBo+DA,mBAEA,wBjCxxDA,SiC0xDA,8CAndA,sBA+cA,cjCtxDA,UmB3PA,qBAo0BA,KAGA,uBnB5kBA,QiCxFA,2DA3BA,mBd+rBA,iCnB5kBA,QiCrGA,SADA,kCATA,6BAiCA,mCd0pBA,iCnB5kBA,SiCrGA,SADA,kCATA,6BAsCA,mBACA,mCdopBA,2BnB5kBA,SiCrGA,SADA,4BAkCA,qBA3CA,6BA2CA,wBAsJA,oBhBrPA,4EgBy7DA,mCAEA,yBjCxxDA,UiC0xDA,yChBz7DA,wEjB+JA,ciCwxDA,yBjCxxDA,UiC0xDA,8CAndA,sBAqhBA,wChBvhEA,qEgBuhEA,4ahB9jEA,2BgB8jEA,OhB7iEA,2BgB6iEA,OhB1iEA,2BgB0iEA,OhBvhEA,2BgBuhEA,2mBhB3/DA,8BAvHA,gBA+BA,4FA/BA,4CF81BA,iCE75BA,yCAjBA,oBFs6BA,SE1gCA,uCjB0cA,ykBmBsUA,anBtUA,EiCovCA,kBjCpvCA,uBQtgBA,YRsgBA,EiCoyCA,oBjCpyCA,EemMA,kBAGA,YftMA,EiCm1CA,kBjCn1CA,keiCoyCA,oBjCpyCA,EiCm1CA,sBhBxyDA,uDWCA,QXVA,MjBFA,iCEqUA,EFrUA,wIDsLA,kBAGA,eCzLA,SDsLA,SACA,SAvCA,aAyCA,eG4IA,mBH/IA,cAGA,WAGA,EANA,OACA,OAvCA,SA4CA,mBwB2uBA,OAEA,OvB9xBA,OA3IA,iIDsLA,cAGA,WCzLA,EDyLA,OAHA,OACA,OAvCA,SChJA,mByBsbA,OAIA,WzBiuBA,OuBjFA,OZiUA,qBc/8BA,YAIA,E1BhTA,S0BgTA,mBzBhcA,iGDsLA,cAGA,WCzLA,EDyLA,OAHA,OACA,OAvCA,SChJA,6CsBicA,OtBjcA,cDyLA,YCzLA,ODgJA,WChJA,OuCuTA,OXjSA,K5BtBA,ODgJA,SChJA,OwC+ZA,OCrTA,KzC1GA,ODgJA,SChJA,wC0CixBA,OA7WA,gBChYA,WjB4CA,WC9EA,YDuFA,qBiBjDA,cChDA,qBCHA,mBDOA,OCJA,mBAIA,kBACA,0CAIA,6DACA,yEC8hCA,+CACA,6DAWA,SAVA,2BAGA,O/Bh0BA,OAqBA,sB+B4yBA,oBAMA,E/BlzBA,IgCrGA,uCDu5BA,SCv5BA,U9CiCA,gBF1GA,SCqfA,eDpZA,qB+C+3BA,S9C3eA,UC1YA,gBF3GA,SCqfA,YC1YA,qEEGA,I2C82BA,sC9CveA,IDpZA,qB+C+3BA,U9C5iCA,sB8C4iCA,E9C5iCA,iC8C4iCA,E9C5iCA,iIDsLA,cAGA,YCzLA,ODsLA,OACA,OAvCA,UChJA,ODgJA,a+C45BA,mB9C5iCA,yDIykBA,IJzkBA,mBI4IA,Ocm8CA,c6Bn9CA,wCAjCA,0BASA,2B3CwCA,Ocm8CA,cblBA,W0C37CA,iDlDspCA,YkD/pCA,OADA,yC/CxHA,mBHo4CA,OOxvCA,Ocm8CA,cbVA,WRjMA,4CiD9WA,kBACA,0BAMA,IALA,c9CxhCA,uE8CyhCA,oB9CzhCA,sB8C6hCA,0DTpnBA,YACA,oBAEA,cACA,8CAGA,aACA,oCACA,sBrC+MA,OqC/MA,2BAIA,oCACA,sBrC0MA,OqC1MA,eACA,sBrCyMA,OqCzMA,8BAZA,sBrCqNA,2B8CqZA,kBACA,0BjDj7BA,IiDk7BA,c9CxhCA,uE8CyhCA,oB9CzhCA,sBHsGA,iDA6CA,iEACA,mBGpJA,4CHuIA,OiD+4BA,kBACA,0BjD/4BA,IiDg5BA,c9CxhCA,uE8CyhCA,oB9CzhCA,sBHwIA,mBAGA,eACA,iDAGA,OAIA,iEAHA,iEsB7DA,4DwB/CA,WjB4CA,WC9EA,YDuFA,qBiBjDA,cChDA,cEm+BA,uD3CtiBA,2CuBrYA,yBvBqYA,8CA7ZA,0BHxBA,qGDsLA,cAGA,YCzLA,ODsLA,OACA,OAvCA,UAyCA,UCzLA,I8C29BA,uB3BxLA,kBnBnUA,OmByTA,OAtsBA,wC4BkEA,uCD40BA,SC50BA,U9CiCA,gBF1GA,SCqfA,eDpZA,qB+CozBA,S9ChaA,UC1YA,gBF3GA,SCqfA,YC1YA,qEEGA,I2CiyBA,sC9C1ZA,IDpZA,qB+CozBA,S3B94BA,WAitBA,yB2B6LA,S3B94BA,O2B44BA,sB3B54BA,enBnFA,iCmBmFA,I2Bg5BA,GADA,WACA,mBjDiaA,qBAUA,WAVA,iDmDp5CA,oCAKA,qCAUA,8CAOA,KjDsEA,SCqfA,WDpZA,IEUA,OF3GA,SCqfA,WDpZA,IEUA,qEEGA,I6CxLA,qDAIA,4CnD29CA,cACA,OAMA,kBACA,cAEA,kBACA,0BADA,MAHA,KAOA,cAEA,uBAEA,OACA,WA+BA,iDoCrnBA,4CAsBA,EApBA,kCACA,OACA,OACA,qCAy5CA,gBAz5CA,gCACA,wCADA,IAiBA,GCjYA,cAyHA,iFAtCA,aACA,qBD+mDA,0BAEA,mBjCxxDA,OiC0xDA,kCAJA,ejCtxDA,ciCpDA,2CdmuBA,gBnB/qBA,OiCrGA,OAdA,eASA,yBdyxBA,gBnB/qBA,OiCrGA,OAdA,eASA,yBdyxBA,gBnB/qBA,OiCrGA,OADA,YAbA,QAIA,kCAKA,MdyxBA,kCczxBA,MdyxBA,uCcumCA,WC3mDA,kBGxPA,QAEA,QAEA,qBAFA,YAEA,AAJA,YH0PA,0BA+BA,ODwlCA,mBCplCA,UDolCA,OCrlCA,yCAMA,OACA,mEAGA,oBAIA,uBD6OA,kBAMA,OACA,8BAuxBA,gBA9xBA,4BACA,eA6xBA,OA5xBA,gBjC5cA,gCiCodA,iElBrJA,6BACA,gBlBhkBA,QkBgkBA,mDlB5hBA,+DWjSA,yES+EA,eetFA,WACA,2BAGA,kBVqtBA,SHgHA,cACA,QGmFA,YPpmBA,SAEA,SAFA,kCElOA,uBADA,KiBsbA,gBA8HA,oEA1CA,OAMA,qBAPA,eACA,kBD0rDA,iCjCtxDA,aiCwxDA,uBjCxxDA,SiC0xDA,6CjC1xDA,SiCu0CA,SjCv0CA,UmB4kBA,0BnB5kBA,kBiCxFA,mDA3BA,mBd+rBA,0BnB5kBA,kBiCrGA,SADA,sBATA,6BAiCA,mBd0pBA,2BnB5kBA,SiCrGA,SADA,sBATA,6BAsCA,mBACA,mBdopBA,qBcjrBA,SADA,gBAkCA,qBA3CA,6BA2CA,qBAJA,YANA,ad0pBA,ae5eA,sBG7KA,UAEA,UAEA,wBAFA,aAEA,AAJA,aH+KA,iCDivCA,uCCpsCA,QACA,iFA+QA,QACA,QAKA,mBACA,uGlCtaA,SkCsaA,SArBA,6DAkCA,OAdA,QACA,uCQvHA,QO3tBA,sBf02BA,Qf3KA,oBe2KA,ef3KA,Oe2KA,2CACA,eA1BA,QACA,8CQvHA,QOjpBA,oBf4yBA,2BfvLA,oBeuLA,cfvLA,OeuLA,2CACA,QAtCA,QACA,yCAaA,sBAbA,QfnJA,mBeoMA,wBfpMA,2BeuLA,eApCA,QAaA,aAbA,2HlCtaA,OkCsaA,OArBA,oDAkCA,OAdA,QACA,sCQnHA,OAjYA,aAiYA,UAJA,QO3tBA,qBf02BA,Qf3KA,oBe2KA,ef3KA,Oe2KA,2CACA,cA1BA,QACA,sDQvHA,QOjpBA,sBf4yBA,4BfvLA,qBeuLA,cfvLA,OeuLA,2CACA,OAtCA,QACA,iDAeA,OAFA,0BAbA,QfnJA,oBeoMA,eAEA,gBftMA,6BeuLA,eApCA,QAeA,OAFA,iBAEA,OAFA,eAbA,oCAhSA,cfwgBA,wCAKA,IatpCA,cbmpCA,cACA,YAEA,qBehKA,OAMA,OJgvBA,OI/uBA,2FlC1fA,OkC0fA,OAzGA,6CAsHA,YAEA,QJguBA,OI/uBA,wCAsBA,OQ/NA,OA7WA,YA6WA,KRyMA,eQ3MA,OOjpBA,cfo3BA,0Bf/PA,mBe+PA,cf/PA,Oe+PA,0CACA,0BAEA,QJotBA,OI/uBA,2BAmCA,OADA,YACA,QQ9OA,OO3tBA,mBf28BA,0Bf5QA,mBe4QA,cf5QA,Oe4QA,0CACA,mBAEA,QJusBA,OI/uBA,kCfvOA,kBewRA,YAEA,QAgIA,mCA3HA,Ef/RA,yBe+PA,kBAaA,iBAnCA,OA+KA,OAzHA,0CcvgCA,OAEA,QAEA,iDAmBA,MAGA,qCASA,IATA,OACA,4CAIA,yBAIA,mBhD9CA,mBgD9BA,yCDyHA,0BASA,iEC7HA,sBnDyPA,QmDzPA,mDnD6RA,gEmD7RA,aACA,iDnDgzCA,YmD3zCA,OADA,yChDoCA,mBHo4CA,OAUA,SAVA,0BAUA,SAVA,iDYl+BA,OACA,OEk8BA,OCzwCA,uDH2UA,UG3UA,WC7HA,OW2nBA,Yb2wBA,OCzwCA,gBC7HA,WJwcA,EG3UA,UC7HA,WJwcA,mBTvaA,iKDsLA,cAGA,YCzLA,ODsLA,OACA,OAvCA,YChJA,ODgJA,SChJA,mBDgJA,SA4CA,+DgBmmBA,sBACA,gBlBhkBA,QkBgkBA,mDlB5hBA,+DWjSA,yHD6WA,gBAEA,uC+BAA,uDhB5JA,6BPqgBA,OAEA,WAFA,uCAEA,4BACA,oDuB5WA,Q/BGA,mC2CggBA,qBtB90BA,QsBixBA,sBtB5wBA,YsB8wBA,sBAIA,gBtBlxBA,Q7BgEA,SCqfA,eDpZA,gBCoZA,8BmDlmBA,kBZiJA,IXpHA,KAEA,OAEA,OAEA,KWqHA,YxC3CA,SCqfA,iBDpZA,8BCoZA,oFoDjmBA,kBZ+GA,IADA,yBYvGA,kCZ+GA,gBADA,OU+vBA,OnDxwBA,SCqfA,WDpZA,I0B6CA,6E4BvOA,QHw2BA,MAFA,wBAjEA,4ClDxxBA,2BW24CA,qBcxrBA,YzBntBA,EyBmtBA,OAmCA,IzBtvBA,mBuBu6BA,OAEA,OvB9xBA,OA3IA,2EsByLA,gBlB7CA,Ocm8CA,coCznDA,WtD2mBA,YsDnmBA,ehC6NA,0DAGA,EtBmYA,UsB7WA,oBACA,oCAGA,UJwrBA,cdzvBA,ccyvBA,iBACA,kCIzrBA,UJyrBA,eADA,MdpwBA,OJqfA,OAzXA,OkB8oBA,+BI/rBA,gDA3BA,uCAEA,iEPimBA,+CACA,gBlBhkBA,QkBgkBA,mDlB5hBA,mEWjSA,0BO8zBA,yBfjyBA,oBIykBA,IJzkBA,uCsBicA,OtBjcA,cDyLA,WCzLA,EDyLA,OAzCA,SChJA,yMyCZA,aACA,4B5C2OA,Q4C3OA,mD5C+QA,gE4C/QA,QACA,eACA,4B5CyOA,Q4CzOA,mD5C6QA,gE4C7QA,QACA,eACA,4B5CuOA,Q4CvOA,mD5C2QA,gE4C3QA,QACA,aACA,+BACA,E5CoOA,Q4CrOA,mD5CyQA,gE4CzQA,wBDoaA,OCrTA,KzC1GA,ODgJA,SChJA,mBuCuTA,OXjSA,K5BtBA,ODgJA,SChJA,wDsByGA,OzB+qCA,YyB/qCA,OAFA,WAEA,OAFA,yCtBvGA,OIykBA,IJzkBA,oEHo4CA,OOxvCA,Ocm8CA,crB9RA,OGj1BA,OmB4kBA,WtB2gBA,WAnLA,IsBxVA,QnB5kBA,OuDhIA,OACA,WpC2sBA,uBtB2gBA,WAnLA,mBGp4CA,mBHo4CA,OAUA,SAVA,mBGp4CA,mBHo4CA,OAUA,SAVA,0CqB39BA,cdlRA,c0BkjDA,O1Bp4CA,gBcqGA,EYi8CA,kBvBznDA,SiDzSA,WCDA,OrDsYA,kBACA,UAEA,qBAKA,mBE6HA,GF5HA,cAGA,OACA,Wc+EA,iDd3MA,2BAGA,gBACA,kCAIA,OoD9RA,WCDA,OrDkSA,2BACA,sCAKA,WAIA,OACA,WAEA,EE4NA,6DYSA,gBAhCA,qBdkFA,OoDrkBA,eCDA,wBvC2hBA,Ud6CA,iBASA,kCctDA,UlB3NA,mBIoRA,YAEA,4Dc3DA,Ud4DA,kBACA,gCE7EA,MF6DA,eJpVA,OIhDA,SAuaA,YchFA,4CdsGA,IJzkBA,4HMmDA,SC6NA,OAEA,WCxTA,ODsTA,4BAEA,qBDrCA,SCmGA,mCD7RA,SC6NA,OAEA,WCxTA,ODwXA,cAlEA,4BAEA,qBDrCA,SCmGA,mCAEA,kBDmlBA,2FACA,+DoDh1BA,4BpDi1BA,uDS3hBA,qBAEA,gBAFA,cAGA,mBADA,yBTgiBA,IAHA,sDAGA,0FA33BA,SC6NA,OAEA,WCxTA,ODsTA,4BAEA,qBDrCA,SCmGA,OAEA,WACA,QAHA,4BAEA,mCDiiBA,0BAr3BA,OoDwFA,cpD+xBA,8BSzeA,qBAEA,gBAFA,cAGA,mBADA,yBT+eA,GAFA,sDAEA,0CG3dA,OACA,OEk8BA,OCzwCA,mDH2UA,kBG3UA,WC7HA,ObiCA,oDW24CA,qBcxrBA,eAmCA,kCzBtvBA,qBDgJA,SYqtCA,OCzwCA,gBC7HA,WJwcA,EG3UA,UC7HA,WJwcA,mBTvaA,2DW24CA,qBcxrBA,eAmCA,kCzBtvBA,2BDgJA,SChJA,mBDgJA,SA4CA,wEyDnPA,WCDA,OrDuFA,kBAOA,SG0OA,OAEA,WCxTA,ODsTA,4BH1OA,8BAGA,uCE0aA,KFraA,Ic4PA,uCAs/CA,oCyCtrDA,UzCw+BA,OAitBA,OAtrCA,OdjeA,OJqfA,OmB9BA,oBwC1fA,oBAgyCA,kEZpvCA,uCzB+bA,UyB/bA,U9CiCA,gBF1GA,SCqfA,eDpZA,qBuBuaA,UtBnBA,UC1YA,gBF3GA,SCqfA,YC1YA,qEEGA,sDH1LA,OIykBA,QkBWA,EtBnBA,IDpZA,qBuBuaA,yBAnJA,ctBjcA,cDyLA,WCzLA,EDyLA,OAzCA,SChJA,sCHo4CA,yB+Dh6CA,8B/D06CA,eAVA,0CqBp/BA,cdzPA,c0BkjDA,O1B7xCA,gBc3BA,EY09CA,kBvBznDA,SHsHA,OsC2aA,OAjYA,YczcA,WCDA,OrD4eA,kBACA,UAEA,qBAIA,mBEwBA,GFvBA,cAGA,OACA,Wc/CA,0CTiBA,OACA,OEk8BA,OCzwCA,mDH2UA,UG3UA,WC7HA,OdiLA,SYqtCA,OCzwCA,gBC7HA,WJwcA,EG3UA,UC7HA,WJwcA,mBTvaA,ODgJA,SChJA,mBoBuDA,2BpBvDA,mBHuIA,OqBypDA,OA9sBA,cAitBA,OAtrCA,OdjeA,OJqfA,OmB9BA,UtB3dA,0CAGA,OwCwQA,QAIA,ahCkbA,QauEA,cdzvBA,ccyvBA,WACA,iBADA,KdpwBA,OJqfA,OAzXA,OkB8oBA,yBrB1wBA,IwCyQA,qBAwBA,8CAxBA,IA4BA,oCACA,sBrC+MA,OqC/MA,2BAIA,oCACA,sBrC0MA,OqC1MA,eACA,sBrCyMA,OqCzMA,8BAnCA,sBrC4OA,sBkB+pCA,OA9sBA,cAitBA,OAtrCA,OdjeA,OJqfA,OmB9BA,ctBvdA,iDAGA,OAIA,iEAHA,+N8B3GA,uBACA,WL+oBA,OHgHA,WACA,QQ5vBA,SZynBA,mCAEA,WY3nBA,aAEA,EZ0nBA,2CX1hBA,Ocm8CA,cblBA,WACA,mEU/xBA,oCACA,gBlBhkBA,QkBgkBA,mDlB5hBA,+DWjSA,wBR6BA,mBoBuDA,gFX2EA,IAsIA,WFzBA,WAGA,2BAEA,SclRA,Qd6QA,OAEA,eACA,2BAEA,S2C+aA,OACA,OXlgBA,OX3JA,UnBmMA,6BFuCA,mBACA,qBEpCA,kBTnEA,uBSmEA,8BP4NA,OqBgqBA,OZ2RA,OAxmCA,6CIyaA,6BJzaA,Q4BmGA,ShB0uBA,O2BraA,gClDsfA,OwCxgCA,ODoPA,OCZA,IjB+sBA,cZqVA,eYrVA,OiBvsBA,OAJA,mBAvOA,cC5IA,OF+XA,OhB+rBA,OZ2RA,OAxmCA,mD6B0IA,iCAvOA,sCUygBA,UvC5aA,OIyaA,6BJzaA,OuC2aA,OWtrBA,6BpDwNA,6BFuCA,eACA,qBEpCA,kBTnEA,wBSmEA,cP4NA,YqBgqBA,OZ+QA,U4Bx+BA,OXrWA,M5B+oCA,OWgPA,qBcxrBA,gByB1CA,EzB6EA,QyB7EA,MzC/dA,yCTi9BA,OWgPA,qBcxrBA,YzBntBA,EyBsvBA,IzBtvBA,mEe+xBA,oCACA,gBlBhkBA,QkBgkBA,mDlB5hBA,mEWjSA,0BO8zBA,yBwBjbA,OsB9XA,iCpDwNA,IFuCA,WACA,SEpCA,kBTnEA,wBSmEA,cP4NA,YqBgqBA,OZ+QA,U4Bx+BA,cXrWA,M5BZA,mB6D2DA,YACA,mBtBoTA,OsB9XA,iCpDwNA,IFuCA,WACA,SEpCA,kBTnEA,wBSmEA,cP4NA,YqBgqBA,OZ+QA,U4Bx+BA,cXrWA,M5BZA,4CA2pCA,OkD5RA,OX7tBA,OX3JA,MnBmMA,IFuCA,eACA,SEpCA,kBTnEA,uBSmEA,8BP4NA,OqBgqBA,OZ2RA,OAxmCA,6CIyaA,aQoaA,O2B1MA,wBACA,OVljBA,cC/UA,MSg4BA,IX/gBA,OXrWA,UsBw3BA,EzC1rBA,IFuCA,WACA,SEpCA,kBTnEA,qBuCsOA,OXrWA,UsBw3BA,EzCtrBA,cP4NA,WqCzDA,OXrWA,UsBw3BA,EvCqdA,O4Bx+BA,OXrWA,UsBw3BA,kLhCpfA,cdzPA,c0BkjDA,O1B7xCA,gBc3BA,EY09CA,kBvBznDA,SHsHA,OsC2aA,OAjYA,YZ2gDA,sBvB3qDA,SiDzSA,WCDA,OrD4eA,kBEjYA,SC6NA,OAEA,WCxTA,ODsTA,4BAEA,qBDrCA,SCmGA,OAEA,WACA,YAHA,4BAEA,mCDiiBA,8BoD7xBA,cpD+xBA,8BSzeA,qBAEA,wBR5DA,ODyiBA,0BCziBA,SHqGA,OEpYA,SC6NA,OAEA,WCxTA,ODsTA,4BAEA,qBDrCA,SCmGA,mCD7RA,SC6NA,OAEA,WCxTA,ODwXA,cAlEA,4BAEA,qBDrCA,SCmGA,mCAEA,kBDmlBA,2FACA,2EoDh1BA,4BpDi1BA,uDS3hBA,qBAEA,yBTwhBA,YAKA,0BALA,SF3eA,YEwBA,GFpBA,OACA,Wc/CA,mBAo6BA,4BlBrzCA,mBI4IA,Oc88CA,clB1lDA,+CIykBA,sCJzkBA,kNI8jBA,6BJ9jBA,EI4IA,OEzFA,SC6NA,OAEA,WCxTA,ODsTA,4BAEA,qBH8SA,gBGhTA,OAEA,WCxTA,ODsTA,4BHiTA,yCJjkBA,mG8DQA,qBlCDA,QkChCA,4C/DqGA,SCqfA,YkB3TA,mC4C7RA,gB9DwlBA,IDpZA,qB+DzJA,uBA7CA,ElCqCA,Q5BZA,wDDsLA,cAGA,mB+DrKA,I/DkKA,OACA,OAvCA,iB+D5HA,OA7CA,M5Cs6BA,qBAGA,cdzvBA,ccyvBA,iBACA,qDAOA,iEARA,MdpwBA,OJqfA,UAzXA,2BkB8oBA,qBU14BA,gBkCQA,mB9DpBA,kGDsLA,cAGA,WCzLA,EDyLA,OAHA,OACA,OAvCA,SChJA,gLI+NA,yBAGA,OE/KA,SC6NA,OAEA,WCxTA,ODsTA,4BAEA,qBDrCA,SCmGA,OAEA,WACA,YAHA,4BAEA,mCDiiBA,8BoD7xBA,cpD+xBA,8BSzeA,qBAEA,wBR5DA,ODyiBA,0BCziBA,aH3GA,OoD9RA,uBCDA,OrDkSA,cEvLA,SC6NA,OAEA,WCxTA,ODsTA,4BAEA,qBDrCA,SCmGA,mCD7RA,SC6NA,OAEA,WCxTA,ODwXA,cAlEA,4BAEA,qBDrCA,SCmGA,mCAEA,kBDmlBA,2FACA,2EoDh1BA,4BpDi1BA,uDS3hBA,qBAEA,yBTwhBA,YAKA,0BALA,aFtrBA,eAIA,OACA,WAEA,EE4NA,mBP7RA,cAGA,WAGA,EANA,OACA,OAvCA,SA4CA,iD6BrLA,OLiJA,QwC9KA,yBhEkGA,SCqfA,WDpZA,IEUA,Q+DpJA,UDjCA,8BACA,UpD63CA,qBch4BA,WAEA,G1BtbA,SCqfA,eDpZA,qBgEtKA,U9DgLA,OuBkUA,IxB9WA,uB+DxIA,MAxBA,cADA,c/DirCA,OWqOA,qBch4BA,WAEA,UGtfA,OrBmOA,OAEA,eACA,0BAEA,UAHA,Q0DgHA,I1DhHA,mBP06BA,OWgPA,qBcxrBA,YzBntBA,EyBsvBA,KzBtvBA,uCW24CA,qBcxrBA,YzBntBA,EyBsvBA,KzBtvBA,mByBsbA,OAIA,OyCtYA,OtCyBA,K5B7EA,ODgJA,SChJA,YA2pCA,OuBjFA,OZiUA,qBc/8BA,YAIA,E1BhTA,S0BgTA,0ClB1TA,cADA,iBHocA,QJzkBA,EmE+cA,gC/D0HA,QJzkBA,EmE+cA,IAEA,4CnEjdA,UmEidA,wLpE3RA,cAGA,YCzLA,ODsLA,OACA,OAvCA,UAyCA,WKgZA,QJzkBA,0EkBklCA,ciDhwBA,OACA,qBAoBA,oBACA,EArBA,8EACA,O5DrIA,+BWg4CA,OC5yBA,kBAVA,O8ChvBA,0B7DmGA,OJoVA,O0CiTA,OA7WA,gBChYA,WjB4CA,YuCZA,4BtClEA,Ye6rBA,gBuB3nBA,qBEkRA,OhE+FA,gDuBrYA,yBvBqYA,kBACA,iBADA,kBA7ZA,0BHxBA,yGDsLA,cAGA,YCzLA,ODsLA,OACA,OAvCA,UAyCA,gBkEhJA,+CE6SA,OAGA,yBAKA,YAXA,4C3DzXA,gC2D8YA,UArBA,WhDidA,iCgD5bA,UArBA,WpB9LA,4C9CiCA,gBF1GA,SCqfA,eDpZA,gBCoZA,UC1YA,gBF3GA,SCqfA,eDpZA,gBEUA,qEEGA,IgEgKA,kDpBrMA,QoB8MA,YAKA,UArBA,enEnVA,iCmEmVA,OAaA,sCAbA,yBAiBA,qBAGA,oBACA,EjD0uBA,OsC5oCA,eCEA,mCvCqqBA,OA8bA,OA4vCA,qBiDh8DA,oBACA,E/D5NA,OJoVA,OkB+0DA,UAlsDA,iBiDtQA,oBACA,GArBA,iCnEnVA,mBCglBA,O2BzkBA,MmCVA,OxC2JA,OvBbA,O4B/HA,M5B+oCA,OWgPA,qBcxrBA,Y1BnkBA,kBEicA,EwBkIA,IAmCA,kCzBtvBA,KCilBA,UFjcA,kBEicA,kBFjcA,SA4CA,mBA5CA,SA4CA,kIKtJA,UG0OA,OAEA,WCxTA,ODsTA,4BH1OA,8BAGA,mBE0aA,GF1aA,wBmBmaA,0B2C/cA,gBnE+EA,SCqfA,WDpZA,I6B3HA,KAEA,OAGA,OAEA,esCpDA,oDzCkNA,0C1B3IA,SCqfA,WDpZA,ImE7KA,IzC0NA,oO4BvOA,QY6WA,IjEiOA,kFkE7eA,c3CoEA,OAyxBA,YRnPA,GfnjBA,OuB+7BA,OAzcA,SAkTA,IAlTA,YR4DA,coD2BA,0CApSA,6BpDwGA,OAEA,YAFA,eA4gBA,sBf75BA,WiE6QA,E1DzMA,mCCrPA,mB2DmyBA,kBArCA,aC7tBA,iCDquBA,sBACA,mCnEtlBA,WiE6QA,EEwUA,cAUA,OhD2DA,eACA,oBADA,IgD3DA,kEpD8TA,qBf75BA,WiE6QA,EEkVA,cACA,WAvTA,6BpDwGA,OAEA,WR/UA,mCCrPA,mB2DmyBA,OAjBA,WnE5QA,OmByTA,WgDpCA,mCACA,oEnEtvBA,qJiEwZA,UjExZA,ODsLA,cAGA,YCzLA,ODsLA,OACA,OAvCA,UAyCA,UC9CA,WiE6QA,GlDoIA,4BA4gBA,QfxiCA,wHiEwZA,UjExZA,ODsLA,cAGA,YCzLA,ODsLA,OACA,OAvCA,UAyCA,WoEojBA,qBnElmBA,WiE6QA,MEgUA,yCD5nBA,OL1GA,iCpDwNA,IFuCA,WACA,SEpCA,kBTnEA,wBSmEA,cP4NA,YqBgqBA,OZ+QA,UuD5vCA,ctCrBA,M5BxEA,qBqEwDA,kBAEA,kBACA,0BlDwuBA,WACA,QnBpUA,OmByTA,OnBzTA,OmB3PA,gBnBsUA,I8BqCA,OXinBA,2BnBjuBA,OmB2pBA,OkD/jCA,qCrEoaA,OmB2pBA,OkD/jCA,qCrEoaA,OmB2pBA,OkD/jCA,qCrEoaA,OmB2pBA,OkD/jCA,kDlDyKA,eAk+BA,kBnBvuBA,OmB2pBA,OkD/jCA,uDACA,4BfhEA,GehBA,sBACA,sBAwFA,eAEA,OrEwZA,OqExZA,OACA,OrEuZA,OqEvZA,OAGA,OvC6nDA,UuCluDA,6BAsGA,OvC4nDA,UuCluDA,6BAuGA,8BlDutBA,WACA,QnBtUA,mBA2EA,I8BqCA,OXinBA,2BnBjuBA,OmB2pBA,OkDriCA,yCrE0YA,OmB2pBA,OkDriCA,yCrE0YA,OmB2pBA,OkDriCA,yCrE0YA,OmB2pBA,OkDriCA,sDrE0YA,SmB6pBA,wBnB7pBA,emBuuBA,kBnBvuBA,OmB2pBA,OkDriCA,0BlDuiCA,kDnB7pBA,OsDneA,4CpCqlCA,ciD3qBA,O/DhRA,c+DgRA,aACA,qDpDgoBA,yBoDtnBA,EAXA,MAGA,WjDs3CA,OA9sBA,OAitBA,OAtrCA,OdjeA,OJqfA,OmB9BA,U0B/ZA,yBsB8OA,EAPA,c5D5NA,+BCrPA,ODqPA,O0DtKA,wBvBwuBA,OA7WA,gBChYA,WjB4CA,WC9EA,yBD8EA,auCjBA,QAIA,O9D4MA,a8D5MA,OvB4nBA,OuB5nBA,wDA1BA,aEoYA,OACA,uCAIA,mB5CqfA,OAEA,OvB9xBA,OA3IA,iEmBmFA,sD2Bu4BA,WACA,2B3CtiBA,gDuBrYA,yBvBqYA,kBACA,iBADA,kBA7ZA,0BHxBA,4GDsLA,cAGA,YCzLA,ODsLA,OACA,OAvCA,UAyCA,U+CiyBA,WACA,yD3BxLA,kBnBnUA,OmByTA,OAtsBA,wC4BkEA,uCD40BA,SC50BA,U9CiCA,gBF1GA,SCqfA,eDpZA,qB+CozBA,S9ChaA,UC1YA,gBF3GA,SCqfA,YC1YA,qEEGA,I2CiyBA,sC9C1ZA,IDpZA,qB+CozBA,S3B94BA,WAitBA,yB2B6LA,S3B94BA,O2B44BA,6B3B54BA,enBnFA,iCmBmFA,I2Bg5BA,GADA,WACA,qHmBnlBA,gBjE2wBA,OyB3oBA,OyC1fA,OtCwCA,MnB4IA,IFuCA,eACA,SEpCA,kBTnEA,uBSmEA,8BP4NA,OqBgqBA,OZ2RA,kCsD3+BA,OnBsqBA,+CACA,wDACA,+BAGA,O/Bh0BA,OAqBA,sB+B4yBA,mB/B5yBA,IgCrGA,4C9CiCA,gBF1GA,SCqfA,eDpZA,gBCoZA,UC1YA,gBF3GA,SCqfA,eDpZA,gBEUA,qEEGA,I2C82BA,6CANA,O9CliCA,8KiEkZA,UjElZA,ODsLA,cAGA,YCzLA,ODsLA,OACA,OAvCA,UChJA,ODgJA,YmEpDA,OL1GA,gCK2GA,ctCrBA,UqC0UA,ExDxMA,IFuCA,WACA,SEpCA,kBTnEA,qBkE9CA,ctCrBA,UqC0UA,ExDpMA,cP4NA,WgE7UA,ctCrBA,UqC0UA,E1CwrBA,OZ+QA,OuD5vCA,ctCrBA,UqC0UA,GnB+oBA,YAWA,kCmB1pBA,UnB0pBA,yC9C5iCA,kF8CshCA,kBACA,0BAMA,IALA,c9CxhCA,uE8CyhCA,oB9CzhCA,sB8C6hCA,0DTpnBA,YACA,oBAEA,cACA,8CAGA,aACA,oCACA,sBrC+MA,OqC/MA,2BAIA,oCACA,sBrC0MA,OqC1MA,eACA,sBrCyMA,OqCzMA,8BAZA,sBrCqNA,2B8CqZA,kBACA,0BjDj7BA,IiDk7BA,c9CxhCA,uE8CyhCA,oB9CzhCA,sBHsGA,iDA6CA,iEACA,mBGpJA,4CHuIA,OiD+4BA,kBACA,0BjD/4BA,IiDg5BA,c9CxhCA,uE8CyhCA,oB9CzhCA,sBHwIA,mBAGA,gBACA,iDAGA,OAIA,iEAHA,mBcqtCA,QCzwCA,4BCvHA,Mb4lBA,YS1LA,OAGA,OAHA,YAGA,IAvQA,IVvDA,SCqfA,WDpZA,IUkOA,sBEs9BA,QCzwCA,4BC7HA,WJoKA,4KwDkeA,gBAGA,sBxDjWA,KACA,kBAEA,OwDgWA,WxDhaA,KFuCA,WACA,SEpCA,oBTpEA,OACA,6CSmEA,cADA,Wc63BA,0BA1cA,iBdlbA,STnEA,OuBwyBA,IAvTA,cAIA,O0ClBA,c1CmWA,ShBlwBA,c0DgaA,oBjEpeA,ciEoeA,0BACA,gBpB1iBA,mH7CqEA,U6CrEA,QoB4iBA,gDACA,gGACA,kBADA,ItDwxBA,qBcxrBA,WAmCA,OwC5IA,OxDlWA,OwDmWA,sHtDgyBA,qBcxrBA,WAmCA,OwC/HA,uBAWA,EAXA,qBpEvZA,QoEwZA,mDpEpXA,oEoEoXA,0BACA,gCjEznBA,oBuBu6BA,OAEA,OvB9xBA,OA3IA,mBA2pCA,OWgPA,qBcxrBA,YzBntBA,EyBsvBA,KzBtvBA,wDWs2CA,oG2DpmCA,0B7DhIA,IAsIA,kBYtSA,Qd6QA,OAEA,kB+DkBA,6BAQA,0BACA,yB3DmpCA,e2DnpCA,uBATA,WtEnQA,mBW24CA,qBcxrBA,WAmCA,MzBtvBA,OsEmQA,I3DmmCA,OAzmCA,yB2D4BA,mC3D6kCA,OXt2CA,mBW24CA,qBcxrBA,WAmCA,MzBtvBA,UWs2CA,OAyDA,eAzDA,kC2DxoCA,sBAmEA,EAnEA,OAqBA,qBAIA,4DAGA,kBAFA,OtExPA,SsEiSA,GAnEA,OAoCA,kB/DnBA,WAGA,2BAEA,S+DcA,W/DhBA,2BAEA,S+DcA,eA4BA,2GAiBA,8C3DqkCA,c2DhkCA,yCzEpFA,QyEoFA,iDzEhDA,gEyEgDA,QAOA,OtEsQA,esE7PA,EATA,YAEA,ctEnLA,OACA,WOqIA,OAEA,kB+D4CA,O/C4wBA,OZgRA,W2D1hCA,iCtE21BA,OWgPA,qBcxrBA,WAmCA,KzBrLA,2BsEtQA,WASA,EATA,W9DjWA,wBD2TA,S+DsCA,eAOA,4BtElUA,oBW24CA,qBcxrBA,YzBntBA,EyBsvBA,IzBtvBA,4FsEuKA,OtE7BA,OACA,OOuIA,iBCxTA,OoB6CA,Y2C6BA,2D3CxBA,oDcmwBA,OO3tBA,mBrB7CA,QkCjBA,SACA,4BlCqBA,QkCjBA,sDAKA,mC9DioBA,U8DjoBA,wC5C+oEA,kBlB/qDA,OApSA,O8D5LA,kB9D4LA,c8D5LA,I7D0lBA,2D6D1lBA,a5C+oEA,Q4C/oEA,sC9DgeA,OkB6rDA,OlBj+DA,qBkByiEA,clBruEA,uDDsLA,cAGA,YAHA,OACA,OAvCA,UmB+/DA,2BdzhEA,kBcknEA,iCnBxlEA,iB6BpIA,OkCjBA,0B5CopEA,O4C7oEA,aACA,UARA,e9DKA,wB8DLA,mCQ4KA,M1C3JA,QkCTA,uDUgFA,8BxEnFA,oBI4IA,Oc88CA,clB1lDA,+CIykBA,0CJzkBA,4ODgJA,SChJA,yFkB+oEA,oClB/qDA,OkB6rDA,OlBj+DA,qBkByiEA,clBruEA,mDDsLA,cAGA,YAHA,OACA,OAvCA,UmB+/DA,6ClB/oEA,qBkBwuEA,qBdlnEA,qBcknEA,SlBxuEA,+DI8jBA,6BJ9jBA,EI4IA,OEzFA,SC6NA,OAEA,WCxTA,ODsTA,4BAEA,qBH8SA,gBGhTA,OAEA,WCxTA,ODsTA,4BHiTA,yCJjkBA,mBDgJA,SA4CA,mBA5CA,SA4CA,gHsBtMA,kBZoNA,6BFuCA,eACA,qBEpCA,8CTpEA,gBACA,6DACA,gBA5IA,6CW24CA,qBcxrBA,eAmCA,gClB5jBA,sBChOA,mBDgOA,SEoBA,actDA,OAsnBA,eRhFA,gBRxjBA,cAqBA,gBcpKA,wBACA,OZ+MA,yBAGA,iCFuCA,eACA,yBADA,UEpCA,gBACA,8CTpEA,gBACA,6DACA,gBA5IA,qDW24CA,qBcxrBA,eAmCA,iCAnCA,OzBntBA,SO0LA,sBChOA,mBDgOA,cP1LA,QSgNA,gBAFA,iBYrNA,OACA,cAFA,qBEgKA,OAyxBA,avBtyBA,OuB+7BA,OAzcA,SAkTA,IAlTA,YR4DA,cf7rBA,mCqBRA,gBE+6BA,OAEA,OvB9xBA,WqB/IA,EV+4CA,qBcxrBA,sBJ3tBA,gBE+6BA,OAEA,OvB9xBA,WqB/IA,EIutBA,IAmCA,4CJ9vBA,oBAGA,8CI2vBA,UJ9vBA,gBE+6BA,OAEA,OvB9xBA,WqB/IA,IEq7BA,IRnPA,yBMnsBA,0CEs7BA,kCdvuBA,eAQA,cARA,sBY9MA,iCVy2CA,QCzwCA,4BCvHA,Mb4lBA,YS1LA,OAGA,OAHA,YAGA,IAvQA,IVvDA,SCqfA,WDpZA,IUkOA,sBEs9BA,QCzwCA,4BC7HA,WJoKA,mBTnIA,OA2pCA,OWgPA,qBcxrBA,YzBntBA,EyBsvBA,IzBtvBA,2EEibA,gBAIA,8LuEjdA,O/C2CA,M+CxBA,iBACA,cvD8QA,mCwD/LA,uBxD0pDA,4CAXA,Ud1kDA,Oc88CA,OAjTA,2BlBxqBA,iCiD7kBA,OjD4aA,UuExcA,OjD6pBA,OHgHA,sBoD7wBA,qChE0TA,cWm5CA,kBlB79CA,qBAyXA,OkB6qBA,OwB/hBA,mC1C9IA,OkB6qBA,WCxgBA,kCnBrKA,ekB6qBA,iBA6bA,aArBA,UA7aA,MAYA,iBAgaA,gBU9sDA,QrB+HA,SAqBA,gBgE9HA,6BAGA,kBxE4CA,SCqfA,WDpZA,ICoZA,UuEniBA,uF3ClBA,Q1B4XA,OACA,OACA,OAIA,cAKA,aAEA,YO3MA,6BFuCA,eACA,qBEpCA,kBTnEA,uBSmEA,8BTnEA,OE+QA,OACA,OAFA,yBO/MA,sBE4pCA,S2DpsCA,cAIA,OACA,0DGjKA,mB1D+NA,OAqBA,Of1PA,WyEQA,azERA,IyEaA,IzEbA,qEDsLA,cAGA,W0EjLA,a1EiLA,I0E5KA,I1EyKA,OACA,OAvCA,S0ExIA,a1EwIA,I0EnIA,mB/CaA,WAGA,kB1B+JA,OyE5LA,YvEqaA,mBFraA,8GDsLA,cAGA,WCzLA,EDyLA,OAHA,OACA,OAvCA,SChJA,mBwEmFA,avDNA,mB0D7EA,eACA,uBCqCA,8BAQA,IARA,U5E2hBA,W2E5lBA,O3EuNA,qB2ErNA,ICmEA,OACA,WAGA,mBAQA,IACA,ID1EA,MACA,oB3E0RA,qB2ErRA,QAEA,OAPA,I3EkBA,wDDsLA,cAGA,W6EhIA,I7E6HA,OACA,OAvCA,S6EvFA,mB7E6HA,cAGA,WAGA,EANA,OACA,OAvCA,SA4CA,iH8EnOA,sEhF+zCA,agF/zCA,mBhF+zCA,agF/zCA,mBhF+zCA,agF/zCA,mBhF+zCA,agF/zCA,mBhF+zCA,agF/zCA,mBhF+zCA,agF/zCA,mBhF+zCA,agF/zCA,mBhF+zCA,agF/zCA,mBhF+zCA,agF/zCA,mBhF+zCA,agF/zCA,oC/CgvDA,OA2XA,OxBnjEA,qBAkBA,cAlBA,kBAuBA,EADA,mCACA,qBAGA,0BA0FA,qBwBijDA,OAmBA,OxBjlDA,cwBilDA,OAkKA,kBxBruDA,OAaA,EwB0wDA,2DxBnxDA,OASA,EwBsjDA,OA2XA,OxBnjEA,qBAkBA,OAlBA,WEvDA,OFwLA,iDACA,mBA4HA,mCACA,mBPxRA,qBAoFA,SCqfA,WDtkBA,iDAIA,EAFA,qBAEA,qBAWA,qBAsIA,SApIA,mBAQA,qBACA,qBAKA,YAkDA,SCqfA,oBDpkBA,I2CoxBA,OA7WA,Y3C7XA,UAyGA,kBAtGA,iDAEA,EAkEA,aCmdA,WDliBA,iDAaA,EAXA,qBAWA,qBY0zCA,QmE13CA,IACA,6BAvBA,kBnEguBA,IAoqBA,QmEl2CA,4C1E+JA,c0BkjDA,O1B7xCA,gBAsBA,E0By6CA,kBvBznDA,UHsHA,OsC2aA,OAjYA,YtCyMA,kBAvKA,uCLxWA,SCqfA,WDtkBA,gBgBoZA,yBhBlZA,kBKubA,mBAGA,OLzUA,aCmdA,WDliBA,gBgBgXA,yBhB9WA,mBKmZA,wDE+BA,GSrEA,qBX6CA,YEwBA,GFvBA,cAGA,OACA,WAEA,iDAyJA,kBA5jBA,gBL6CA,SCqfA,WM9GA,SFraA,Ic4PA,uCAsGA,sCyCtSA,UzCw+BA,OAitBA,OAtrCA,OdjeA,OJqfA,OmB9BA,oBwC1fA,0BtD8gBA,oB0ErfA,kB3E4bA,yBJ9jBA,EI4IA,OLIA,SChJA,iDI2lBA,kBA5jBA,gBL6CA,SCqfA,WM9GA,SFraA,Ic4PA,uCAsGA,sCyCtSA,UzCw+BA,OAitBA,OAtrCA,OdjeA,OJqfA,OmB9BA,oBwC1fA,0BtD8gBA,oBA4xCA,4BAxwCA,gBA20CA,0C2Ez7DA,WACA,eA7CA,IA2EA,OACA,WACA,OAGA,OAHA,YAGA,QAhFA,qBAsHA,KA5GA,0CAuFA,WACA,iBA/EA,IAwDA,OACA,WAIA,OhFggBA,iCgF7jBA,ItC6wBA,OA7WA,YsC7UA,UAgBA,aAnGA,mBCgIA,UACA,qBAtIA,cACA,O9DmvBA,e8DlvBA,aACA,c9DivBA,oC8DjvBA,OACA,8EAEA,c9D8uBA,oC8D9uBA,OACA,mD9D6uBA,uB8D7uBA,e9D6uBA,O8D7uBA,OACA,+EARA,OALA,iCAeA,mBCtCA,wCA6BA,yBACA,OAyFA,EA1FA,elFgeA,OkF1dA,OAWA,OAEA,wBjD63CA,sDiDv4CA,mBlFudA,OkF1dA,OA+BA,iCAGA,iBjDw2CA,EiDv4CA,mBlFudA,OkF1dA,OAsCA,0DACA,wDACA,4CACA,iDAKA,OA3CA,mBlFudA,OkF1dA,OA+CA,iCAGA,iBjDw1CA,EiDv4CA,mBlFudA,OkF1dA,OAsDA,8DACA,wDACA,qDAKA,OA1DA,mBlFudA,OkF1dA,OA8DA,iCAGA,OA9DA,oBlFudA,OkF1dA,OAkEA,kCAGA,iBjDq0CA,gBiDn4CA,+CAbA,S/DqyBA,WACA,QADA,WACA,QnBtUA,OmByTA,+B+DzxBA,O/DqyBA,WACA,QAHA,WACA,QACA,WACA,QnBtUA,OmByTA,+B+DzxBA,O/DqyBA,WACA,QAHA,WACA,QACA,WACA,QnBtUA,OmByTA,+B+DzxBA,O/DqyBA,WACA,QAHA,WACA,QACA,WACA,QnBtUA,OmByTA,+B+DzxBA,O/DqyBA,WACA,QAHA,WACA,QACA,WACA,QnBtUA,OmByTA,+B+DzxBA,O/DqyBA,WACA,QAHA,WACA,QACA,WACA,QnBtUA,OmByTA,+B+DzxBA,Q/DqyBA,WACA,QAHA,WACA,QACA,WACA,QnBtUA,OmByTA,sC+DzxBA,+DA0FA,0LAkBA,sCA6BA,IAnKA,IAwIA,sOlFkXA,QmB4kBA,uBAv0BA,2BnB2PA,OmBuhCA,Ic/mCA,2CA3BA,ed+rBA,yBnB5kBA,OmBuhCA,Ic5nCA,OADA,uBATA,sBAiCA,gBd0pBA,0BnB5kBA,OmBuhCA,Ic5nCA,OADA,uBATA,sBAsCA,cACA,gBdopBA,sBnB5kBA,OmBuhCA,Ic5nCA,OADA,mBAkCA,iBA3CA,sBA2CA,mBAJA,aANA,aAgKA,mOIxKA,6BA/BA,QPu6BA,KOp6BA,cACA,wCA8BA,2B8C0HA,kCAKA,e3EjdA,kBDsCA,4BmC8lBA,OnC9lBA,sB2EsBA,kBjD4jDA,qBAmkBA,+BAEA,wBjCxxDA,QiC0xDA,mCAJA,+BAEA,wBjCxxDA,QiC0xDA,mCjC1xDA,QiCwuCA,SiDhlDA,mDACA,8DACA,yC7CyRA,SAEA,SAEA,sBAFA,YAEA,AAJA,Y6CvRA,c/D66BA,KAGA,wCc0sCA,0CAEA,wBjCxxDA,QiC0xDA,8Cd9sCA,anB5kBA,mBiCu0CA,SiDxqDA,kClFiWA,mBmB4kBA,Q+Dz6BA,Q/Dy6BA,gBnB5kBA,QkF7VA,gBACA,gBrFmJA,gDqFnJA,0CAtBA,gDjDqsDA,uBzBtvDA,gBXmKA,UWnKA,uDXuMA,uEWjSA,UyBg1DA,QA/FA,gCiDtmDA,gBA2BA,KADA,kBACA,wDrF2vCA,OUnyCA,kBVurCA,aUvrCA,eVmyCA,IU3xCA,OV+qCA,aU/qCA,OARA,0BVmyCA,qBGp4CA,mBHo4CA,OAUA,SAVA,+DsBluBA,ctBlcA,QsBmcA,mDtB/ZA,gEsB+ZA,oEiE5pBA,cvFyNA,QuFxNA,mDvF4PA,gEuF5PA,8CC1BA,OAiLA,yBACA,YACA,YAEA,kBACA,kBACA,OrF2TA,SAiKA,OqF3dA,crF0TA,SqFzTA,OrF0dA,OqF1dA,cARA,gDAgBA,uBACA,kBAEA,OrF8SA,SAiKA,OqF9cA,uBAJA,SAQA,WACA,OACA,QrFwcA,OqFxcA,wBrFwcA,OqF9bA,OAEA,uBACA,IAXA,OACA,OrFoSA,SAiKA,OqFpcA,kBrFocA,OqF9bA,OAEA,uBACA,mDDvKA,2EACA,2KvFgrCA,6FAQA,+BGxvBA,OmB4kBA,8BnB5kBA,OiCTA,OAjGA,qBAkGA,kBdolBA,sCcllBA,SpC0fA,sBAgBA,+BAXA,cACA,0CwCjjBA,eACA,yBAEA,oCAIA,gBACA,QrCgNA,+BqC3MA,QrC2MA,SqC1MA,SrC0MA,kCqCrNA,6DxC8iBA,0EAmCA,MAjCA,2BASA,YATA,kEASA,oCAwBA,MAxBA,oEAwBA,KApBA,2BAhBA,cACA,0CwCjjBA,eACA,yBAEA,oCAIA,gBACA,QrCgNA,+BqC3MA,QrC2MA,SqC1MA,SrC0MA,kCqCrNA,6DxC8iBA,0EAmCA,MAjCA,2BAcA,YAdA,kEAcA,oCAmBA,MAnBA,oEAmBA,KAgOA,mBArOA,QAkEA,mGAQA,mCARA,oBAYA,cwC7pBA,YACA,sBAEA,cACA,gDAGA,aACA,qCACA,sBrC+MA,QqC/MA,4BAIA,8BACA,sBrC0MA,QqC1MA,eACA,2BrCyMA,SqCzMA,mCAZA,yBrCqNA,mCqCxNA,uBKsWA,gBO3tBA,QpDqhCA,wFwChqBA,mBxColBA,KApCA,cACA,sBwCjjBA,aACA,uBAEA,kCAIA,cACA,QrCgNA,6BqC3MA,QrC2MA,QqC1MA,QrC0MA,gCqCrNA,qDxC8iBA,8DADA,gBAGA,mEA6BA,wBA7BA,gDAgHA,4B6C7TA,sBO3tBA,QpD2hCA,wFAHA,mBA/EA,KA+EA,4BAnHA,eAsBA,gBACA,gBAvBA,cACA,0CwCjjBA,eACA,yBAEA,oCAIA,gBACA,QrCgNA,+BqC3MA,QrC2MA,SqC1MA,SrC0MA,kCqCrNA,6DxC8iBA,0EAmCA,MAjCA,yFAqBA,8BAYA,MAXA,SAwEA,8FAQA,2CARA,qBAYA,SwC7pBA,eACA,yBAEA,iBACA,yDAGA,gBACA,8CACA,4BrC+MA,SqC/MA,gCAIA,qCACA,4BrC0MA,SqC1MA,mBACA,4BrCyMA,SqCzMA,mCAZA,0BrCqNA,mCqCxNA,yBKsWA,kBO3tBA,SpDqhCA,qGwChqBA,mBxColBA,KAVA,2DAyFA,oCA/EA,KA+EA,I6C7TA,wBO3tBA,SpD2hCA,qGAHA,mBA/EA,KA+EA,iFuFtlCA,6EACA,qBvF6QA,iEuF7QA,oHjEirBA,ctBxcA,QsBycA,mDtBraA,gEsBqaA,mDZniBA,cAqBA,wCVm3BA,0EAmCA,KUt5BA,OVu3BA,0BUv3BA,sBPqUA,O+BylCA,OZ7gBA,OY6gBA,oBZp1CA,0BnB2PA,OiCxFA,iCdoqBA,OnB5kBA,OiCtGA,IdkrBA,YclrBA,YAwBA,gBd0pBA,OnB5kBA,OiCtGA,IdkrBA,YclrBA,YA8BA,gBdopBA,OnB5kBA,OiCtGA,IdkrBA,YclrBA,KA8BA,MANA,MG9MA,eH8WA,eG7WA,QjBo2BA,IAGA,yCc0sCA,mCAEA,eApfA,ajCpyCA,QiC0xDA,+BAtfA,gBF3MA,IlCvhBA,wEAeA,KkCwgBA,MlCphBA,iBGrkBA,QmB4kBA,iCnB5kBA,SiCTA,SAjGA,yBAkGA,mBdolBA,0CcllBA,SpC2kBA,gBACA,0EAWA,KAZA,yBGrkBA,SiCTA,SAjGA,yBAkGA,mBdolBA,0CtBAA,mBAcA,sGAQA,yCARA,qBAYA,iBwC7pBA,eACA,uBAEA,eACA,iDAGA,cACA,sCACA,uBrC+MA,QqC/MA,4BAIA,+BACA,uBrC0MA,QqC1MA,eACA,uBrCyMA,QqCzMA,+BAZA,uBrCqNA,8BqCxNA,uBKsWA,gBO3tBA,QpDqhCA,uFwChqBA,kBxCwoBA,KAJA,gDA+BA,mCA3BA,KA2BA,I6C7TA,qBO3tBA,QpD2hCA,uFAHA,kBA3BA,KA2BA,uMoCq8BA,gBAZA,+BAmPA,cjCxxDA,QiC0xDA,uCAjPA,QA6OA,iDAjPA,+BAmPA,eApfA,ajCpyCA,QiC0xDA,mCAtfA,eAiQA,IAcA,uBACA,gBADA,mCAIA,2BACA,aADA,SpCvzDA,eoCyzDA,sFpCrxDA,wEoCqxDA,UAIA,WpC7zDA,oBoC6zDA,qHpCzxDA,wEoCyxDA,UAyNA,iCAEA,ajCxxDA,OiC0xDA,sCAFA,OAFA,cArNA,SAqNA,qDAEA,cjCxxDA,QiC0xDA,6BArNA,QAiNA,sEjCtxDA,mBiCsxDA,QA/cA,QjCv0CA,OmB4kBA,WZzxBA,OP6MA,OiCxFA,sCA3BA,ed+rBA,qBnB5kBA,OiCrGA,OADA,mBATA,uBAiCA,gBd0pBA,oBnB5kBA,OiCrGA,OADA,kBATA,sBAsCA,cACA,gBdopBA,iBcjrBA,OADA,eAkCA,iBA3CA,uBA2CA,aAJA,OANA,OAspDA,SIrpDA,SAEA,SAEA,sBAFA,YAEA,AAJA,YJspDA,gCpCz0DA,yBoC00DA,oJpCtyDA,wEoCsyDA,yBpCtqBA,qBAgEA,WAhEA,qBAtBA,6DA6FA,sBAKA,IAJA,OwCtkCA,gNiD9YA,SACA,eACA,+CACA,aACA,mDAEA,gBAGA,gBAHA,OAMA,mBANA,OASA,kBATA,OAYA,kBAZA,cAeA,kBAfA,kCjD6WA,OPu6BA,KOp6BA,cACA,gCAuBA,YA4OA,2FA9GA,8DAuBA,+BAvBA,EAaA,iCA1OA,QACA,+BA2OA,WACA,sCAEA,kDAlBA,EASA,0CATA,EAKA,0CALA,EACA,kDxCy2BA,+CA+FA,yCwCvkCA,OxC0kCA,IAlGA,mDAkGA,iD0Fp7CA,O1FoMA,Q0FpMA,mD1FmpCA,2G0FlpCA,mBFyEA,SACA,kDxFiwBA,6FGxYA,YmB3PA,StBooBA,oKGzYA,YHuZA,6BsBkLA,KAGA,yBnB5kBA,OmBuhCA,IA3cA,oBnB5kBA,QHyZA,yBACA,mGACA,oFG3ZA,oDmB4kBA,0BnB5kBA,QmB4kBA,oBnB5kBA,QHkaA,mGAoBA,sBACA,sBACA,uBAgBA,iGAEA,eACA,kCA5rBA,gCA4rBA,UA3rBA,yBADA,iBAyrBA,EsBiIA,OACA,OAEA,sBnB5kBA,OmBuhCA,OtBxwCA,0BACA,yBADA,YsB6zBA,MtBpIA,cAfA,kCAeA,iGAEA,eACA,qCA5rBA,mCA4rBA,WA3rBA,yBADA,iBAyrBA,EsBiIA,OACA,OAEA,sBnB5kBA,OmBuhCA,OtBxwCA,0BACA,yBADA,YsB6zBA,MtBpIA,cAdA,kCAIA,qBsB2IA,OACA,OAEA,mBnB5kBA,OmBuhCA,YtBxlBA,gEADA,qBAKA,oBAhCA,0CGnaA,QH2cA,sCUxpBA,eV4oBA,gBAxCA,QsBqLA,QtBnKA,QsBmKA,mBtBlKA,wGAnBA,kBAuBA,KAvBA,2CAhqBA,SACA,mByFpQA,oBtF4gBA,UmB4kBA,kCnB5kBA,OsF1gBA,qBACA,eACA,wBAMA,enE8kCA,OmE9kCA,2BnEq0BA,kBAEA,kBnBrUA,sBmB4kBA,cnB5kBA,OsFvgBA,OACA,2CnEklCA,kCAxQA,eAEA,emElzBA,QtF4eA,OmB4kBA,emExjCA,IAhBA,yBtF4fA,O0D1YA,O4B9GA,iBnEokCA,kBmEnkCA,uBtFufA,O0D1YA,OnD8PA,Q+E3WA,gBAEA,iBAEA,OACA,sBAGA,OnE2jCA,uCmExkCA,OAgBA,W/E+RA,Q+E/SA,+F/BsKA,qBACA,kBxCmZA,6BwCnZA,OAeA,yBAEA,IAhBA,6FAoCA,O1DogCA,O0DpgCA,kB1DgDA,Q0D1EA,gF1DyhCA,4G0D7hCA,IA1LA,qB1DwQA,I0D5EA,mD1DmIA,+E0DnIA,iBA4BA,IArCA,OAeA,yBAEA,mB1DwuCA,qBAUA,iCAVA,mBGp4CA,mBiC4zEA,esBv0EA,ItBu0EA,mBsB11EA,yBACA,O1DssCA,gE0DtsCA,8BvD6fA,OmB3PA,oBAo0BA,IAGA,4BnB5kBA,OiCxFA,6CA3BA,ed+rBA,wBnB5kBA,OiCrGA,OADA,wBATA,sBAiCA,gBd0pBA,wBnB5kBA,OiCrGA,OADA,wBATA,sBAsCA,cACA,gBdopBA,oBnB5kBA,OiCrGA,OADA,oBAkCA,iBA3CA,sBA2CA,gBAJA,UANA,UAgKA,cCnTA,+BArLA,qFf2JA,WoCzPA,YpCyPA,WoC7PA,OACA,aAOA,OtBswEA,0BAEA,mBjCxxDA,OiC0xDA,kCpCjlCA,8D0DzrCA,iCvDgfA,YiCwxDA,mBjCxxDA,OiC0xDA,sCAndA,OAqhBA,0CsBv0EA,WtB+wDA,mBA+CA,cAygBA,iDIn5DA,YACA,mBxCrUA,eACA,IwCsUA,cACA,8CAGA,aACA,oCACA,sBrC+MA,OqC/MA,2BAIA,oCACA,sBrC0MA,OqC1MA,eACA,sBrCyMA,OqCzMA,8BAZA,sBrCqNA,0BH5hBA,eACA,iDA6CA,iEACA,mBGpJA,mBHuIA,kBACA,0CAGA,cwC8RA,YACA,mBxCrUA,eAuCA,IwCgSA,cACA,8CAGA,aACA,oCACA,sBrC+MA,OqC/MA,2BAIA,oCACA,sBrC0MA,OqC1MA,eACA,sBrCyMA,OqCzMA,8BAZA,sBrCqNA,0BH5hBA,eAuCA,iDAGA,OAIA,iEAHA,mBAyhCA,gE0B9wBA,mB1B8wBA,gE0B1vBA,mBcmMA,oDAQA,OA4FA,KApGA,EAIA,cACA,OACA,qBA8FA,KApGA,EACA,OACA,sBAkGA,KApGA,EA9GA,yDA0BA,OAwLA,KAlNA,EAuBA,OACA,sBA0LA,KAlNA,EAaA,wDA1OA,QACA,+BA2OA,WACA,QAEA,eAEA,qBA8LA,KAlNA,EASA,OACA,sBAwMA,KAlNA,EAKA,OACA,sBA4MA,KAlNA,EACA,OACA,sBAgNA,+BAnCA,wFApHA,cACA,wHADA,aAmEA,mCAqFA,wD9BmCA,qBV1hBA,IU2hBA,sBVvfA,gEUufA,iD2BjOA,+HAmBA,qGlC7EA,QkCwkBA,QAEA,SfvTA,2BeuTA,OACA,sBAKA,2BAEA,gDAVA,sDAKA,gBAEA,QAPA,yCAmBA,QAnBA,uDfrTA,uDnBnRA,OkCwkBA,OAEA,SfvTA,sBeuTA,OACA,sBAKA,2BAEA,gDAVA,kEAKA,gBAEA,QAPA,qDAmBA,QAnBA,sDfrTA,YeyDA,qCfPA,WACA,QeqBA,OfxBA,WACA,QACA,WACA,QnBtUA,OmBu8DA,iBAKA,4Be7kDA,QQ5EA,QAjYA,c1C8EA,2BkC4YA,2CfgMA,6Be7MA,gCfwkDA,yCe90CA,2CACA,efvWA,2BeuWA,OACA,gBfxWA,2BewWA,OACA,mBAEA,gBAEA,8BACA,mBAEA,wCAFA,cAEA,sEAaA,uDfuzCA,QAprDA,8DesWA,2CACA,efvWA,2BeuWA,OACA,gBfxWA,2BewWA,OACA,mBAEA,gBAEA,gCACA,mBAEA,wCAFA,cAEA,sEAaA,yDf7XA,8CuBgCA,UAjYA,gBRmbA,SfhCA,aACA,QADA,4CnBrUA,SkC4YA,gDfgMA,iEevgBA,2MAQA,qBD+tBA,0BAEA,0BAoBA,cACA,mBACA,sDAoBA,mFApBA,EAwBA,wCACA,0DACA,wDACA,4CACA,iDAGA,mFA/BA,EAoCA,wCACA,8DACA,wDACA,qDAGA,yEAGA,mFA7CA,YAmDA,YAMA,cACA,YAkBA,cAjBA,qBjC/3BA,OiCm4BA,OjCn4BA,OiCo4BA,OACA,qCAIA,OAVA,kCAaA,0DACA,OADA,mCA9FA,0FAuEA,6BAvEA,EA0CA,eA1CA,EA2CA,6BA3CA,EA8CA,eA9CA,EAmDA,2BAnDA,EAqDA,eArDA,EAsDA,8BAtDA,EA0DA,eA1DA,EA8DA,2BA9DA,EAgEA,eAhEA,EAiEA,8BAjEA,EAmEA,eAnEA,EAoEA,4BlB1SA,qBkBvzBA,GADA,mCACA,+FsBnMA,0CACA,sBxC+eA,kBwC/dA,eAhBA,OAgBA,WAEA,IAjBA,2EAmCA,O1DimCA,O0DjmCA,kB1D6IA,I0DrKA,gF1DonCA,4G0DznCA,IA9FA,qB1DwQA,I0DvKA,gF1D8NA,+E0D/NA,iBA2BA,QApCA,OAgBA,WAEA,mB1DwmCA,8DoCmpCA,OsB7rEA,wDAMA,mBA4BA,2CAYA,IxCiXA,mBwC9WA,O1DogCA,O0DpgCA,uB1Dy/BA,gE0DrgCA,qCAEA,2CACA,O1DkgCA,+D0DlgCA,2BAEA,O1DggCA,qEkB3oBA,MwC5XA,WAWA,gGAcA,qBACA,kBxCkWA,kBwC/UA,eAnBA,OAmBA,WACA,EAYA,O1Dw9BA,O0Dx9BA,cAtBA,gF1D0BA,I0DrBA,mD1Do+BA,+G0Dn/BA,OAmBA,WACA,EAnBA,IArOA,qBAuOA,yD1DiCA,I0D5BA,mD1DmFA,+E0DnFA,oBARA,OAmBA,WACA,4C1D+9BA,yG0Dt2BA,uCAOA,mBAMA,SAEA,mBA5HA,O1Dw9BA,O0Dx9BA,uBATA,0CASA,YAJA,cxCsUA,kBwCtUA,WAmJA,IAxJA,uB1Ds9BA,8D0Dj9BA,OxCsUA,sBwCnLA,IADA,O1D+zBA,mE0D9zBA,mB1D3IA,sBAYA,0CAkHA,qFACA,mBA00BA,8DACA,0CAKA,qFACA,mBAwCA,wCAsJA,6DACA,uBADA,6DAiEA,yBAeA,KG99BA,OmB4kBA,wBAv0BA,+CnB2PA,OmBuhCA,Ic/mCA,2CA3BA,ed+rBA,0BnB5kBA,OmBuhCA,Ic5nCA,OADA,wBATA,uBAiCA,gBd0pBA,2BnB5kBA,OmBuhCA,Ic5nCA,OADA,wBATA,uBAsCA,cACA,gBdopBA,uBnB5kBA,OmBuhCA,Ic5nCA,OADA,oBAkCA,iBA3CA,uBA2CA,mBAJA,aANA,aAgKA,qOqD1jBA,UACA,gBACA,mDACA,cACA,uDAEA,iBAGA,iBAHA,QAMA,iBANA,SASA,mBATA,SAYA,mBAZA,kBAeA,oBAfA,0CjD6WA,QPu6BA,KOp6BA,cACA,wCAoUA,yDApHA,OACA,uIADA,SxCq3BA,iBsB3YA,KAGA,6CcuoBA,qBAmkBA,8BAEA,uBjCxxDA,QiC0xDA,uCAJA,8BAEA,uBjCxxDA,QiC0xDA,mCjC1xDA,SiCwuCA,UpC/hBA,2DA4QA,kDwCn0BA,yGA9GA,qEAuBA,sCAvBA,EAaA,uCA1OA,QACA,+BA2OA,YACA,+CAEA,8DAlBA,EASA,mDATA,EAKA,mDALA,EACA,2DxCy2BA,gDAyEA,iDwCpiCA,SAEA,SAEA,sBAFA,YAEA,AAJA,YxCsiCA,QsBhZA,KAGA,iDAv0BA,QtBytCA,aoCwzBA,2CAEA,eArcA,ajCn1CA,QiC0xDA,sCAvcA,apCrXA,QoCsRA,kBdxqBA,QnB5kBA,mBiCu0CA,QpC9nBA,gDAmRA,yBAEA,KAhFA,oDAgFA,oBAMA,WACA,mByF78CA,SACA,aACA,+BAwBA,IAvBA,aACA,+BAsBA,IApBA,gBAGA,gBAHA,OAMA,gBANA,OASA,kBATA,OAYA,kBAZA,eAoBA,IALA,uCtFbA,0CHo4CA,OwFt5CA,eAiMA,+BACA,0CrFgTA,SAiKA,OqF9cA,2BAIA,4BAIA,OrFqSA,SAiKA,OqFpcA,oBAdA,OAUA,QrFwcA,OqFxcA,yBrFwcA,OqF9bA,OAEA,uBxF+rCA,mBGp4CA,mBHo4CA,OwF9xCA,SxF8xCA,4CwFzyCA,OAlFA,8LrFwnBA,OiDtLA,OAhFA,WoC1SA,qCA/DA,OACA,O3C4qBA,qCvBoGA,YACA,SnBpUA,OmByTA,QkElvBA,uBAqDA,IlEusBA,0CkErzBA,OAiLA,yBACA,YACA,YAEA,kBACA,kBACA,OrF2TA,SAiKA,OqF3dA,crF0TA,SqFzTA,OrF0dA,OqF1dA,cARA,gDAgBA,uBACA,kBAEA,OrF8SA,SAiKA,OqF9cA,uBAJA,SAQA,WACA,OACA,QrFwcA,OqFxcA,wBrFwcA,OqF9bA,OAEA,uBACA,IAXA,OACA,OrFoSA,SAiKA,OqFpcA,kBrFocA,OqF9bA,OAEA,uBACA,qBpDsnEA,kBH2MA,wB9BviEA,OmByTA,OAtsBA,4BWo7EA,S9BviEA,0B8BmjEA,OACA,QOzrEA,uBACA,yBACA,iCAFA,OAKA,mBP6jDA,6BAlDA,yBX/zBA,2BWsgDA,qBAhMA,GGtDA,sEpCnpCA,gE0DroCA,mCzB0hFA,OAHA,iByBr/EA,uCzBq/EA,If7hEA,iBwC3cA,O1DimCA,O0DjmCA,cAXA,gB1DimCA,mEkB3oBA,KwCvdA,ezBo/EA,mB9B3jFA,mBHo4CA,OiC6rCA,4CjCx5CA,oEA2NA,OiC6rCA,EjCx5CA,oEA2NA,OiC6rCA,EjCx5CA,oEA2NA,OiC6rCA,EjCx5CA,oEA2NA,gDwFt5CA,eAiMA,+BACA,0CrFgTA,SAiKA,OqF9cA,2BAIA,4BAIA,OrFqSA,SAiKA,OqFpcA,oBAdA,OAUA,QrFwcA,OqFxcA,yBrFwcA,OqF9bA,OAEA,uBA9FA,mBADA,SACA,0CAwCA,cvDuiDA,OuDtiDA,YAeA,yBACA,YACA,YAEA,kBACA,kBACA,OrF2TA,SAiKA,OqF3dA,crF0TA,SqFzTA,OrF0dA,OqF1dA,cARA,gDAgBA,uBACA,kBAEA,OrF8SA,SAiKA,OqF9cA,uBAJA,SAQA,WACA,OACA,QrFwcA,OqFxcA,wBrFwcA,OqF9bA,OAEA,uBACA,IAXA,OACA,OrFoSA,SAiKA,OqFpcA,kBrFocA,OqF9bA,OAEA,uBACA,0DpDzFA,OpC4jCA,gE0DroCA,mCtBwEA,OAHA,iBAIA,OAJA,iBsBnCA,uCtBmCA,IlBqbA,iBwC3cA,O1DimCA,O0DjmCA,cAXA,gB1DimCA,mEkB3oBA,KwCvdA,etBkCA,mBjCzGA,iDHo4CA,OUnyCA,wBVwkCA,wEA2NA,IU3xCA,OVgkCA,gE0D1iCA,iDhDtBA,OARA,WgDgEA,8BxC6XA,mBwC9WA,O1DogCA,O0DpgCA,uB1Dy/BA,gE0DrgCA,qCAEA,uCACA,O1DkgCA,+D0DlgCA,0BAEA,O1DggCA,qEkB3oBA,MwC5XA,YADA,Q1DmuCA,4CwFzyCA,OAlFA,8LrFwnBA,OiDtLA,OAhFA,OoC/YA,QAqGA,qCA/DA,OACA,O3C4qBA,+BvBoGA,YACA,SnBpUA,OmByTA,QkElvBA,uBAqDA,IlEusBA","sourcesContent":["// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Utilities for formatting and printing strings.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse cell::{UnsafeCell, Cell, RefCell, Ref, RefMut};\nuse marker::PhantomData;\nuse mem;\nuse num::flt2dec;\nuse ops::Deref;\nuse result;\nuse slice;\nuse str;\n\nmod float;\nmod num;\nmod builders;\n\n#[unstable(feature = \"fmt_flags_align\", issue = \"27726\")]\n/// Possible alignments returned by `Formatter::align`\n#[derive(Debug)]\npub enum Alignment {\n    /// Indication that contents should be left-aligned.\n    Left,\n    /// Indication that contents should be right-aligned.\n    Right,\n    /// Indication that contents should be center-aligned.\n    Center,\n    /// No alignment was requested.\n    Unknown,\n}\n\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap};\n\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n           issue = \"0\")]\n#[doc(hidden)]\npub mod rt {\n    pub mod v1;\n}\n\n/// The type returned by formatter methods.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// #[derive(Debug)]\n/// struct Triangle {\n///     a: f32,\n///     b: f32,\n///     c: f32\n/// }\n///\n/// impl fmt::Display for Triangle {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         write!(f, \"({}, {}, {})\", self.a, self.b, self.c)\n///     }\n/// }\n///\n/// let pythagorean_triple = Triangle { a: 3.0, b: 4.0, c: 5.0 };\n///\n/// println!(\"{}\", pythagorean_triple);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result = result::Result<(), Error>;\n\n/// The error type which is returned from formatting a message into a stream.\n///\n/// This type does not support transmission of an error other than that an error\n/// occurred. Any extra information must be arranged to be transmitted through\n/// some other means.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct Error;\n\n/// A collection of methods that are required to format a message into a stream.\n///\n/// This trait is the type which this modules requires when formatting\n/// information. This is similar to the standard library's [`io::Write`] trait,\n/// but it is only intended for use in libcore.\n///\n/// This trait should generally not be implemented by consumers of the standard\n/// library. The [`write!`] macro accepts an instance of [`io::Write`], and the\n/// [`io::Write`] trait is favored over implementing this trait.\n///\n/// [`write!`]: ../../std/macro.write.html\n/// [`io::Write`]: ../../std/io/trait.Write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Write {\n    /// Writes a slice of bytes into this writer, returning whether the write\n    /// succeeded.\n    ///\n    /// This method can only succeed if the entire byte slice was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// [`Error`]: struct.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n    ///     f.write_str(s)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, \"hola\").unwrap();\n    /// assert_eq!(&buf, \"hola\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_str(&mut self, s: &str) -> Result;\n\n    /// Writes a [`char`] into this writer, returning whether the write succeeded.\n    ///\n    /// A single [`char`] may be encoded as more than one byte.\n    /// This method can only succeed if the entire byte sequence was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    /// [`Error`]: struct.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n    ///     f.write_char(c)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, 'a').unwrap();\n    /// writer(&mut buf, 'b').unwrap();\n    /// assert_eq!(&buf, \"ab\");\n    /// ```\n    #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n    fn write_char(&mut self, c: char) -> Result {\n        self.write_str(c.encode_utf8(&mut [0; 4]))\n    }\n\n    /// Glue for usage of the [`write!`] macro with implementors of this trait.\n    ///\n    /// This method should generally not be invoked manually, but rather through\n    /// the [`write!`] macro itself.\n    ///\n    /// [`write!`]: ../../std/macro.write.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n    ///     f.write_fmt(format_args!(\"{}\", s))\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, \"world\").unwrap();\n    /// assert_eq!(&buf, \"world\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(&mut self, args: Arguments) -> Result {\n        // This Adapter is needed to allow `self` (of type `&mut\n        // Self`) to be cast to a Write (below) without\n        // requiring a `Sized` bound.\n        struct Adapter<'a,T: ?Sized +'a>(&'a mut T);\n\n        impl<'a, T: ?Sized> Write for Adapter<'a, T>\n            where T: Write\n        {\n            fn write_str(&mut self, s: &str) -> Result {\n                self.0.write_str(s)\n            }\n\n            fn write_char(&mut self, c: char) -> Result {\n                self.0.write_char(c)\n            }\n\n            fn write_fmt(&mut self, args: Arguments) -> Result {\n                self.0.write_fmt(args)\n            }\n        }\n\n        write(&mut Adapter(self), args)\n    }\n}\n\n#[stable(feature = \"fmt_write_blanket_impl\", since = \"1.4.0\")]\nimpl<'a, W: Write + ?Sized> Write for &'a mut W {\n    fn write_str(&mut self, s: &str) -> Result {\n        (**self).write_str(s)\n    }\n\n    fn write_char(&mut self, c: char) -> Result {\n        (**self).write_char(c)\n    }\n\n    fn write_fmt(&mut self, args: Arguments) -> Result {\n        (**self).write_fmt(args)\n    }\n}\n\n/// A struct to represent both where to emit formatting strings to and how they\n/// should be formatted. A mutable version of this is passed to all formatting\n/// traits.\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Formatter<'a> {\n    flags: u32,\n    fill: char,\n    align: rt::v1::Alignment,\n    width: Option<usize>,\n    precision: Option<usize>,\n\n    buf: &'a mut (Write+'a),\n    curarg: slice::Iter<'a, ArgumentV1<'a>>,\n    args: &'a [ArgumentV1<'a>],\n}\n\n// NB. Argument is essentially an optimized partially applied formatting function,\n// equivalent to `exists T.(&T, fn(&T, &mut Formatter) -> Result`.\n\nstruct Void {\n    _priv: (),\n}\n\n/// This struct represents the generic \"argument\" which is taken by the Xprintf\n/// family of functions. It contains a function to format the given value. At\n/// compile time it is ensured that the function and the value have the correct\n/// types, and then this struct is used to canonicalize arguments to one type.\n#[derive(Copy)]\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n           issue = \"0\")]\n#[doc(hidden)]\npub struct ArgumentV1<'a> {\n    value: &'a Void,\n    formatter: fn(&Void, &mut Formatter) -> Result,\n}\n\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n           issue = \"0\")]\nimpl<'a> Clone for ArgumentV1<'a> {\n    fn clone(&self) -> ArgumentV1<'a> {\n        *self\n    }\n}\n\nimpl<'a> ArgumentV1<'a> {\n    #[inline(never)]\n    fn show_usize(x: &usize, f: &mut Formatter) -> Result {\n        Display::fmt(x, f)\n    }\n\n    #[doc(hidden)]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n               issue = \"0\")]\n    pub fn new<'b, T>(x: &'b T,\n                      f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {\n        unsafe {\n            ArgumentV1 {\n                formatter: mem::transmute(f),\n                value: mem::transmute(x)\n            }\n        }\n    }\n\n    #[doc(hidden)]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n               issue = \"0\")]\n    pub fn from_usize(x: &usize) -> ArgumentV1 {\n        ArgumentV1::new(x, ArgumentV1::show_usize)\n    }\n\n    fn as_usize(&self) -> Option<usize> {\n        if self.formatter as usize == ArgumentV1::show_usize as usize {\n            Some(unsafe { *(self.value as *const _ as *const usize) })\n        } else {\n            None\n        }\n    }\n}\n\n// flags available in the v1 format of format_args\n#[derive(Copy, Clone)]\n#[allow(dead_code)] // SignMinus isn't currently used\nenum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, }\n\nimpl<'a> Arguments<'a> {\n    /// When using the format_args!() macro, this function is used to generate the\n    /// Arguments structure.\n    #[doc(hidden)] #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n               issue = \"0\")]\n    pub fn new_v1(pieces: &'a [&'a str],\n                  args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n        Arguments {\n            pieces: pieces,\n            fmt: None,\n            args: args\n        }\n    }\n\n    /// This function is used to specify nonstandard formatting parameters.\n    /// The `pieces` array must be at least as long as `fmt` to construct\n    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n    /// created with `argumentusize`. However, failing to do so doesn't cause\n    /// unsafety, but will ignore invalid .\n    #[doc(hidden)] #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n               issue = \"0\")]\n    pub fn new_v1_formatted(pieces: &'a [&'a str],\n                            args: &'a [ArgumentV1<'a>],\n                            fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {\n        Arguments {\n            pieces: pieces,\n            fmt: Some(fmt),\n            args: args\n        }\n    }\n\n    /// Estimates the length of the formatted text.\n    ///\n    /// This is intended to be used for setting initial `String` capacity\n    /// when using `format!`. Note: this is neither the lower nor upper bound.\n    #[doc(hidden)] #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n               issue = \"0\")]\n    pub fn estimated_capacity(&self) -> usize {\n        let pieces_length: usize = self.pieces.iter()\n            .map(|x| x.len()).sum();\n\n        if self.args.is_empty() {\n            pieces_length\n        } else if self.pieces[0] == \"\" && pieces_length < 16 {\n            // If the format string starts with an argument,\n            // don't preallocate anything, unless length\n            // of pieces is significant.\n            0\n        } else {\n            // There are some arguments, so any additional push\n            // will reallocate the string. To avoid that,\n            // we're \"pre-doubling\" the capacity here.\n            pieces_length.checked_mul(2).unwrap_or(0)\n        }\n    }\n}\n\n/// This structure represents a safely precompiled version of a format string\n/// and its arguments. This cannot be generated at runtime because it cannot\n/// safely be done, so no constructors are given and the fields are private\n/// to prevent modification.\n///\n/// The [`format_args!`] macro will safely create an instance of this structure\n/// and pass it to a function or closure, passed as the first argument. The\n/// macro validates the format string at compile-time so usage of the [`write`]\n/// and [`format`] functions can be safely performed.\n///\n/// [`format_args!`]: ../../std/macro.format_args.html\n/// [`format`]: ../../std/fmt/fn.format.html\n/// [`write`]: ../../std/fmt/fn.write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone)]\npub struct Arguments<'a> {\n    // Format string pieces to print.\n    pieces: &'a [&'a str],\n\n    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n    fmt: Option<&'a [rt::v1::Argument]>,\n\n    // Dynamic arguments for interpolation, to be interleaved with string\n    // pieces. (Every argument is preceded by a string piece.)\n    args: &'a [ArgumentV1<'a>],\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Debug for Arguments<'a> {\n    fn fmt(&self, fmt: &mut Formatter) -> Result {\n        Display::fmt(self, fmt)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Display for Arguments<'a> {\n    fn fmt(&self, fmt: &mut Formatter) -> Result {\n        write(fmt.buf, *self)\n    }\n}\n\n/// Format trait for the `?` character.\n///\n/// `Debug` should format the output in a programmer-facing, debugging context.\n///\n/// Generally speaking, you should just `derive` a `Debug` implementation.\n///\n/// When used with the alternate format specifier `#?`, the output is pretty-printed.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// This trait can be used with `#[derive]` if all fields implement `Debug`. When\n/// `derive`d for structs, it will use the name of the `struct`, then `{`, then a\n/// comma-separated list of each field's name and `Debug` value, then `}`. For\n/// `enum`s, it will use the name of the variant and, if applicable, `(`, then the\n/// `Debug` values of the fields, then `)`.\n///\n/// # Examples\n///\n/// Deriving an implementation:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// println!(\"The origin is: {:?}\", origin);\n/// ```\n///\n/// Manually implementing:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl fmt::Debug for Point {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         write!(f, \"Point {{ x: {}, y: {} }}\", self.x, self.y)\n///     }\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// println!(\"The origin is: {:?}\", origin);\n/// ```\n///\n/// This outputs:\n///\n/// ```text\n/// The origin is: Point { x: 0, y: 0 }\n/// ```\n///\n/// There are a number of `debug_*` methods on `Formatter` to help you with manual\n/// implementations, such as [`debug_struct`][debug_struct].\n///\n/// `Debug` implementations using either `derive` or the debug builder API\n/// on `Formatter` support pretty printing using the alternate flag: `{:#?}`.\n///\n/// [debug_struct]: ../../std/fmt/struct.Formatter.html#method.debug_struct\n///\n/// Pretty printing with `#?`:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// println!(\"The origin is: {:#?}\", origin);\n/// ```\n///\n/// This outputs:\n///\n/// ```text\n/// The origin is: Point {\n///     x: 0,\n///     y: 0\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"`{Self}` cannot be formatted using `:?`; if it is \\\n                            defined in your crate, add `#[derive(Debug)]` or \\\n                            manually implement it\"]\n#[lang = \"debug_trait\"]\npub trait Debug {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// Format trait for an empty format, `{}`.\n///\n/// `Display` is similar to [`Debug`][debug], but `Display` is for user-facing\n/// output, and so cannot be derived.\n///\n/// [debug]: trait.Debug.html\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Implementing `Display` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl fmt::Display for Point {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         write!(f, \"({}, {})\", self.x, self.y)\n///     }\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// println!(\"The origin is: {}\", origin);\n/// ```\n#[rustc_on_unimplemented = \"`{Self}` cannot be formatted with the default \\\n                            formatter; try using `:?` instead if you are using \\\n                            a format string\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Display {\n    /// Formats the value using the given formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Position {\n    ///     longitude: f32,\n    ///     latitude: f32,\n    /// }\n    ///\n    /// impl fmt::Display for Position {\n    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    ///         write!(f, \"({}, {})\", self.longitude, self.latitude)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\"(1.987, 2.983)\".to_owned(),\n    ///            format!(\"{}\", Position { longitude: 1.987, latitude: 2.983, }));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// Format trait for the `o` character.\n///\n/// The `Octal` trait should format its output as a number in base-8.\n///\n/// The alternate flag, `#`, adds a `0o` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '52' in octal\n///\n/// assert_eq!(format!(\"{:o}\", x), \"52\");\n/// assert_eq!(format!(\"{:#o}\", x), \"0o52\");\n/// ```\n///\n/// Implementing `Octal` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Octal for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         let val = self.0;\n///\n///         write!(f, \"{:o}\", val) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// println!(\"l as octal is: {:o}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Octal {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// Format trait for the `b` character.\n///\n/// The `Binary` trait should format its output as a number in binary.\n///\n/// The alternate flag, `#`, adds a `0b` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '101010' in binary\n///\n/// assert_eq!(format!(\"{:b}\", x), \"101010\");\n/// assert_eq!(format!(\"{:#b}\", x), \"0b101010\");\n/// ```\n///\n/// Implementing `Binary` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Binary for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         let val = self.0;\n///\n///         write!(f, \"{:b}\", val) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(107);\n///\n/// println!(\"l as binary is: {:b}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Binary {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// Format trait for the `x` character.\n///\n/// The `LowerHex` trait should format its output as a number in hexadecimal, with `a` through `f`\n/// in lower case.\n///\n/// The alternate flag, `#`, adds a `0x` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '2a' in hex\n///\n/// assert_eq!(format!(\"{:x}\", x), \"2a\");\n/// assert_eq!(format!(\"{:#x}\", x), \"0x2a\");\n/// ```\n///\n/// Implementing `LowerHex` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::LowerHex for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         let val = self.0;\n///\n///         write!(f, \"{:x}\", val) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// println!(\"l as hex is: {:x}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait LowerHex {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// Format trait for the `X` character.\n///\n/// The `UpperHex` trait should format its output as a number in hexadecimal, with `A` through `F`\n/// in upper case.\n///\n/// The alternate flag, `#`, adds a `0x` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '2A' in hex\n///\n/// assert_eq!(format!(\"{:X}\", x), \"2A\");\n/// assert_eq!(format!(\"{:#X}\", x), \"0x2A\");\n/// ```\n///\n/// Implementing `UpperHex` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::UpperHex for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         let val = self.0;\n///\n///         write!(f, \"{:X}\", val) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// println!(\"l as hex is: {:X}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait UpperHex {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// Format trait for the `p` character.\n///\n/// The `Pointer` trait should format its output as a memory location. This is commonly presented\n/// as hexadecimal.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `&i32`:\n///\n/// ```\n/// let x = &42;\n///\n/// let address = format!(\"{:p}\", x); // this produces something like '0x7f06092ac6d0'\n/// ```\n///\n/// Implementing `Pointer` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Pointer for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         // use `as` to convert to a `*const T`, which implements Pointer, which we can use\n///\n///         write!(f, \"{:p}\", self as *const Length)\n///     }\n/// }\n///\n/// let l = Length(42);\n///\n/// println!(\"l is in memory here: {:p}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Pointer {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// Format trait for the `e` character.\n///\n/// The `LowerExp` trait should format its output in scientific notation with a lower-case `e`.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42.0; // 42.0 is '4.2e1' in scientific notation\n///\n/// assert_eq!(format!(\"{:e}\", x), \"4.2e1\");\n/// ```\n///\n/// Implementing `LowerExp` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::LowerExp for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         let val = self.0;\n///         write!(f, \"{}e1\", val / 10)\n///     }\n/// }\n///\n/// let l = Length(100);\n///\n/// println!(\"l in scientific notation is: {:e}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait LowerExp {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// Format trait for the `E` character.\n///\n/// The `UpperExp` trait should format its output in scientific notation with an upper-case `E`.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `f32`:\n///\n/// ```\n/// let x = 42.0; // 42.0 is '4.2E1' in scientific notation\n///\n/// assert_eq!(format!(\"{:E}\", x), \"4.2E1\");\n/// ```\n///\n/// Implementing `UpperExp` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::UpperExp for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         let val = self.0;\n///         write!(f, \"{}E1\", val / 10)\n///     }\n/// }\n///\n/// let l = Length(100);\n///\n/// println!(\"l in scientific notation is: {:E}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait UpperExp {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// The `write` function takes an output stream, and an `Arguments` struct\n/// that can be precompiled with the `format_args!` macro.\n///\n/// The arguments will be formatted according to the specified format string\n/// into the output stream provided.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::fmt;\n///\n/// let mut output = String::new();\n/// fmt::write(&mut output, format_args!(\"Hello {}!\", \"world\"))\n///     .expect(\"Error occurred while trying to write in String\");\n/// assert_eq!(output, \"Hello world!\");\n/// ```\n///\n/// Please note that using [`write!`] might be preferrable. Example:\n///\n/// ```\n/// use std::fmt::Write;\n///\n/// let mut output = String::new();\n/// write!(&mut output, \"Hello {}!\", \"world\")\n///     .expect(\"Error occurred while trying to write in String\");\n/// assert_eq!(output, \"Hello world!\");\n/// ```\n///\n/// [`write!`]: ../../std/macro.write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn write(output: &mut Write, args: Arguments) -> Result {\n    let mut formatter = Formatter {\n        flags: 0,\n        width: None,\n        precision: None,\n        buf: output,\n        align: rt::v1::Alignment::Unknown,\n        fill: ' ',\n        args: args.args,\n        curarg: args.args.iter(),\n    };\n\n    let mut pieces = args.pieces.iter();\n\n    match args.fmt {\n        None => {\n            // We can use default formatting parameters for all arguments.\n            for (arg, piece) in args.args.iter().zip(pieces.by_ref()) {\n                formatter.buf.write_str(*piece)?;\n                (arg.formatter)(arg.value, &mut formatter)?;\n            }\n        }\n        Some(fmt) => {\n            // Every spec has a corresponding argument that is preceded by\n            // a string piece.\n            for (arg, piece) in fmt.iter().zip(pieces.by_ref()) {\n                formatter.buf.write_str(*piece)?;\n                formatter.run(arg)?;\n            }\n        }\n    }\n\n    // There can be only one trailing string piece left.\n    if let Some(piece) = pieces.next() {\n        formatter.buf.write_str(*piece)?;\n    }\n\n    Ok(())\n}\n\nimpl<'a> Formatter<'a> {\n    // First up is the collection of functions used to execute a format string\n    // at runtime. This consumes all of the compile-time statics generated by\n    // the format! syntax extension.\n    fn run(&mut self, arg: &rt::v1::Argument) -> Result {\n        // Fill in the format parameters into the formatter\n        self.fill = arg.format.fill;\n        self.align = arg.format.align;\n        self.flags = arg.format.flags;\n        self.width = self.getcount(&arg.format.width);\n        self.precision = self.getcount(&arg.format.precision);\n\n        // Extract the correct argument\n        let value = match arg.position {\n            rt::v1::Position::Next => { *self.curarg.next().unwrap() }\n            rt::v1::Position::At(i) => self.args[i],\n        };\n\n        // Then actually do some printing\n        (value.formatter)(value.value, self)\n    }\n\n    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<usize> {\n        match *cnt {\n            rt::v1::Count::Is(n) => Some(n),\n            rt::v1::Count::Implied => None,\n            rt::v1::Count::Param(i) => {\n                self.args[i].as_usize()\n            }\n            rt::v1::Count::NextParam => {\n                self.curarg.next().and_then(|arg| arg.as_usize())\n            }\n        }\n    }\n\n    // Helper methods used for padding and processing formatting arguments that\n    // all formatting traits can use.\n\n    /// Performs the correct padding for an integer which has already been\n    /// emitted into a str. The str should *not* contain the sign for the\n    /// integer, that will be added by this method.\n    ///\n    /// # Arguments\n    ///\n    /// * is_nonnegative - whether the original integer was either positive or zero.\n    /// * prefix - if the '#' character (Alternate) is provided, this\n    ///   is the prefix to put in front of the number.\n    /// * buf - the byte array that the number has been formatted into\n    ///\n    /// This function will correctly account for the flags provided as well as\n    /// the minimum width. It will not take precision into account.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pad_integral(&mut self,\n                        is_nonnegative: bool,\n                        prefix: &str,\n                        buf: &str)\n                        -> Result {\n        let mut width = buf.len();\n\n        let mut sign = None;\n        if !is_nonnegative {\n            sign = Some('-'); width += 1;\n        } else if self.sign_plus() {\n            sign = Some('+'); width += 1;\n        }\n\n        let mut prefixed = false;\n        if self.alternate() {\n            prefixed = true; width += prefix.chars().count();\n        }\n\n        // Writes the sign if it exists, and then the prefix if it was requested\n        let write_prefix = |f: &mut Formatter| {\n            if let Some(c) = sign {\n                f.buf.write_str(c.encode_utf8(&mut [0; 4]))?;\n            }\n            if prefixed { f.buf.write_str(prefix) }\n            else { Ok(()) }\n        };\n\n        // The `width` field is more of a `min-width` parameter at this point.\n        match self.width {\n            // If there's no minimum length requirements then we can just\n            // write the bytes.\n            None => {\n                write_prefix(self)?; self.buf.write_str(buf)\n            }\n            // Check if we're over the minimum width, if so then we can also\n            // just write the bytes.\n            Some(min) if width >= min => {\n                write_prefix(self)?; self.buf.write_str(buf)\n            }\n            // The sign and prefix goes before the padding if the fill character\n            // is zero\n            Some(min) if self.sign_aware_zero_pad() => {\n                self.fill = '0';\n                self.align = rt::v1::Alignment::Right;\n                write_prefix(self)?;\n                self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n                    f.buf.write_str(buf)\n                })\n            }\n            // Otherwise, the sign and prefix goes after the padding\n            Some(min) => {\n                self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n                    write_prefix(f)?; f.buf.write_str(buf)\n                })\n            }\n        }\n    }\n\n    /// This function takes a string slice and emits it to the internal buffer\n    /// after applying the relevant formatting flags specified. The flags\n    /// recognized for generic strings are:\n    ///\n    /// * width - the minimum width of what to emit\n    /// * fill/align - what to emit and where to emit it if the string\n    ///                provided needs to be padded\n    /// * precision - the maximum length to emit, the string is truncated if it\n    ///               is longer than this length\n    ///\n    /// Notably this function ignores the `flag` parameters.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pad(&mut self, s: &str) -> Result {\n        // Make sure there's a fast path up front\n        if self.width.is_none() && self.precision.is_none() {\n            return self.buf.write_str(s);\n        }\n        // The `precision` field can be interpreted as a `max-width` for the\n        // string being formatted.\n        let s = if let Some(max) = self.precision {\n            // If our string is longer that the precision, then we must have\n            // truncation. However other flags like `fill`, `width` and `align`\n            // must act as always.\n            if let Some((i, _)) = s.char_indices().skip(max).next() {\n                &s[..i]\n            } else {\n                &s\n            }\n        } else {\n            &s\n        };\n        // The `width` field is more of a `min-width` parameter at this point.\n        match self.width {\n            // If we're under the maximum length, and there's no minimum length\n            // requirements, then we can just emit the string\n            None => self.buf.write_str(s),\n            // If we're under the maximum width, check if we're over the minimum\n            // width, if so it's as easy as just emitting the string.\n            Some(width) if s.chars().count() >= width => {\n                self.buf.write_str(s)\n            }\n            // If we're under both the maximum and the minimum width, then fill\n            // up the minimum width with the specified string + some alignment.\n            Some(width) => {\n                let align = rt::v1::Alignment::Left;\n                self.with_padding(width - s.chars().count(), align, |me| {\n                    me.buf.write_str(s)\n                })\n            }\n        }\n    }\n\n    /// Runs a callback, emitting the correct padding either before or\n    /// afterwards depending on whether right or left alignment is requested.\n    fn with_padding<F>(&mut self, padding: usize, default: rt::v1::Alignment,\n                       f: F) -> Result\n        where F: FnOnce(&mut Formatter) -> Result,\n    {\n        let align = match self.align {\n            rt::v1::Alignment::Unknown => default,\n            _ => self.align\n        };\n\n        let (pre_pad, post_pad) = match align {\n            rt::v1::Alignment::Left => (0, padding),\n            rt::v1::Alignment::Right |\n            rt::v1::Alignment::Unknown => (padding, 0),\n            rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n        };\n\n        let mut fill = [0; 4];\n        let fill = self.fill.encode_utf8(&mut fill);\n\n        for _ in 0..pre_pad {\n            self.buf.write_str(fill)?;\n        }\n\n        f(self)?;\n\n        for _ in 0..post_pad {\n            self.buf.write_str(fill)?;\n        }\n\n        Ok(())\n    }\n\n    /// Takes the formatted parts and applies the padding.\n    /// Assumes that the caller already has rendered the parts with required precision,\n    /// so that `self.precision` can be ignored.\n    fn pad_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result {\n        if let Some(mut width) = self.width {\n            // for the sign-aware zero padding, we render the sign first and\n            // behave as if we had no sign from the beginning.\n            let mut formatted = formatted.clone();\n            let old_fill = self.fill;\n            let old_align = self.align;\n            let mut align = old_align;\n            if self.sign_aware_zero_pad() {\n                // a sign always goes first\n                let sign = unsafe { str::from_utf8_unchecked(formatted.sign) };\n                self.buf.write_str(sign)?;\n\n                // remove the sign from the formatted parts\n                formatted.sign = b\"\";\n                width = if width < sign.len() { 0 } else { width - sign.len() };\n                align = rt::v1::Alignment::Right;\n                self.fill = '0';\n                self.align = rt::v1::Alignment::Right;\n            }\n\n            // remaining parts go through the ordinary padding process.\n            let len = formatted.len();\n            let ret = if width <= len { // no padding\n                self.write_formatted_parts(&formatted)\n            } else {\n                self.with_padding(width - len, align, |f| {\n                    f.write_formatted_parts(&formatted)\n                })\n            };\n            self.fill = old_fill;\n            self.align = old_align;\n            ret\n        } else {\n            // this is the common case and we take a shortcut\n            self.write_formatted_parts(formatted)\n        }\n    }\n\n    fn write_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result {\n        fn write_bytes(buf: &mut Write, s: &[u8]) -> Result {\n            buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n        }\n\n        if !formatted.sign.is_empty() {\n            write_bytes(self.buf, formatted.sign)?;\n        }\n        for part in formatted.parts {\n            match *part {\n                flt2dec::Part::Zero(mut nzeroes) => {\n                    const ZEROES: &'static str = // 64 zeroes\n                        \"0000000000000000000000000000000000000000000000000000000000000000\";\n                    while nzeroes > ZEROES.len() {\n                        self.buf.write_str(ZEROES)?;\n                        nzeroes -= ZEROES.len();\n                    }\n                    if nzeroes > 0 {\n                        self.buf.write_str(&ZEROES[..nzeroes])?;\n                    }\n                }\n                flt2dec::Part::Num(mut v) => {\n                    let mut s = [0; 5];\n                    let len = part.len();\n                    for c in s[..len].iter_mut().rev() {\n                        *c = b'0' + (v % 10) as u8;\n                        v /= 10;\n                    }\n                    write_bytes(self.buf, &s[..len])?;\n                }\n                flt2dec::Part::Copy(buf) => {\n                    write_bytes(self.buf, buf)?;\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Writes some data to the underlying buffer contained within this\n    /// formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write_str(&mut self, data: &str) -> Result {\n        self.buf.write_str(data)\n    }\n\n    /// Writes some formatted information into this instance\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n        write(self.buf, fmt)\n    }\n\n    /// Flags for formatting (packed version of rt::Flag)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn flags(&self) -> u32 { self.flags }\n\n    /// Character used as 'fill' whenever there is alignment\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn fill(&self) -> char { self.fill }\n\n    /// Flag indicating what form of alignment was requested\n    #[unstable(feature = \"fmt_flags_align\", reason = \"method was just created\",\n               issue = \"27726\")]\n    pub fn align(&self) -> Alignment {\n        match self.align {\n            rt::v1::Alignment::Left => Alignment::Left,\n            rt::v1::Alignment::Right => Alignment::Right,\n            rt::v1::Alignment::Center => Alignment::Center,\n            rt::v1::Alignment::Unknown => Alignment::Unknown,\n        }\n    }\n\n    /// Optionally specified integer width that the output should be\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn width(&self) -> Option<usize> { self.width }\n\n    /// Optionally specified precision for numeric types\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn precision(&self) -> Option<usize> { self.precision }\n\n    /// Determines if the `+` flag was specified.\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_plus(&self) -> bool { self.flags & (1 << FlagV1::SignPlus as u32) != 0 }\n\n    /// Determines if the `-` flag was specified.\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_minus(&self) -> bool { self.flags & (1 << FlagV1::SignMinus as u32) != 0 }\n\n    /// Determines if the `#` flag was specified.\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn alternate(&self) -> bool { self.flags & (1 << FlagV1::Alternate as u32) != 0 }\n\n    /// Determines if the `0` flag was specified.\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_aware_zero_pad(&self) -> bool {\n        self.flags & (1 << FlagV1::SignAwareZeroPad as u32) != 0\n    }\n\n    /// Creates a `DebugStruct` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for structs.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo {\n    ///     bar: i32,\n    ///     baz: String,\n    /// }\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_struct(\"Foo\")\n    ///             .field(\"bar\", &self.bar)\n    ///             .field(\"baz\", &self.baz)\n    ///             .finish()\n    ///     }\n    /// }\n    ///\n    /// // prints \"Foo { bar: 10, baz: \"Hello World\" }\"\n    /// println!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() });\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    #[inline]\n    pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> {\n        builders::debug_struct_new(self, name)\n    }\n\n    /// Creates a `DebugTuple` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for tuple structs.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32, String);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_tuple(\"Foo\")\n    ///             .field(&self.0)\n    ///             .field(&self.1)\n    ///             .finish()\n    ///     }\n    /// }\n    ///\n    /// // prints \"Foo(10, \"Hello World\")\"\n    /// println!(\"{:?}\", Foo(10, \"Hello World\".to_string()));\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    #[inline]\n    pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> {\n        builders::debug_tuple_new(self, name)\n    }\n\n    /// Creates a `DebugList` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for list-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_list().entries(self.0.iter()).finish()\n    ///     }\n    /// }\n    ///\n    /// // prints \"[10, 11]\"\n    /// println!(\"{:?}\", Foo(vec![10, 11]));\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    #[inline]\n    pub fn debug_list<'b>(&'b mut self) -> DebugList<'b, 'a> {\n        builders::debug_list_new(self)\n    }\n\n    /// Creates a `DebugSet` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for set-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_set().entries(self.0.iter()).finish()\n    ///     }\n    /// }\n    ///\n    /// // prints \"{10, 11}\"\n    /// println!(\"{:?}\", Foo(vec![10, 11]));\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    #[inline]\n    pub fn debug_set<'b>(&'b mut self) -> DebugSet<'b, 'a> {\n        builders::debug_set_new(self)\n    }\n\n    /// Creates a `DebugMap` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for map-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<(String, i32)>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref v)| (k, v))).finish()\n    ///     }\n    /// }\n    ///\n    /// // prints \"{\"A\": 10, \"B\": 11}\"\n    /// println!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)]));\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    #[inline]\n    pub fn debug_map<'b>(&'b mut self) -> DebugMap<'b, 'a> {\n        builders::debug_map_new(self)\n    }\n}\n\n#[stable(since = \"1.2.0\", feature = \"formatter_write\")]\nimpl<'a> Write for Formatter<'a> {\n    fn write_str(&mut self, s: &str) -> Result {\n        self.buf.write_str(s)\n    }\n\n    fn write_char(&mut self, c: char) -> Result {\n        self.buf.write_char(c)\n    }\n\n    fn write_fmt(&mut self, args: Arguments) -> Result {\n        write(self.buf, args)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for Error {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Display::fmt(\"an error occurred when formatting an argument\", f)\n    }\n}\n\n// Implementations of the core formatting traits\n\nmacro_rules! fmt_refs {\n    ($($tr:ident),*) => {\n        $(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T: ?Sized + $tr> $tr for &'a T {\n            fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n        }\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T: ?Sized + $tr> $tr for &'a mut T {\n            fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n        }\n        )*\n    }\n}\n\nfmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n\n#[unstable(feature = \"never_type_impls\", issue = \"35121\")]\nimpl Debug for ! {\n    fn fmt(&self, _: &mut Formatter) -> Result {\n        *self\n    }\n}\n\n#[unstable(feature = \"never_type_impls\", issue = \"35121\")]\nimpl Display for ! {\n    fn fmt(&self, _: &mut Formatter) -> Result {\n        *self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for bool {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Display::fmt(self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for bool {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Display::fmt(if *self { \"true\" } else { \"false\" }, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for str {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.write_char('\"')?;\n        let mut from = 0;\n        for (i, c) in self.char_indices() {\n            let esc = c.escape_debug();\n            // If char needs escaping, flush backlog so far and write, else skip\n            if esc.len() != 1 {\n                f.write_str(&self[from..i])?;\n                for c in esc {\n                    f.write_char(c)?;\n                }\n                from = i + c.len_utf8();\n            }\n        }\n        f.write_str(&self[from..])?;\n        f.write_char('\"')\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for str {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.pad(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for char {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.write_char('\\'')?;\n        for c in self.escape_debug() {\n            f.write_char(c)?\n        }\n        f.write_char('\\'')\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for char {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        if f.width.is_none() && f.precision.is_none() {\n            f.write_char(*self)\n        } else {\n            f.pad(self.encode_utf8(&mut [0; 4]))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Pointer for *const T {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        let old_width = f.width;\n        let old_flags = f.flags;\n\n        // The alternate flag is already treated by LowerHex as being special-\n        // it denotes whether to prefix with 0x. We use it to work out whether\n        // or not to zero extend, and then unconditionally set it to get the\n        // prefix.\n        if f.alternate() {\n            f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n\n            if let None = f.width {\n                f.width = Some(((mem::size_of::<usize>() * 8) / 4) + 2);\n            }\n        }\n        f.flags |= 1 << (FlagV1::Alternate as u32);\n\n        let ret = LowerHex::fmt(&(*self as *const () as usize), f);\n\n        f.width = old_width;\n        f.flags = old_flags;\n\n        ret\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Pointer for *mut T {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Pointer::fmt(&(*self as *const T), f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized> Pointer for &'a T {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Pointer::fmt(&(*self as *const T), f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized> Pointer for &'a mut T {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Pointer::fmt(&(&**self as *const T), f)\n    }\n}\n\n// Implementation of Display/Debug for various core types\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Debug for *const T {\n    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Debug for *mut T {\n    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n}\n\nmacro_rules! peel {\n    ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n}\n\nmacro_rules! tuple {\n    () => ();\n    ( $($name:ident,)+ ) => (\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<$($name:Debug),*> Debug for ($($name,)*) {\n            #[allow(non_snake_case, unused_assignments, deprecated)]\n            fn fmt(&self, f: &mut Formatter) -> Result {\n                let mut builder = f.debug_tuple(\"\");\n                let ($(ref $name,)*) = *self;\n                $(\n                    builder.field($name);\n                )*\n\n                builder.finish()\n            }\n        }\n        peel! { $($name,)* }\n    )\n}\n\ntuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Debug> Debug for [T] {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for () {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.pad(\"()\")\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Debug for PhantomData<T> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.pad(\"PhantomData\")\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Copy + Debug> Debug for Cell<T> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.debug_struct(\"Cell\")\n            .field(\"value\", &self.get())\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Debug> Debug for RefCell<T> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        match self.try_borrow() {\n            Ok(borrow) => {\n                f.debug_struct(\"RefCell\")\n                    .field(\"value\", &borrow)\n                    .finish()\n            }\n            Err(_) => {\n                f.debug_struct(\"RefCell\")\n                    .field(\"value\", &\"<borrowed>\")\n                    .finish()\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'b, T: ?Sized + Debug> Debug for Ref<'b, T> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'b, T: ?Sized + Debug> Debug for RefMut<'b, T> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Debug::fmt(&*(self.deref()), f)\n    }\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: ?Sized + Debug> Debug for UnsafeCell<T> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.pad(\"UnsafeCell\")\n    }\n}\n\n// If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n// it's a lot easier than creating all of the rt::Piece structures here.\n",null,"// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![unstable(feature = \"heap_api\",\n            reason = \"the precise API and guarantees it provides may be tweaked \\\n                      slightly, especially to possibly take into account the \\\n                      types being stored to make room for a future \\\n                      tracing garbage collector\",\n            issue = \"27700\")]\n\nuse allocator::{Alloc, AllocErr, CannotReallocInPlace, Layout};\nuse core::{isize, usize, cmp, ptr};\nuse core::intrinsics::{min_align_of_val, size_of_val};\n\n#[allow(improper_ctypes)]\nextern \"C\" {\n    #[allocator]\n    fn __rust_allocate(size: usize, align: usize) -> *mut u8;\n    fn __rust_allocate_zeroed(size: usize, align: usize) -> *mut u8;\n    fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);\n    fn __rust_reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8;\n    fn __rust_reallocate_inplace(ptr: *mut u8,\n                                 old_size: usize,\n                                 size: usize,\n                                 align: usize)\n                                 -> usize;\n    fn __rust_usable_size(size: usize, align: usize) -> usize;\n}\n\n#[inline(always)]\nfn check_size_and_alignment(size: usize, align: usize) {\n    debug_assert!(size != 0);\n    debug_assert!(size <= isize::MAX as usize,\n                  \"Tried to allocate too much: {} bytes\",\n                  size);\n    debug_assert!(usize::is_power_of_two(align),\n                  \"Invalid alignment of allocation: {}\",\n                  align);\n}\n\n#[derive(Copy, Clone, Default, Debug)]\npub struct HeapAlloc;\n\nunsafe impl Alloc for HeapAlloc {\n    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n        let addr = allocate(layout.size(), layout.align());\n        if addr.is_null() {\n            Err(AllocErr::Exhausted { request: layout })\n        } else {\n            Ok(addr)\n        }\n    }\n\n    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n        let addr = allocate_zeroed(layout.size(), layout.align());\n        if addr.is_null() {\n            Err(AllocErr::Exhausted { request: layout })\n        } else {\n            Ok(addr)\n        }\n    }\n\n    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n        deallocate(ptr, layout.size(), layout.align());\n    }\n\n    fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n        (layout.size(), usable_size(layout.size(), layout.align()))\n    }\n\n    unsafe fn realloc(&mut self,\n                      ptr: *mut u8,\n                      layout: Layout,\n                      new_layout: Layout)\n                      -> Result<*mut u8, AllocErr>\n    {\n        let old_size = layout.size();\n        let new_size = new_layout.size();\n        if layout.align() == new_layout.align() {\n            let new_ptr = reallocate(ptr, old_size, new_size, layout.align());\n            if new_ptr.is_null() {\n                // We assume `reallocate` already tried alloc + copy +\n                // dealloc fallback; thus pointless to repeat effort\n                Err(AllocErr::Exhausted { request: new_layout })\n            } else {\n                Ok(new_ptr)\n            }\n        } else {\n            // if alignments don't match, fall back on alloc + copy + dealloc\n            let result = self.alloc(new_layout);\n            if let Ok(new_ptr) = result {\n                ptr::copy_nonoverlapping(ptr as *const u8, new_ptr, cmp::min(old_size, new_size));\n                self.dealloc(ptr, layout);\n            }\n            result\n        }\n    }\n\n    unsafe fn grow_in_place(&mut self,\n                            ptr: *mut u8,\n                            layout: Layout,\n                            new_layout: Layout)\n                            -> Result<(), CannotReallocInPlace>\n    {\n        // grow_in_place spec requires this, and the spec for reallocate_inplace\n        // makes it hard to detect failure if it does not hold.\n        debug_assert!(new_layout.size() >= layout.size());\n\n        if layout.align() != new_layout.align() { // reallocate_inplace requires this.\n            return Err(CannotReallocInPlace);\n        }\n        let usable = reallocate_inplace(ptr, layout.size(), new_layout.size(), layout.align());\n        if usable >= new_layout.size() { Ok(()) } else { Err(CannotReallocInPlace) }\n    }\n}\n\n// FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n\n/// Return a pointer to `size` bytes of memory aligned to `align`.\n///\n/// On failure, return a null pointer.\n///\n/// Behavior is undefined if the requested size is 0 or the alignment is not a\n/// power of 2. The alignment must be no larger than the largest supported page\n/// size on the platform.\n#[inline]\npub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n    check_size_and_alignment(size, align);\n    __rust_allocate(size, align)\n}\n\n/// Return a pointer to `size` bytes of memory aligned to `align` and\n/// initialized to zeroes.\n///\n/// On failure, return a null pointer.\n///\n/// Behavior is undefined if the requested size is 0 or the alignment is not a\n/// power of 2. The alignment must be no larger than the largest supported page\n/// size on the platform.\n#[inline]\npub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n    check_size_and_alignment(size, align);\n    __rust_allocate_zeroed(size, align)\n}\n\n/// Resize the allocation referenced by `ptr` to `size` bytes.\n///\n/// On failure, return a null pointer and leave the original allocation intact.\n///\n/// If the allocation was relocated, the memory at the passed-in pointer is\n/// undefined after the call.\n///\n/// Behavior is undefined if the requested size is 0 or the alignment is not a\n/// power of 2. The alignment must be no larger than the largest supported page\n/// size on the platform.\n///\n/// The `old_size` and `align` parameters are the parameters that were used to\n/// create the allocation referenced by `ptr`. The `old_size` parameter may be\n/// any value in range_inclusive(requested_size, usable_size).\n#[inline]\npub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n    check_size_and_alignment(size, align);\n    __rust_reallocate(ptr, old_size, size, align)\n}\n\n/// Resize the allocation referenced by `ptr` to `size` bytes.\n///\n/// If the operation succeeds, it returns `usable_size(size, align)` and if it\n/// fails (or is a no-op) it returns `usable_size(old_size, align)`.\n///\n/// Behavior is undefined if the requested size is 0 or the alignment is not a\n/// power of 2. The alignment must be no larger than the largest supported page\n/// size on the platform.\n///\n/// The `old_size` and `align` parameters are the parameters that were used to\n/// create the allocation referenced by `ptr`. The `old_size` parameter may be\n/// any value in range_inclusive(requested_size, usable_size).\n#[inline]\npub unsafe fn reallocate_inplace(ptr: *mut u8,\n                                 old_size: usize,\n                                 size: usize,\n                                 align: usize)\n                                 -> usize {\n    check_size_and_alignment(size, align);\n    __rust_reallocate_inplace(ptr, old_size, size, align)\n}\n\n/// Deallocates the memory referenced by `ptr`.\n///\n/// The `ptr` parameter must not be null.\n///\n/// The `old_size` and `align` parameters are the parameters that were used to\n/// create the allocation referenced by `ptr`. The `old_size` parameter may be\n/// any value in range_inclusive(requested_size, usable_size).\n#[inline]\npub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n    __rust_deallocate(ptr, old_size, align)\n}\n\n/// Returns the usable size of an allocation created with the specified the\n/// `size` and `align`.\n#[inline]\npub fn usable_size(size: usize, align: usize) -> usize {\n    unsafe { __rust_usable_size(size, align) }\n}\n\n/// An arbitrary non-null address to represent zero-size allocations.\n///\n/// This preserves the non-null invariant for types like `Box<T>`. The address\n/// may overlap with non-zero-size memory allocations.\n#[rustc_deprecated(since = \"1.19\", reason = \"Use Unique/Shared::empty() instead\")]\n#[unstable(feature = \"heap_api\", issue = \"27700\")]\npub const EMPTY: *mut () = 1 as *mut ();\n\n/// The allocator for unique pointers.\n// This function must not unwind. If it does, MIR trans will fail.\n#[cfg(not(test))]\n#[lang = \"exchange_malloc\"]\n#[inline]\nunsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n    if size == 0 {\n        align as *mut u8\n    } else {\n        let ptr = allocate(size, align);\n        if ptr.is_null() {\n            ::oom()\n        }\n        ptr\n    }\n}\n\n#[cfg_attr(not(test), lang = \"box_free\")]\n#[inline]\npub(crate) unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n    let size = size_of_val(&*ptr);\n    let align = min_align_of_val(&*ptr);\n    // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n    if size != 0 {\n        deallocate(ptr as *mut u8, size, align);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate test;\n    use self::test::Bencher;\n    use boxed::Box;\n    use heap;\n\n    #[test]\n    fn allocate_zeroed() {\n        unsafe {\n            let size = 1024;\n            let ptr = heap::allocate_zeroed(size, 1);\n            if ptr.is_null() {\n                ::oom()\n            }\n\n            let end = ptr.offset(size as isize);\n            let mut i = ptr;\n            while i < end {\n                assert_eq!(*i, 0);\n                i = i.offset(1);\n            }\n            heap::deallocate(ptr, size, 1);\n        }\n    }\n\n    #[test]\n    fn basic_reallocate_inplace_noop() {\n        unsafe {\n            let size = 4000;\n            let ptr = heap::allocate(size, 8);\n            if ptr.is_null() {\n                ::oom()\n            }\n            let ret = heap::reallocate_inplace(ptr, size, size, 8);\n            heap::deallocate(ptr, size, 8);\n            assert_eq!(ret, heap::usable_size(size, 8));\n        }\n    }\n\n    #[bench]\n    fn alloc_owned_small(b: &mut Bencher) {\n        b.iter(|| {\n            let _: Box<_> = box 10;\n        })\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n// FIXME: talk about offset, copy_memory, copy_nonoverlapping_memory\n\n//! Raw, unsafe pointers, `*const T`, and `*mut T`.\n//!\n//! *[See also the pointer primitive types](../../std/primitive.pointer.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse intrinsics;\nuse ops::CoerceUnsized;\nuse fmt;\nuse hash;\nuse marker::{PhantomData, Unsize};\nuse mem;\nuse nonzero::NonZero;\n\nuse cmp::Ordering::{self, Less, Equal, Greater};\n\n// FIXME #19649: intrinsic docs don't render, so these have no docs :(\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use intrinsics::copy_nonoverlapping;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use intrinsics::copy;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use intrinsics::write_bytes;\n\n/// Executes the destructor (if any) of the pointed-to value.\n///\n/// This has two use cases:\n///\n/// * It is *required* to use `drop_in_place` to drop unsized types like\n///   trait objects, because they can't be read out onto the stack and\n///   dropped normally.\n///\n/// * It is friendlier to the optimizer to do this over `ptr::read` when\n///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n///   as the compiler doesn't need to prove that it's sound to elide the\n///   copy.\n///\n/// # Undefined Behavior\n///\n/// This has all the same safety problems as `ptr::read` with respect to\n/// invalid pointers, types, and double drops.\n#[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n#[lang=\"drop_in_place\"]\n#[allow(unconditional_recursion)]\npub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n    // Code here does not matter - this is replaced by the\n    // real drop glue by the compiler.\n    drop_in_place(to_drop);\n}\n\n/// Creates a null raw pointer.\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let p: *const i32 = ptr::null();\n/// assert!(p.is_null());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const fn null<T>() -> *const T { 0 as *const T }\n\n/// Creates a null mutable raw pointer.\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let p: *mut i32 = ptr::null_mut();\n/// assert!(p.is_null());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n\n/// Swaps the values at two mutable locations of the same type, without\n/// deinitializing either. They may overlap, unlike `mem::swap` which is\n/// otherwise equivalent.\n///\n/// # Safety\n///\n/// This function copies the memory through the raw pointers passed to it\n/// as arguments.\n///\n/// Ensure that these pointers are valid before calling `swap`.\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n    // Give ourselves some scratch space to work with\n    let mut tmp: T = mem::uninitialized();\n\n    // Perform the swap\n    copy_nonoverlapping(x, &mut tmp, 1);\n    copy(y, x, 1); // `x` and `y` may overlap\n    copy_nonoverlapping(&tmp, y, 1);\n\n    // y and t now point to the same thing, but we need to completely forget `tmp`\n    // because it's no longer relevant.\n    mem::forget(tmp);\n}\n\n/// Swaps a sequence of values at two mutable locations of the same type.\n///\n/// # Safety\n///\n/// The two arguments must each point to the beginning of `count` locations\n/// of valid memory, and the two memory ranges must not overlap.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// #![feature(swap_nonoverlapping)]\n///\n/// use std::ptr;\n///\n/// let mut x = [1, 2, 3, 4];\n/// let mut y = [7, 8, 9];\n///\n/// unsafe {\n///     ptr::swap_nonoverlapping(x.as_mut_ptr(), y.as_mut_ptr(), 2);\n/// }\n///\n/// assert_eq!(x, [7, 8, 3, 4]);\n/// assert_eq!(y, [1, 2, 9]);\n/// ```\n#[inline]\n#[unstable(feature = \"swap_nonoverlapping\", issue = \"42818\")]\npub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n    let x = x as *mut u8;\n    let y = y as *mut u8;\n    let len = mem::size_of::<T>() * count;\n    swap_nonoverlapping_bytes(x, y, len)\n}\n\n#[inline]\nunsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n    // The approach here is to utilize simd to swap x & y efficiently. Testing reveals\n    // that swapping either 32 bytes or 64 bytes at a time is most efficient for intel\n    // Haswell E processors. LLVM is more able to optimize if we give a struct a\n    // #[repr(simd)], even if we don't actually use this struct directly.\n    //\n    // FIXME repr(simd) broken on emscripten and redox\n    #[cfg_attr(not(any(target_os = \"emscripten\", target_os = \"redox\")), repr(simd))]\n    struct Block(u64, u64, u64, u64);\n    struct UnalignedBlock(u64, u64, u64, u64);\n\n    let block_size = mem::size_of::<Block>();\n\n    // Loop through x & y, copying them `Block` at a time\n    // The optimizer should unroll the loop fully for most types\n    // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively\n    let mut i = 0;\n    while i + block_size <= len {\n        // Create some uninitialized memory as scratch space\n        // Declaring `t` here avoids aligning the stack when this loop is unused\n        let mut t: Block = mem::uninitialized();\n        let t = &mut t as *mut _ as *mut u8;\n        let x = x.offset(i as isize);\n        let y = y.offset(i as isize);\n\n        // Swap a block of bytes of x & y, using t as a temporary buffer\n        // This should be optimized into efficient SIMD operations where available\n        copy_nonoverlapping(x, t, block_size);\n        copy_nonoverlapping(y, x, block_size);\n        copy_nonoverlapping(t, y, block_size);\n        i += block_size;\n    }\n\n    if i < len {\n        // Swap any remaining bytes\n        let mut t: UnalignedBlock = mem::uninitialized();\n        let rem = len - i;\n\n        let t = &mut t as *mut _ as *mut u8;\n        let x = x.offset(i as isize);\n        let y = y.offset(i as isize);\n\n        copy_nonoverlapping(x, t, rem);\n        copy_nonoverlapping(y, x, rem);\n        copy_nonoverlapping(t, y, rem);\n    }\n}\n\n/// Replaces the value at `dest` with `src`, returning the old\n/// value, without dropping either.\n///\n/// # Safety\n///\n/// This is only unsafe because it accepts a raw pointer.\n/// Otherwise, this operation is identical to `mem::replace`.\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n    mem::swap(&mut *dest, &mut src); // cannot overlap\n    src\n}\n\n/// Reads the value from `src` without moving it. This leaves the\n/// memory in `src` unchanged.\n///\n/// # Safety\n///\n/// Beyond accepting a raw pointer, this is unsafe because it semantically\n/// moves the value out of `src` without preventing further usage of `src`.\n/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n/// `src` is not used before the data is overwritten again (e.g. with `write`,\n/// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n/// because it will attempt to drop the value previously at `*src`.\n///\n/// The pointer must be aligned; use `read_unaligned` if that is not the case.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let x = 12;\n/// let y = &x as *const i32;\n///\n/// unsafe {\n///     assert_eq!(std::ptr::read(y), 12);\n/// }\n/// ```\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn read<T>(src: *const T) -> T {\n    let mut tmp: T = mem::uninitialized();\n    copy_nonoverlapping(src, &mut tmp, 1);\n    tmp\n}\n\n/// Reads the value from `src` without moving it. This leaves the\n/// memory in `src` unchanged.\n///\n/// Unlike `read`, the pointer may be unaligned.\n///\n/// # Safety\n///\n/// Beyond accepting a raw pointer, this is unsafe because it semantically\n/// moves the value out of `src` without preventing further usage of `src`.\n/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n/// `src` is not used before the data is overwritten again (e.g. with `write`,\n/// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n/// because it will attempt to drop the value previously at `*src`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let x = 12;\n/// let y = &x as *const i32;\n///\n/// unsafe {\n///     assert_eq!(std::ptr::read_unaligned(y), 12);\n/// }\n/// ```\n#[inline(always)]\n#[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\npub unsafe fn read_unaligned<T>(src: *const T) -> T {\n    let mut tmp: T = mem::uninitialized();\n    copy_nonoverlapping(src as *const u8,\n                        &mut tmp as *mut T as *mut u8,\n                        mem::size_of::<T>());\n    tmp\n}\n\n/// Overwrites a memory location with the given value without reading or\n/// dropping the old value.\n///\n/// # Safety\n///\n/// This operation is marked unsafe because it accepts a raw pointer.\n///\n/// It does not drop the contents of `dst`. This is safe, but it could leak\n/// allocations or resources, so care must be taken not to overwrite an object\n/// that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// This is appropriate for initializing uninitialized memory, or overwriting\n/// memory that has previously been `read` from.\n///\n/// The pointer must be aligned; use `write_unaligned` if that is not the case.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let mut x = 0;\n/// let y = &mut x as *mut i32;\n/// let z = 12;\n///\n/// unsafe {\n///     std::ptr::write(y, z);\n///     assert_eq!(std::ptr::read(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn write<T>(dst: *mut T, src: T) {\n    intrinsics::move_val_init(&mut *dst, src)\n}\n\n/// Overwrites a memory location with the given value without reading or\n/// dropping the old value.\n///\n/// Unlike `write`, the pointer may be unaligned.\n///\n/// # Safety\n///\n/// This operation is marked unsafe because it accepts a raw pointer.\n///\n/// It does not drop the contents of `dst`. This is safe, but it could leak\n/// allocations or resources, so care must be taken not to overwrite an object\n/// that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// This is appropriate for initializing uninitialized memory, or overwriting\n/// memory that has previously been `read` from.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let mut x = 0;\n/// let y = &mut x as *mut i32;\n/// let z = 12;\n///\n/// unsafe {\n///     std::ptr::write_unaligned(y, z);\n///     assert_eq!(std::ptr::read_unaligned(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\npub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n    copy_nonoverlapping(&src as *const T as *const u8,\n                        dst as *mut u8,\n                        mem::size_of::<T>());\n    mem::forget(src);\n}\n\n/// Performs a volatile read of the value from `src` without moving it. This\n/// leaves the memory in `src` unchanged.\n///\n/// Volatile operations are intended to act on I/O memory, and are guaranteed\n/// to not be elided or reordered by the compiler across other volatile\n/// operations.\n///\n/// # Notes\n///\n/// Rust does not currently have a rigorously and formally defined memory model,\n/// so the precise semantics of what \"volatile\" means here is subject to change\n/// over time. That being said, the semantics will almost always end up pretty\n/// similar to [C11's definition of volatile][c11].\n///\n/// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n///\n/// # Safety\n///\n/// Beyond accepting a raw pointer, this is unsafe because it semantically\n/// moves the value out of `src` without preventing further usage of `src`.\n/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n/// `src` is not used before the data is overwritten again (e.g. with `write`,\n/// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n/// because it will attempt to drop the value previously at `*src`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let x = 12;\n/// let y = &x as *const i32;\n///\n/// unsafe {\n///     assert_eq!(std::ptr::read_volatile(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"volatile\", since = \"1.9.0\")]\npub unsafe fn read_volatile<T>(src: *const T) -> T {\n    intrinsics::volatile_load(src)\n}\n\n/// Performs a volatile write of a memory location with the given value without\n/// reading or dropping the old value.\n///\n/// Volatile operations are intended to act on I/O memory, and are guaranteed\n/// to not be elided or reordered by the compiler across other volatile\n/// operations.\n///\n/// # Notes\n///\n/// Rust does not currently have a rigorously and formally defined memory model,\n/// so the precise semantics of what \"volatile\" means here is subject to change\n/// over time. That being said, the semantics will almost always end up pretty\n/// similar to [C11's definition of volatile][c11].\n///\n/// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n///\n/// # Safety\n///\n/// This operation is marked unsafe because it accepts a raw pointer.\n///\n/// It does not drop the contents of `dst`. This is safe, but it could leak\n/// allocations or resources, so care must be taken not to overwrite an object\n/// that should be dropped.\n///\n/// This is appropriate for initializing uninitialized memory, or overwriting\n/// memory that has previously been `read` from.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let mut x = 0;\n/// let y = &mut x as *mut i32;\n/// let z = 12;\n///\n/// unsafe {\n///     std::ptr::write_volatile(y, z);\n///     assert_eq!(std::ptr::read_volatile(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"volatile\", since = \"1.9.0\")]\npub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n    intrinsics::volatile_store(dst, src);\n}\n\n#[lang = \"const_ptr\"]\nimpl<T: ?Sized> *const T {\n    /// Returns `true` if the pointer is null.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s: &str = \"Follow the rabbit\";\n    /// let ptr: *const u8 = s.as_ptr();\n    /// assert!(!ptr.is_null());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_null(self) -> bool where T: Sized {\n        self == null()\n    }\n\n    /// Returns `None` if the pointer is null, or else returns a reference to\n    /// the value wrapped in `Some`.\n    ///\n    /// # Safety\n    ///\n    /// While this method and its mutable counterpart are useful for\n    /// null-safety, it is important to note that this is still an unsafe\n    /// operation because the returned value could be pointing to invalid\n    /// memory.\n    ///\n    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n    /// not necessarily reflect the actual lifetime of the data.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let ptr: *const u8 = &10u8 as *const u8;\n    ///\n    /// unsafe {\n    ///     if let Some(val_back) = ptr.as_ref() {\n    ///         println!(\"We got back the value: {}!\", val_back);\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n    #[inline]\n    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> where T: Sized {\n        if self.is_null() {\n            None\n        } else {\n            Some(&*self)\n        }\n    }\n\n    /// Calculates the offset from a pointer. `count` is in units of T; e.g. a\n    /// `count` of 3 represents a pointer offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// Both the starting and resulting pointer must be either in bounds or one\n    /// byte past the end of an allocated object. If either pointer is out of\n    /// bounds or arithmetic overflow occurs then\n    /// any further use of the returned value will result in undefined behavior.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s: &str = \"123\";\n    /// let ptr: *const u8 = s.as_ptr();\n    ///\n    /// unsafe {\n    ///     println!(\"{}\", *ptr.offset(1) as char);\n    ///     println!(\"{}\", *ptr.offset(2) as char);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn offset(self, count: isize) -> *const T where T: Sized {\n        intrinsics::offset(self, count)\n    }\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// Always use `.offset(count)` instead when possible, because `offset`\n    /// allows the compiler to optimize better.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // Iterate using a raw pointer in increments of two elements\n    /// let data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *const u8 = data.as_ptr();\n    /// let step = 2;\n    /// let end_rounded_up = ptr.wrapping_offset(6);\n    ///\n    /// // This loop prints \"1, 3, 5, \"\n    /// while ptr != end_rounded_up {\n    ///     unsafe {\n    ///         print!(\"{}, \", *ptr);\n    ///     }\n    ///     ptr = ptr.wrapping_offset(step);\n    /// }\n    /// ```\n    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n    #[inline]\n    pub fn wrapping_offset(self, count: isize) -> *const T where T: Sized {\n        unsafe {\n            intrinsics::arith_offset(self, count)\n        }\n    }\n\n    /// Calculates the distance between two pointers. The returned value is in\n    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n    ///\n    /// If the address different between the two pointers ia not a multiple of\n    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n    /// zero.\n    ///\n    /// This function returns `None` if `T` is a zero-sized typed.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(offset_to)]\n    ///\n    /// fn main() {\n    ///     let a = [0; 5];\n    ///     let ptr1: *const i32 = &a[1];\n    ///     let ptr2: *const i32 = &a[3];\n    ///     assert_eq!(ptr1.offset_to(ptr2), Some(2));\n    ///     assert_eq!(ptr2.offset_to(ptr1), Some(-2));\n    ///     assert_eq!(unsafe { ptr1.offset(2) }, ptr2);\n    ///     assert_eq!(unsafe { ptr2.offset(-2) }, ptr1);\n    /// }\n    /// ```\n    #[unstable(feature = \"offset_to\", issue = \"41079\")]\n    #[inline]\n    pub fn offset_to(self, other: *const T) -> Option<isize> where T: Sized {\n        let size = mem::size_of::<T>();\n        if size == 0 {\n            None\n        } else {\n            let diff = (other as isize).wrapping_sub(self as isize);\n            Some(diff / size as isize)\n        }\n    }\n}\n\n#[lang = \"mut_ptr\"]\nimpl<T: ?Sized> *mut T {\n    /// Returns `true` if the pointer is null.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = [1, 2, 3];\n    /// let ptr: *mut u32 = s.as_mut_ptr();\n    /// assert!(!ptr.is_null());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_null(self) -> bool where T: Sized {\n        self == null_mut()\n    }\n\n    /// Returns `None` if the pointer is null, or else returns a reference to\n    /// the value wrapped in `Some`.\n    ///\n    /// # Safety\n    ///\n    /// While this method and its mutable counterpart are useful for\n    /// null-safety, it is important to note that this is still an unsafe\n    /// operation because the returned value could be pointing to invalid\n    /// memory.\n    ///\n    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n    /// not necessarily reflect the actual lifetime of the data.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let ptr: *mut u8 = &mut 10u8 as *mut u8;\n    ///\n    /// unsafe {\n    ///     if let Some(val_back) = ptr.as_ref() {\n    ///         println!(\"We got back the value: {}!\", val_back);\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n    #[inline]\n    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> where T: Sized {\n        if self.is_null() {\n            None\n        } else {\n            Some(&*self)\n        }\n    }\n\n    /// Calculates the offset from a pointer. `count` is in units of T; e.g. a\n    /// `count` of 3 represents a pointer offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The offset must be in-bounds of the object, or one-byte-past-the-end.\n    /// Otherwise `offset` invokes Undefined Behavior, regardless of whether\n    /// the pointer is used.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = [1, 2, 3];\n    /// let ptr: *mut u32 = s.as_mut_ptr();\n    ///\n    /// unsafe {\n    ///     println!(\"{}\", *ptr.offset(1));\n    ///     println!(\"{}\", *ptr.offset(2));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn offset(self, count: isize) -> *mut T where T: Sized {\n        intrinsics::offset(self, count) as *mut T\n    }\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// Always use `.offset(count)` instead when possible, because `offset`\n    /// allows the compiler to optimize better.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // Iterate using a raw pointer in increments of two elements\n    /// let mut data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *mut u8 = data.as_mut_ptr();\n    /// let step = 2;\n    /// let end_rounded_up = ptr.wrapping_offset(6);\n    ///\n    /// while ptr != end_rounded_up {\n    ///     unsafe {\n    ///         *ptr = 0;\n    ///     }\n    ///     ptr = ptr.wrapping_offset(step);\n    /// }\n    /// assert_eq!(&data, &[0, 2, 0, 4, 0]);\n    /// ```\n    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n    #[inline]\n    pub fn wrapping_offset(self, count: isize) -> *mut T where T: Sized {\n        unsafe {\n            intrinsics::arith_offset(self, count) as *mut T\n        }\n    }\n\n    /// Returns `None` if the pointer is null, or else returns a mutable\n    /// reference to the value wrapped in `Some`.\n    ///\n    /// # Safety\n    ///\n    /// As with `as_ref`, this is unsafe because it cannot verify the validity\n    /// of the returned pointer, nor can it ensure that the lifetime `'a`\n    /// returned is indeed a valid lifetime for the contained data.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = [1, 2, 3];\n    /// let ptr: *mut u32 = s.as_mut_ptr();\n    /// let first_value = unsafe { ptr.as_mut().unwrap() };\n    /// *first_value = 4;\n    /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n    /// ```\n    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n    #[inline]\n    pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> where T: Sized {\n        if self.is_null() {\n            None\n        } else {\n            Some(&mut *self)\n        }\n    }\n\n    /// Calculates the distance between two pointers. The returned value is in\n    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n    ///\n    /// If the address different between the two pointers ia not a multiple of\n    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n    /// zero.\n    ///\n    /// This function returns `None` if `T` is a zero-sized typed.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(offset_to)]\n    ///\n    /// fn main() {\n    ///     let mut a = [0; 5];\n    ///     let ptr1: *mut i32 = &mut a[1];\n    ///     let ptr2: *mut i32 = &mut a[3];\n    ///     assert_eq!(ptr1.offset_to(ptr2), Some(2));\n    ///     assert_eq!(ptr2.offset_to(ptr1), Some(-2));\n    ///     assert_eq!(unsafe { ptr1.offset(2) }, ptr2);\n    ///     assert_eq!(unsafe { ptr2.offset(-2) }, ptr1);\n    /// }\n    /// ```\n    #[unstable(feature = \"offset_to\", issue = \"41079\")]\n    #[inline]\n    pub fn offset_to(self, other: *const T) -> Option<isize> where T: Sized {\n        let size = mem::size_of::<T>();\n        if size == 0 {\n            None\n        } else {\n            let diff = (other as isize).wrapping_sub(self as isize);\n            Some(diff / size as isize)\n        }\n    }\n}\n\n// Equality for pointers\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> PartialEq for *const T {\n    #[inline]\n    fn eq(&self, other: &*const T) -> bool { *self == *other }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Eq for *const T {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> PartialEq for *mut T {\n    #[inline]\n    fn eq(&self, other: &*mut T) -> bool { *self == *other }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Eq for *mut T {}\n\n/// Compare raw pointers for equality.\n///\n/// This is the same as using the `==` operator, but less generic:\n/// the arguments have to be `*const T` raw pointers,\n/// not anything that implements `PartialEq`.\n///\n/// This can be used to compare `&T` references (which coerce to `*const T` implicitly)\n/// by their address rather than comparing the values they point to\n/// (which is what the `PartialEq for &T` implementation does).\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let five = 5;\n/// let other_five = 5;\n/// let five_ref = &five;\n/// let same_five_ref = &five;\n/// let other_five_ref = &other_five;\n///\n/// assert!(five_ref == same_five_ref);\n/// assert!(five_ref == other_five_ref);\n///\n/// assert!(ptr::eq(five_ref, same_five_ref));\n/// assert!(!ptr::eq(five_ref, other_five_ref));\n/// ```\n#[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n#[inline]\npub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n    a == b\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Clone for *const T {\n    #[inline]\n    fn clone(&self) -> *const T {\n        *self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Clone for *mut T {\n    #[inline]\n    fn clone(&self) -> *mut T {\n        *self\n    }\n}\n\n// Impls for function pointers\nmacro_rules! fnptr_impls_safety_abi {\n    ($FnTy: ty, $($Arg: ident),*) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<Ret, $($Arg),*> Clone for $FnTy {\n            #[inline]\n            fn clone(&self) -> Self {\n                *self\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> PartialEq for $FnTy {\n            #[inline]\n            fn eq(&self, other: &Self) -> bool {\n                *self as usize == *other as usize\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> Eq for $FnTy {}\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> PartialOrd for $FnTy {\n            #[inline]\n            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n                (*self as usize).partial_cmp(&(*other as usize))\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> Ord for $FnTy {\n            #[inline]\n            fn cmp(&self, other: &Self) -> Ordering {\n                (*self as usize).cmp(&(*other as usize))\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> hash::Hash for $FnTy {\n            fn hash<HH: hash::Hasher>(&self, state: &mut HH) {\n                state.write_usize(*self as usize)\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> fmt::Pointer for $FnTy {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                fmt::Pointer::fmt(&(*self as *const ()), f)\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> fmt::Debug for $FnTy {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                fmt::Pointer::fmt(&(*self as *const ()), f)\n            }\n        }\n    }\n}\n\nmacro_rules! fnptr_impls_args {\n    ($($Arg: ident),+) => {\n        fnptr_impls_safety_abi! { extern \"Rust\" fn($($Arg),*) -> Ret, $($Arg),* }\n        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),*) -> Ret, $($Arg),* }\n        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),* , ...) -> Ret, $($Arg),* }\n        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn($($Arg),*) -> Ret, $($Arg),* }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),*) -> Ret, $($Arg),* }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),* , ...) -> Ret, $($Arg),* }\n    };\n    () => {\n        // No variadic functions with 0 parameters\n        fnptr_impls_safety_abi! { extern \"Rust\" fn() -> Ret, }\n        fnptr_impls_safety_abi! { extern \"C\" fn() -> Ret, }\n        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn() -> Ret, }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn() -> Ret, }\n    };\n}\n\nfnptr_impls_args! { }\nfnptr_impls_args! { A }\nfnptr_impls_args! { A, B }\nfnptr_impls_args! { A, B, C }\nfnptr_impls_args! { A, B, C, D }\nfnptr_impls_args! { A, B, C, D, E }\nfnptr_impls_args! { A, B, C, D, E, F }\nfnptr_impls_args! { A, B, C, D, E, F, G }\nfnptr_impls_args! { A, B, C, D, E, F, G, H }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n\n// Comparison for pointers\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Ord for *const T {\n    #[inline]\n    fn cmp(&self, other: &*const T) -> Ordering {\n        if self < other {\n            Less\n        } else if self == other {\n            Equal\n        } else {\n            Greater\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> PartialOrd for *const T {\n    #[inline]\n    fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n\n    #[inline]\n    fn lt(&self, other: &*const T) -> bool { *self < *other }\n\n    #[inline]\n    fn le(&self, other: &*const T) -> bool { *self <= *other }\n\n    #[inline]\n    fn gt(&self, other: &*const T) -> bool { *self > *other }\n\n    #[inline]\n    fn ge(&self, other: &*const T) -> bool { *self >= *other }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Ord for *mut T {\n    #[inline]\n    fn cmp(&self, other: &*mut T) -> Ordering {\n        if self < other {\n            Less\n        } else if self == other {\n            Equal\n        } else {\n            Greater\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> PartialOrd for *mut T {\n    #[inline]\n    fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n\n    #[inline]\n    fn lt(&self, other: &*mut T) -> bool { *self < *other }\n\n    #[inline]\n    fn le(&self, other: &*mut T) -> bool { *self <= *other }\n\n    #[inline]\n    fn gt(&self, other: &*mut T) -> bool { *self > *other }\n\n    #[inline]\n    fn ge(&self, other: &*mut T) -> bool { *self >= *other }\n}\n\n/// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n/// of this wrapper owns the referent. Useful for building abstractions like\n/// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n///\n/// Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n/// It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n/// the kind of strong aliasing guarantees an instance of `T` can expect:\n/// the referent of the pointer should not be modified without a unique path to\n/// its owning Unique.\n///\n/// If you're uncertain of whether it's correct to use `Unique` for your purposes,\n/// consider using `Shared`, which has weaker semantics.\n///\n/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n/// is never dereferenced. This is so that enums may use this forbidden value\n/// as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n/// However the pointer may still dangle if it isn't dereferenced.\n///\n/// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n/// for any type which upholds Unique's aliasing requirements.\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n           issue = \"27730\")]\npub struct Unique<T: ?Sized> {\n    pointer: NonZero<*const T>,\n    // NOTE: this marker has no consequences for variance, but is necessary\n    // for dropck to understand that we logically own a `T`.\n    //\n    // For details, see:\n    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data\n    _marker: PhantomData<T>,\n}\n\n/// `Unique` pointers are `Send` if `T` is `Send` because the data they\n/// reference is unaliased. Note that this aliasing invariant is\n/// unenforced by the type system; the abstraction using the\n/// `Unique` must enforce it.\n#[unstable(feature = \"unique\", issue = \"27730\")]\nunsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n\n/// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n/// reference is unaliased. Note that this aliasing invariant is\n/// unenforced by the type system; the abstraction using the\n/// `Unique` must enforce it.\n#[unstable(feature = \"unique\", issue = \"27730\")]\nunsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n\n#[unstable(feature = \"unique\", issue = \"27730\")]\nimpl<T: Sized> Unique<T> {\n    /// Creates a new `Unique` that is dangling, but well-aligned.\n    ///\n    /// This is useful for initializing types which lazily allocate, like\n    /// `Vec::new` does.\n    pub fn empty() -> Self {\n        unsafe {\n            let ptr = mem::align_of::<T>() as *mut T;\n            Unique::new(ptr)\n        }\n    }\n}\n\n#[unstable(feature = \"unique\", issue = \"27730\")]\nimpl<T: ?Sized> Unique<T> {\n    /// Creates a new `Unique`.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    pub const unsafe fn new(ptr: *mut T) -> Unique<T> {\n        Unique { pointer: NonZero::new(ptr), _marker: PhantomData }\n    }\n\n    /// Acquires the underlying `*mut` pointer.\n    pub fn as_ptr(self) -> *mut T {\n        self.pointer.get() as *mut T\n    }\n\n    /// Dereferences the content.\n    ///\n    /// The resulting lifetime is bound to self so this behaves \"as if\"\n    /// it were actually an instance of T that is getting borrowed. If a longer\n    /// (unbound) lifetime is needed, use `&*my_ptr.ptr()`.\n    pub unsafe fn as_ref(&self) -> &T {\n        &*self.as_ptr()\n    }\n\n    /// Mutably dereferences the content.\n    ///\n    /// The resulting lifetime is bound to self so this behaves \"as if\"\n    /// it were actually an instance of T that is getting borrowed. If a longer\n    /// (unbound) lifetime is needed, use `&mut *my_ptr.ptr()`.\n    pub unsafe fn as_mut(&mut self) -> &mut T {\n        &mut *self.as_ptr()\n    }\n}\n\n#[unstable(feature = \"shared\", issue = \"27730\")]\nimpl<T: ?Sized> Clone for Unique<T> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\n#[unstable(feature = \"shared\", issue = \"27730\")]\nimpl<T: ?Sized> Copy for Unique<T> { }\n\n#[unstable(feature = \"unique\", issue = \"27730\")]\nimpl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n\n#[unstable(feature = \"unique\", issue = \"27730\")]\nimpl<T: ?Sized> fmt::Pointer for Unique<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Pointer::fmt(&self.as_ptr(), f)\n    }\n}\n\n/// A wrapper around a raw `*mut T` that indicates that the possessor\n/// of this wrapper has shared ownership of the referent. Useful for\n/// building abstractions like `Rc<T>`, `Arc<T>`, or doubly-linked lists, which\n/// internally use aliased raw pointers to manage the memory that they own.\n///\n/// This is similar to `Unique`, except that it doesn't make any aliasing\n/// guarantees, and doesn't derive Send and Sync. Note that unlike `&T`,\n/// Shared has no special mutability requirements. Shared may mutate data\n/// aliased by other Shared pointers. More precise rules require Rust to\n/// develop an actual aliasing model.\n///\n/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n/// is never dereferenced. This is so that enums may use this forbidden value\n/// as a discriminant -- `Option<Shared<T>>` has the same size as `Shared<T>`.\n/// However the pointer may still dangle if it isn't dereferenced.\n///\n/// Unlike `*mut T`, `Shared<T>` is covariant over `T`. If this is incorrect\n/// for your use case, you should include some PhantomData in your type to\n/// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n/// Usually this won't be necessary; covariance is correct for Rc, Arc, and LinkedList\n/// because they provide a public API that follows the normal shared XOR mutable\n/// rules of Rust.\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"shared\", reason = \"needs an RFC to flesh out design\",\n           issue = \"27730\")]\npub struct Shared<T: ?Sized> {\n    pointer: NonZero<*const T>,\n    // NOTE: this marker has no consequences for variance, but is necessary\n    // for dropck to understand that we logically own a `T`.\n    //\n    // For details, see:\n    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data\n    _marker: PhantomData<T>,\n}\n\n/// `Shared` pointers are not `Send` because the data they reference may be aliased.\n// NB: This impl is unnecessary, but should provide better error messages.\n#[unstable(feature = \"shared\", issue = \"27730\")]\nimpl<T: ?Sized> !Send for Shared<T> { }\n\n/// `Shared` pointers are not `Sync` because the data they reference may be aliased.\n// NB: This impl is unnecessary, but should provide better error messages.\n#[unstable(feature = \"shared\", issue = \"27730\")]\nimpl<T: ?Sized> !Sync for Shared<T> { }\n\n#[unstable(feature = \"shared\", issue = \"27730\")]\nimpl<T: Sized> Shared<T> {\n    /// Creates a new `Shared` that is dangling, but well-aligned.\n    ///\n    /// This is useful for initializing types which lazily allocate, like\n    /// `Vec::new` does.\n    pub fn empty() -> Self {\n        unsafe {\n            let ptr = mem::align_of::<T>() as *mut T;\n            Shared::new(ptr)\n        }\n    }\n}\n\n#[unstable(feature = \"shared\", issue = \"27730\")]\nimpl<T: ?Sized> Shared<T> {\n    /// Creates a new `Shared`.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    pub unsafe fn new(ptr: *mut T) -> Self {\n        Shared { pointer: NonZero::new(ptr), _marker: PhantomData }\n    }\n\n    /// Acquires the underlying `*mut` pointer.\n    pub fn as_ptr(self) -> *mut T {\n        self.pointer.get() as *mut T\n    }\n\n    /// Dereferences the content.\n    ///\n    /// The resulting lifetime is bound to self so this behaves \"as if\"\n    /// it were actually an instance of T that is getting borrowed. If a longer\n    /// (unbound) lifetime is needed, use `&*my_ptr.ptr()`.\n    pub unsafe fn as_ref(&self) -> &T {\n        &*self.as_ptr()\n    }\n\n    /// Mutably dereferences the content.\n    ///\n    /// The resulting lifetime is bound to self so this behaves \"as if\"\n    /// it were actually an instance of T that is getting borrowed. If a longer\n    /// (unbound) lifetime is needed, use `&mut *my_ptr.ptr_mut()`.\n    pub unsafe fn as_mut(&mut self) -> &mut T {\n        &mut *self.as_ptr()\n    }\n\n    /// Acquires the underlying pointer as a `*mut` pointer.\n    #[rustc_deprecated(since = \"1.19\", reason = \"renamed to `as_ptr` for ergonomics/consistency\")]\n    #[unstable(feature = \"shared\", issue = \"27730\")]\n    pub unsafe fn as_mut_ptr(&self) -> *mut T {\n        self.as_ptr()\n    }\n}\n\n#[unstable(feature = \"shared\", issue = \"27730\")]\nimpl<T: ?Sized> Clone for Shared<T> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\n#[unstable(feature = \"shared\", issue = \"27730\")]\nimpl<T: ?Sized> Copy for Shared<T> { }\n\n#[unstable(feature = \"shared\", issue = \"27730\")]\nimpl<T: ?Sized, U: ?Sized> CoerceUnsized<Shared<U>> for Shared<T> where T: Unsize<U> { }\n\n#[unstable(feature = \"shared\", issue = \"27730\")]\nimpl<T: ?Sized> fmt::Pointer for Shared<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Pointer::fmt(&self.as_ptr(), f)\n    }\n}\n","// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A pointer type for heap allocation.\n//!\n//! `Box<T>`, casually referred to as a 'box', provides the simplest form of\n//! heap allocation in Rust. Boxes provide ownership for this allocation, and\n//! drop their contents when they go out of scope.\n//!\n//! # Examples\n//!\n//! Creating a box:\n//!\n//! ```\n//! let x = Box::new(5);\n//! ```\n//!\n//! Creating a recursive data structure:\n//!\n//! ```\n//! #[derive(Debug)]\n//! enum List<T> {\n//!     Cons(T, Box<List<T>>),\n//!     Nil,\n//! }\n//!\n//! fn main() {\n//!     let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n//!     println!(\"{:?}\", list);\n//! }\n//! ```\n//!\n//! This will print `Cons(1, Cons(2, Nil))`.\n//!\n//! Recursive structures must be boxed, because if the definition of `Cons`\n//! looked like this:\n//!\n//! ```compile_fail,E0072\n//! # enum List<T> {\n//! Cons(T, List<T>),\n//! # }\n//! ```\n//!\n//! It wouldn't work. This is because the size of a `List` depends on how many\n//! elements are in the list, and so we don't know how much memory to allocate\n//! for a `Cons`. By introducing a `Box`, which has a defined size, we know how\n//! big `Cons` needs to be.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse heap;\nuse raw_vec::RawVec;\n\nuse core::any::Any;\nuse core::borrow;\nuse core::cmp::Ordering;\nuse core::fmt;\nuse core::hash::{self, Hash};\nuse core::iter::FusedIterator;\nuse core::marker::{self, Unsize};\nuse core::mem;\nuse core::ops::{CoerceUnsized, Deref, DerefMut};\nuse core::ops::{BoxPlace, Boxed, InPlace, Place, Placer};\nuse core::ptr::{self, Unique};\nuse core::convert::From;\nuse str::from_boxed_utf8_unchecked;\n\n/// A value that represents the heap. This is the default place that the `box`\n/// keyword allocates into when no place is supplied.\n///\n/// The following two examples are equivalent:\n///\n/// ```\n/// #![feature(box_heap)]\n///\n/// #![feature(box_syntax, placement_in_syntax)]\n/// use std::boxed::HEAP;\n///\n/// fn main() {\n///     let foo: Box<i32> = in HEAP { 5 };\n///     let foo = box 5;\n/// }\n/// ```\n#[unstable(feature = \"box_heap\",\n           reason = \"may be renamed; uncertain about custom allocator design\",\n           issue = \"27779\")]\npub const HEAP: ExchangeHeapSingleton = ExchangeHeapSingleton { _force_singleton: () };\n\n/// This the singleton type used solely for `boxed::HEAP`.\n#[unstable(feature = \"box_heap\",\n           reason = \"may be renamed; uncertain about custom allocator design\",\n           issue = \"27779\")]\n#[allow(missing_debug_implementations)]\n#[derive(Copy, Clone)]\npub struct ExchangeHeapSingleton {\n    _force_singleton: (),\n}\n\n/// A pointer type for heap allocation.\n///\n/// See the [module-level documentation](../../std/boxed/index.html) for more.\n#[lang = \"owned_box\"]\n#[fundamental]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Box<T: ?Sized>(Unique<T>);\n\n/// `IntermediateBox` represents uninitialized backing storage for `Box`.\n///\n/// FIXME (pnkfelix): Ideally we would just reuse `Box<T>` instead of\n/// introducing a separate `IntermediateBox<T>`; but then you hit\n/// issues when you e.g. attempt to destructure an instance of `Box`,\n/// since it is a lang item and so it gets special handling by the\n/// compiler.  Easier just to make this parallel type for now.\n///\n/// FIXME (pnkfelix): Currently the `box` protocol only supports\n/// creating instances of sized types. This IntermediateBox is\n/// designed to be forward-compatible with a future protocol that\n/// supports creating instances of unsized types; that is why the type\n/// parameter has the `?Sized` generalization marker, and is also why\n/// this carries an explicit size. However, it probably does not need\n/// to carry the explicit alignment; that is just a work-around for\n/// the fact that the `align_of` intrinsic currently requires the\n/// input type to be Sized (which I do not think is strictly\n/// necessary).\n#[unstable(feature = \"placement_in\",\n           reason = \"placement box design is still being worked out.\",\n           issue = \"27779\")]\n#[allow(missing_debug_implementations)]\npub struct IntermediateBox<T: ?Sized> {\n    ptr: *mut u8,\n    size: usize,\n    align: usize,\n    marker: marker::PhantomData<*mut T>,\n}\n\n#[unstable(feature = \"placement_in\",\n           reason = \"placement box design is still being worked out.\",\n           issue = \"27779\")]\nimpl<T> Place<T> for IntermediateBox<T> {\n    fn pointer(&mut self) -> *mut T {\n        self.ptr as *mut T\n    }\n}\n\nunsafe fn finalize<T>(b: IntermediateBox<T>) -> Box<T> {\n    let p = b.ptr as *mut T;\n    mem::forget(b);\n    mem::transmute(p)\n}\n\nfn make_place<T>() -> IntermediateBox<T> {\n    let size = mem::size_of::<T>();\n    let align = mem::align_of::<T>();\n\n    let p = if size == 0 {\n        mem::align_of::<T>() as *mut u8\n    } else {\n        let p = unsafe { heap::allocate(size, align) };\n        if p.is_null() {\n            panic!(\"Box make_place allocation failure.\");\n        }\n        p\n    };\n\n    IntermediateBox {\n        ptr: p,\n        size: size,\n        align: align,\n        marker: marker::PhantomData,\n    }\n}\n\n#[unstable(feature = \"placement_in\",\n           reason = \"placement box design is still being worked out.\",\n           issue = \"27779\")]\nimpl<T> BoxPlace<T> for IntermediateBox<T> {\n    fn make_place() -> IntermediateBox<T> {\n        make_place()\n    }\n}\n\n#[unstable(feature = \"placement_in\",\n           reason = \"placement box design is still being worked out.\",\n           issue = \"27779\")]\nimpl<T> InPlace<T> for IntermediateBox<T> {\n    type Owner = Box<T>;\n    unsafe fn finalize(self) -> Box<T> {\n        finalize(self)\n    }\n}\n\n#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\nimpl<T> Boxed for Box<T> {\n    type Data = T;\n    type Place = IntermediateBox<T>;\n    unsafe fn finalize(b: IntermediateBox<T>) -> Box<T> {\n        finalize(b)\n    }\n}\n\n#[unstable(feature = \"placement_in\",\n           reason = \"placement box design is still being worked out.\",\n           issue = \"27779\")]\nimpl<T> Placer<T> for ExchangeHeapSingleton {\n    type Place = IntermediateBox<T>;\n\n    fn make_place(self) -> IntermediateBox<T> {\n        make_place()\n    }\n}\n\n#[unstable(feature = \"placement_in\",\n           reason = \"placement box design is still being worked out.\",\n           issue = \"27779\")]\nimpl<T: ?Sized> Drop for IntermediateBox<T> {\n    fn drop(&mut self) {\n        if self.size > 0 {\n            unsafe { heap::deallocate(self.ptr, self.size, self.align) }\n        }\n    }\n}\n\nimpl<T> Box<T> {\n    /// Allocates memory on the heap and then places `x` into it.\n    ///\n    /// This doesn't actually allocate if `T` is zero-sized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let five = Box::new(5);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline(always)]\n    pub fn new(x: T) -> Box<T> {\n        box x\n    }\n}\n\nimpl<T: ?Sized> Box<T> {\n    /// Constructs a box from a raw pointer.\n    ///\n    /// After calling this function, the raw pointer is owned by the\n    /// resulting `Box`. Specifically, the `Box` destructor will call\n    /// the destructor of `T` and free the allocated memory. Since the\n    /// way `Box` allocates and releases memory is unspecified, the\n    /// only valid pointer to pass to this function is the one taken\n    /// from another `Box` via the [`Box::into_raw`] function.\n    ///\n    /// This function is unsafe because improper use may lead to\n    /// memory problems. For example, a double-free may occur if the\n    /// function is called twice on the same raw pointer.\n    ///\n    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new(5);\n    /// let ptr = Box::into_raw(x);\n    /// let x = unsafe { Box::from_raw(ptr) };\n    /// ```\n    #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n    #[inline]\n    pub unsafe fn from_raw(raw: *mut T) -> Self {\n        mem::transmute(raw)\n    }\n\n    /// Consumes the `Box`, returning the wrapped raw pointer.\n    ///\n    /// After calling this function, the caller is responsible for the\n    /// memory previously managed by the `Box`. In particular, the\n    /// caller should properly destroy `T` and release the memory. The\n    /// proper way to do so is to convert the raw pointer back into a\n    /// `Box` with the [`Box::from_raw`] function.\n    ///\n    /// Note: this is an associated function, which means that you have\n    /// to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n    /// is so that there is no conflict with a method on the inner type.\n    ///\n    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new(5);\n    /// let ptr = Box::into_raw(x);\n    /// ```\n    #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n    #[inline]\n    pub fn into_raw(b: Box<T>) -> *mut T {\n        unsafe { mem::transmute(b) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T: ?Sized> Drop for Box<T> {\n    fn drop(&mut self) {\n        // FIXME: Do nothing, drop is currently performed by compiler.\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Default> Default for Box<T> {\n    /// Creates a `Box<T>`, with the `Default` value for T.\n    fn default() -> Box<T> {\n        box Default::default()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for Box<[T]> {\n    fn default() -> Box<[T]> {\n        Box::<[T; 0]>::new([])\n    }\n}\n\n#[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\nimpl Default for Box<str> {\n    fn default() -> Box<str> {\n        unsafe { from_boxed_utf8_unchecked(Default::default()) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> Clone for Box<T> {\n    /// Returns a new box with a `clone()` of this box's contents.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new(5);\n    /// let y = x.clone();\n    /// ```\n    #[rustfmt_skip]\n    #[inline]\n    fn clone(&self) -> Box<T> {\n        box { (**self).clone() }\n    }\n    /// Copies `source`'s contents into `self` without creating a new allocation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new(5);\n    /// let mut y = Box::new(10);\n    ///\n    /// y.clone_from(&x);\n    ///\n    /// assert_eq!(*y, 5);\n    /// ```\n    #[inline]\n    fn clone_from(&mut self, source: &Box<T>) {\n        (**self).clone_from(&(**source));\n    }\n}\n\n\n#[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\nimpl Clone for Box<str> {\n    fn clone(&self) -> Self {\n        let len = self.len();\n        let buf = RawVec::with_capacity(len);\n        unsafe {\n            ptr::copy_nonoverlapping(self.as_ptr(), buf.ptr(), len);\n            from_boxed_utf8_unchecked(buf.into_box())\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + PartialEq> PartialEq for Box<T> {\n    #[inline]\n    fn eq(&self, other: &Box<T>) -> bool {\n        PartialEq::eq(&**self, &**other)\n    }\n    #[inline]\n    fn ne(&self, other: &Box<T>) -> bool {\n        PartialEq::ne(&**self, &**other)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n        PartialOrd::partial_cmp(&**self, &**other)\n    }\n    #[inline]\n    fn lt(&self, other: &Box<T>) -> bool {\n        PartialOrd::lt(&**self, &**other)\n    }\n    #[inline]\n    fn le(&self, other: &Box<T>) -> bool {\n        PartialOrd::le(&**self, &**other)\n    }\n    #[inline]\n    fn ge(&self, other: &Box<T>) -> bool {\n        PartialOrd::ge(&**self, &**other)\n    }\n    #[inline]\n    fn gt(&self, other: &Box<T>) -> bool {\n        PartialOrd::gt(&**self, &**other)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Ord> Ord for Box<T> {\n    #[inline]\n    fn cmp(&self, other: &Box<T>) -> Ordering {\n        Ord::cmp(&**self, &**other)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Eq> Eq for Box<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Hash> Hash for Box<T> {\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        (**self).hash(state);\n    }\n}\n\n#[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\nimpl<T> From<T> for Box<T> {\n    fn from(t: T) -> Self {\n        Box::new(t)\n    }\n}\n\n#[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\nimpl<'a, T: Copy> From<&'a [T]> for Box<[T]> {\n    fn from(slice: &'a [T]) -> Box<[T]> {\n        let mut boxed = unsafe { RawVec::with_capacity(slice.len()).into_box() };\n        boxed.copy_from_slice(slice);\n        boxed\n    }\n}\n\n#[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\nimpl<'a> From<&'a str> for Box<str> {\n    fn from(s: &'a str) -> Box<str> {\n        unsafe { from_boxed_utf8_unchecked(Box::from(s.as_bytes())) }\n    }\n}\n\n#[stable(feature = \"boxed_str_conv\", since = \"1.19.0\")]\nimpl From<Box<str>> for Box<[u8]> {\n    fn from(s: Box<str>) -> Self {\n        unsafe {\n            mem::transmute(s)\n        }\n    }\n}\n\nimpl Box<Any> {\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    /// Attempt to downcast the box to a concrete type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(value: Box<Any>) {\n    ///     if let Ok(string) = value.downcast::<String>() {\n    ///         println!(\"String ({}): {}\", string.len(), string);\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     let my_string = \"Hello World\".to_string();\n    ///     print_if_string(Box::new(my_string));\n    ///     print_if_string(Box::new(0i8));\n    /// }\n    /// ```\n    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n        if self.is::<T>() {\n            unsafe {\n                let raw: *mut Any = Box::into_raw(self);\n                Ok(Box::from_raw(raw as *mut T))\n            }\n        } else {\n            Err(self)\n        }\n    }\n}\n\nimpl Box<Any + Send> {\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    /// Attempt to downcast the box to a concrete type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(value: Box<Any + Send>) {\n    ///     if let Ok(string) = value.downcast::<String>() {\n    ///         println!(\"String ({}): {}\", string.len(), string);\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     let my_string = \"Hello World\".to_string();\n    ///     print_if_string(Box::new(my_string));\n    ///     print_if_string(Box::new(0i8));\n    /// }\n    /// ```\n    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any + Send>> {\n        <Box<Any>>::downcast(self).map_err(|s| unsafe {\n            // reapply the Send marker\n            mem::transmute::<Box<Any>, Box<Any + Send>>(s)\n        })\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Display + ?Sized> fmt::Display for Box<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> fmt::Pointer for Box<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // It's not possible to extract the inner Uniq directly from the Box,\n        // instead we cast it to a *const which aliases the Unique\n        let ptr: *const T = &**self;\n        fmt::Pointer::fmt(&ptr, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Deref for Box<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &**self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> DerefMut for Box<T> {\n    fn deref_mut(&mut self) -> &mut T {\n        &mut **self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator + ?Sized> Iterator for Box<I> {\n    type Item = I::Item;\n    fn next(&mut self) -> Option<I::Item> {\n        (**self).next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (**self).size_hint()\n    }\n    fn nth(&mut self, n: usize) -> Option<I::Item> {\n        (**self).nth(n)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n    fn next_back(&mut self) -> Option<I::Item> {\n        (**self).next_back()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {\n    fn len(&self) -> usize {\n        (**self).len()\n    }\n    fn is_empty(&self) -> bool {\n        (**self).is_empty()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I: FusedIterator + ?Sized> FusedIterator for Box<I> {}\n\n\n/// `FnBox` is a version of the `FnOnce` intended for use with boxed\n/// closure objects. The idea is that where one would normally store a\n/// `Box<FnOnce()>` in a data structure, you should use\n/// `Box<FnBox()>`. The two traits behave essentially the same, except\n/// that a `FnBox` closure can only be called if it is boxed. (Note\n/// that `FnBox` may be deprecated in the future if `Box<FnOnce()>`\n/// closures become directly usable.)\n///\n/// ### Example\n///\n/// Here is a snippet of code which creates a hashmap full of boxed\n/// once closures and then removes them one by one, calling each\n/// closure as it is removed. Note that the type of the closures\n/// stored in the map is `Box<FnBox() -> i32>` and not `Box<FnOnce()\n/// -> i32>`.\n///\n/// ```\n/// #![feature(fnbox)]\n///\n/// use std::boxed::FnBox;\n/// use std::collections::HashMap;\n///\n/// fn make_map() -> HashMap<i32, Box<FnBox() -> i32>> {\n///     let mut map: HashMap<i32, Box<FnBox() -> i32>> = HashMap::new();\n///     map.insert(1, Box::new(|| 22));\n///     map.insert(2, Box::new(|| 44));\n///     map\n/// }\n///\n/// fn main() {\n///     let mut map = make_map();\n///     for i in &[1, 2] {\n///         let f = map.remove(&i).unwrap();\n///         assert_eq!(f(), i * 22);\n///     }\n/// }\n/// ```\n#[rustc_paren_sugar]\n#[unstable(feature = \"fnbox\",\n           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\npub trait FnBox<A> {\n    type Output;\n\n    fn call_box(self: Box<Self>, args: A) -> Self::Output;\n}\n\n#[unstable(feature = \"fnbox\",\n           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\nimpl<A, F> FnBox<A> for F\n    where F: FnOnce<A>\n{\n    type Output = F::Output;\n\n    fn call_box(self: Box<F>, args: A) -> F::Output {\n        self.call_once(args)\n    }\n}\n\n#[unstable(feature = \"fnbox\",\n           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\nimpl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n    type Output = R;\n\n    extern \"rust-call\" fn call_once(self, args: A) -> R {\n        self.call_box(args)\n    }\n}\n\n#[unstable(feature = \"fnbox\",\n           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\nimpl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + Send + 'a> {\n    type Output = R;\n\n    extern \"rust-call\" fn call_once(self, args: A) -> R {\n        self.call_box(args)\n    }\n}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n\n#[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\nimpl<T: Clone> Clone for Box<[T]> {\n    fn clone(&self) -> Self {\n        let mut new = BoxBuilder {\n            data: RawVec::with_capacity(self.len()),\n            len: 0,\n        };\n\n        let mut target = new.data.ptr();\n\n        for item in self.iter() {\n            unsafe {\n                ptr::write(target, item.clone());\n                target = target.offset(1);\n            };\n\n            new.len += 1;\n        }\n\n        return unsafe { new.into_box() };\n\n        // Helper type for responding to panics correctly.\n        struct BoxBuilder<T> {\n            data: RawVec<T>,\n            len: usize,\n        }\n\n        impl<T> BoxBuilder<T> {\n            unsafe fn into_box(self) -> Box<[T]> {\n                let raw = ptr::read(&self.data);\n                mem::forget(self);\n                raw.into_box()\n            }\n        }\n\n        impl<T> Drop for BoxBuilder<T> {\n            fn drop(&mut self) {\n                let mut data = self.data.ptr();\n                let max = unsafe { data.offset(self.len as isize) };\n\n                while data != max {\n                    unsafe {\n                        ptr::read(data);\n                        data = data.offset(1);\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> borrow::Borrow<T> for Box<T> {\n    fn borrow(&self) -> &T {\n        &**self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> borrow::BorrowMut<T> for Box<T> {\n    fn borrow_mut(&mut self) -> &mut T {\n        &mut **self\n    }\n}\n\n#[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\nimpl<T: ?Sized> AsRef<T> for Box<T> {\n    fn as_ref(&self) -> &T {\n        &**self\n    }\n}\n\n#[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\nimpl<T: ?Sized> AsMut<T> for Box<T> {\n    fn as_mut(&mut self) -> &mut T {\n        &mut **self\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of various bits and pieces of the `panic!` macro and\n//! associated runtime pieces.\n//!\n//! Specifically, this module contains the implementation of:\n//!\n//! * Panic hooks\n//! * Executing a panic up to doing the actual implementation\n//! * Shims around \"try\"\n\nuse io::prelude::*;\n\nuse any::Any;\nuse cell::RefCell;\nuse fmt;\nuse intrinsics;\nuse mem;\nuse ptr;\nuse raw;\nuse sys::stdio::Stderr;\nuse sys_common::rwlock::RWLock;\nuse sys_common::thread_info;\nuse sys_common::util;\nuse thread;\n\nthread_local! {\n    pub static LOCAL_STDERR: RefCell<Option<Box<Write + Send>>> = {\n        RefCell::new(None)\n    }\n}\n\n// Binary interface to the panic runtime that the standard library depends on.\n//\n// The standard library is tagged with `#![needs_panic_runtime]` (introduced in\n// RFC 1513) to indicate that it requires some other crate tagged with\n// `#![panic_runtime]` to exist somewhere. Each panic runtime is intended to\n// implement these symbols (with the same signatures) so we can get matched up\n// to them.\n//\n// One day this may look a little less ad-hoc with the compiler helping out to\n// hook up these functions, but it is not this day!\n#[allow(improper_ctypes)]\nextern {\n    fn __rust_maybe_catch_panic(f: fn(*mut u8),\n                                data: *mut u8,\n                                data_ptr: *mut usize,\n                                vtable_ptr: *mut usize) -> u32;\n    #[unwind]\n    fn __rust_start_panic(data: usize, vtable: usize) -> u32;\n}\n\n#[derive(Copy, Clone)]\nenum Hook {\n    Default,\n    Custom(*mut (Fn(&PanicInfo) + 'static + Sync + Send)),\n}\n\nstatic HOOK_LOCK: RWLock = RWLock::new();\nstatic mut HOOK: Hook = Hook::Default;\n\n/// Registers a custom panic hook, replacing any that was previously registered.\n///\n/// The panic hook is invoked when a thread panics, but before the panic runtime\n/// is invoked. As such, the hook will run with both the aborting and unwinding\n/// runtimes. The default hook prints a message to standard error and generates\n/// a backtrace if requested, but this behavior can be customized with the\n/// `set_hook` and `take_hook` functions.\n///\n/// The hook is provided with a `PanicInfo` struct which contains information\n/// about the origin of the panic, including the payload passed to `panic!` and\n/// the source code location from which the panic originated.\n///\n/// The panic hook is a global resource.\n///\n/// # Panics\n///\n/// Panics if called from a panicking thread.\n///\n/// # Examples\n///\n/// The following will print \"Custom panic hook\":\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|_| {\n///     println!(\"Custom panic hook\");\n/// }));\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub fn set_hook(hook: Box<Fn(&PanicInfo) + 'static + Sync + Send>) {\n    if thread::panicking() {\n        panic!(\"cannot modify the panic hook from a panicking thread\");\n    }\n\n    unsafe {\n        HOOK_LOCK.write();\n        let old_hook = HOOK;\n        HOOK = Hook::Custom(Box::into_raw(hook));\n        HOOK_LOCK.write_unlock();\n\n        if let Hook::Custom(ptr) = old_hook {\n            Box::from_raw(ptr);\n        }\n    }\n}\n\n/// Unregisters the current panic hook, returning it.\n///\n/// If no custom hook is registered, the default hook will be returned.\n///\n/// # Panics\n///\n/// Panics if called from a panicking thread.\n///\n/// # Examples\n///\n/// The following will print \"Normal panic\":\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|_| {\n///     println!(\"Custom panic hook\");\n/// }));\n///\n/// let _ = panic::take_hook();\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub fn take_hook() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n    if thread::panicking() {\n        panic!(\"cannot modify the panic hook from a panicking thread\");\n    }\n\n    unsafe {\n        HOOK_LOCK.write();\n        let hook = HOOK;\n        HOOK = Hook::Default;\n        HOOK_LOCK.write_unlock();\n\n        match hook {\n            Hook::Default => Box::new(default_hook),\n            Hook::Custom(ptr) => Box::from_raw(ptr),\n        }\n    }\n}\n\n/// A struct providing information about a panic.\n///\n/// `PanicInfo` structure is passed to a panic hook set by the [`set_hook`]\n/// function.\n///\n/// [`set_hook`]: ../../std/panic/fn.set_hook.html\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|panic_info| {\n///     println!(\"panic occured: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n/// }));\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n#[derive(Debug)]\npub struct PanicInfo<'a> {\n    payload: &'a (Any + Send),\n    location: Location<'a>,\n}\n\nimpl<'a> PanicInfo<'a> {\n    /// Returns the payload associated with the panic.\n    ///\n    /// This will commonly, but not always, be a `&'static str` or [`String`].\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     println!(\"panic occured: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn payload(&self) -> &(Any + Send) {\n        self.payload\n    }\n\n    /// Returns information about the location from which the panic originated,\n    /// if available.\n    ///\n    /// This method will currently always return [`Some`], but this may change\n    /// in future versions.\n    ///\n    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occured in file '{}' at line {}\", location.file(), location.line());\n    ///     } else {\n    ///         println!(\"panic occured but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn location(&self) -> Option<&Location> {\n        Some(&self.location)\n    }\n}\n\n/// A struct containing information about the location of a panic.\n///\n/// This structure is created by the [`location`] method of [`PanicInfo`].\n///\n/// [`location`]: ../../std/panic/struct.PanicInfo.html#method.location\n/// [`PanicInfo`]: ../../std/panic/struct.PanicInfo.html\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|panic_info| {\n///     if let Some(location) = panic_info.location() {\n///         println!(\"panic occured in file '{}' at line {}\", location.file(), location.line());\n///     } else {\n///         println!(\"panic occured but can't get location information...\");\n///     }\n/// }));\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[derive(Debug)]\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub struct Location<'a> {\n    file: &'a str,\n    line: u32,\n    col: u32,\n}\n\nimpl<'a> Location<'a> {\n    /// Returns the name of the source file from which the panic originated.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occured in file '{}'\", location.file());\n    ///     } else {\n    ///         println!(\"panic occured but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn file(&self) -> &str {\n        self.file\n    }\n\n    /// Returns the line number from which the panic originated.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occured at line {}\", location.line());\n    ///     } else {\n    ///         println!(\"panic occured but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn line(&self) -> u32 {\n        self.line\n    }\n\n    /// Returns the column from which the panic originated.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// #![feature(panic_col)]\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occured at column {}\", location.column());\n    ///     } else {\n    ///         println!(\"panic occured but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[unstable(feature = \"panic_col\", reason = \"recently added\", issue = \"42939\")]\n    pub fn column(&self) -> u32 {\n        self.col\n    }\n}\n\nfn default_hook(info: &PanicInfo) {\n    #[cfg(feature = \"backtrace\")]\n    use sys_common::backtrace;\n\n    // If this is a double panic, make sure that we print a backtrace\n    // for this panic. Otherwise only print it if logging is enabled.\n    #[cfg(feature = \"backtrace\")]\n    let log_backtrace = {\n        let panics = update_panic_count(0);\n\n        if panics >= 2 {\n            Some(backtrace::PrintFormat::Full)\n        } else {\n            backtrace::log_enabled()\n        }\n    };\n\n    let file = info.location.file;\n    let line = info.location.line;\n    let col = info.location.col;\n\n    let msg = match info.payload.downcast_ref::<&'static str>() {\n        Some(s) => *s,\n        None => match info.payload.downcast_ref::<String>() {\n            Some(s) => &s[..],\n            None => \"Box<Any>\",\n        }\n    };\n    let mut err = Stderr::new().ok();\n    let thread = thread_info::current_thread();\n    let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n\n    let write = |err: &mut ::io::Write| {\n        let _ = writeln!(err, \"thread '{}' panicked at '{}', {}:{}:{}\",\n                         name, msg, file, line, col);\n\n        #[cfg(feature = \"backtrace\")]\n        {\n            use sync::atomic::{AtomicBool, Ordering};\n\n            static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n\n            if let Some(format) = log_backtrace {\n                let _ = backtrace::print(err, format);\n            } else if FIRST_PANIC.compare_and_swap(true, false, Ordering::SeqCst) {\n                let _ = writeln!(err, \"note: Run with `RUST_BACKTRACE=1` for a backtrace.\");\n            }\n        }\n    };\n\n    let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());\n    match (prev, err.as_mut()) {\n        (Some(mut stderr), _) => {\n            write(&mut *stderr);\n            let mut s = Some(stderr);\n            LOCAL_STDERR.with(|slot| {\n                *slot.borrow_mut() = s.take();\n            });\n        }\n        (None, Some(ref mut err)) => { write(err) }\n        _ => {}\n    }\n}\n\n\n#[cfg(not(test))]\n#[doc(hidden)]\n#[unstable(feature = \"update_panic_count\", issue = \"0\")]\npub fn update_panic_count(amt: isize) -> usize {\n    use cell::Cell;\n    thread_local! { static PANIC_COUNT: Cell<usize> = Cell::new(0) }\n\n    PANIC_COUNT.with(|c| {\n        let next = (c.get() as isize + amt) as usize;\n        c.set(next);\n        return next\n    })\n}\n\n#[cfg(test)]\npub use realstd::rt::update_panic_count;\n\n/// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\npub unsafe fn try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<Any + Send>> {\n    #[allow(unions_with_drop_fields)]\n    union Data<F, R> {\n        f: F,\n        r: R,\n    }\n\n    // We do some sketchy operations with ownership here for the sake of\n    // performance. We can only  pass pointers down to\n    // `__rust_maybe_catch_panic` (can't pass objects by value), so we do all\n    // the ownership tracking here manually using a union.\n    //\n    // We go through a transition where:\n    //\n    // * First, we set the data to be the closure that we're going to call.\n    // * When we make the function call, the `do_call` function below, we take\n    //   ownership of the function pointer. At this point the `Data` union is\n    //   entirely uninitialized.\n    // * If the closure successfully returns, we write the return value into the\n    //   data's return slot. Note that `ptr::write` is used as it's overwriting\n    //   uninitialized data.\n    // * Finally, when we come back out of the `__rust_maybe_catch_panic` we're\n    //   in one of two states:\n    //\n    //      1. The closure didn't panic, in which case the return value was\n    //         filled in. We move it out of `data` and return it.\n    //      2. The closure panicked, in which case the return value wasn't\n    //         filled in. In this case the entire `data` union is invalid, so\n    //         there is no need to drop anything.\n    //\n    // Once we stack all that together we should have the \"most efficient'\n    // method of calling a catch panic whilst juggling ownership.\n    let mut any_data = 0;\n    let mut any_vtable = 0;\n    let mut data = Data {\n        f: f,\n    };\n\n    let r = __rust_maybe_catch_panic(do_call::<F, R>,\n                                     &mut data as *mut _ as *mut u8,\n                                     &mut any_data,\n                                     &mut any_vtable);\n\n    return if r == 0 {\n        debug_assert!(update_panic_count(0) == 0);\n        Ok(data.r)\n    } else {\n        update_panic_count(-1);\n        debug_assert!(update_panic_count(0) == 0);\n        Err(mem::transmute(raw::TraitObject {\n            data: any_data as *mut _,\n            vtable: any_vtable as *mut _,\n        }))\n    };\n\n    fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n        unsafe {\n            let data = data as *mut Data<F, R>;\n            let f = ptr::read(&mut (*data).f);\n            ptr::write(&mut (*data).r, f());\n        }\n    }\n}\n\n/// Determines whether the current thread is unwinding because of panic.\npub fn panicking() -> bool {\n    update_panic_count(0) != 0\n}\n\n/// Entry point of panic from the libcore crate.\n#[cfg(not(test))]\n#[lang = \"panic_fmt\"]\n#[unwind]\npub extern fn rust_begin_panic(msg: fmt::Arguments,\n                               file: &'static str,\n                               line: u32,\n                               col: u32) -> ! {\n    begin_panic_fmt(&msg, &(file, line, col))\n}\n\n/// The entry point for panicking with a formatted message.\n///\n/// This is designed to reduce the amount of code required at the call\n/// site as much as possible (so that `panic!()` has as low an impact\n/// on (e.g.) the inlining of other functions as possible), by moving\n/// the actual formatting into this shared place.\n#[unstable(feature = \"libstd_sys_internals\",\n           reason = \"used by the panic! macro\",\n           issue = \"0\")]\n#[inline(never)] #[cold]\npub fn begin_panic_fmt(msg: &fmt::Arguments,\n                       file_line_col: &(&'static str, u32, u32)) -> ! {\n    use fmt::Write;\n\n    // We do two allocations here, unfortunately. But (a) they're\n    // required with the current scheme, and (b) we don't handle\n    // panic + OOM properly anyway (see comment in begin_panic\n    // below).\n\n    let mut s = String::new();\n    let _ = s.write_fmt(*msg);\n    begin_panic_new(s, file_line_col)\n}\n\n// FIXME: In PR #42938, we have added the column as info passed to the panic\n// handling code. For this, we want to break the ABI of begin_panic.\n// This is not possible to do directly, as the stage0 compiler is hardcoded\n// to emit a call to begin_panic in src/libsyntax/ext/build.rs, only\n// with the file and line number being passed, but not the colum number.\n// By changing the compiler source, we can only affect behaviour of higher\n// stages. We need to perform the switch over two stage0 replacements, using\n// a temporary function begin_panic_new while performing the switch:\n// 0. Right now, we tell stage1 onward to emit a call to begin_panic_new.\n// 1. In the first SNAP, stage0 calls begin_panic_new with the new ABI,\n//    begin_panic stops being used. Now we can change begin_panic to\n//    the new ABI, and start emitting calls to begin_panic in higher\n//    stages again, this time with the new ABI.\n// 2. After the second SNAP, stage0 calls begin_panic with the new ABI,\n//    and we can remove the temporary begin_panic_new function.\n\n/// This is the entry point of panicking for panic!() and assert!().\n#[unstable(feature = \"libstd_sys_internals\",\n           reason = \"used by the panic! macro\",\n           issue = \"0\")]\n#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\npub fn begin_panic_new<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u32)) -> ! {\n    // Note that this should be the only allocation performed in this code path.\n    // Currently this means that panic!() on OOM will invoke this code path,\n    // but then again we're not really ready for panic on OOM anyway. If\n    // we do start doing this, then we should propagate this allocation to\n    // be performed in the parent of this thread instead of the thread that's\n    // panicking.\n\n    rust_panic_with_hook(Box::new(msg), file_line_col)\n}\n\n/// This is the entry point of panicking for panic!() and assert!().\n#[unstable(feature = \"libstd_sys_internals\",\n           reason = \"used by the panic! macro\",\n           issue = \"0\")]\n#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\npub fn begin_panic<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> ! {\n    // Note that this should be the only allocation performed in this code path.\n    // Currently this means that panic!() on OOM will invoke this code path,\n    // but then again we're not really ready for panic on OOM anyway. If\n    // we do start doing this, then we should propagate this allocation to\n    // be performed in the parent of this thread instead of the thread that's\n    // panicking.\n\n    let (file, line) = *file_line;\n    let file_line_col = (file, line, 0);\n\n    rust_panic_with_hook(Box::new(msg), &file_line_col)\n}\n\n/// Executes the primary logic for a panic, including checking for recursive\n/// panics and panic hooks.\n///\n/// This is the entry point or panics from libcore, formatted panics, and\n/// `Box<Any>` panics. Here we'll verify that we're not panicking recursively,\n/// run panic hooks, and then delegate to the actual implementation of panics.\n#[inline(never)]\n#[cold]\nfn rust_panic_with_hook(msg: Box<Any + Send>,\n                        file_line_col: &(&'static str, u32, u32)) -> ! {\n    let (file, line, col) = *file_line_col;\n\n    let panics = update_panic_count(1);\n\n    // If this is the third nested call (e.g. panics == 2, this is 0-indexed),\n    // the panic hook probably triggered the last panic, otherwise the\n    // double-panic check would have aborted the process. In this case abort the\n    // process real quickly as we don't want to try calling it again as it'll\n    // probably just panic again.\n    if panics > 2 {\n        util::dumb_print(format_args!(\"thread panicked while processing \\\n                                       panic. aborting.\\n\"));\n        unsafe { intrinsics::abort() }\n    }\n\n    unsafe {\n        let info = PanicInfo {\n            payload: &*msg,\n            location: Location {\n                file,\n                line,\n                col,\n            },\n        };\n        HOOK_LOCK.read();\n        match HOOK {\n            Hook::Default => default_hook(&info),\n            Hook::Custom(ptr) => (*ptr)(&info),\n        }\n        HOOK_LOCK.read_unlock();\n    }\n\n    if panics > 1 {\n        // If a thread panics while it's already unwinding then we\n        // have limited options. Currently our preference is to\n        // just abort. In the future we may consider resuming\n        // unwinding or otherwise exiting the thread cleanly.\n        util::dumb_print(format_args!(\"thread panicked while panicking. \\\n                                       aborting.\\n\"));\n        unsafe { intrinsics::abort() }\n    }\n\n    rust_panic(msg)\n}\n\n/// Shim around rust_panic. Called by resume_unwind.\npub fn update_count_then_panic(msg: Box<Any + Send>) -> ! {\n    update_panic_count(1);\n    rust_panic(msg)\n}\n\n/// A private no-mangle function on which to slap yer breakpoints.\n#[no_mangle]\n#[allow(private_no_mangle_fns)] // yes we get it, but we like breakpoints\npub fn rust_panic(msg: Box<Any + Send>) -> ! {\n    let code = unsafe {\n        let obj = mem::transmute::<_, raw::TraitObject>(msg);\n        __rust_start_panic(obj.data as usize, obj.vtable as usize)\n    };\n    rtabort!(\"failed to initiate panic, error {}\", code)\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse error;\nuse fmt;\nuse result;\nuse sys;\nuse convert::From;\n\n/// A specialized [`Result`](../result/enum.Result.html) type for I/O\n/// operations.\n///\n/// This type is broadly used across `std::io` for any operation which may\n/// produce an error.\n///\n/// This typedef is generally used to avoid writing out `io::Error` directly and\n/// is otherwise a direct mapping to `Result`.\n///\n/// While usual Rust style is to import types directly, aliases of `Result`\n/// often are not, to make it easier to distinguish between them. `Result` is\n/// generally assumed to be `std::result::Result`, and so users of this alias\n/// will generally use `io::Result` instead of shadowing the prelude's import\n/// of `std::result::Result`.\n///\n/// # Examples\n///\n/// A convenience function that bubbles an `io::Result` to its caller:\n///\n/// ```\n/// use std::io;\n///\n/// fn get_string() -> io::Result<String> {\n///     let mut buffer = String::new();\n///\n///     io::stdin().read_line(&mut buffer)?;\n///\n///     Ok(buffer)\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result<T> = result::Result<T, Error>;\n\n/// The error type for I/O operations of the `Read`, `Write`, `Seek`, and\n/// associated traits.\n///\n/// Errors mostly originate from the underlying OS, but custom instances of\n/// `Error` can be created with crafted error messages and a particular value of\n/// [`ErrorKind`].\n///\n/// [`ErrorKind`]: enum.ErrorKind.html\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Error {\n    repr: Repr,\n}\n\nenum Repr {\n    Os(i32),\n    Simple(ErrorKind),\n    Custom(Box<Custom>),\n}\n\n#[derive(Debug)]\nstruct Custom {\n    kind: ErrorKind,\n    error: Box<error::Error+Send+Sync>,\n}\n\n/// A list specifying general categories of I/O error.\n///\n/// This list is intended to grow over time and it is not recommended to\n/// exhaustively match against it.\n///\n/// It is used with the [`io::Error`] type.\n///\n/// [`io::Error`]: struct.Error.html\n#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\npub enum ErrorKind {\n    /// An entity was not found, often a file.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    NotFound,\n    /// The operation lacked the necessary privileges to complete.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    PermissionDenied,\n    /// The connection was refused by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionRefused,\n    /// The connection was reset by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionReset,\n    /// The connection was aborted (terminated) by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionAborted,\n    /// The network operation failed because it was not connected yet.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    NotConnected,\n    /// A socket address could not be bound because the address is already in\n    /// use elsewhere.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AddrInUse,\n    /// A nonexistent interface was requested or the requested address was not\n    /// local.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AddrNotAvailable,\n    /// The operation failed because a pipe was closed.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    BrokenPipe,\n    /// An entity already exists, often a file.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AlreadyExists,\n    /// The operation needs to block to complete, but the blocking operation was\n    /// requested to not occur.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    WouldBlock,\n    /// A parameter was incorrect.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    InvalidInput,\n    /// Data not valid for the operation were encountered.\n    ///\n    /// Unlike [`InvalidInput`], this typically means that the operation\n    /// parameters were valid, however the error was caused by malformed\n    /// input data.\n    ///\n    /// For example, a function that reads a file into a string will error with\n    /// `InvalidData` if the file's contents are not valid UTF-8.\n    ///\n    /// [`InvalidInput`]: #variant.InvalidInput\n    #[stable(feature = \"io_invalid_data\", since = \"1.2.0\")]\n    InvalidData,\n    /// The I/O operation's timeout expired, causing it to be canceled.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    TimedOut,\n    /// An error returned when an operation could not be completed because a\n    /// call to [`write`] returned [`Ok(0)`].\n    ///\n    /// This typically means that an operation could only succeed if it wrote a\n    /// particular number of bytes but only a smaller number of bytes could be\n    /// written.\n    ///\n    /// [`write`]: ../../std/io/trait.Write.html#tymethod.write\n    /// [`Ok(0)`]: ../../std/io/type.Result.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    WriteZero,\n    /// This operation was interrupted.\n    ///\n    /// Interrupted operations can typically be retried.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Interrupted,\n    /// Any I/O error not part of this list.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Other,\n\n    /// An error returned when an operation could not be completed because an\n    /// \"end of file\" was reached prematurely.\n    ///\n    /// This typically means that an operation could only succeed if it read a\n    /// particular number of bytes but only a smaller number of bytes could be\n    /// read.\n    #[stable(feature = \"read_exact\", since = \"1.6.0\")]\n    UnexpectedEof,\n\n    /// A marker variant that tells the compiler that users of this enum cannot\n    /// match it exhaustively.\n    #[unstable(feature = \"io_error_internals\",\n               reason = \"better expressed through extensible enums that this \\\n                         enum cannot be exhaustively matched against\",\n               issue = \"0\")]\n    #[doc(hidden)]\n    __Nonexhaustive,\n}\n\nimpl ErrorKind {\n    fn as_str(&self) -> &'static str {\n        match *self {\n            ErrorKind::NotFound => \"entity not found\",\n            ErrorKind::PermissionDenied => \"permission denied\",\n            ErrorKind::ConnectionRefused => \"connection refused\",\n            ErrorKind::ConnectionReset => \"connection reset\",\n            ErrorKind::ConnectionAborted => \"connection aborted\",\n            ErrorKind::NotConnected => \"not connected\",\n            ErrorKind::AddrInUse => \"address in use\",\n            ErrorKind::AddrNotAvailable => \"address not available\",\n            ErrorKind::BrokenPipe => \"broken pipe\",\n            ErrorKind::AlreadyExists => \"entity already exists\",\n            ErrorKind::WouldBlock => \"operation would block\",\n            ErrorKind::InvalidInput => \"invalid input parameter\",\n            ErrorKind::InvalidData => \"invalid data\",\n            ErrorKind::TimedOut => \"timed out\",\n            ErrorKind::WriteZero => \"write zero\",\n            ErrorKind::Interrupted => \"operation interrupted\",\n            ErrorKind::Other => \"other os error\",\n            ErrorKind::UnexpectedEof => \"unexpected end of file\",\n            ErrorKind::__Nonexhaustive => unreachable!()\n        }\n    }\n}\n\n/// Intended for use for errors not exposed to the user, where allocating onto\n/// the heap (for normal construction via Error::new) is too costly.\n#[stable(feature = \"io_error_from_errorkind\", since = \"1.14.0\")]\nimpl From<ErrorKind> for Error {\n    #[inline]\n    fn from(kind: ErrorKind) -> Error {\n        Error {\n            repr: Repr::Simple(kind)\n        }\n    }\n}\n\nimpl Error {\n    /// Creates a new I/O error from a known kind of error as well as an\n    /// arbitrary error payload.\n    ///\n    /// This function is used to generically create I/O errors which do not\n    /// originate from the OS itself. The `error` argument is an arbitrary\n    /// payload which will be contained in this `Error`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// // errors can be created from strings\n    /// let custom_error = Error::new(ErrorKind::Other, \"oh no!\");\n    ///\n    /// // errors can also be created from other errors\n    /// let custom_error2 = Error::new(ErrorKind::Interrupted, custom_error);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<E>(kind: ErrorKind, error: E) -> Error\n        where E: Into<Box<error::Error+Send+Sync>>\n    {\n        Self::_new(kind, error.into())\n    }\n\n    fn _new(kind: ErrorKind, error: Box<error::Error+Send+Sync>) -> Error {\n        Error {\n            repr: Repr::Custom(Box::new(Custom {\n                kind: kind,\n                error: error,\n            }))\n        }\n    }\n\n    /// Returns an error representing the last OS error which occurred.\n    ///\n    /// This function reads the value of `errno` for the target platform (e.g.\n    /// `GetLastError` on Windows) and will return a corresponding instance of\n    /// `Error` for the error code.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Error;\n    ///\n    /// println!(\"last OS error: {:?}\", Error::last_os_error());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn last_os_error() -> Error {\n        Error::from_raw_os_error(sys::os::errno() as i32)\n    }\n\n    /// Creates a new instance of an `Error` from a particular OS error code.\n    ///\n    /// # Examples\n    ///\n    /// On Linux:\n    ///\n    /// ```\n    /// # if cfg!(target_os = \"linux\") {\n    /// use std::io;\n    ///\n    /// let error = io::Error::from_raw_os_error(98);\n    /// assert_eq!(error.kind(), io::ErrorKind::AddrInUse);\n    /// # }\n    /// ```\n    ///\n    /// On Windows:\n    ///\n    /// ```\n    /// # if cfg!(windows) {\n    /// use std::io;\n    ///\n    /// let error = io::Error::from_raw_os_error(10048);\n    /// assert_eq!(error.kind(), io::ErrorKind::AddrInUse);\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_raw_os_error(code: i32) -> Error {\n        Error { repr: Repr::Os(code) }\n    }\n\n    /// Returns the OS error that this error represents (if any).\n    ///\n    /// If this `Error` was constructed via `last_os_error` or\n    /// `from_raw_os_error`, then this function will return `Some`, otherwise\n    /// it will return `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_os_error(err: &Error) {\n    ///     if let Some(raw_os_err) = err.raw_os_error() {\n    ///         println!(\"raw OS error: {:?}\", raw_os_err);\n    ///     } else {\n    ///         println!(\"Not an OS error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"raw OS error: ...\".\n    ///     print_os_error(&Error::last_os_error());\n    ///     // Will print \"Not an OS error\".\n    ///     print_os_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn raw_os_error(&self) -> Option<i32> {\n        match self.repr {\n            Repr::Os(i) => Some(i),\n            Repr::Custom(..) => None,\n            Repr::Simple(..) => None,\n        }\n    }\n\n    /// Returns a reference to the inner error wrapped by this error (if any).\n    ///\n    /// If this `Error` was constructed via `new` then this function will\n    /// return `Some`, otherwise it will return `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: &Error) {\n    ///     if let Some(inner_err) = err.get_ref() {\n    ///         println!(\"Inner error: {:?}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(&Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    pub fn get_ref(&self) -> Option<&(error::Error+Send+Sync+'static)> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::Custom(ref c) => Some(&*c.error),\n        }\n    }\n\n    /// Returns a mutable reference to the inner error wrapped by this error\n    /// (if any).\n    ///\n    /// If this `Error` was constructed via `new` then this function will\n    /// return `Some`, otherwise it will return `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    /// use std::{error, fmt};\n    /// use std::fmt::Display;\n    ///\n    /// #[derive(Debug)]\n    /// struct MyError {\n    ///     v: String,\n    /// }\n    ///\n    /// impl MyError {\n    ///     fn new() -> MyError {\n    ///         MyError {\n    ///             v: \"oh no!\".to_string()\n    ///         }\n    ///     }\n    ///\n    ///     fn change_message(&mut self, new_message: &str) {\n    ///         self.v = new_message.to_string();\n    ///     }\n    /// }\n    ///\n    /// impl error::Error for MyError {\n    ///     fn description(&self) -> &str { &self.v }\n    /// }\n    ///\n    /// impl Display for MyError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    ///         write!(f, \"MyError: {}\", &self.v)\n    ///     }\n    /// }\n    ///\n    /// fn change_error(mut err: Error) -> Error {\n    ///     if let Some(inner_err) = err.get_mut() {\n    ///         inner_err.downcast_mut::<MyError>().unwrap().change_message(\"I've been changed!\");\n    ///     }\n    ///     err\n    /// }\n    ///\n    /// fn print_error(err: &Error) {\n    ///     if let Some(inner_err) = err.get_ref() {\n    ///         println!(\"Inner error: {}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(&change_error(Error::last_os_error()));\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(&change_error(Error::new(ErrorKind::Other, MyError::new())));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    pub fn get_mut(&mut self) -> Option<&mut (error::Error+Send+Sync+'static)> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::Custom(ref mut c) => Some(&mut *c.error),\n        }\n    }\n\n    /// Consumes the `Error`, returning its inner error (if any).\n    ///\n    /// If this `Error` was constructed via `new` then this function will\n    /// return `Some`, otherwise it will return `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: Error) {\n    ///     if let Some(inner_err) = err.into_inner() {\n    ///         println!(\"Inner error: {}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    pub fn into_inner(self) -> Option<Box<error::Error+Send+Sync>> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::Custom(c) => Some(c.error)\n        }\n    }\n\n    /// Returns the corresponding `ErrorKind` for this error.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: Error) {\n    ///     println!(\"{:?}\", err.kind());\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(Error::new(ErrorKind::AddrInUse, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn kind(&self) -> ErrorKind {\n        match self.repr {\n            Repr::Os(code) => sys::decode_error_kind(code),\n            Repr::Custom(ref c) => c.kind,\n            Repr::Simple(kind) => kind,\n        }\n    }\n}\n\nimpl fmt::Debug for Repr {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Repr::Os(ref code) =>\n                fmt.debug_struct(\"Os\").field(\"code\", code)\n                   .field(\"message\", &sys::os::error_string(*code)).finish(),\n            Repr::Custom(ref c) => fmt.debug_tuple(\"Custom\").field(c).finish(),\n            Repr::Simple(kind) => fmt.debug_tuple(\"Kind\").field(&kind).finish(),\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Error {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        match self.repr {\n            Repr::Os(code) => {\n                let detail = sys::os::error_string(code);\n                write!(fmt, \"{} (os error {})\", detail, code)\n            }\n            Repr::Custom(ref c) => c.error.fmt(fmt),\n            Repr::Simple(kind) => write!(fmt, \"{}\", kind.as_str()),\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl error::Error for Error {\n    fn description(&self) -> &str {\n        match self.repr {\n            Repr::Os(..) | Repr::Simple(..) => self.kind().as_str(),\n            Repr::Custom(ref c) => c.error.description(),\n        }\n    }\n\n    fn cause(&self) -> Option<&error::Error> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::Custom(ref c) => c.error.cause(),\n        }\n    }\n}\n\nfn _assert_error_is_sync_send() {\n    fn _is_sync_send<T: Sync+Send>() {}\n    _is_sync_send::<Error>();\n}\n\n#[cfg(test)]\nmod test {\n    use super::{Error, ErrorKind};\n    use error;\n    use fmt;\n    use sys::os::error_string;\n\n    #[test]\n    fn test_debug_error() {\n        let code = 6;\n        let msg = error_string(code);\n        let err = Error { repr: super::Repr::Os(code) };\n        let expected = format!(\"Error {{ repr: Os {{ code: {:?}, message: {:?} }} }}\", code, msg);\n        assert_eq!(format!(\"{:?}\", err), expected);\n    }\n\n    #[test]\n    fn test_downcasting() {\n        #[derive(Debug)]\n        struct TestError;\n\n        impl fmt::Display for TestError {\n            fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n                Ok(())\n            }\n        }\n\n        impl error::Error for TestError {\n            fn description(&self) -> &str {\n                \"asdf\"\n            }\n        }\n\n        // we have to call all of these UFCS style right now since method\n        // resolution won't implicitly drop the Send+Sync bounds\n        let mut err = Error::new(ErrorKind::Other, TestError);\n        assert!(err.get_ref().unwrap().is::<TestError>());\n        assert_eq!(\"asdf\", err.get_ref().unwrap().description());\n        assert!(err.get_mut().unwrap().is::<TestError>());\n        let extracted = err.into_inner().unwrap();\n        extracted.downcast::<TestError>().unwrap();\n    }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse allocator::{Alloc, Layout};\nuse core::ptr::{self, Unique};\nuse core::mem;\nuse core::slice;\nuse heap::{HeapAlloc};\nuse super::boxed::Box;\nuse core::ops::Drop;\nuse core::cmp;\n\n/// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n/// a buffer of memory on the heap without having to worry about all the corner cases\n/// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n/// In particular:\n///\n/// * Produces Unique::empty() on zero-sized types\n/// * Produces Unique::empty() on zero-length allocations\n/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics)\n/// * Guards against 32-bit systems allocating more than isize::MAX bytes\n/// * Guards against overflowing your length\n/// * Aborts on OOM\n/// * Avoids freeing Unique::empty()\n/// * Contains a ptr::Unique and thus endows the user with all related benefits\n///\n/// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n/// free its memory, but it *won't* try to Drop its contents. It is up to the user of RawVec\n/// to handle the actual things *stored* inside of a RawVec.\n///\n/// Note that a RawVec always forces its capacity to be usize::MAX for zero-sized types.\n/// This enables you to use capacity growing logic catch the overflows in your length\n/// that might occur with zero-sized types.\n///\n/// However this means that you need to be careful when roundtripping this type\n/// with a `Box<[T]>`: `cap()` won't yield the len. However `with_capacity`,\n/// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n/// field. This allows zero-sized types to not be special-cased by consumers of\n/// this type.\n#[allow(missing_debug_implementations)]\npub struct RawVec<T, A: Alloc = HeapAlloc> {\n    ptr: Unique<T>,\n    cap: usize,\n    a: A,\n}\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    /// Like `new` but parameterized over the choice of allocator for\n    /// the returned RawVec.\n    pub fn new_in(a: A) -> Self {\n        // !0 is usize::MAX. This branch should be stripped at compile time.\n        let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n\n        // Unique::empty() doubles as \"unallocated\" and \"zero-sized allocation\"\n        RawVec {\n            ptr: Unique::empty(),\n            cap: cap,\n            a: a,\n        }\n    }\n\n    /// Like `with_capacity` but parameterized over the choice of\n    /// allocator for the returned RawVec.\n    #[inline]\n    pub fn with_capacity_in(cap: usize, a: A) -> Self {\n        RawVec::allocate_in(cap, false, a)\n    }\n\n    /// Like `with_capacity_zeroed` but parameterized over the choice\n    /// of allocator for the returned RawVec.\n    #[inline]\n    pub fn with_capacity_zeroed_in(cap: usize, a: A) -> Self {\n        RawVec::allocate_in(cap, true, a)\n    }\n\n    fn allocate_in(cap: usize, zeroed: bool, mut a: A) -> Self {\n        unsafe {\n            let elem_size = mem::size_of::<T>();\n\n            let alloc_size = cap.checked_mul(elem_size).expect(\"capacity overflow\");\n            alloc_guard(alloc_size);\n\n            // handles ZSTs and `cap = 0` alike\n            let ptr = if alloc_size == 0 {\n                mem::align_of::<T>() as *mut u8\n            } else {\n                let align = mem::align_of::<T>();\n                let result = if zeroed {\n                    a.alloc_zeroed(Layout::from_size_align(alloc_size, align).unwrap())\n                } else {\n                    a.alloc(Layout::from_size_align(alloc_size, align).unwrap())\n                };\n                match result {\n                    Ok(ptr) => ptr,\n                    Err(err) => a.oom(err),\n                }\n            };\n\n            RawVec {\n                ptr: Unique::new(ptr as *mut _),\n                cap: cap,\n                a: a,\n            }\n        }\n    }\n}\n\nimpl<T> RawVec<T, HeapAlloc> {\n    /// Creates the biggest possible RawVec (on the system heap)\n    /// without allocating. If T has positive size, then this makes a\n    /// RawVec with capacity 0. If T has 0 size, then it it makes a\n    /// RawVec with capacity `usize::MAX`. Useful for implementing\n    /// delayed allocation.\n    pub fn new() -> Self {\n        Self::new_in(HeapAlloc)\n    }\n\n    /// Creates a RawVec (on the system heap) with exactly the\n    /// capacity and alignment requirements for a `[T; cap]`. This is\n    /// equivalent to calling RawVec::new when `cap` is 0 or T is\n    /// zero-sized. Note that if `T` is zero-sized this means you will\n    /// *not* get a RawVec with the requested capacity!\n    ///\n    /// # Panics\n    ///\n    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM\n    #[inline]\n    pub fn with_capacity(cap: usize) -> Self {\n        RawVec::allocate_in(cap, false, HeapAlloc)\n    }\n\n    /// Like `with_capacity` but guarantees the buffer is zeroed.\n    #[inline]\n    pub fn with_capacity_zeroed(cap: usize) -> Self {\n        RawVec::allocate_in(cap, true, HeapAlloc)\n    }\n}\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    /// Reconstitutes a RawVec from a pointer, capacity, and allocator.\n    ///\n    /// # Undefined Behavior\n    ///\n    /// The ptr must be allocated (via the given allocator `a`), and with the given capacity. The\n    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n    /// If the ptr and capacity come from a RawVec created via `a`, then this is guaranteed.\n    pub unsafe fn from_raw_parts_in(ptr: *mut T, cap: usize, a: A) -> Self {\n        RawVec {\n            ptr: Unique::new(ptr),\n            cap: cap,\n            a: a,\n        }\n    }\n}\n\nimpl<T> RawVec<T, HeapAlloc> {\n    /// Reconstitutes a RawVec from a pointer, capacity.\n    ///\n    /// # Undefined Behavior\n    ///\n    /// The ptr must be allocated (on the system heap), and with the given capacity. The\n    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n    /// If the ptr and capacity come from a RawVec, then this is guaranteed.\n    pub unsafe fn from_raw_parts(ptr: *mut T, cap: usize) -> Self {\n        RawVec {\n            ptr: Unique::new(ptr),\n            cap: cap,\n            a: HeapAlloc,\n        }\n    }\n\n    /// Converts a `Box<[T]>` into a `RawVec<T>`.\n    pub fn from_box(mut slice: Box<[T]>) -> Self {\n        unsafe {\n            let result = RawVec::from_raw_parts(slice.as_mut_ptr(), slice.len());\n            mem::forget(slice);\n            result\n        }\n    }\n}\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    /// Gets a raw pointer to the start of the allocation. Note that this is\n    /// Unique::empty() if `cap = 0` or T is zero-sized. In the former case, you must\n    /// be careful.\n    pub fn ptr(&self) -> *mut T {\n        self.ptr.as_ptr()\n    }\n\n    /// Gets the capacity of the allocation.\n    ///\n    /// This will always be `usize::MAX` if `T` is zero-sized.\n    #[inline(always)]\n    pub fn cap(&self) -> usize {\n        if mem::size_of::<T>() == 0 {\n            !0\n        } else {\n            self.cap\n        }\n    }\n\n    /// Returns a shared reference to the allocator backing this RawVec.\n    pub fn alloc(&self) -> &A {\n        &self.a\n    }\n\n    /// Returns a mutable reference to the allocator backing this RawVec.\n    pub fn alloc_mut(&mut self) -> &mut A {\n        &mut self.a\n    }\n\n    /// Doubles the size of the type's backing allocation. This is common enough\n    /// to want to do that it's easiest to just have a dedicated method. Slightly\n    /// more efficient logic can be provided for this than the general case.\n    ///\n    /// This function is ideal for when pushing elements one-at-a-time because\n    /// you don't need to incur the costs of the more general computations\n    /// reserve needs to do to guard against overflow. You do however need to\n    /// manually check if your `len == cap`.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n    ///   all `usize::MAX` slots in your imaginary buffer.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(alloc)]\n    /// # extern crate alloc;\n    /// # use std::ptr;\n    /// # use alloc::raw_vec::RawVec;\n    /// struct MyVec<T> {\n    ///     buf: RawVec<T>,\n    ///     len: usize,\n    /// }\n    ///\n    /// impl<T> MyVec<T> {\n    ///     pub fn push(&mut self, elem: T) {\n    ///         if self.len == self.buf.cap() { self.buf.double(); }\n    ///         // double would have aborted or panicked if the len exceeded\n    ///         // `isize::MAX` so this is safe to do unchecked now.\n    ///         unsafe {\n    ///             ptr::write(self.buf.ptr().offset(self.len as isize), elem);\n    ///         }\n    ///         self.len += 1;\n    ///     }\n    /// }\n    /// # fn main() {\n    /// #   let mut vec = MyVec { buf: RawVec::new(), len: 0 };\n    /// #   vec.push(1);\n    /// # }\n    /// ```\n    #[inline(never)]\n    #[cold]\n    pub fn double(&mut self) {\n        unsafe {\n            let elem_size = mem::size_of::<T>();\n\n            // since we set the capacity to usize::MAX when elem_size is\n            // 0, getting to here necessarily means the RawVec is overfull.\n            assert!(elem_size != 0, \"capacity overflow\");\n\n            let (new_cap, ptr_res) = if self.cap == 0 {\n                // skip to 4 because tiny Vec's are dumb; but not if that would cause overflow\n                let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                let ptr_res = self.a.alloc_array::<T>(new_cap);\n                (new_cap, ptr_res)\n            } else {\n                // Since we guarantee that we never allocate more than isize::MAX bytes,\n                // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow\n                let new_cap = 2 * self.cap;\n                let new_alloc_size = new_cap * elem_size;\n                alloc_guard(new_alloc_size);\n                let ptr_res = self.a.realloc_array(self.ptr, self.cap, new_cap);\n                (new_cap, ptr_res)\n            };\n\n            // If allocate or reallocate fail, we'll get `null` back\n            let uniq = match ptr_res {\n                Err(err) => self.a.oom(err),\n                Ok(uniq) => uniq,\n            };\n\n            self.ptr = uniq;\n            self.cap = new_cap;\n        }\n    }\n\n    /// Attempts to double the size of the type's backing allocation in place. This is common\n    /// enough to want to do that it's easiest to just have a dedicated method. Slightly\n    /// more efficient logic can be provided for this than the general case.\n    ///\n    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n    ///   all `usize::MAX` slots in your imaginary buffer.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    #[inline(never)]\n    #[cold]\n    pub fn double_in_place(&mut self) -> bool {\n        unsafe {\n            let elem_size = mem::size_of::<T>();\n\n            // since we set the capacity to usize::MAX when elem_size is\n            // 0, getting to here necessarily means the RawVec is overfull.\n            assert!(elem_size != 0, \"capacity overflow\");\n\n            // Since we guarantee that we never allocate more than isize::MAX bytes,\n            // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow\n            let new_cap = 2 * self.cap;\n            let new_alloc_size = new_cap * elem_size;\n\n            alloc_guard(new_alloc_size);\n\n            let ptr = self.ptr() as *mut _;\n            let old_layout = Layout::new::<T>().repeat(self.cap).unwrap().0;\n            let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n            match self.a.grow_in_place(ptr, old_layout, new_layout) {\n                Ok(_) => {\n                    // We can't directly divide `size`.\n                    self.cap = new_cap;\n                    true\n                }\n                Err(_) => {\n                    false\n                }\n            }\n        }\n    }\n\n    /// Ensures that the buffer contains at least enough space to hold\n    /// `used_cap + needed_extra_cap` elements. If it doesn't already,\n    /// will reallocate the minimum possible amount of memory necessary.\n    /// Generally this will be exactly the amount of memory necessary,\n    /// but in principle the allocator is free to give back more than\n    /// we asked for.\n    ///\n    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n    /// the requested space. This is not really unsafe, but the unsafe\n    /// code *you* write that relies on the behavior of this function may break.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM\n    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n        unsafe {\n            let elem_size = mem::size_of::<T>();\n\n            // NOTE: we don't early branch on ZSTs here because we want this\n            // to actually catch \"asking for more than usize::MAX\" in that case.\n            // If we make it past the first branch then we are guaranteed to\n            // panic.\n\n            // Don't actually need any more capacity.\n            // Wrapping in case they gave a bad `used_cap`.\n            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n                return;\n            }\n\n            // Nothing we can really do about these checks :(\n            let new_cap = used_cap.checked_add(needed_extra_cap).expect(\"capacity overflow\");\n            let new_alloc_size = new_cap.checked_mul(elem_size).expect(\"capacity overflow\");\n            alloc_guard(new_alloc_size);\n\n            let result = if self.cap == 0 {\n                self.a.alloc_array::<T>(new_cap)\n            } else {\n                self.a.realloc_array(self.ptr, self.cap, new_cap)\n            };\n\n            // If allocate or reallocate fail, we'll get `null` back\n            let uniq = match result {\n                Err(err) => self.a.oom(err),\n                Ok(uniq) => uniq,\n            };\n\n            self.ptr = uniq;\n            self.cap = new_cap;\n        }\n    }\n\n    /// Calculates the buffer's new size given that it'll hold `used_cap +\n    /// needed_extra_cap` elements. This logic is used in amortized reserve methods.\n    /// Returns `(new_capacity, new_alloc_size)`.\n    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize) -> (usize, usize) {\n        let elem_size = mem::size_of::<T>();\n        // Nothing we can really do about these checks :(\n        let required_cap = used_cap.checked_add(needed_extra_cap)\n            .expect(\"capacity overflow\");\n        // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n        let double_cap = self.cap * 2;\n        // `double_cap` guarantees exponential growth.\n        let new_cap = cmp::max(double_cap, required_cap);\n        let new_alloc_size = new_cap.checked_mul(elem_size).expect(\"capacity overflow\");\n        (new_cap, new_alloc_size)\n    }\n\n    /// Ensures that the buffer contains at least enough space to hold\n    /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n    /// enough capacity, will reallocate enough space plus comfortable slack\n    /// space to get amortized `O(1)` behavior. Will limit this behavior\n    /// if it would needlessly cause itself to panic.\n    ///\n    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n    /// the requested space. This is not really unsafe, but the unsafe\n    /// code *you* write that relies on the behavior of this function may break.\n    ///\n    /// This is ideal for implementing a bulk-push operation like `extend`.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(alloc)]\n    /// # extern crate alloc;\n    /// # use std::ptr;\n    /// # use alloc::raw_vec::RawVec;\n    /// struct MyVec<T> {\n    ///     buf: RawVec<T>,\n    ///     len: usize,\n    /// }\n    ///\n    /// impl<T: Clone> MyVec<T> {\n    ///     pub fn push_all(&mut self, elems: &[T]) {\n    ///         self.buf.reserve(self.len, elems.len());\n    ///         // reserve would have aborted or panicked if the len exceeded\n    ///         // `isize::MAX` so this is safe to do unchecked now.\n    ///         for x in elems {\n    ///             unsafe {\n    ///                 ptr::write(self.buf.ptr().offset(self.len as isize), x.clone());\n    ///             }\n    ///             self.len += 1;\n    ///         }\n    ///     }\n    /// }\n    /// # fn main() {\n    /// #   let mut vector = MyVec { buf: RawVec::new(), len: 0 };\n    /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n    /// # }\n    /// ```\n    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n        unsafe {\n            // NOTE: we don't early branch on ZSTs here because we want this\n            // to actually catch \"asking for more than usize::MAX\" in that case.\n            // If we make it past the first branch then we are guaranteed to\n            // panic.\n\n            // Don't actually need any more capacity.\n            // Wrapping in case they give a bad `used_cap`\n            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n                return;\n            }\n\n            let (new_cap, new_alloc_size) = self.amortized_new_size(used_cap, needed_extra_cap);\n            // FIXME: may crash and burn on over-reserve\n            alloc_guard(new_alloc_size);\n\n            let result = if self.cap == 0 {\n                self.a.alloc_array::<T>(new_cap)\n            } else {\n                self.a.realloc_array(self.ptr, self.cap, new_cap)\n            };\n\n            let uniq = match result {\n                Err(err) => self.a.oom(err),\n                Ok(uniq) => uniq,\n            };\n\n            self.ptr = uniq;\n            self.cap = new_cap;\n        }\n    }\n\n    /// Attempts to ensure that the buffer contains at least enough space to hold\n    /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n    /// enough capacity, will reallocate in place enough space plus comfortable slack\n    /// space to get amortized `O(1)` behaviour. Will limit this behaviour\n    /// if it would needlessly cause itself to panic.\n    ///\n    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n    /// the requested space. This is not really unsafe, but the unsafe\n    /// code *you* write that relies on the behaviour of this function may break.\n    ///\n    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    pub fn reserve_in_place(&mut self, used_cap: usize, needed_extra_cap: usize) -> bool {\n        unsafe {\n            // NOTE: we don't early branch on ZSTs here because we want this\n            // to actually catch \"asking for more than usize::MAX\" in that case.\n            // If we make it past the first branch then we are guaranteed to\n            // panic.\n\n            // Don't actually need any more capacity. If the current `cap` is 0, we can't\n            // reallocate in place.\n            // Wrapping in case they give a bad `used_cap`\n            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap || self.cap == 0 {\n                return false;\n            }\n\n            let (new_cap, new_alloc_size) = self.amortized_new_size(used_cap, needed_extra_cap);\n            // FIXME: may crash and burn on over-reserve\n            alloc_guard(new_alloc_size);\n\n            // Here, `cap < used_cap + needed_extra_cap <= new_cap`\n            // (regardless of whether `self.cap - used_cap` wrapped).\n            // Therefore we can safely call grow_in_place.\n\n            let ptr = self.ptr() as *mut _;\n            let old_layout = Layout::new::<T>().repeat(self.cap).unwrap().0;\n            let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n            match self.a.grow_in_place(ptr, old_layout, new_layout) {\n                Ok(_) => {\n                    self.cap = new_cap;\n                    true\n                }\n                Err(_) => {\n                    false\n                }\n            }\n        }\n    }\n\n    /// Shrinks the allocation down to the specified amount. If the given amount\n    /// is 0, actually completely deallocates.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the given amount is *larger* than the current capacity.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM.\n    pub fn shrink_to_fit(&mut self, amount: usize) {\n        let elem_size = mem::size_of::<T>();\n\n        // Set the `cap` because they might be about to promote to a `Box<[T]>`\n        if elem_size == 0 {\n            self.cap = amount;\n            return;\n        }\n\n        // This check is my waterloo; it's the only thing Vec wouldn't have to do.\n        assert!(self.cap >= amount, \"Tried to shrink to a larger capacity\");\n\n        if amount == 0 {\n            // We want to create a new zero-length vector within the\n            // same allocator.  We use ptr::write to avoid an\n            // erroneous attempt to drop the contents, and we use\n            // ptr::read to sidestep condition against destructuring\n            // types that implement Drop.\n\n            unsafe {\n                let a = ptr::read(&self.a as *const A);\n                self.dealloc_buffer();\n                ptr::write(self, RawVec::new_in(a));\n            }\n        } else if self.cap != amount {\n            unsafe {\n                match self.a.realloc_array(self.ptr, self.cap, amount) {\n                    Err(err) => self.a.oom(err),\n                    Ok(uniq) => self.ptr = uniq,\n                }\n            }\n            self.cap = amount;\n        }\n    }\n}\n\nimpl<T> RawVec<T, HeapAlloc> {\n    /// Converts the entire buffer into `Box<[T]>`.\n    ///\n    /// While it is not *strictly* Undefined Behavior to call\n    /// this procedure while some of the RawVec is uninitialized,\n    /// it certainly makes it trivial to trigger it.\n    ///\n    /// Note that this will correctly reconstitute any `cap` changes\n    /// that may have been performed. (see description of type for details)\n    pub unsafe fn into_box(self) -> Box<[T]> {\n        // NOTE: not calling `cap()` here, actually using the real `cap` field!\n        let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);\n        let output: Box<[T]> = Box::from_raw(slice);\n        mem::forget(self);\n        output\n    }\n}\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n    pub unsafe fn dealloc_buffer(&mut self) {\n        let elem_size = mem::size_of::<T>();\n        if elem_size != 0 && self.cap != 0 {\n            let ptr = self.ptr() as *mut u8;\n            let layout = Layout::new::<T>().repeat(self.cap).unwrap().0;\n            self.a.dealloc(ptr, layout);\n        }\n    }\n}\n\nunsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n    fn drop(&mut self) {\n        unsafe { self.dealloc_buffer(); }\n    }\n}\n\n\n\n// We need to guarantee the following:\n// * We don't ever allocate `> isize::MAX` byte-size objects\n// * We don't overflow `usize::MAX` and actually allocate too little\n//\n// On 64-bit we just need to check for overflow since trying to allocate\n// `> isize::MAX` bytes will surely fail. On 32-bit and 16-bit we need to add\n// an extra guard for this in case we're running on a platform which can use\n// all 4GB in user-space. e.g. PAE or x32\n\n#[inline]\nfn alloc_guard(alloc_size: usize) {\n    if mem::size_of::<usize>() < 8 {\n        assert!(alloc_size <= ::core::isize::MAX as usize,\n                \"capacity overflow\");\n    }\n}\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn allocator_param() {\n        use allocator::{Alloc, AllocErr};\n\n        // Writing a test of integration between third-party\n        // allocators and RawVec is a little tricky because the RawVec\n        // API does not expose fallible allocation methods, so we\n        // cannot check what happens when allocator is exhausted\n        // (beyond detecting a panic).\n        //\n        // Instead, this just checks that the RawVec methods do at\n        // least go through the Allocator API when it reserves\n        // storage.\n\n        // A dumb allocator that consumes a fixed amount of fuel\n        // before allocation attempts start failing.\n        struct BoundedAlloc { fuel: usize }\n        unsafe impl Alloc for BoundedAlloc {\n            unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n                let size = layout.size();\n                if size > self.fuel {\n                    return Err(AllocErr::Unsupported { details: \"fuel exhausted\" });\n                }\n                match HeapAlloc.alloc(layout) {\n                    ok @ Ok(_) => { self.fuel -= size; ok }\n                    err @ Err(_) => err,\n                }\n            }\n            unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n                HeapAlloc.dealloc(ptr, layout)\n            }\n        }\n\n        let a = BoundedAlloc { fuel: 500 };\n        let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n        assert_eq!(v.a.fuel, 450);\n        v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n        assert_eq!(v.a.fuel, 250);\n    }\n\n    #[test]\n    fn reserve_does_not_overallocate() {\n        {\n            let mut v: RawVec<u32> = RawVec::new();\n            // First `reserve` allocates like `reserve_exact`\n            v.reserve(0, 9);\n            assert_eq!(9, v.cap());\n        }\n\n        {\n            let mut v: RawVec<u32> = RawVec::new();\n            v.reserve(0, 7);\n            assert_eq!(7, v.cap());\n            // 97 if more than double of 7, so `reserve` should work\n            // like `reserve_exact`.\n            v.reserve(7, 90);\n            assert_eq!(97, v.cap());\n        }\n\n        {\n            let mut v: RawVec<u32> = RawVec::new();\n            v.reserve(0, 12);\n            assert_eq!(12, v.cap());\n            v.reserve(12, 3);\n            // 3 is less than half of 12, so `reserve` must grow\n            // exponentially. At the time of writing this test grow\n            // factor is 2, so new capacity is 24, however, grow factor\n            // of 1.5 is OK too. Hence `>= 18` in assert.\n            assert!(v.cap() >= 12 + 12 / 2);\n        }\n    }\n\n\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A UTF-8 encoded, growable string.\n//!\n//! This module contains the [`String`] type, a trait for converting\n//! [`ToString`]s, and several error types that may result from working with\n//! [`String`]s.\n//!\n//! [`ToString`]: trait.ToString.html\n//!\n//! # Examples\n//!\n//! There are multiple ways to create a new [`String`] from a string literal:\n//!\n//! ```\n//! let s = \"Hello\".to_string();\n//!\n//! let s = String::from(\"world\");\n//! let s: String = \"also this\".into();\n//! ```\n//!\n//! You can create a new [`String`] from an existing one by concatenating with\n//! `+`:\n//!\n//! [`String`]: struct.String.html\n//!\n//! ```\n//! let s = \"Hello\".to_string();\n//!\n//! let message = s + \" world!\";\n//! ```\n//!\n//! If you have a vector of valid UTF-8 bytes, you can make a `String` out of\n//! it. You can do the reverse too.\n//!\n//! ```\n//! let sparkle_heart = vec![240, 159, 146, 150];\n//!\n//! // We know these bytes are valid, so we'll use `unwrap()`.\n//! let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n//!\n//! assert_eq!(\"\", sparkle_heart);\n//!\n//! let bytes = sparkle_heart.into_bytes();\n//!\n//! assert_eq!(bytes, [240, 159, 146, 150]);\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::fmt;\nuse core::hash;\nuse core::iter::{FromIterator, FusedIterator};\nuse core::ops::{self, Add, AddAssign, Index, IndexMut};\nuse core::ptr;\nuse core::str::pattern::Pattern;\nuse std_unicode::lossy;\nuse std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n\nuse borrow::{Cow, ToOwned};\nuse range::RangeArgument;\nuse Bound::{Excluded, Included, Unbounded};\nuse str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\nuse vec::Vec;\nuse boxed::Box;\n\n/// A UTF-8 encoded, growable string.\n///\n/// The `String` type is the most common string type that has ownership over the\n/// contents of the string. It has a close relationship with its borrowed\n/// counterpart, the primitive [`str`].\n///\n/// [`str`]: ../../std/primitive.str.html\n///\n/// # Examples\n///\n/// You can create a `String` from a literal string with `String::from`:\n///\n/// ```\n/// let hello = String::from(\"Hello, world!\");\n/// ```\n///\n/// You can append a [`char`] to a `String` with the [`push`] method, and\n/// append a [`&str`] with the [`push_str`] method:\n///\n/// ```\n/// let mut hello = String::from(\"Hello, \");\n///\n/// hello.push('w');\n/// hello.push_str(\"orld!\");\n/// ```\n///\n/// [`char`]: ../../std/primitive.char.html\n/// [`push`]: #method.push\n/// [`push_str`]: #method.push_str\n///\n/// If you have a vector of UTF-8 bytes, you can create a `String` from it with\n/// the [`from_utf8`] method:\n///\n/// ```\n/// // some bytes, in a vector\n/// let sparkle_heart = vec![240, 159, 146, 150];\n///\n/// // We know these bytes are valid, so we'll use `unwrap()`.\n/// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n///\n/// assert_eq!(\"\", sparkle_heart);\n/// ```\n///\n/// [`from_utf8`]: #method.from_utf8\n///\n/// # UTF-8\n///\n/// `String`s are always valid UTF-8. This has a few implications, the first of\n/// which is that if you need a non-UTF-8 string, consider [`OsString`]. It is\n/// similar, but without the UTF-8 constraint. The second implication is that\n/// you cannot index into a `String`:\n///\n/// ```compile_fail,E0277\n/// let s = \"hello\";\n///\n/// println!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n/// ```\n///\n/// [`OsString`]: ../../std/ffi/struct.OsString.html\n///\n/// Indexing is intended to be a constant-time operation, but UTF-8 encoding\n/// does not allow us to do this. Furthermore, it's not clear what sort of\n/// thing the index should return: a byte, a codepoint, or a grapheme cluster.\n/// The [`bytes`] and [`chars`] methods return iterators over the first\n/// two, respectively.\n///\n/// [`bytes`]: #method.bytes\n/// [`chars`]: #method.chars\n///\n/// # Deref\n///\n/// `String`s implement [`Deref`]`<Target=str>`, and so inherit all of [`str`]'s\n/// methods. In addition, this means that you can pass a `String` to any\n/// function which takes a [`&str`] by using an ampersand (`&`):\n///\n/// ```\n/// fn takes_str(s: &str) { }\n///\n/// let s = String::from(\"Hello\");\n///\n/// takes_str(&s);\n/// ```\n///\n/// [`&str`]: ../../std/primitive.str.html\n/// [`Deref`]: ../../std/ops/trait.Deref.html\n///\n/// This will create a [`&str`] from the `String` and pass it in. This\n/// conversion is very inexpensive, and so generally, functions will accept\n/// [`&str`]s as arguments unless they need a `String` for some specific reason.\n///\n///\n/// # Representation\n///\n/// A `String` is made up of three components: a pointer to some bytes, a\n/// length, and a capacity. The pointer points to an internal buffer `String`\n/// uses to store its data. The length is the number of bytes currently stored\n/// in the buffer, and the capacity is the size of the buffer in bytes. As such,\n/// the length will always be less than or equal to the capacity.\n///\n/// This buffer is always stored on the heap.\n///\n/// You can look at these with the [`as_ptr`], [`len`], and [`capacity`]\n/// methods:\n///\n/// ```\n/// use std::mem;\n///\n/// let story = String::from(\"Once upon a time...\");\n///\n/// let ptr = story.as_ptr();\n/// let len = story.len();\n/// let capacity = story.capacity();\n///\n/// // story has nineteen bytes\n/// assert_eq!(19, len);\n///\n/// // Now that we have our parts, we throw the story away.\n/// mem::forget(story);\n///\n/// // We can re-build a String out of ptr, len, and capacity. This is all\n/// // unsafe because we are responsible for making sure the components are\n/// // valid:\n/// let s = unsafe { String::from_raw_parts(ptr as *mut _, len, capacity) } ;\n///\n/// assert_eq!(String::from(\"Once upon a time...\"), s);\n/// ```\n///\n/// [`as_ptr`]: #method.as_ptr\n/// [`len`]: #method.len\n/// [`capacity`]: #method.capacity\n///\n/// If a `String` has enough capacity, adding elements to it will not\n/// re-allocate. For example, consider this program:\n///\n/// ```\n/// let mut s = String::new();\n///\n/// println!(\"{}\", s.capacity());\n///\n/// for _ in 0..5 {\n///     s.push_str(\"hello\");\n///     println!(\"{}\", s.capacity());\n/// }\n/// ```\n///\n/// This will output the following:\n///\n/// ```text\n/// 0\n/// 5\n/// 10\n/// 20\n/// 20\n/// 40\n/// ```\n///\n/// At first, we have no memory allocated at all, but as we append to the\n/// string, it increases its capacity appropriately. If we instead use the\n/// [`with_capacity`] method to allocate the correct capacity initially:\n///\n/// ```\n/// let mut s = String::with_capacity(25);\n///\n/// println!(\"{}\", s.capacity());\n///\n/// for _ in 0..5 {\n///     s.push_str(\"hello\");\n///     println!(\"{}\", s.capacity());\n/// }\n/// ```\n///\n/// [`with_capacity`]: #method.with_capacity\n///\n/// We end up with a different output:\n///\n/// ```text\n/// 25\n/// 25\n/// 25\n/// 25\n/// 25\n/// 25\n/// ```\n///\n/// Here, there's no need to allocate more memory inside the loop.\n#[derive(PartialOrd, Eq, Ord)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct String {\n    vec: Vec<u8>,\n}\n\n/// A possible error value when converting a `String` from a UTF-8 byte vector.\n///\n/// This type is the error type for the [`from_utf8`] method on [`String`]. It\n/// is designed in such a way to carefully avoid reallocations: the\n/// [`into_bytes`] method will give back the byte vector that was used in the\n/// conversion attempt.\n///\n/// [`from_utf8`]: struct.String.html#method.from_utf8\n/// [`String`]: struct.String.html\n/// [`into_bytes`]: struct.FromUtf8Error.html#method.into_bytes\n///\n/// The [`Utf8Error`] type provided by [`std::str`] represents an error that may\n/// occur when converting a slice of [`u8`]s to a [`&str`]. In this sense, it's\n/// an analogue to `FromUtf8Error`, and you can get one from a `FromUtf8Error`\n/// through the [`utf8_error`] method.\n///\n/// [`Utf8Error`]: ../../std/str/struct.Utf8Error.html\n/// [`std::str`]: ../../std/str/index.html\n/// [`u8`]: ../../std/primitive.u8.html\n/// [`&str`]: ../../std/primitive.str.html\n/// [`utf8_error`]: #method.utf8_error\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // some invalid bytes, in a vector\n/// let bytes = vec![0, 159];\n///\n/// let value = String::from_utf8(bytes);\n///\n/// assert!(value.is_err());\n/// assert_eq!(vec![0, 159], value.unwrap_err().into_bytes());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct FromUtf8Error {\n    bytes: Vec<u8>,\n    error: Utf8Error,\n}\n\n/// A possible error value when converting a `String` from a UTF-16 byte slice.\n///\n/// This type is the error type for the [`from_utf16`] method on [`String`].\n///\n/// [`from_utf16`]: struct.String.html#method.from_utf16\n/// [`String`]: struct.String.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // mu<invalid>ic\n/// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n///           0xD800, 0x0069, 0x0063];\n///\n/// assert!(String::from_utf16(v).is_err());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct FromUtf16Error(());\n\nimpl String {\n    /// Creates a new empty `String`.\n    ///\n    /// Given that the `String` is empty, this will not allocate any initial\n    /// buffer. While that means that this initial operation is very\n    /// inexpensive, but may cause excessive allocation later, when you add\n    /// data. If you have an idea of how much data the `String` will hold,\n    /// consider the [`with_capacity`] method to prevent excessive\n    /// re-allocation.\n    ///\n    /// [`with_capacity`]: #method.with_capacity\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::new();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> String {\n        String { vec: Vec::new() }\n    }\n\n    /// Creates a new empty `String` with a particular capacity.\n    ///\n    /// `String`s have an internal buffer to hold their data. The capacity is\n    /// the length of that buffer, and can be queried with the [`capacity`]\n    /// method. This method creates an empty `String`, but one with an initial\n    /// buffer that can hold `capacity` bytes. This is useful when you may be\n    /// appending a bunch of data to the `String`, reducing the number of\n    /// reallocations it needs to do.\n    ///\n    /// [`capacity`]: #method.capacity\n    ///\n    /// If the given capacity is `0`, no allocation will occur, and this method\n    /// is identical to the [`new`] method.\n    ///\n    /// [`new`]: #method.new\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::with_capacity(10);\n    ///\n    /// // The String contains no chars, even though it has capacity for more\n    /// assert_eq!(s.len(), 0);\n    ///\n    /// // These are all done without reallocating...\n    /// let cap = s.capacity();\n    /// for i in 0..10 {\n    ///     s.push('a');\n    /// }\n    ///\n    /// assert_eq!(s.capacity(), cap);\n    ///\n    /// // ...but this may make the vector reallocate\n    /// s.push('a');\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> String {\n        String { vec: Vec::with_capacity(capacity) }\n    }\n\n    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n    // required for this method definition, is not available. Since we don't\n    // require this method for testing purposes, I'll just stub it\n    // NB see the slice::hack module in slice.rs for more information\n    #[inline]\n    #[cfg(test)]\n    pub fn from_str(_: &str) -> String {\n        panic!(\"not available with cfg(test)\");\n    }\n\n    /// Converts a vector of bytes to a `String`.\n    ///\n    /// A string slice ([`&str`]) is made of bytes ([`u8`]), and a vector of bytes\n    /// ([`Vec<u8>`]) is made of bytes, so this function converts between the\n    /// two. Not all byte slices are valid `String`s, however: `String`\n    /// requires that it is valid UTF-8. `from_utf8()` checks to ensure that\n    /// the bytes are valid UTF-8, and then does the conversion.\n    ///\n    /// [`&str`]: ../../std/primitive.str.html\n    /// [`u8`]: ../../std/primitive.u8.html\n    /// [`Vec<u8>`]: ../../std/vec/struct.Vec.html\n    ///\n    /// If you are sure that the byte slice is valid UTF-8, and you don't want\n    /// to incur the overhead of the validity check, there is an unsafe version\n    /// of this function, [`from_utf8_unchecked`], which has the same behavior\n    /// but skips the check.\n    ///\n    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n    ///\n    /// This method will take care to not copy the vector, for efficiency's\n    /// sake.\n    ///\n    /// If you need a `&str` instead of a `String`, consider\n    /// [`str::from_utf8`].\n    ///\n    /// [`str::from_utf8`]: ../../std/str/fn.from_utf8.html\n    ///\n    /// The inverse of this method is [`as_bytes`].\n    ///\n    /// [`as_bytes`]: #method.as_bytes\n    ///\n    /// # Errors\n    ///\n    /// Returns `Err` if the slice is not UTF-8 with a description as to why the\n    /// provided bytes are not UTF-8. The vector you moved in is also included.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some bytes, in a vector\n    /// let sparkle_heart = vec![240, 159, 146, 150];\n    ///\n    /// // We know these bytes are valid, so we'll use `unwrap()`.\n    /// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n    ///\n    /// assert_eq!(\"\", sparkle_heart);\n    /// ```\n    ///\n    /// Incorrect bytes:\n    ///\n    /// ```\n    /// // some invalid bytes, in a vector\n    /// let sparkle_heart = vec![0, 159, 146, 150];\n    ///\n    /// assert!(String::from_utf8(sparkle_heart).is_err());\n    /// ```\n    ///\n    /// See the docs for [`FromUtf8Error`] for more details on what you can do\n    /// with this error.\n    ///\n    /// [`FromUtf8Error`]: struct.FromUtf8Error.html\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n        match str::from_utf8(&vec) {\n            Ok(..) => Ok(String { vec: vec }),\n            Err(e) => {\n                Err(FromUtf8Error {\n                    bytes: vec,\n                    error: e,\n                })\n            }\n        }\n    }\n\n    /// Converts a slice of bytes to a string, including invalid characters.\n    ///\n    /// Strings are made of bytes ([`u8`]), and a slice of bytes\n    /// ([`&[u8]`][byteslice]) is made of bytes, so this function converts\n    /// between the two. Not all byte slices are valid strings, however: strings\n    /// are required to be valid UTF-8. During this conversion,\n    /// `from_utf8_lossy()` will replace any invalid UTF-8 sequences with\n    /// `U+FFFD REPLACEMENT CHARACTER`, which looks like this: \n    ///\n    /// [`u8`]: ../../std/primitive.u8.html\n    /// [byteslice]: ../../std/primitive.slice.html\n    ///\n    /// If you are sure that the byte slice is valid UTF-8, and you don't want\n    /// to incur the overhead of the conversion, there is an unsafe version\n    /// of this function, [`from_utf8_unchecked`], which has the same behavior\n    /// but skips the checks.\n    ///\n    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n    ///\n    /// This function returns a [`Cow<'a, str>`]. If our byte slice is invalid\n    /// UTF-8, then we need to insert the replacement characters, which will\n    /// change the size of the string, and hence, require a `String`. But if\n    /// it's already valid UTF-8, we don't need a new allocation. This return\n    /// type allows us to handle both cases.\n    ///\n    /// [`Cow<'a, str>`]: ../../std/borrow/enum.Cow.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some bytes, in a vector\n    /// let sparkle_heart = vec![240, 159, 146, 150];\n    ///\n    /// let sparkle_heart = String::from_utf8_lossy(&sparkle_heart);\n    ///\n    /// assert_eq!(\"\", sparkle_heart);\n    /// ```\n    ///\n    /// Incorrect bytes:\n    ///\n    /// ```\n    /// // some invalid bytes\n    /// let input = b\"Hello \\xF0\\x90\\x80World\";\n    /// let output = String::from_utf8_lossy(input);\n    ///\n    /// assert_eq!(\"Hello World\", output);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> Cow<'a, str> {\n        let mut iter = lossy::Utf8Lossy::from_bytes(v).chunks();\n\n        let (first_valid, first_broken) = if let Some(chunk) = iter.next() {\n            let lossy::Utf8LossyChunk { valid, broken } = chunk;\n            if valid.len() == v.len() {\n                debug_assert!(broken.is_empty());\n                return Cow::Borrowed(valid);\n            }\n            (valid, broken)\n        } else {\n            return Cow::Borrowed(\"\");\n        };\n\n        const REPLACEMENT: &'static str = \"\\u{FFFD}\";\n\n        let mut res = String::with_capacity(v.len());\n        res.push_str(first_valid);\n        if !first_broken.is_empty() {\n            res.push_str(REPLACEMENT);\n        }\n\n        for lossy::Utf8LossyChunk { valid, broken } in iter {\n            res.push_str(valid);\n            if !broken.is_empty() {\n                res.push_str(REPLACEMENT);\n            }\n        }\n\n        Cow::Owned(res)\n    }\n\n    /// Decode a UTF-16 encoded vector `v` into a `String`, returning `Err`\n    /// if `v` contains any invalid data.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // music\n    /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n    ///           0x0073, 0x0069, 0x0063];\n    /// assert_eq!(String::from(\"music\"),\n    ///            String::from_utf16(v).unwrap());\n    ///\n    /// // mu<invalid>ic\n    /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n    ///           0xD800, 0x0069, 0x0063];\n    /// assert!(String::from_utf16(v).is_err());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n        decode_utf16(v.iter().cloned()).collect::<Result<_, _>>().map_err(|_| FromUtf16Error(()))\n    }\n\n    /// Decode a UTF-16 encoded vector `v` into a string, replacing\n    /// invalid data with the replacement character (U+FFFD).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // mus<invalid>ic<invalid>\n    /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n    ///           0x0073, 0xDD1E, 0x0069, 0x0063,\n    ///           0xD834];\n    ///\n    /// assert_eq!(String::from(\"mus\\u{FFFD}ic\\u{FFFD}\"),\n    ///            String::from_utf16_lossy(v));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_utf16_lossy(v: &[u16]) -> String {\n        decode_utf16(v.iter().cloned()).map(|r| r.unwrap_or(REPLACEMENT_CHARACTER)).collect()\n    }\n\n    /// Creates a new `String` from a length, capacity, and pointer.\n    ///\n    /// # Safety\n    ///\n    /// This is highly unsafe, due to the number of invariants that aren't\n    /// checked:\n    ///\n    /// * The memory at `ptr` needs to have been previously allocated by the\n    ///   same allocator the standard library uses.\n    /// * `length` needs to be less than or equal to `capacity`.\n    /// * `capacity` needs to be the correct value.\n    ///\n    /// Violating these may cause problems like corrupting the allocator's\n    /// internal datastructures.\n    ///\n    /// The ownership of `ptr` is effectively transferred to the\n    /// `String` which may then deallocate, reallocate or change the\n    /// contents of memory pointed to by the pointer at will. Ensure\n    /// that nothing else uses the pointer after calling this\n    /// function.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::mem;\n    ///\n    /// unsafe {\n    ///     let s = String::from(\"hello\");\n    ///     let ptr = s.as_ptr();\n    ///     let len = s.len();\n    ///     let capacity = s.capacity();\n    ///\n    ///     mem::forget(s);\n    ///\n    ///     let s = String::from_raw_parts(ptr as *mut _, len, capacity);\n    ///\n    ///     assert_eq!(String::from(\"hello\"), s);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_raw_parts(buf: *mut u8, length: usize, capacity: usize) -> String {\n        String { vec: Vec::from_raw_parts(buf, length, capacity) }\n    }\n\n    /// Converts a vector of bytes to a `String` without checking that the\n    /// string contains valid UTF-8.\n    ///\n    /// See the safe version, [`from_utf8`], for more details.\n    ///\n    /// [`from_utf8`]: struct.String.html#method.from_utf8\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because it does not check that the bytes passed\n    /// to it are valid UTF-8. If this constraint is violated, it may cause\n    /// memory unsafety issues with future users of the `String`, as the rest of\n    /// the standard library assumes that `String`s are valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some bytes, in a vector\n    /// let sparkle_heart = vec![240, 159, 146, 150];\n    ///\n    /// let sparkle_heart = unsafe {\n    ///     String::from_utf8_unchecked(sparkle_heart)\n    /// };\n    ///\n    /// assert_eq!(\"\", sparkle_heart);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {\n        String { vec: bytes }\n    }\n\n    /// Converts a `String` into a byte vector.\n    ///\n    /// This consumes the `String`, so we do not need to copy its contents.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::from(\"hello\");\n    /// let bytes = s.into_bytes();\n    ///\n    /// assert_eq!(&[104, 101, 108, 108, 111][..], &bytes[..]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_bytes(self) -> Vec<u8> {\n        self.vec\n    }\n\n    /// Extracts a string slice containing the entire string.\n    #[inline]\n    #[stable(feature = \"string_as_str\", since = \"1.7.0\")]\n    pub fn as_str(&self) -> &str {\n        self\n    }\n\n    /// Extracts a string slice containing the entire string.\n    #[inline]\n    #[stable(feature = \"string_as_str\", since = \"1.7.0\")]\n    pub fn as_mut_str(&mut self) -> &mut str {\n        self\n    }\n\n    /// Appends a given string slice onto the end of this `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// s.push_str(\"bar\");\n    ///\n    /// assert_eq!(\"foobar\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push_str(&mut self, string: &str) {\n        self.vec.extend_from_slice(string.as_bytes())\n    }\n\n    /// Returns this `String`'s capacity, in bytes.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::with_capacity(10);\n    ///\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n        self.vec.capacity()\n    }\n\n    /// Ensures that this `String`'s capacity is at least `additional` bytes\n    /// larger than its length.\n    ///\n    /// The capacity may be increased by more than `additional` bytes if it\n    /// chooses, to prevent frequent reallocations.\n    ///\n    /// If you do not want this \"at least\" behavior, see the [`reserve_exact`]\n    /// method.\n    ///\n    /// [`reserve_exact`]: #method.reserve_exact\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::new();\n    ///\n    /// s.reserve(10);\n    ///\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    ///\n    /// This may not actually increase the capacity:\n    ///\n    /// ```\n    /// let mut s = String::with_capacity(10);\n    /// s.push('a');\n    /// s.push('b');\n    ///\n    /// // s now has a length of 2 and a capacity of 10\n    /// assert_eq!(2, s.len());\n    /// assert_eq!(10, s.capacity());\n    ///\n    /// // Since we already have an extra 8 capacity, calling this...\n    /// s.reserve(8);\n    ///\n    /// // ... doesn't actually increase.\n    /// assert_eq!(10, s.capacity());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n        self.vec.reserve(additional)\n    }\n\n    /// Ensures that this `String`'s capacity is `additional` bytes\n    /// larger than its length.\n    ///\n    /// Consider using the [`reserve`] method unless you absolutely know\n    /// better than the allocator.\n    ///\n    /// [`reserve`]: #method.reserve\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::new();\n    ///\n    /// s.reserve_exact(10);\n    ///\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    ///\n    /// This may not actually increase the capacity:\n    ///\n    /// ```\n    /// let mut s = String::with_capacity(10);\n    /// s.push('a');\n    /// s.push('b');\n    ///\n    /// // s now has a length of 2 and a capacity of 10\n    /// assert_eq!(2, s.len());\n    /// assert_eq!(10, s.capacity());\n    ///\n    /// // Since we already have an extra 8 capacity, calling this...\n    /// s.reserve_exact(8);\n    ///\n    /// // ... doesn't actually increase.\n    /// assert_eq!(10, s.capacity());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.vec.reserve_exact(additional)\n    }\n\n    /// Shrinks the capacity of this `String` to match its length.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// s.reserve(100);\n    /// assert!(s.capacity() >= 100);\n    ///\n    /// s.shrink_to_fit();\n    /// assert_eq!(3, s.capacity());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n        self.vec.shrink_to_fit()\n    }\n\n    /// Appends the given `char` to the end of this `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"abc\");\n    ///\n    /// s.push('1');\n    /// s.push('2');\n    /// s.push('3');\n    ///\n    /// assert_eq!(\"abc123\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push(&mut self, ch: char) {\n        match ch.len_utf8() {\n            1 => self.vec.push(ch as u8),\n            _ => self.vec.extend_from_slice(ch.encode_utf8(&mut [0; 4]).as_bytes()),\n        }\n    }\n\n    /// Returns a byte slice of this `String`'s contents.\n    ///\n    /// The inverse of this method is [`from_utf8`].\n    ///\n    /// [`from_utf8`]: #method.from_utf8\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::from(\"hello\");\n    ///\n    /// assert_eq!(&[104, 101, 108, 108, 111], s.as_bytes());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_bytes(&self) -> &[u8] {\n        &self.vec\n    }\n\n    /// Shortens this `String` to the specified length.\n    ///\n    /// If `new_len` is greater than the string's current length, this has no\n    /// effect.\n    ///\n    /// Note that this method has no effect on the allocated capacity\n    /// of the string\n    ///\n    /// # Panics\n    ///\n    /// Panics if `new_len` does not lie on a [`char`] boundary.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"hello\");\n    ///\n    /// s.truncate(2);\n    ///\n    /// assert_eq!(\"he\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn truncate(&mut self, new_len: usize) {\n        if new_len <= self.len() {\n            assert!(self.is_char_boundary(new_len));\n            self.vec.truncate(new_len)\n        }\n    }\n\n    /// Removes the last character from the string buffer and returns it.\n    ///\n    /// Returns `None` if this `String` is empty.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// assert_eq!(s.pop(), Some('o'));\n    /// assert_eq!(s.pop(), Some('o'));\n    /// assert_eq!(s.pop(), Some('f'));\n    ///\n    /// assert_eq!(s.pop(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop(&mut self) -> Option<char> {\n        let ch = match self.chars().rev().next() {\n            Some(ch) => ch,\n            None => return None,\n        };\n        let newlen = self.len() - ch.len_utf8();\n        unsafe {\n            self.vec.set_len(newlen);\n        }\n        Some(ch)\n    }\n\n    /// Removes a `char` from this `String` at a byte position and returns it.\n    ///\n    /// This is an `O(n)` operation, as it requires copying every element in the\n    /// buffer.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `idx` is larger than or equal to the `String`'s length,\n    /// or if it does not lie on a [`char`] boundary.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// assert_eq!(s.remove(0), 'f');\n    /// assert_eq!(s.remove(1), 'o');\n    /// assert_eq!(s.remove(0), 'o');\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove(&mut self, idx: usize) -> char {\n        let ch = match self[idx..].chars().next() {\n            Some(ch) => ch,\n            None => panic!(\"cannot remove a char from the end of a string\"),\n        };\n\n        let next = idx + ch.len_utf8();\n        let len = self.len();\n        unsafe {\n            ptr::copy(self.vec.as_ptr().offset(next as isize),\n                      self.vec.as_mut_ptr().offset(idx as isize),\n                      len - next);\n            self.vec.set_len(len - (next - idx));\n        }\n        ch\n    }\n\n    /// Inserts a character into this `String` at a byte position.\n    ///\n    /// This is an `O(n)` operation as it requires copying every element in the\n    /// buffer.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `idx` is larger than the `String`'s length, or if it does not\n    /// lie on a [`char`] boundary.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::with_capacity(3);\n    ///\n    /// s.insert(0, 'f');\n    /// s.insert(1, 'o');\n    /// s.insert(2, 'o');\n    ///\n    /// assert_eq!(\"foo\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, idx: usize, ch: char) {\n        assert!(self.is_char_boundary(idx));\n        let mut bits = [0; 4];\n        let bits = ch.encode_utf8(&mut bits).as_bytes();\n\n        unsafe {\n            self.insert_bytes(idx, bits);\n        }\n    }\n\n    unsafe fn insert_bytes(&mut self, idx: usize, bytes: &[u8]) {\n        let len = self.len();\n        let amt = bytes.len();\n        self.vec.reserve(amt);\n\n        ptr::copy(self.vec.as_ptr().offset(idx as isize),\n                  self.vec.as_mut_ptr().offset((idx + amt) as isize),\n                  len - idx);\n        ptr::copy(bytes.as_ptr(),\n                  self.vec.as_mut_ptr().offset(idx as isize),\n                  amt);\n        self.vec.set_len(len + amt);\n    }\n\n    /// Inserts a string slice into this `String` at a byte position.\n    ///\n    /// This is an `O(n)` operation as it requires copying every element in the\n    /// buffer.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `idx` is larger than the `String`'s length, or if it does not\n    /// lie on a [`char`] boundary.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"bar\");\n    ///\n    /// s.insert_str(0, \"foo\");\n    ///\n    /// assert_eq!(\"foobar\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"insert_str\", since = \"1.16.0\")]\n    pub fn insert_str(&mut self, idx: usize, string: &str) {\n        assert!(self.is_char_boundary(idx));\n\n        unsafe {\n            self.insert_bytes(idx, string.as_bytes());\n        }\n    }\n\n    /// Returns a mutable reference to the contents of this `String`.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because it does not check that the bytes passed\n    /// to it are valid UTF-8. If this constraint is violated, it may cause\n    /// memory unsafety issues with future users of the `String`, as the rest of\n    /// the standard library assumes that `String`s are valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"hello\");\n    ///\n    /// unsafe {\n    ///     let vec = s.as_mut_vec();\n    ///     assert_eq!(&[104, 101, 108, 108, 111][..], &vec[..]);\n    ///\n    ///     vec.reverse();\n    /// }\n    /// assert_eq!(s, \"olleh\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn as_mut_vec(&mut self) -> &mut Vec<u8> {\n        &mut self.vec\n    }\n\n    /// Returns the length of this `String`, in bytes.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = String::from(\"foo\");\n    ///\n    /// assert_eq!(a.len(), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n        self.vec.len()\n    }\n\n    /// Returns `true` if this `String` has a length of zero.\n    ///\n    /// Returns `false` otherwise.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut v = String::new();\n    /// assert!(v.is_empty());\n    ///\n    /// v.push('a');\n    /// assert!(!v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Splits the string into two at the given index.\n    ///\n    /// Returns a newly allocated `String`. `self` contains bytes `[0, at)`, and\n    /// the returned `String` contains bytes `[at, len)`. `at` must be on the\n    /// boundary of a UTF-8 code point.\n    ///\n    /// Note that the capacity of `self` does not change.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at` is not on a `UTF-8` code point boundary, or if it is beyond the last\n    /// code point of the string.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # fn main() {\n    /// let mut hello = String::from(\"Hello, World!\");\n    /// let world = hello.split_off(7);\n    /// assert_eq!(hello, \"Hello, \");\n    /// assert_eq!(world, \"World!\");\n    /// # }\n    /// ```\n    #[inline]\n    #[stable(feature = \"string_split_off\", since = \"1.16.0\")]\n    pub fn split_off(&mut self, at: usize) -> String {\n        assert!(self.is_char_boundary(at));\n        let other = self.vec.split_off(at);\n        unsafe { String::from_utf8_unchecked(other) }\n    }\n\n    /// Truncates this `String`, removing all contents.\n    ///\n    /// While this means the `String` will have a length of zero, it does not\n    /// touch its capacity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// s.clear();\n    ///\n    /// assert!(s.is_empty());\n    /// assert_eq!(0, s.len());\n    /// assert_eq!(3, s.capacity());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n        self.vec.clear()\n    }\n\n    /// Creates a draining iterator that removes the specified range in the string\n    /// and yields the removed chars.\n    ///\n    /// Note: The element range is removed even if the iterator is not\n    /// consumed until the end.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point or end point do not lie on a [`char`]\n    /// boundary, or if they're out of bounds.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\" is alpha,  is beta\");\n    /// let beta_offset = s.find('').unwrap_or(s.len());\n    ///\n    /// // Remove the range up until the  from the string\n    /// let t: String = s.drain(..beta_offset).collect();\n    /// assert_eq!(t, \" is alpha, \");\n    /// assert_eq!(s, \" is beta\");\n    ///\n    /// // A full range clears the string\n    /// s.drain(..);\n    /// assert_eq!(s, \"\");\n    /// ```\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain<R>(&mut self, range: R) -> Drain\n        where R: RangeArgument<usize>\n    {\n        // Memory safety\n        //\n        // The String version of Drain does not have the memory safety issues\n        // of the vector version. The data is just plain bytes.\n        // Because the range removal happens in Drop, if the Drain iterator is leaked,\n        // the removal will not happen.\n        let len = self.len();\n        let start = match range.start() {\n            Included(&n) => n,\n            Excluded(&n) => n + 1,\n            Unbounded => 0,\n        };\n        let end = match range.end() {\n            Included(&n) => n + 1,\n            Excluded(&n) => n,\n            Unbounded => len,\n        };\n\n        // Take out two simultaneous borrows. The &mut String won't be accessed\n        // until iteration is over, in Drop.\n        let self_ptr = self as *mut _;\n        // slicing does the appropriate bounds checks\n        let chars_iter = self[start..end].chars();\n\n        Drain {\n            start: start,\n            end: end,\n            iter: chars_iter,\n            string: self_ptr,\n        }\n    }\n\n    /// Creates a splicing iterator that removes the specified range in the string,\n    /// replaces with the given string, and yields the removed chars.\n    /// The given string doesnt need to be the same length as the range.\n    ///\n    /// Note: The element range is removed when the `Splice` is dropped,\n    /// even if the iterator is not consumed until the end.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point or end point do not lie on a [`char`]\n    /// boundary, or if they're out of bounds.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(splice)]\n    /// let mut s = String::from(\" is alpha,  is beta\");\n    /// let beta_offset = s.find('').unwrap_or(s.len());\n    ///\n    /// // Replace the range up until the  from the string\n    /// let t: String = s.splice(..beta_offset, \" is capital alpha; \").collect();\n    /// assert_eq!(t, \" is alpha, \");\n    /// assert_eq!(s, \" is capital alpha;  is beta\");\n    /// ```\n    #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n    pub fn splice<'a, 'b, R>(&'a mut self, range: R, replace_with: &'b str) -> Splice<'a, 'b>\n        where R: RangeArgument<usize>\n    {\n        // Memory safety\n        //\n        // The String version of Splice does not have the memory safety issues\n        // of the vector version. The data is just plain bytes.\n        // Because the range removal happens in Drop, if the Splice iterator is leaked,\n        // the removal will not happen.\n        let len = self.len();\n        let start = match range.start() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n             Unbounded => 0,\n        };\n        let end = match range.end() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n             Unbounded => len,\n        };\n\n        // Take out two simultaneous borrows. The &mut String won't be accessed\n        // until iteration is over, in Drop.\n        let self_ptr = self as *mut _;\n        // slicing does the appropriate bounds checks\n        let chars_iter = self[start..end].chars();\n\n        Splice {\n            start: start,\n            end: end,\n            iter: chars_iter,\n            string: self_ptr,\n            replace_with: replace_with\n        }\n    }\n\n    /// Converts this `String` into a `Box<str>`.\n    ///\n    /// This will drop any excess capacity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::from(\"hello\");\n    ///\n    /// let b = s.into_boxed_str();\n    /// ```\n    #[stable(feature = \"box_str\", since = \"1.4.0\")]\n    pub fn into_boxed_str(self) -> Box<str> {\n        let slice = self.vec.into_boxed_slice();\n        unsafe { from_boxed_utf8_unchecked(slice) }\n    }\n}\n\nimpl FromUtf8Error {\n    /// Returns a slice of [`u8`]s bytes that were attempted to convert to a `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(from_utf8_error_as_bytes)]\n    /// // some invalid bytes, in a vector\n    /// let bytes = vec![0, 159];\n    ///\n    /// let value = String::from_utf8(bytes);\n    ///\n    /// assert_eq!(&[0, 159], value.unwrap_err().as_bytes());\n    /// ```\n    #[unstable(feature = \"from_utf8_error_as_bytes\", reason = \"recently added\", issue = \"40895\")]\n    pub fn as_bytes(&self) -> &[u8] {\n        &self.bytes[..]\n    }\n\n    /// Returns the bytes that were attempted to convert to a `String`.\n    ///\n    /// This method is carefully constructed to avoid allocation. It will\n    /// consume the error, moving out the bytes, so that a copy of the bytes\n    /// does not need to be made.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some invalid bytes, in a vector\n    /// let bytes = vec![0, 159];\n    ///\n    /// let value = String::from_utf8(bytes);\n    ///\n    /// assert_eq!(vec![0, 159], value.unwrap_err().into_bytes());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_bytes(self) -> Vec<u8> {\n        self.bytes\n    }\n\n    /// Fetch a `Utf8Error` to get more details about the conversion failure.\n    ///\n    /// The [`Utf8Error`] type provided by [`std::str`] represents an error that may\n    /// occur when converting a slice of [`u8`]s to a [`&str`]. In this sense, it's\n    /// an analogue to `FromUtf8Error`. See its documentation for more details\n    /// on using it.\n    ///\n    /// [`Utf8Error`]: ../../std/str/struct.Utf8Error.html\n    /// [`std::str`]: ../../std/str/index.html\n    /// [`u8`]: ../../std/primitive.u8.html\n    /// [`&str`]: ../../std/primitive.str.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some invalid bytes, in a vector\n    /// let bytes = vec![0, 159];\n    ///\n    /// let error = String::from_utf8(bytes).unwrap_err().utf8_error();\n    ///\n    /// // the first byte is invalid here\n    /// assert_eq!(1, error.valid_up_to());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn utf8_error(&self) -> Utf8Error {\n        self.error\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for FromUtf8Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&self.error, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for FromUtf16Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(\"invalid utf-16: lone surrogate found\", f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for String {\n    fn clone(&self) -> Self {\n        String { vec: self.vec.clone() }\n    }\n\n    fn clone_from(&mut self, source: &Self) {\n        self.vec.clone_from(&source.vec);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromIterator<char> for String {\n    fn from_iter<I: IntoIterator<Item = char>>(iter: I) -> String {\n        let mut buf = String::new();\n        buf.extend(iter);\n        buf\n    }\n}\n\n#[stable(feature = \"string_from_iter_by_ref\", since = \"1.17.0\")]\nimpl<'a> FromIterator<&'a char> for String {\n    fn from_iter<I: IntoIterator<Item = &'a char>>(iter: I) -> String {\n        let mut buf = String::new();\n        buf.extend(iter);\n        buf\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> FromIterator<&'a str> for String {\n    fn from_iter<I: IntoIterator<Item = &'a str>>(iter: I) -> String {\n        let mut buf = String::new();\n        buf.extend(iter);\n        buf\n    }\n}\n\n#[stable(feature = \"extend_string\", since = \"1.4.0\")]\nimpl FromIterator<String> for String {\n    fn from_iter<I: IntoIterator<Item = String>>(iter: I) -> String {\n        let mut buf = String::new();\n        buf.extend(iter);\n        buf\n    }\n}\n\n#[stable(feature = \"herd_cows\", since = \"1.19.0\")]\nimpl<'a> FromIterator<Cow<'a, str>> for String {\n    fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> String {\n        let mut buf = String::new();\n        buf.extend(iter);\n        buf\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Extend<char> for String {\n    fn extend<I: IntoIterator<Item = char>>(&mut self, iter: I) {\n        let iterator = iter.into_iter();\n        let (lower_bound, _) = iterator.size_hint();\n        self.reserve(lower_bound);\n        for ch in iterator {\n            self.push(ch)\n        }\n    }\n}\n\n#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\nimpl<'a> Extend<&'a char> for String {\n    fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iter: I) {\n        self.extend(iter.into_iter().cloned());\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Extend<&'a str> for String {\n    fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I) {\n        for s in iter {\n            self.push_str(s)\n        }\n    }\n}\n\n#[stable(feature = \"extend_string\", since = \"1.4.0\")]\nimpl Extend<String> for String {\n    fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I) {\n        for s in iter {\n            self.push_str(&s)\n        }\n    }\n}\n\n#[stable(feature = \"herd_cows\", since = \"1.19.0\")]\nimpl<'a> Extend<Cow<'a, str>> for String {\n    fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I) {\n        for s in iter {\n            self.push_str(&s)\n        }\n    }\n}\n\n/// A convenience impl that delegates to the impl for `&str`\n#[unstable(feature = \"pattern\",\n           reason = \"API not fully fleshed out and ready to be stabilized\",\n           issue = \"27721\")]\nimpl<'a, 'b> Pattern<'a> for &'b String {\n    type Searcher = <&'b str as Pattern<'a>>::Searcher;\n\n    fn into_searcher(self, haystack: &'a str) -> <&'b str as Pattern<'a>>::Searcher {\n        self[..].into_searcher(haystack)\n    }\n\n    #[inline]\n    fn is_contained_in(self, haystack: &'a str) -> bool {\n        self[..].is_contained_in(haystack)\n    }\n\n    #[inline]\n    fn is_prefix_of(self, haystack: &'a str) -> bool {\n        self[..].is_prefix_of(haystack)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for String {\n    #[inline]\n    fn eq(&self, other: &String) -> bool {\n        PartialEq::eq(&self[..], &other[..])\n    }\n    #[inline]\n    fn ne(&self, other: &String) -> bool {\n        PartialEq::ne(&self[..], &other[..])\n    }\n}\n\nmacro_rules! impl_eq {\n    ($lhs:ty, $rhs: ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, 'b> PartialEq<$rhs> for $lhs {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&self[..], &other[..]) }\n            #[inline]\n            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&self[..], &other[..]) }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&self[..], &other[..]) }\n            #[inline]\n            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&self[..], &other[..]) }\n        }\n\n    }\n}\n\nimpl_eq! { String, str }\nimpl_eq! { String, &'a str }\nimpl_eq! { Cow<'a, str>, str }\nimpl_eq! { Cow<'a, str>, &'b str }\nimpl_eq! { Cow<'a, str>, String }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Default for String {\n    /// Creates an empty `String`.\n    #[inline]\n    fn default() -> String {\n        String::new()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for String {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for String {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl hash::Hash for String {\n    #[inline]\n    fn hash<H: hash::Hasher>(&self, hasher: &mut H) {\n        (**self).hash(hasher)\n    }\n}\n\n/// Implements the `+` operator for concatenating two strings.\n///\n/// This consumes the `String` on the left-hand side and re-uses its buffer (growing it if\n/// necessary). This is done to avoid allocating a new `String` and copying the entire contents on\n/// every operation, which would lead to `O(n^2)` running time when building an `n`-byte string by\n/// repeated concatenation.\n///\n/// The string on the right-hand side is only borrowed; its contents are copied into the returned\n/// `String`.\n///\n/// # Examples\n///\n/// Concatenating two `String`s takes the first by value and borrows the second:\n///\n/// ```\n/// let a = String::from(\"hello\");\n/// let b = String::from(\" world\");\n/// let c = a + &b;\n/// // `a` is moved and can no longer be used here.\n/// ```\n///\n/// If you want to keep using the first `String`, you can clone it and append to the clone instead:\n///\n/// ```\n/// let a = String::from(\"hello\");\n/// let b = String::from(\" world\");\n/// let c = a.clone() + &b;\n/// // `a` is still valid here.\n/// ```\n///\n/// Concatenating `&str` slices can be done by converting the first to a `String`:\n///\n/// ```\n/// let a = \"hello\";\n/// let b = \" world\";\n/// let c = a.to_string() + b;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Add<&'a str> for String {\n    type Output = String;\n\n    #[inline]\n    fn add(mut self, other: &str) -> String {\n        self.push_str(other);\n        self\n    }\n}\n\n/// Implements the `+=` operator for appending to a `String`.\n///\n/// This has the same behavior as the [`push_str`] method.\n///\n/// [`push_str`]: struct.String.html#method.push_str\n#[stable(feature = \"stringaddassign\", since = \"1.12.0\")]\nimpl<'a> AddAssign<&'a str> for String {\n    #[inline]\n    fn add_assign(&mut self, other: &str) {\n        self.push_str(other);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::Range<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::Range<usize>) -> &str {\n        &self[..][index]\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::RangeTo<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::RangeTo<usize>) -> &str {\n        &self[..][index]\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::RangeFrom<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n        &self[..][index]\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::RangeFull> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, _index: ops::RangeFull) -> &str {\n        unsafe { str::from_utf8_unchecked(&self.vec) }\n    }\n}\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl ops::Index<ops::RangeInclusive<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n        Index::index(&**self, index)\n    }\n}\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl ops::Index<ops::RangeToInclusive<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n        Index::index(&**self, index)\n    }\n}\n\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::IndexMut<ops::Range<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str {\n        &mut self[..][index]\n    }\n}\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::IndexMut<ops::RangeTo<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str {\n        &mut self[..][index]\n    }\n}\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::IndexMut<ops::RangeFrom<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str {\n        &mut self[..][index]\n    }\n}\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::IndexMut<ops::RangeFull> for String {\n    #[inline]\n    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut str {\n        unsafe { str::from_utf8_unchecked_mut(&mut *self.vec) }\n    }\n}\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl ops::IndexMut<ops::RangeInclusive<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl ops::IndexMut<ops::RangeToInclusive<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Deref for String {\n    type Target = str;\n\n    #[inline]\n    fn deref(&self) -> &str {\n        unsafe { str::from_utf8_unchecked(&self.vec) }\n    }\n}\n\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::DerefMut for String {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut str {\n        unsafe { str::from_utf8_unchecked_mut(&mut *self.vec) }\n    }\n}\n\n/// An error when parsing a `String`.\n///\n/// This `enum` is slightly awkward: it will never actually exist. This error is\n/// part of the type signature of the implementation of [`FromStr`] on\n/// [`String`]. The return type of [`from_str`], requires that an error be\n/// defined, but, given that a [`String`] can always be made into a new\n/// [`String`] without error, this type will never actually be returned. As\n/// such, it is only here to satisfy said signature, and is useless otherwise.\n///\n/// [`FromStr`]: ../../std/str/trait.FromStr.html\n/// [`String`]: struct.String.html\n/// [`from_str`]: ../../std/str/trait.FromStr.html#tymethod.from_str\n#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n#[derive(Copy)]\npub enum ParseError {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromStr for String {\n    type Err = ParseError;\n    #[inline]\n    fn from_str(s: &str) -> Result<String, ParseError> {\n        Ok(String::from(s))\n    }\n}\n\n#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\nimpl Clone for ParseError {\n    fn clone(&self) -> ParseError {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\nimpl fmt::Debug for ParseError {\n    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"str_parse_error2\", since = \"1.8.0\")]\nimpl fmt::Display for ParseError {\n    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\nimpl PartialEq for ParseError {\n    fn eq(&self, _: &ParseError) -> bool {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\nimpl Eq for ParseError {}\n\n/// A trait for converting a value to a `String`.\n///\n/// This trait is automatically implemented for any type which implements the\n/// [`Display`] trait. As such, `ToString` shouldn't be implemented directly:\n/// [`Display`] should be implemented instead, and you get the `ToString`\n/// implementation for free.\n///\n/// [`Display`]: ../../std/fmt/trait.Display.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait ToString {\n    /// Converts the given value to a `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let i = 5;\n    /// let five = String::from(\"5\");\n    ///\n    /// assert_eq!(five, i.to_string());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn to_string(&self) -> String;\n}\n\n/// # Panics\n///\n/// In this implementation, the `to_string` method panics\n/// if the `Display` implementation returns an error.\n/// This indicates an incorrect `Display` implementation\n/// since `fmt::Write for String` never returns an error itself.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Display + ?Sized> ToString for T {\n    #[inline]\n    default fn to_string(&self) -> String {\n        use core::fmt::Write;\n        let mut buf = String::new();\n        buf.write_fmt(format_args!(\"{}\", self))\n           .expect(\"a Display implementation return an error unexpectedly\");\n        buf.shrink_to_fit();\n        buf\n    }\n}\n\n#[stable(feature = \"str_to_string_specialization\", since = \"1.9.0\")]\nimpl ToString for str {\n    #[inline]\n    fn to_string(&self) -> String {\n        String::from(self)\n    }\n}\n\n#[stable(feature = \"cow_str_to_string_specialization\", since = \"1.17.0\")]\nimpl<'a> ToString for Cow<'a, str> {\n    #[inline]\n    fn to_string(&self) -> String {\n        self[..].to_owned()\n    }\n}\n\n#[stable(feature = \"string_to_string_specialization\", since = \"1.17.0\")]\nimpl ToString for String {\n    #[inline]\n    fn to_string(&self) -> String {\n        self.to_owned()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<str> for String {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<[u8]> for String {\n    #[inline]\n    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<&'a str> for String {\n    fn from(s: &'a str) -> String {\n        s.to_owned()\n    }\n}\n\n// note: test pulls in libstd, which causes errors here\n#[cfg(not(test))]\n#[stable(feature = \"string_from_box\", since = \"1.18.0\")]\nimpl From<Box<str>> for String {\n    fn from(s: Box<str>) -> String {\n        s.into_string()\n    }\n}\n\n#[stable(feature = \"box_from_str\", since = \"1.20.0\")]\nimpl From<String> for Box<str> {\n    fn from(s: String) -> Box<str> {\n        s.into_boxed_str()\n    }\n}\n\n#[stable(feature = \"string_from_cow_str\", since = \"1.14.0\")]\nimpl<'a> From<Cow<'a, str>> for String {\n    fn from(s: Cow<'a, str>) -> String {\n        s.into_owned()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<&'a str> for Cow<'a, str> {\n    #[inline]\n    fn from(s: &'a str) -> Cow<'a, str> {\n        Cow::Borrowed(s)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<String> for Cow<'a, str> {\n    #[inline]\n    fn from(s: String) -> Cow<'a, str> {\n        Cow::Owned(s)\n    }\n}\n\n#[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\nimpl<'a> FromIterator<char> for Cow<'a, str> {\n    fn from_iter<I: IntoIterator<Item = char>>(it: I) -> Cow<'a, str> {\n        Cow::Owned(FromIterator::from_iter(it))\n    }\n}\n\n#[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\nimpl<'a, 'b> FromIterator<&'b str> for Cow<'a, str> {\n    fn from_iter<I: IntoIterator<Item = &'b str>>(it: I) -> Cow<'a, str> {\n        Cow::Owned(FromIterator::from_iter(it))\n    }\n}\n\n#[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\nimpl<'a> FromIterator<String> for Cow<'a, str> {\n    fn from_iter<I: IntoIterator<Item = String>>(it: I) -> Cow<'a, str> {\n        Cow::Owned(FromIterator::from_iter(it))\n    }\n}\n\n#[stable(feature = \"from_string_for_vec_u8\", since = \"1.14.0\")]\nimpl From<String> for Vec<u8> {\n    fn from(string: String) -> Vec<u8> {\n        string.into_bytes()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Write for String {\n    #[inline]\n    fn write_str(&mut self, s: &str) -> fmt::Result {\n        self.push_str(s);\n        Ok(())\n    }\n\n    #[inline]\n    fn write_char(&mut self, c: char) -> fmt::Result {\n        self.push(c);\n        Ok(())\n    }\n}\n\n/// A draining iterator for `String`.\n///\n/// This struct is created by the [`drain`] method on [`String`]. See its\n/// documentation for more.\n///\n/// [`drain`]: struct.String.html#method.drain\n/// [`String`]: struct.String.html\n#[stable(feature = \"drain\", since = \"1.6.0\")]\npub struct Drain<'a> {\n    /// Will be used as &'a mut String in the destructor\n    string: *mut String,\n    /// Start of part to remove\n    start: usize,\n    /// End of part to remove\n    end: usize,\n    /// Current remaining range to remove\n    iter: Chars<'a>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<'a> fmt::Debug for Drain<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"Drain { .. }\")\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl<'a> Sync for Drain<'a> {}\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl<'a> Send for Drain<'a> {}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a> Drop for Drain<'a> {\n    fn drop(&mut self) {\n        unsafe {\n            // Use Vec::drain. \"Reaffirm\" the bounds checks to avoid\n            // panic code being inserted again.\n            let self_vec = (*self.string).as_mut_vec();\n            if self.start <= self.end && self.end <= self_vec.len() {\n                self_vec.drain(self.start..self.end);\n            }\n        }\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a> Iterator for Drain<'a> {\n    type Item = char;\n\n    #[inline]\n    fn next(&mut self) -> Option<char> {\n        self.iter.next()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a> DoubleEndedIterator for Drain<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<char> {\n        self.iter.next_back()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a> FusedIterator for Drain<'a> {}\n\n/// A splicing iterator for `String`.\n///\n/// This struct is created by the [`splice()`] method on [`String`]. See its\n/// documentation for more.\n///\n/// [`splice()`]: struct.String.html#method.splice\n/// [`String`]: struct.String.html\n#[derive(Debug)]\n#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\npub struct Splice<'a, 'b> {\n    /// Will be used as &'a mut String in the destructor\n    string: *mut String,\n    /// Start of part to remove\n    start: usize,\n    /// End of part to remove\n    end: usize,\n    /// Current remaining range to remove\n    iter: Chars<'a>,\n    replace_with: &'b str,\n}\n\n#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\nunsafe impl<'a, 'b> Sync for Splice<'a, 'b> {}\n#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\nunsafe impl<'a, 'b> Send for Splice<'a, 'b> {}\n\n#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\nimpl<'a, 'b> Drop for Splice<'a, 'b> {\n    fn drop(&mut self) {\n        unsafe {\n            let vec = (*self.string).as_mut_vec();\n            vec.splice(self.start..self.end, self.replace_with.bytes());\n        }\n    }\n}\n\n#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\nimpl<'a, 'b> Iterator for Splice<'a, 'b> {\n    type Item = char;\n\n    #[inline]\n    fn next(&mut self) -> Option<char> {\n        self.iter.next()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\nimpl<'a, 'b> DoubleEndedIterator for Splice<'a, 'b> {\n    #[inline]\n    fn next_back(&mut self) -> Option<char> {\n        self.iter.next_back()\n    }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![unstable(feature = \"allocator_api\",\n            reason = \"the precise API and guarantees it provides may be tweaked \\\n                      slightly, especially to possibly take into account the \\\n                      types being stored to make room for a future \\\n                      tracing garbage collector\",\n            issue = \"27700\")]\n\nuse core::cmp;\nuse core::fmt;\nuse core::mem;\nuse core::usize;\nuse core::ptr::{self, Unique};\n\n/// Represents the combination of a starting address and\n/// a total capacity of the returned block.\n#[derive(Debug)]\npub struct Excess(pub *mut u8, pub usize);\n\nfn size_align<T>() -> (usize, usize) {\n    (mem::size_of::<T>(), mem::align_of::<T>())\n}\n\n/// Layout of a block of memory.\n///\n/// An instance of `Layout` describes a particular layout of memory.\n/// You build a `Layout` up as an input to give to an allocator.\n///\n/// All layouts have an associated non-negative size and a\n/// power-of-two alignment.\n///\n/// (Note however that layouts are *not* required to have positive\n/// size, even though many allocators require that all memory\n/// requeusts have positive size. A caller to the `Alloc::alloc`\n/// method must either ensure that conditions like this are met, or\n/// use specific allocators with looser requirements.)\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Layout {\n    // size of the requested block of memory, measured in bytes.\n    size: usize,\n\n    // alignment of the requested block of memory, measured in bytes.\n    // we ensure that this is always a power-of-two, because API's\n    // like `posix_memalign` require it and it is a reasonable\n    // constraint to impose on Layout constructors.\n    //\n    // (However, we do not analogously require `align >= sizeof(void*)`,\n    //  even though that is *also* a requirement of `posix_memalign`.)\n    align: usize,\n}\n\n\n// FIXME: audit default implementations for overflow errors,\n// (potentially switching to overflowing_add and\n//  overflowing_mul as necessary).\n\nimpl Layout {\n    /// Constructs a `Layout` from a given `size` and `align`,\n    /// or returns `None` if either of the following conditions\n    /// are not met:\n    ///\n    /// * `align` must be a power of two,\n    ///\n    /// * `size`, when rounded up to the nearest multiple of `align`,\n    ///    must not overflow (i.e. the rounded value must be less than\n    ///    `usize::MAX`).\n    pub fn from_size_align(size: usize, align: usize) -> Option<Layout> {\n        if !align.is_power_of_two() {\n            return None;\n        }\n\n        // (power-of-two implies align != 0.)\n\n        // Rounded up size is:\n        //   size_rounded_up = (size + align - 1) & !(align - 1);\n        //\n        // We know from above that align != 0. If adding (align - 1)\n        // does not overflow, then rounding up will be fine.\n        //\n        // Conversely, &-masking with !(align - 1) will subtract off\n        // only low-order-bits. Thus if overflow occurs with the sum,\n        // the &-mask cannot subtract enough to undo that overflow.\n        //\n        // Above implies that checking for summation overflow is both\n        // necessary and sufficient.\n        if size > usize::MAX - (align - 1) {\n            return None;\n        }\n\n        Some(Layout { size: size, align: align })\n    }\n\n    /// The minimum size in bytes for a memory block of this layout.\n    pub fn size(&self) -> usize { self.size }\n\n    /// The minimum byte alignment for a memory block of this layout.\n    pub fn align(&self) -> usize { self.align }\n\n    /// Constructs a `Layout` suitable for holding a value of type `T`.\n    pub fn new<T>() -> Self {\n        let (size, align) = size_align::<T>();\n        Layout::from_size_align(size, align).unwrap()\n    }\n\n    /// Produces layout describing a record that could be used to\n    /// allocate backing structure for `T` (which could be a trait\n    /// or other unsized type like a slice).\n    pub fn for_value<T: ?Sized>(t: &T) -> Self {\n        let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n        Layout::from_size_align(size, align).unwrap()\n    }\n\n    /// Creates a layout describing the record that can hold a value\n    /// of the same layout as `self`, but that also is aligned to\n    /// alignment `align` (measured in bytes).\n    ///\n    /// If `self` already meets the prescribed alignment, then returns\n    /// `self`.\n    ///\n    /// Note that this method does not add any padding to the overall\n    /// size, regardless of whether the returned layout has a different\n    /// alignment. In other words, if `K` has size 16, `K.align_to(32)`\n    /// will *still* have size 16.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the combination of `self.size` and the given `align`\n    /// violates the conditions listed in `from_size_align`.\n    pub fn align_to(&self, align: usize) -> Self {\n        Layout::from_size_align(self.size, cmp::max(self.align, align)).unwrap()\n    }\n\n    /// Returns the amount of padding we must insert after `self`\n    /// to ensure that the following address will satisfy `align`\n    /// (measured in bytes).\n    ///\n    /// E.g. if `self.size` is 9, then `self.padding_needed_for(4)`\n    /// returns 3, because that is the minimum number of bytes of\n    /// padding required to get a 4-aligned address (assuming that the\n    /// corresponding memory block starts at a 4-aligned address).\n    ///\n    /// The return value of this function has no meaning if `align` is\n    /// not a power-of-two.\n    ///\n    /// Note that the utility of the returned value requires `align`\n    /// to be less than or equal to the alignment of the starting\n    /// address for the whole allocated block of memory. One way to\n    /// satisfy this constraint is to ensure `align <= self.align`.\n    pub fn padding_needed_for(&self, align: usize) -> usize {\n        let len = self.size();\n\n        // Rounded up value is:\n        //   len_rounded_up = (len + align - 1) & !(align - 1);\n        // and then we return the padding difference: `len_rounded_up - len`.\n        //\n        // We use modular arithmetic throughout:\n        //\n        // 1. align is guaranteed to be > 0, so align - 1 is always\n        //    valid.\n        //\n        // 2. `len + align - 1` can overflow by at most `align - 1`,\n        //    so the &-mask wth `!(align - 1)` will ensure that in the\n        //    case of overflow, `len_rounded_up` will itself be 0.\n        //    Thus the returned padding, when added to `len`, yields 0,\n        //    which trivially satisfies the alignment `align`.\n        //\n        // (Of course, attempts to allocate blocks of memory whose\n        // size and padding overflow in the above manner should cause\n        // the allocator to yield an error anyway.)\n\n        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);\n        return len_rounded_up.wrapping_sub(len);\n    }\n\n    /// Creates a layout describing the record for `n` instances of\n    /// `self`, with a suitable amount of padding between each to\n    /// ensure that each instance is given its requested size and\n    /// alignment. On success, returns `(k, offs)` where `k` is the\n    /// layout of the array and `offs` is the distance between the start\n    /// of each element in the array.\n    ///\n    /// On arithmetic overflow, returns `None`.\n    pub fn repeat(&self, n: usize) -> Option<(Self, usize)> {\n        let padded_size = match self.size.checked_add(self.padding_needed_for(self.align)) {\n            None => return None,\n            Some(padded_size) => padded_size,\n        };\n        let alloc_size = match padded_size.checked_mul(n) {\n            None => return None,\n            Some(alloc_size) => alloc_size,\n        };\n\n        // We can assume that `self.align` is a power-of-two.\n        // Furthermore, `alloc_size` has alreayd been rounded up\n        // to a multiple of `self.align`; therefore, the call\n        // to `Layout::from_size_align` below should never panic.\n        Some((Layout::from_size_align(alloc_size, self.align).unwrap(), padded_size))\n    }\n\n    /// Creates a layout describing the record for `self` followed by\n    /// `next`, including any necessary padding to ensure that `next`\n    /// will be properly aligned. Note that the result layout will\n    /// satisfy the alignment properties of both `self` and `next`.\n    ///\n    /// Returns `Some((k, offset))`, where `k` is layout of the concatenated\n    /// record and `offset` is the relative location, in bytes, of the\n    /// start of the `next` embedded witnin the concatenated record\n    /// (assuming that the record itself starts at offset 0).\n    ///\n    /// On arithmetic overflow, returns `None`.\n    pub fn extend(&self, next: Self) -> Option<(Self, usize)> {\n        let new_align = cmp::max(self.align, next.align);\n        let realigned = match Layout::from_size_align(self.size, new_align) {\n            None => return None,\n            Some(l) => l,\n        };\n\n        let pad = realigned.padding_needed_for(next.align);\n\n        let offset = match self.size.checked_add(pad) {\n            None => return None,\n            Some(offset) => offset,\n        };\n        let new_size = match offset.checked_add(next.size) {\n            None => return None,\n            Some(new_size) => new_size,\n        };\n\n        let layout = match Layout::from_size_align(new_size, new_align) {\n            None => return None,\n            Some(l) => l,\n        };\n        Some((layout, offset))\n    }\n\n    /// Creates a layout describing the record for `n` instances of\n    /// `self`, with no padding between each instance.\n    ///\n    /// Note that, unlike `repeat`, `repeat_packed` does not guarantee\n    /// that the repeated instances of `self` will be properly\n    /// aligned, even if a given instance of `self` is properly\n    /// aligned. In other words, if the layout returned by\n    /// `repeat_packed` is used to allocate an array, it is not\n    /// guaranteed that all elements in the array will be properly\n    /// aligned.\n    ///\n    /// On arithmetic overflow, returns `None`.\n    pub fn repeat_packed(&self, n: usize) -> Option<Self> {\n        let size = match self.size().checked_mul(n) {\n            None => return None,\n            Some(scaled) => scaled,\n        };\n\n        Layout::from_size_align(size, self.align)\n    }\n\n    /// Creates a layout describing the record for `self` followed by\n    /// `next` with no additional padding between the two. Since no\n    /// padding is inserted, the alignment of `next` is irrelevant,\n    /// and is not incoporated *at all* into the resulting layout.\n    ///\n    /// Returns `(k, offset)`, where `k` is layout of the concatenated\n    /// record and `offset` is the relative location, in bytes, of the\n    /// start of the `next` embedded witnin the concatenated record\n    /// (assuming that the record itself starts at offset 0).\n    ///\n    /// (The `offset` is always the same as `self.size()`; we use this\n    ///  signature out of convenience in matching the signature of\n    ///  `extend`.)\n    ///\n    /// On arithmetic overflow, returns `None`.\n    pub fn extend_packed(&self, next: Self) -> Option<(Self, usize)> {\n        let new_size = match self.size().checked_add(next.size()) {\n            None => return None,\n            Some(new_size) => new_size,\n        };\n        let layout = match Layout::from_size_align(new_size, self.align) {\n            None => return None,\n            Some(l) => l,\n        };\n        Some((layout, self.size()))\n    }\n\n    /// Creates a layout describing the record for a `[T; n]`.\n    ///\n    /// On arithmetic overflow, returns `None`.\n    pub fn array<T>(n: usize) -> Option<Self> {\n        Layout::new::<T>()\n            .repeat(n)\n            .map(|(k, offs)| {\n                debug_assert!(offs == mem::size_of::<T>());\n                k\n            })\n    }\n}\n\n/// The `AllocErr` error specifies whether an allocation failure is\n/// specifically due to resource exhaustion or if it is due to\n/// something wrong when combining the given input arguments with this\n/// allocator.\n#[derive(Clone, PartialEq, Eq, Debug)]\npub enum AllocErr {\n    /// Error due to hitting some resource limit or otherwise running\n    /// out of memory. This condition strongly implies that *some*\n    /// series of deallocations would allow a subsequent reissuing of\n    /// the original allocation request to succeed.\n    Exhausted { request: Layout },\n\n    /// Error due to allocator being fundamentally incapable of\n    /// satisfying the original request. This condition implies that\n    /// such an allocation request will never succeed on the given\n    /// allocator, regardless of environment, memory pressure, or\n    /// other contextual conditions.\n    ///\n    /// For example, an allocator that does not support requests for\n    /// large memory blocks might return this error variant.\n    Unsupported { details: &'static str },\n}\n\nimpl AllocErr {\n    pub fn invalid_input(details: &'static str) -> Self {\n        AllocErr::Unsupported { details: details }\n    }\n    pub fn is_memory_exhausted(&self) -> bool {\n        if let AllocErr::Exhausted { .. } = *self { true } else { false }\n    }\n    pub fn is_request_unsupported(&self) -> bool {\n        if let AllocErr::Unsupported { .. } = *self { true } else { false }\n    }\n    pub fn description(&self) -> &str {\n        match *self {\n            AllocErr::Exhausted { .. } => \"allocator memory exhausted\",\n            AllocErr::Unsupported { .. } => \"unsupported allocator request\",\n        }\n    }\n}\n\n// (we need this for downstream impl of trait Error)\nimpl fmt::Display for AllocErr {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.description())\n    }\n}\n\n/// The `CannotReallocInPlace` error is used when `grow_in_place` or\n/// `shrink_in_place` were unable to reuse the given memory block for\n/// a requested layout.\n#[derive(Clone, PartialEq, Eq, Debug)]\npub struct CannotReallocInPlace;\n\nimpl CannotReallocInPlace {\n    pub fn description(&self) -> &str {\n        \"cannot reallocate allocator's memory in place\"\n    }\n}\n\n// (we need this for downstream impl of trait Error)\nimpl fmt::Display for CannotReallocInPlace {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.description())\n    }\n}\n\n/// An implementation of `Alloc` can allocate, reallocate, and\n/// deallocate arbitrary blocks of data described via `Layout`.\n///\n/// Some of the methods require that a memory block be *currently\n/// allocated* via an allocator. This means that:\n///\n/// * the starting address for that memory block was previously\n///   returned by a previous call to an allocation method (`alloc`,\n///   `alloc_zeroed`, `alloc_excess`, `alloc_one`, `alloc_array`) or\n///   reallocation method (`realloc`, `realloc_excess`, or\n///   `realloc_array`), and\n///\n/// * the memory block has not been subsequently deallocated, where\n///   blocks are deallocated either by being passed to a deallocation\n///   method (`dealloc`, `dealloc_one`, `dealloc_array`) or by being\n///   passed to a reallocation method (see above) that returns `Ok`.\n///\n/// A note regarding zero-sized types and zero-sized layouts: many\n/// methods in the `Alloc` trait state that allocation requests\n/// must be non-zero size, or else undefined behavior can result.\n///\n/// * However, some higher-level allocation methods (`alloc_one`,\n///   `alloc_array`) are well-defined on zero-sized types and can\n///   optionally support them: it is left up to the implementor\n///   whether to return `Err`, or to return `Ok` with some pointer.\n///\n/// * If an `Alloc` implementation chooses to return `Ok` in this\n///   case (i.e. the pointer denotes a zero-sized inaccessible block)\n///   then that returned pointer must be considered \"currently\n///   allocated\". On such an allocator, *all* methods that take\n///   currently-allocated pointers as inputs must accept these\n///   zero-sized pointers, *without* causing undefined behavior.\n///\n/// * In other words, if a zero-sized pointer can flow out of an\n///   allocator, then that allocator must likewise accept that pointer\n///   flowing back into its deallocation and reallocation methods.\n///\n/// Some of the methods require that a layout *fit* a memory block.\n/// What it means for a layout to \"fit\" a memory block means (or\n/// equivalently, for a memory block to \"fit\" a layout) is that the\n/// following two conditions must hold:\n///\n/// 1. The block's starting address must be aligned to `layout.align()`.\n///\n/// 2. The block's size must fall in the range `[use_min, use_max]`, where:\n///\n///    * `use_min` is `self.usable_size(layout).0`, and\n///\n///    * `use_max` is the capacity that was (or would have been)\n///      returned when (if) the block was allocated via a call to\n///      `alloc_excess` or `realloc_excess`.\n///\n/// Note that:\n///\n///  * the size of the layout most recently used to allocate the block\n///    is guaranteed to be in the range `[use_min, use_max]`, and\n///\n///  * a lower-bound on `use_max` can be safely approximated by a call to\n///    `usable_size`.\n///\n///  * if a layout `k` fits a memory block (denoted by `ptr`)\n///    currently allocated via an allocator `a`, then it is legal to\n///    use that layout to deallocate it, i.e. `a.dealloc(ptr, k);`.\npub unsafe trait Alloc {\n\n    // (Note: existing allocators have unspecified but well-defined\n    // behavior in response to a zero size allocation request ;\n    // e.g. in C, `malloc` of 0 will either return a null pointer or a\n    // unique pointer, but will not have arbitrary undefined\n    // behavior. Rust should consider revising the alloc::heap crate\n    // to reflect this reality.)\n\n    /// Returns a pointer meeting the size and alignment guarantees of\n    /// `layout`.\n    ///\n    /// If this method returns an `Ok(addr)`, then the `addr` returned\n    /// will be non-null address pointing to a block of storage\n    /// suitable for holding an instance of `layout`.\n    ///\n    /// The returned block of storage may or may not have its contents\n    /// initialized. (Extension subtraits might restrict this\n    /// behavior, e.g. to ensure initialization to particular sets of\n    /// bit patterns.)\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure that `layout` has non-zero size.\n    ///\n    /// (Extension subtraits might provide more specific bounds on\n    /// behavior, e.g. guarantee a sentinel address or a null pointer\n    /// in response to a zero-size allocation request.)\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `layout` does not meet allocator's size or alignment\n    /// constraints.\n    ///\n    /// Implementations are encouraged to return `Err` on memory\n    /// exhaustion rather than panicking or aborting, but this is not\n    /// a strict requirement. (Specifically: it is *legal* to\n    /// implement this trait atop an underlying native allocation\n    /// library that aborts on memory exhaustion.)\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// allocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr>;\n\n    /// Deallocate the memory referenced by `ptr`.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure all of the following:\n    ///\n    /// * `ptr` must denote a block of memory currently allocated via\n    ///   this allocator,\n    ///\n    /// * `layout` must *fit* that block of memory,\n    ///\n    /// * In addition to fitting the block of memory `layout`, the\n    ///   alignment of the `layout` must match the alignment used\n    ///   to allocate that block of memory.\n    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout);\n\n    /// Allocator-specific method for signalling an out-of-memory\n    /// condition.\n    ///\n    /// `oom` aborts the thread or process, optionally performing\n    /// cleanup or logging diagnostic information before panicking or\n    /// aborting.\n    ///\n    /// `oom` is meant to be used by clients unable to cope with an\n    /// unsatisfied allocation request (signaled by an error such as\n    /// `AllocErr::Exhausted`), and wish to abandon computation rather\n    /// than attempt to recover locally. Such clients should pass the\n    /// signalling error value back into `oom`, where the allocator\n    /// may incorporate that error value into its diagnostic report\n    /// before aborting.\n    ///\n    /// Implementations of the `oom` method are discouraged from\n    /// infinitely regressing in nested calls to `oom`. In\n    /// practice this means implementors should eschew allocating,\n    /// especially from `self` (directly or indirectly).\n    ///\n    /// Implementions of the allocation and reallocation methods\n    /// (e.g. `alloc`, `alloc_one`, `realloc`) are discouraged from\n    /// panicking (or aborting) in the event of memory exhaustion;\n    /// instead they should return an appropriate error from the\n    /// invoked method, and let the client decide whether to invoke\n    /// this `oom` method in response.\n    fn oom(&mut self, _: AllocErr) -> ! {\n        unsafe { ::core::intrinsics::abort() }\n    }\n\n    // == ALLOCATOR-SPECIFIC QUANTITIES AND LIMITS ==\n    // usable_size\n\n    /// Returns bounds on the guaranteed usable size of a successful\n    /// allocation created with the specified `layout`.\n    ///\n    /// In particular, if one has a memory block allocated via a given\n    /// allocator `a` and layout `k` where `a.usable_size(k)` returns\n    /// `(l, u)`, then one can pass that block to `a.dealloc()` with a\n    /// layout in the size range [l, u].\n    ///\n    /// (All implementors of `usable_size` must ensure that\n    /// `l <= k.size() <= u`)\n    ///\n    /// Both the lower- and upper-bounds (`l` and `u` respectively)\n    /// are provided, because an allocator based on size classes could\n    /// misbehave if one attempts to deallocate a block without\n    /// providing a correct value for its size (i.e., one within the\n    /// range `[l, u]`).\n    ///\n    /// Clients who wish to make use of excess capacity are encouraged\n    /// to use the `alloc_excess` and `realloc_excess` instead, as\n    /// this method is constrained to report conservative values that\n    /// serve as valid bounds for *all possible* allocation method\n    /// calls.\n    ///\n    /// However, for clients that do not wish to track the capacity\n    /// returned by `alloc_excess` locally, this method is likely to\n    /// produce useful results.\n    fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n        (layout.size(), layout.size())\n    }\n\n    // == METHODS FOR MEMORY REUSE ==\n    // realloc. alloc_excess, realloc_excess\n\n    /// Returns a pointer suitable for holding data described by\n    /// `new_layout`, meeting its size and alignment guarantees. To\n    /// accomplish this, this may extend or shrink the allocation\n    /// referenced by `ptr` to fit `new_layout`.\n    ///\n    /// If this returns `Ok`, then ownership of the memory block\n    /// referenced by `ptr` has been transferred to this\n    /// allocator. The memory may or may not have been freed, and\n    /// should be considered unusable (unless of course it was\n    /// transferred back to the caller again via the return value of\n    /// this method).\n    ///\n    /// If this method returns `Err`, then ownership of the memory\n    /// block has not been transferred to this allocator, and the\n    /// contents of the memory block are unaltered.\n    ///\n    /// For best results, `new_layout` should not impose a different\n    /// alignment constraint than `layout`. (In other words,\n    /// `new_layout.align()` should equal `layout.align()`.) However,\n    /// behavior is well-defined (though underspecified) when this\n    /// constraint is violated; further discussion below.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure all of the following:\n    ///\n    /// * `ptr` must be currently allocated via this allocator,\n    ///\n    /// * `layout` must *fit* the `ptr` (see above). (The `new_layout`\n    ///   argument need not fit it.)\n    ///\n    /// * `new_layout` must have size greater than zero.\n    ///\n    /// * the alignment of `new_layout` is non-zero.\n    ///\n    /// (Extension subtraits might provide more specific bounds on\n    /// behavior, e.g. guarantee a sentinel address or a null pointer\n    /// in response to a zero-size allocation request.)\n    ///\n    /// # Errors\n    ///\n    /// Returns `Err` only if `new_layout` does not match the\n    /// alignment of `layout`, or does not meet the allocator's size\n    /// and alignment constraints of the allocator, or if reallocation\n    /// otherwise fails.\n    ///\n    /// (Note the previous sentence did not say \"if and only if\" -- in\n    /// particular, an implementation of this method *can* return `Ok`\n    /// if `new_layout.align() != old_layout.align()`; or it can\n    /// return `Err` in that scenario, depending on whether this\n    /// allocator can dynamically adjust the alignment constraint for\n    /// the block.)\n    ///\n    /// Implementations are encouraged to return `Err` on memory\n    /// exhaustion rather than panicking or aborting, but this is not\n    /// a strict requirement. (Specifically: it is *legal* to\n    /// implement this trait atop an underlying native allocation\n    /// library that aborts on memory exhaustion.)\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// reallocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    unsafe fn realloc(&mut self,\n                      ptr: *mut u8,\n                      layout: Layout,\n                      new_layout: Layout) -> Result<*mut u8, AllocErr> {\n        let new_size = new_layout.size();\n        let old_size = layout.size();\n        let aligns_match = layout.align == new_layout.align;\n\n        if new_size >= old_size && aligns_match {\n            if let Ok(()) = self.grow_in_place(ptr, layout.clone(), new_layout.clone()) {\n                return Ok(ptr);\n            }\n        } else if new_size < old_size && aligns_match {\n            if let Ok(()) = self.shrink_in_place(ptr, layout.clone(), new_layout.clone()) {\n                return Ok(ptr);\n            }\n        }\n\n        // otherwise, fall back on alloc + copy + dealloc.\n        let result = self.alloc(new_layout);\n        if let Ok(new_ptr) = result {\n            ptr::copy_nonoverlapping(ptr as *const u8, new_ptr, cmp::min(old_size, new_size));\n            self.dealloc(ptr, layout);\n        }\n        result\n    }\n\n    /// Behaves like `alloc`, but also ensures that the contents\n    /// are set to zero before being returned.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe for the same reasons that `alloc` is.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `layout` does not meet allocator's size or alignment\n    /// constraints, just as in `alloc`.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// allocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n        let size = layout.size();\n        let p = self.alloc(layout);\n        if let Ok(p) = p {\n            ptr::write_bytes(p, 0, size);\n        }\n        p\n    }\n\n    /// Behaves like `alloc`, but also returns the whole size of\n    /// the returned block. For some `layout` inputs, like arrays, this\n    /// may include extra storage usable for additional data.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe for the same reasons that `alloc` is.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `layout` does not meet allocator's size or alignment\n    /// constraints, just as in `alloc`.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// allocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n        let usable_size = self.usable_size(&layout);\n        self.alloc(layout).map(|p| Excess(p, usable_size.1))\n    }\n\n    /// Behaves like `realloc`, but also returns the whole size of\n    /// the returned block. For some `layout` inputs, like arrays, this\n    /// may include extra storage usable for additional data.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe for the same reasons that `realloc` is.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `layout` does not meet allocator's size or alignment\n    /// constraints, just as in `realloc`.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// reallocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    unsafe fn realloc_excess(&mut self,\n                             ptr: *mut u8,\n                             layout: Layout,\n                             new_layout: Layout) -> Result<Excess, AllocErr> {\n        let usable_size = self.usable_size(&new_layout);\n        self.realloc(ptr, layout, new_layout)\n            .map(|p| Excess(p, usable_size.1))\n    }\n\n    /// Attempts to extend the allocation referenced by `ptr` to fit `new_layout`.\n    ///\n    /// If this returns `Ok`, then the allocator has asserted that the\n    /// memory block referenced by `ptr` now fits `new_layout`, and thus can\n    /// be used to carry data of that layout. (The allocator is allowed to\n    /// expend effort to accomplish this, such as extending the memory block to\n    /// include successor blocks, or virtual memory tricks.)\n    ///\n    /// Regardless of what this method returns, ownership of the\n    /// memory block referenced by `ptr` has not been transferred, and\n    /// the contents of the memory block are unaltered.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure all of the following:\n    ///\n    /// * `ptr` must be currently allocated via this allocator,\n    ///\n    /// * `layout` must *fit* the `ptr` (see above); note the\n    ///   `new_layout` argument need not fit it,\n    ///\n    /// * `new_layout.size()` must not be less than `layout.size()`,\n    ///\n    /// * `new_layout.align()` must equal `layout.align()`.\n    ///\n    /// # Errors\n    ///\n    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n    /// unable to assert that the memory block referenced by `ptr`\n    /// could fit `layout`.\n    ///\n    /// Note that one cannot pass `CannotReallocInPlace` to the `oom`\n    /// method; clients are expected either to be able to recover from\n    /// `grow_in_place` failures without aborting, or to fall back on\n    /// another reallocation method before resorting to an abort.\n    unsafe fn grow_in_place(&mut self,\n                            ptr: *mut u8,\n                            layout: Layout,\n                            new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n        let _ = ptr; // this default implementation doesn't care about the actual address.\n        debug_assert!(new_layout.size >= layout.size);\n        debug_assert!(new_layout.align == layout.align);\n        let (_l, u) = self.usable_size(&layout);\n        // _l <= layout.size()                       [guaranteed by usable_size()]\n        //       layout.size() <= new_layout.size()  [required by this method]\n        if new_layout.size <= u {\n            return Ok(());\n        } else {\n            return Err(CannotReallocInPlace);\n        }\n    }\n\n    /// Attempts to shrink the allocation referenced by `ptr` to fit `new_layout`.\n    ///\n    /// If this returns `Ok`, then the allocator has asserted that the\n    /// memory block referenced by `ptr` now fits `new_layout`, and\n    /// thus can only be used to carry data of that smaller\n    /// layout. (The allocator is allowed to take advantage of this,\n    /// carving off portions of the block for reuse elsewhere.) The\n    /// truncated contents of the block within the smaller layout are\n    /// unaltered, and ownership of block has not been transferred.\n    ///\n    /// If this returns `Err`, then the memory block is considered to\n    /// still represent the original (larger) `layout`. None of the\n    /// block has been carved off for reuse elsewhere, ownership of\n    /// the memory block has not been transferred, and the contents of\n    /// the memory block are unaltered.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure all of the following:\n    ///\n    /// * `ptr` must be currently allocated via this allocator,\n    ///\n    /// * `layout` must *fit* the `ptr` (see above); note the\n    ///   `new_layout` argument need not fit it,\n    ///\n    /// * `new_layout.size()` must not be greater than `layout.size()`\n    ///   (and must be greater than zero),\n    ///\n    /// * `new_layout.align()` must equal `layout.align()`.\n    ///\n    /// # Errors\n    ///\n    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n    /// unable to assert that the memory block referenced by `ptr`\n    /// could fit `layout`.\n    ///\n    /// Note that one cannot pass `CannotReallocInPlace` to the `oom`\n    /// method; clients are expected either to be able to recover from\n    /// `shrink_in_place` failures without aborting, or to fall back\n    /// on another reallocation method before resorting to an abort.\n    unsafe fn shrink_in_place(&mut self,\n                              ptr: *mut u8,\n                              layout: Layout,\n                              new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n        let _ = ptr; // this default implementation doesn't care about the actual address.\n        debug_assert!(new_layout.size <= layout.size);\n        debug_assert!(new_layout.align == layout.align);\n        let (l, _u) = self.usable_size(&layout);\n        //                      layout.size() <= _u  [guaranteed by usable_size()]\n        // new_layout.size() <= layout.size()        [required by this method]\n        if l <= new_layout.size {\n            return Ok(());\n        } else {\n            return Err(CannotReallocInPlace);\n        }\n    }\n\n\n    // == COMMON USAGE PATTERNS ==\n    // alloc_one, dealloc_one, alloc_array, realloc_array. dealloc_array\n\n    /// Allocates a block suitable for holding an instance of `T`.\n    ///\n    /// Captures a common usage pattern for allocators.\n    ///\n    /// The returned block is suitable for passing to the\n    /// `alloc`/`realloc` methods of this allocator.\n    ///\n    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n    /// must be considered \"currently allocated\" and must be\n    /// acceptable input to methods such as `realloc` or `dealloc`,\n    /// *even if* `T` is a zero-sized type. In other words, if your\n    /// `Alloc` implementation overrides this method in a manner\n    /// that can return a zero-sized `ptr`, then all reallocation and\n    /// deallocation methods need to be similarly overridden to accept\n    /// such values as input.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `T` does not meet allocator's size or alignment constraints.\n    ///\n    /// For zero-sized `T`, may return either of `Ok` or `Err`, but\n    /// will *not* yield undefined behavior.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// allocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    fn alloc_one<T>(&mut self) -> Result<Unique<T>, AllocErr>\n        where Self: Sized\n    {\n        let k = Layout::new::<T>();\n        if k.size() > 0 {\n            unsafe { self.alloc(k).map(|p| Unique::new(p as *mut T)) }\n        } else {\n            Err(AllocErr::invalid_input(\"zero-sized type invalid for alloc_one\"))\n        }\n    }\n\n    /// Deallocates a block suitable for holding an instance of `T`.\n    ///\n    /// The given block must have been produced by this allocator,\n    /// and must be suitable for storing a `T` (in terms of alignment\n    /// as well as minimum and maximum size); otherwise yields\n    /// undefined behavior.\n    ///\n    /// Captures a common usage pattern for allocators.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure both:\n    ///\n    /// * `ptr` must denote a block of memory currently allocated via this allocator\n    ///\n    /// * the layout of `T` must *fit* that block of memory.\n    unsafe fn dealloc_one<T>(&mut self, ptr: Unique<T>)\n        where Self: Sized\n    {\n        let raw_ptr = ptr.as_ptr() as *mut u8;\n        let k = Layout::new::<T>();\n        if k.size() > 0 {\n            self.dealloc(raw_ptr, k);\n        }\n    }\n\n    /// Allocates a block suitable for holding `n` instances of `T`.\n    ///\n    /// Captures a common usage pattern for allocators.\n    ///\n    /// The returned block is suitable for passing to the\n    /// `alloc`/`realloc` methods of this allocator.\n    ///\n    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n    /// must be considered \"currently allocated\" and must be\n    /// acceptable input to methods such as `realloc` or `dealloc`,\n    /// *even if* `T` is a zero-sized type. In other words, if your\n    /// `Alloc` implementation overrides this method in a manner\n    /// that can return a zero-sized `ptr`, then all reallocation and\n    /// deallocation methods need to be similarly overridden to accept\n    /// such values as input.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `[T; n]` does not meet allocator's size or alignment\n    /// constraints.\n    ///\n    /// For zero-sized `T` or `n == 0`, may return either of `Ok` or\n    /// `Err`, but will *not* yield undefined behavior.\n    ///\n    /// Always returns `Err` on arithmetic overflow.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// allocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    fn alloc_array<T>(&mut self, n: usize) -> Result<Unique<T>, AllocErr>\n        where Self: Sized\n    {\n        match Layout::array::<T>(n) {\n            Some(ref layout) if layout.size() > 0 => {\n                unsafe {\n                    self.alloc(layout.clone())\n                        .map(|p| {\n                            Unique::new(p as *mut T)\n                        })\n                }\n            }\n            _ => Err(AllocErr::invalid_input(\"invalid layout for alloc_array\")),\n        }\n    }\n\n    /// Reallocates a block previously suitable for holding `n_old`\n    /// instances of `T`, returning a block suitable for holding\n    /// `n_new` instances of `T`.\n    ///\n    /// Captures a common usage pattern for allocators.\n    ///\n    /// The returned block is suitable for passing to the\n    /// `alloc`/`realloc` methods of this allocator.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure all of the following:\n    ///\n    /// * `ptr` must be currently allocated via this allocator,\n    ///\n    /// * the layout of `[T; n_old]` must *fit* that block of memory.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `[T; n_new]` does not meet allocator's size or alignment\n    /// constraints.\n    ///\n    /// For zero-sized `T` or `n_new == 0`, may return either of `Ok` or\n    /// `Err`, but will *not* yield undefined behavior.\n    ///\n    /// Always returns `Err` on arithmetic overflow.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// reallocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    unsafe fn realloc_array<T>(&mut self,\n                               ptr: Unique<T>,\n                               n_old: usize,\n                               n_new: usize) -> Result<Unique<T>, AllocErr>\n        where Self: Sized\n    {\n        match (Layout::array::<T>(n_old), Layout::array::<T>(n_new), ptr.as_ptr()) {\n            (Some(ref k_old), Some(ref k_new), ptr) if k_old.size() > 0 && k_new.size() > 0 => {\n                self.realloc(ptr as *mut u8, k_old.clone(), k_new.clone())\n                    .map(|p|Unique::new(p as *mut T))\n            }\n            _ => {\n                Err(AllocErr::invalid_input(\"invalid layout for realloc_array\"))\n            }\n        }\n    }\n\n    /// Deallocates a block suitable for holding `n` instances of `T`.\n    ///\n    /// Captures a common usage pattern for allocators.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure both:\n    ///\n    /// * `ptr` must denote a block of memory currently allocated via this allocator\n    ///\n    /// * the layout of `[T; n]` must *fit* that block of memory.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either `[T; n]` or the given\n    /// memory block does not meet allocator's size or alignment\n    /// constraints.\n    ///\n    /// Always returns `Err` on arithmetic overflow.\n    unsafe fn dealloc_array<T>(&mut self, ptr: Unique<T>, n: usize) -> Result<(), AllocErr>\n        where Self: Sized\n    {\n        let raw_ptr = ptr.as_ptr() as *mut u8;\n        match Layout::array::<T>(n) {\n            Some(ref k) if k.size() > 0 => {\n                Ok(self.dealloc(raw_ptr, k.clone()))\n            }\n            _ => {\n                Err(AllocErr::invalid_input(\"invalid layout for dealloc_array\"))\n            }\n        }\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Optional values.\n//!\n//! Type [`Option`] represents an optional value: every [`Option`]\n//! is either [`Some`] and contains a value, or [`None`], and\n//! does not. [`Option`] types are very common in Rust code, as\n//! they have a number of uses:\n//!\n//! * Initial values\n//! * Return values for functions that are not defined\n//!   over their entire input range (partial functions)\n//! * Return value for otherwise reporting simple errors, where `None` is\n//!   returned on error\n//! * Optional struct fields\n//! * Struct fields that can be loaned or \"taken\"\n//! * Optional function arguments\n//! * Nullable pointers\n//! * Swapping things out of difficult situations\n//!\n//! [`Option`]s are commonly paired with pattern matching to query the presence\n//! of a value and take action, always accounting for the [`None`] case.\n//!\n//! ```\n//! fn divide(numerator: f64, denominator: f64) -> Option<f64> {\n//!     if denominator == 0.0 {\n//!         None\n//!     } else {\n//!         Some(numerator / denominator)\n//!     }\n//! }\n//!\n//! // The return value of the function is an option\n//! let result = divide(2.0, 3.0);\n//!\n//! // Pattern match to retrieve the value\n//! match result {\n//!     // The division was valid\n//!     Some(x) => println!(\"Result: {}\", x),\n//!     // The division was invalid\n//!     None    => println!(\"Cannot divide by 0\"),\n//! }\n//! ```\n//!\n//\n// FIXME: Show how `Option` is used in practice, with lots of methods\n//\n//! # Options and pointers (\"nullable\" pointers)\n//!\n//! Rust's pointer types must always point to a valid location; there are\n//! no \"null\" pointers. Instead, Rust has *optional* pointers, like\n//! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n//!\n//! The following example uses [`Option`] to create an optional box of\n//! [`i32`]. Notice that in order to use the inner [`i32`] value first, the\n//! `check_optional` function needs to use pattern matching to\n//! determine whether the box has a value (i.e. it is [`Some(...)`][`Some`]) or\n//! not ([`None`]).\n//!\n//! ```\n//! let optional = None;\n//! check_optional(optional);\n//!\n//! let optional = Some(Box::new(9000));\n//! check_optional(optional);\n//!\n//! fn check_optional(optional: Option<Box<i32>>) {\n//!     match optional {\n//!         Some(ref p) => println!(\"has value {}\", p),\n//!         None => println!(\"has no value\"),\n//!     }\n//! }\n//! ```\n//!\n//! This usage of [`Option`] to create safe nullable pointers is so\n//! common that Rust does special optimizations to make the\n//! representation of [`Option`]`<`[`Box<T>`]`>` a single pointer. Optional pointers\n//! in Rust are stored as efficiently as any other pointer type.\n//!\n//! # Examples\n//!\n//! Basic pattern matching on [`Option`]:\n//!\n//! ```\n//! let msg = Some(\"howdy\");\n//!\n//! // Take a reference to the contained string\n//! if let Some(ref m) = msg {\n//!     println!(\"{}\", *m);\n//! }\n//!\n//! // Remove the contained string, destroying the Option\n//! let unwrapped_msg = msg.unwrap_or(\"default message\");\n//! ```\n//!\n//! Initialize a result to [`None`] before a loop:\n//!\n//! ```\n//! enum Kingdom { Plant(u32, &'static str), Animal(u32, &'static str) }\n//!\n//! // A list of data to search through.\n//! let all_the_big_things = [\n//!     Kingdom::Plant(250, \"redwood\"),\n//!     Kingdom::Plant(230, \"noble fir\"),\n//!     Kingdom::Plant(229, \"sugar pine\"),\n//!     Kingdom::Animal(25, \"blue whale\"),\n//!     Kingdom::Animal(19, \"fin whale\"),\n//!     Kingdom::Animal(15, \"north pacific right whale\"),\n//! ];\n//!\n//! // We're going to search for the name of the biggest animal,\n//! // but to start with we've just got `None`.\n//! let mut name_of_biggest_animal = None;\n//! let mut size_of_biggest_animal = 0;\n//! for big_thing in &all_the_big_things {\n//!     match *big_thing {\n//!         Kingdom::Animal(size, name) if size > size_of_biggest_animal => {\n//!             // Now we've found the name of some big animal\n//!             size_of_biggest_animal = size;\n//!             name_of_biggest_animal = Some(name);\n//!         }\n//!         Kingdom::Animal(..) | Kingdom::Plant(..) => ()\n//!     }\n//! }\n//!\n//! match name_of_biggest_animal {\n//!     Some(name) => println!(\"the biggest animal is {}\", name),\n//!     None => println!(\"there are no animals :(\"),\n//! }\n//! ```\n//!\n//! [`Option`]: enum.Option.html\n//! [`Some`]: enum.Option.html#variant.Some\n//! [`None`]: enum.Option.html#variant.None\n//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n//! [`i32`]: ../../std/primitive.i32.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse iter::{FromIterator, FusedIterator, TrustedLen};\nuse mem;\n\n// Note that this is not a lang item per se, but it has a hidden dependency on\n// `Iterator`, which is one. The compiler assumes that the `next` method of\n// `Iterator` is an enumeration with one type parameter and two variants,\n// which basically means it must be `Option`.\n\n/// The `Option` type. See [the module level documentation](index.html) for more.\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Option<T> {\n    /// No value\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    None,\n    /// Some value `T`\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Type implementation\n/////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Option<T> {\n    /////////////////////////////////////////////////////////////////////////\n    // Querying the contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns `true` if the option is a [`Some`] value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x: Option<u32> = Some(2);\n    /// assert_eq!(x.is_some(), true);\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.is_some(), false);\n    /// ```\n    ///\n    /// [`Some`]: #variant.Some\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_some(&self) -> bool {\n        match *self {\n            Some(_) => true,\n            None => false,\n        }\n    }\n\n    /// Returns `true` if the option is a [`None`] value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x: Option<u32> = Some(2);\n    /// assert_eq!(x.is_none(), false);\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.is_none(), true);\n    /// ```\n    ///\n    /// [`None`]: #variant.None\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_none(&self) -> bool {\n        !self.is_some()\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Adapter for working with references\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Converts from `Option<T>` to `Option<&T>`.\n    ///\n    /// # Examples\n    ///\n    /// Convert an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n    /// The [`map`] method takes the `self` argument by value, consuming the original,\n    /// so this technique uses `as_ref` to first take an `Option` to a reference\n    /// to the value inside the original.\n    ///\n    /// [`map`]: enum.Option.html#method.map\n    /// [`String`]: ../../std/string/struct.String.html\n    /// [`usize`]: ../../std/primitive.usize.html\n    ///\n    /// ```\n    /// let num_as_str: Option<String> = Some(\"10\".to_string());\n    /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n    /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n    /// let num_as_int: Option<usize> = num_as_str.as_ref().map(|n| n.len());\n    /// println!(\"still can print num_as_str: {:?}\", num_as_str);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_ref(&self) -> Option<&T> {\n        match *self {\n            Some(ref x) => Some(x),\n            None => None,\n        }\n    }\n\n    /// Converts from `Option<T>` to `Option<&mut T>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(2);\n    /// match x.as_mut() {\n    ///     Some(v) => *v = 42,\n    ///     None => {},\n    /// }\n    /// assert_eq!(x, Some(42));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_mut(&mut self) -> Option<&mut T> {\n        match *self {\n            Some(ref mut x) => Some(x),\n            None => None,\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Getting to contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Unwraps an option, yielding the content of a [`Some`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is a [`None`] with a custom panic message provided by\n    /// `msg`.\n    ///\n    /// [`Some`]: #variant.Some\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"value\");\n    /// assert_eq!(x.expect(\"the world is ending\"), \"value\");\n    /// ```\n    ///\n    /// ```{.should_panic}\n    /// let x: Option<&str> = None;\n    /// x.expect(\"the world is ending\"); // panics with `the world is ending`\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn expect(self, msg: &str) -> T {\n        match self {\n            Some(val) => val,\n            None => expect_failed(msg),\n        }\n    }\n\n    /// Moves the value `v` out of the `Option<T>` if it is [`Some(v)`].\n    ///\n    /// In general, because this function may panic, its use is discouraged.\n    /// Instead, prefer to use pattern matching and handle the [`None`]\n    /// case explicitly.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the self value equals [`None`].\n    ///\n    /// [`Some(v)`]: #variant.Some\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"air\");\n    /// assert_eq!(x.unwrap(), \"air\");\n    /// ```\n    ///\n    /// ```{.should_panic}\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.unwrap(), \"air\"); // fails\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap(self) -> T {\n        match self {\n            Some(val) => val,\n            None => panic!(\"called `Option::unwrap()` on a `None` value\"),\n        }\n    }\n\n    /// Returns the contained value or a default.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n    /// assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or(self, def: T) -> T {\n        match self {\n            Some(x) => x,\n            None => def,\n        }\n    }\n\n    /// Returns the contained value or computes it from a closure.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let k = 10;\n    /// assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n    /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Transforming contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n    ///\n    /// # Examples\n    ///\n    /// Convert an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    /// [`usize`]: ../../std/primitive.usize.html\n    ///\n    /// ```\n    /// let maybe_some_string = Some(String::from(\"Hello, World!\"));\n    /// // `Option::map` takes self *by value*, consuming `maybe_some_string`\n    /// let maybe_some_len = maybe_some_string.map(|s| s.len());\n    ///\n    /// assert_eq!(maybe_some_len, Some(13));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }\n\n    /// Applies a function to the contained value (if any),\n    /// or returns a [`default`][] (if not).\n    ///\n    /// [`default`]: ../default/trait.Default.html#tymethod.default\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.map_or(42, |v| v.len()), 3);\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.map_or(42, |v| v.len()), 42);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {\n        match self {\n            Some(t) => f(t),\n            None => default,\n        }\n    }\n\n    /// Applies a function to the contained value (if any),\n    /// or computes a [`default`][] (if not).\n    ///\n    /// [`default`]: ../default/trait.Default.html#tymethod.default\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let k = 21;\n    ///\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3);\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U {\n        match self {\n            Some(t) => f(t),\n            None => default(),\n        }\n    }\n\n    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n    /// [`Ok(v)`] and [`None`] to [`Err(err)`].\n    ///\n    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`Err(err)`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`None`]: #variant.None\n    /// [`Some(v)`]: #variant.Some\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.ok_or(0), Ok(\"foo\"));\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.ok_or(0), Err(0));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ok_or<E>(self, err: E) -> Result<T, E> {\n        match self {\n            Some(v) => Ok(v),\n            None => Err(err),\n        }\n    }\n\n    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n    /// [`Ok(v)`] and [`None`] to [`Err(err())`].\n    ///\n    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`Err(err())`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`None`]: #variant.None\n    /// [`Some(v)`]: #variant.Some\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.ok_or_else(|| 0), Ok(\"foo\"));\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.ok_or_else(|| 0), Err(0));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {\n        match self {\n            Some(v) => Ok(v),\n            None => Err(err()),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Iterator constructors\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns an iterator over the possibly contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(4);\n    /// assert_eq!(x.iter().next(), Some(&4));\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.iter().next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<T> {\n        Iter { inner: Item { opt: self.as_ref() } }\n    }\n\n    /// Returns a mutable iterator over the possibly contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(4);\n    /// match x.iter_mut().next() {\n    ///     Some(v) => *v = 42,\n    ///     None => {},\n    /// }\n    /// assert_eq!(x, Some(42));\n    ///\n    /// let mut x: Option<u32> = None;\n    /// assert_eq!(x.iter_mut().next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut { inner: Item { opt: self.as_mut() } }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Boolean operations on the values, eager and lazy\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns [`None`] if the option is [`None`], otherwise returns `optb`.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(2);\n    /// let y: Option<&str> = None;\n    /// assert_eq!(x.and(y), None);\n    ///\n    /// let x: Option<u32> = None;\n    /// let y = Some(\"foo\");\n    /// assert_eq!(x.and(y), None);\n    ///\n    /// let x = Some(2);\n    /// let y = Some(\"foo\");\n    /// assert_eq!(x.and(y), Some(\"foo\"));\n    ///\n    /// let x: Option<u32> = None;\n    /// let y: Option<&str> = None;\n    /// assert_eq!(x.and(y), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n        match self {\n            Some(_) => optb,\n            None => None,\n        }\n    }\n\n    /// Returns [`None`] if the option is [`None`], otherwise calls `f` with the\n    /// wrapped value and returns the result.\n    ///\n    /// Some languages call this operation flatmap.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// fn sq(x: u32) -> Option<u32> { Some(x * x) }\n    /// fn nope(_: u32) -> Option<u32> { None }\n    ///\n    /// assert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\n    /// assert_eq!(Some(2).and_then(sq).and_then(nope), None);\n    /// assert_eq!(Some(2).and_then(nope).and_then(sq), None);\n    /// assert_eq!(None.and_then(sq).and_then(sq), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n        match self {\n            Some(x) => f(x),\n            None => None,\n        }\n    }\n\n    /// Returns the option if it contains a value, otherwise returns `optb`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(2);\n    /// let y = None;\n    /// assert_eq!(x.or(y), Some(2));\n    ///\n    /// let x = None;\n    /// let y = Some(100);\n    /// assert_eq!(x.or(y), Some(100));\n    ///\n    /// let x = Some(2);\n    /// let y = Some(100);\n    /// assert_eq!(x.or(y), Some(2));\n    ///\n    /// let x: Option<u32> = None;\n    /// let y = None;\n    /// assert_eq!(x.or(y), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or(self, optb: Option<T>) -> Option<T> {\n        match self {\n            Some(_) => self,\n            None => optb,\n        }\n    }\n\n    /// Returns the option if it contains a value, otherwise calls `f` and\n    /// returns the result.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// fn nobody() -> Option<&'static str> { None }\n    /// fn vikings() -> Option<&'static str> { Some(\"vikings\") }\n    ///\n    /// assert_eq!(Some(\"barbarians\").or_else(vikings), Some(\"barbarians\"));\n    /// assert_eq!(None.or_else(vikings), Some(\"vikings\"));\n    /// assert_eq!(None.or_else(nobody), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n        match self {\n            Some(_) => self,\n            None => f(),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Entry-like operations to insert if None and return a reference\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Inserts `v` into the option if it is [`None`], then\n    /// returns a mutable reference to the contained value.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(option_entry)]\n    ///\n    /// let mut x = None;\n    ///\n    /// {\n    ///     let y: &mut u32 = x.get_or_insert(5);\n    ///     assert_eq!(y, &5);\n    ///\n    ///     *y = 7;\n    /// }\n    ///\n    /// assert_eq!(x, Some(7));\n    /// ```\n    #[inline]\n    #[unstable(feature = \"option_entry\", issue = \"39288\")]\n    pub fn get_or_insert(&mut self, v: T) -> &mut T {\n        match *self {\n            None => *self = Some(v),\n            _ => (),\n        }\n\n        match *self {\n            Some(ref mut v) => v,\n            _ => unreachable!(),\n        }\n    }\n\n    /// Inserts a value computed from `f` into the option if it is [`None`], then\n    /// returns a mutable reference to the contained value.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(option_entry)]\n    ///\n    /// let mut x = None;\n    ///\n    /// {\n    ///     let y: &mut u32 = x.get_or_insert_with(|| 5);\n    ///     assert_eq!(y, &5);\n    ///\n    ///     *y = 7;\n    /// }\n    ///\n    /// assert_eq!(x, Some(7));\n    /// ```\n    #[inline]\n    #[unstable(feature = \"option_entry\", issue = \"39288\")]\n    pub fn get_or_insert_with<F: FnOnce() -> T>(&mut self, f: F) -> &mut T {\n        match *self {\n            None => *self = Some(f()),\n            _ => (),\n        }\n\n        match *self {\n            Some(ref mut v) => v,\n            _ => unreachable!(),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Misc\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Takes the value out of the option, leaving a [`None`] in its place.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(2);\n    /// x.take();\n    /// assert_eq!(x, None);\n    ///\n    /// let mut x: Option<u32> = None;\n    /// x.take();\n    /// assert_eq!(x, None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn take(&mut self) -> Option<T> {\n        mem::replace(self, None)\n    }\n}\n\nimpl<'a, T: Clone> Option<&'a T> {\n    /// Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n    /// option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 12;\n    /// let opt_x = Some(&x);\n    /// assert_eq!(opt_x, Some(&12));\n    /// let cloned = opt_x.cloned();\n    /// assert_eq!(cloned, Some(12));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn cloned(self) -> Option<T> {\n        self.map(|t| t.clone())\n    }\n}\n\nimpl<T: Default> Option<T> {\n    /// Returns the contained value or a default\n    ///\n    /// Consumes the `self` argument then, if [`Some`], returns the contained\n    /// value, otherwise if [`None`], returns the default value for that\n    /// type.\n    ///\n    /// # Examples\n    ///\n    /// Convert a string to an integer, turning poorly-formed strings\n    /// into 0 (the default value for integers). [`parse`] converts\n    /// a string to any other type that implements [`FromStr`], returning\n    /// [`None`] on error.\n    ///\n    /// ```\n    /// let good_year_from_input = \"1909\";\n    /// let bad_year_from_input = \"190blarg\";\n    /// let good_year = good_year_from_input.parse().ok().unwrap_or_default();\n    /// let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n    ///\n    /// assert_eq!(1909, good_year);\n    /// assert_eq!(0, bad_year);\n    /// ```\n    ///\n    /// [`Some`]: #variant.Some\n    /// [`None`]: #variant.None\n    /// [`parse`]: ../../std/primitive.str.html#method.parse\n    /// [`FromStr`]: ../../std/str/trait.FromStr.html\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or_default(self) -> T {\n        match self {\n            Some(x) => x,\n            None => Default::default(),\n        }\n    }\n}\n\n// This is a separate function to reduce the code size of .expect() itself.\n#[inline(never)]\n#[cold]\nfn expect_failed(msg: &str) -> ! {\n    panic!(\"{}\", msg)\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Trait implementations\n/////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for Option<T> {\n    /// Returns [`None`].\n    ///\n    /// [`None`]: #variant.None\n    #[inline]\n    fn default() -> Option<T> { None }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> IntoIterator for Option<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Returns a consuming iterator over the possibly contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"string\");\n    /// let v: Vec<&str> = x.into_iter().collect();\n    /// assert_eq!(v, [\"string\"]);\n    ///\n    /// let x = None;\n    /// let v: Vec<&str> = x.into_iter().collect();\n    /// assert!(v.is_empty());\n    /// ```\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n        IntoIter { inner: Item { opt: self } }\n    }\n}\n\n#[stable(since = \"1.4.0\", feature = \"option_iter\")]\nimpl<'a, T> IntoIterator for &'a Option<T> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(since = \"1.4.0\", feature = \"option_iter\")]\nimpl<'a, T> IntoIterator for &'a mut Option<T> {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(mut self) -> IterMut<'a, T> {\n        self.iter_mut()\n    }\n}\n\n#[stable(since = \"1.12.0\", feature = \"option_from\")]\nimpl<T> From<T> for Option<T> {\n    fn from(val: T) -> Option<T> {\n        Some(val)\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The Option Iterators\n/////////////////////////////////////////////////////////////////////////////\n\n#[derive(Clone, Debug)]\nstruct Item<A> {\n    opt: Option<A>\n}\n\nimpl<A> Iterator for Item<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        self.opt.take()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match self.opt {\n            Some(_) => (1, Some(1)),\n            None => (0, Some(0)),\n        }\n    }\n}\n\nimpl<A> DoubleEndedIterator for Item<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A> {\n        self.opt.take()\n    }\n}\n\nimpl<A> ExactSizeIterator for Item<A> {}\nimpl<A> FusedIterator for Item<A> {}\nunsafe impl<A> TrustedLen for Item<A> {}\n\n/// An iterator over a reference to the [`Some`] variant of an [`Option`].\n///\n/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n///\n/// This `struct` is created by the [`Option::iter`] function.\n///\n/// [`Option`]: enum.Option.html\n/// [`Some`]: enum.Option.html#variant.Some\n/// [`Option::iter`]: enum.Option.html#method.iter\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> Iterator for Iter<'a, A> {\n    type Item = &'a A;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a A> { self.inner.next() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, A> FusedIterator for Iter<'a, A> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, A> TrustedLen for Iter<'a, A> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> Clone for Iter<'a, A> {\n    fn clone(&self) -> Iter<'a, A> {\n        Iter { inner: self.inner.clone() }\n    }\n}\n\n/// An iterator over a mutable reference to the [`Some`] variant of an [`Option`].\n///\n/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n///\n/// This `struct` is created by the [`Option::iter_mut`] function.\n///\n/// [`Option`]: enum.Option.html\n/// [`Some`]: enum.Option.html#variant.Some\n/// [`Option::iter_mut`]: enum.Option.html#method.iter_mut\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> Iterator for IterMut<'a, A> {\n    type Item = &'a mut A;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, A> FusedIterator for IterMut<'a, A> {}\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n\n/// An iterator over the value in [`Some`] variant of an [`Option`].\n///\n/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n///\n/// This `struct` is created by the [`Option::into_iter`] function.\n///\n/// [`Option`]: enum.Option.html\n/// [`Some`]: enum.Option.html#variant.Some\n/// [`Option::into_iter`]: enum.Option.html#method.into_iter\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<A> { inner: Item<A> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> Iterator for IntoIter<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> { self.inner.next() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> DoubleEndedIterator for IntoIter<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> ExactSizeIterator for IntoIter<A> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<A> FusedIterator for IntoIter<A> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A> TrustedLen for IntoIter<A> {}\n\n/////////////////////////////////////////////////////////////////////////////\n// FromIterator\n/////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n    /// Takes each element in the [`Iterator`]: if it is [`None`], no further\n    /// elements are taken, and the [`None`] is returned. Should no [`None`] occur, a\n    /// container with the values of each `Option` is returned.\n    ///\n    /// Here is an example which increments every integer in a vector,\n    /// checking for overflow:\n    ///\n    /// ```\n    /// use std::u16;\n    ///\n    /// let v = vec![1, 2];\n    /// let res: Option<Vec<u16>> = v.iter().map(|&x: &u16|\n    ///     if x == u16::MAX { None }\n    ///     else { Some(x + 1) }\n    /// ).collect();\n    /// assert!(res == Some(vec![2, 3]));\n    /// ```\n    ///\n    /// [`Iterator`]: ../iter/trait.Iterator.html\n    /// [`None`]: enum.Option.html#variant.None\n    #[inline]\n    fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> {\n        // FIXME(#11084): This could be replaced with Iterator::scan when this\n        // performance bug is closed.\n\n        struct Adapter<Iter> {\n            iter: Iter,\n            found_none: bool,\n        }\n\n        impl<T, Iter: Iterator<Item=Option<T>>> Iterator for Adapter<Iter> {\n            type Item = T;\n\n            #[inline]\n            fn next(&mut self) -> Option<T> {\n                match self.iter.next() {\n                    Some(Some(value)) => Some(value),\n                    Some(None) => {\n                        self.found_none = true;\n                        None\n                    }\n                    None => None,\n                }\n            }\n        }\n\n        let mut adapter = Adapter { iter: iter.into_iter(), found_none: false };\n        let v: V = FromIterator::from_iter(adapter.by_ref());\n\n        if adapter.found_none {\n            None\n        } else {\n            Some(v)\n        }\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n/// Entry point of thread panic, for details, see std::macros\n#[macro_export]\n#[allow_internal_unstable]\n#[stable(feature = \"core\", since = \"1.6.0\")]\nmacro_rules! panic {\n    () => (\n        panic!(\"explicit panic\")\n    );\n    ($msg:expr) => ({\n        static _MSG_FILE_LINE_COL: (&'static str, &'static str, u32, u32) =\n            ($msg, file!(), line!(), column!());\n        $crate::panicking::panic(&_MSG_FILE_LINE_COL)\n    });\n    ($fmt:expr, $($arg:tt)*) => ({\n        // The leading _'s are to avoid dead code warnings if this is\n        // used inside a dead function. Just `#[allow(dead_code)]` is\n        // insufficient, since the user may have\n        // `#[forbid(dead_code)]` and which cannot be overridden.\n        static _MSG_FILE_LINE_COL: (&'static str, u32, u32) =\n            (file!(), line!(), column!());\n        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*), &_MSG_FILE_LINE_COL)\n    });\n}\n\n/// Ensure that a boolean expression is `true` at runtime.\n///\n/// This will invoke the [`panic!`] macro if the provided expression cannot be\n/// evaluated to `true` at runtime.\n///\n/// # Uses\n///\n/// Assertions are always checked in both debug and release builds, and cannot\n/// be disabled. See [`debug_assert!`] for assertions that are not enabled in\n/// release builds by default.\n///\n/// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n/// violated could lead to unsafety.\n///\n/// Other use-cases of `assert!` include [testing] and enforcing run-time\n/// invariants in safe code (whose violation cannot result in unsafety).\n///\n/// # Custom Messages\n///\n/// This macro has a second form, where a custom panic message can\n/// be provided with or without arguments for formatting.\n///\n/// [`panic!`]: macro.panic.html\n/// [`debug_assert!`]: macro.debug_assert.html\n/// [testing]: ../book/first-edition/testing.html\n///\n/// # Examples\n///\n/// ```\n/// // the panic message for these assertions is the stringified value of the\n/// // expression given.\n/// assert!(true);\n///\n/// fn some_computation() -> bool { true } // a very simple function\n///\n/// assert!(some_computation());\n///\n/// // assert with a custom message\n/// let x = true;\n/// assert!(x, \"x wasn't true!\");\n///\n/// let a = 3; let b = 27;\n/// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! assert {\n    ($cond:expr) => (\n        if !$cond {\n            panic!(concat!(\"assertion failed: \", stringify!($cond)))\n        }\n    );\n    ($cond:expr, $($arg:tt)+) => (\n        if !$cond {\n            panic!($($arg)+)\n        }\n    );\n}\n\n/// Asserts that two expressions are equal to each other (using [`PartialEq`]).\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Like [`assert!`], this macro has a second form, where a custom\n/// panic message can be provided.\n///\n/// [`PartialEq`]: cmp/trait.PartialEq.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 1 + 2;\n/// assert_eq!(a, b);\n///\n/// assert_eq!(a, b, \"we are testing addition with {} and {}\", a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! assert_eq {\n    ($left:expr, $right:expr) => ({\n        match (&$left, &$right) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    panic!(r#\"assertion failed: `(left == right)`\n  left: `{:?}`,\n right: `{:?}`\"#, left_val, right_val)\n                }\n            }\n        }\n    });\n    ($left:expr, $right:expr, $($arg:tt)+) => ({\n        match (&($left), &($right)) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    panic!(r#\"assertion failed: `(left == right)`\n  left: `{:?}`,\n right: `{:?}`: {}\"#, left_val, right_val,\n                           format_args!($($arg)+))\n                }\n            }\n        }\n    });\n}\n\n/// Asserts that two expressions are not equal to each other (using [`PartialEq`]).\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Like [`assert!`], this macro has a second form, where a custom\n/// panic message can be provided.\n///\n/// [`PartialEq`]: cmp/trait.PartialEq.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 2;\n/// assert_ne!(a, b);\n///\n/// assert_ne!(a, b, \"we are testing that the values are not equal\");\n/// ```\n#[macro_export]\n#[stable(feature = \"assert_ne\", since = \"1.13.0\")]\nmacro_rules! assert_ne {\n    ($left:expr, $right:expr) => ({\n        match (&$left, &$right) {\n            (left_val, right_val) => {\n                if *left_val == *right_val {\n                    panic!(r#\"assertion failed: `(left != right)`\n  left: `{:?}`,\n right: `{:?}`\"#, left_val, right_val)\n                }\n            }\n        }\n    });\n    ($left:expr, $right:expr, $($arg:tt)+) => ({\n        match (&($left), &($right)) {\n            (left_val, right_val) => {\n                if *left_val == *right_val {\n                    panic!(r#\"assertion failed: `(left != right)`\n  left: `{:?}`,\n right: `{:?}`: {}\"#, left_val, right_val,\n                           format_args!($($arg)+))\n                }\n            }\n        }\n    });\n}\n\n/// Ensure that a boolean expression is `true` at runtime.\n///\n/// This will invoke the [`panic!`] macro if the provided expression cannot be\n/// evaluated to `true` at runtime.\n///\n/// Like [`assert!`], this macro also has a second version, where a custom panic\n/// message can be provided.\n///\n/// # Uses\n///\n/// Unlike [`assert!`], `debug_assert!` statements are only enabled in non\n/// optimized builds by default. An optimized build will omit all\n/// `debug_assert!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development.\n///\n/// An unchecked assertion allows a program in an inconsistent state to keep\n/// running, which might have unexpected consequences but does not introduce\n/// unsafety as long as this only happens in safe code. The performance cost\n/// of assertions, is however, not measurable in general. Replacing [`assert!`]\n/// with `debug_assert!` is thus only encouraged after thorough profiling, and\n/// more importantly, only in safe code!\n///\n/// [`panic!`]: macro.panic.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// // the panic message for these assertions is the stringified value of the\n/// // expression given.\n/// debug_assert!(true);\n///\n/// fn some_expensive_computation() -> bool { true } // a very simple function\n/// debug_assert!(some_expensive_computation());\n///\n/// // assert with a custom message\n/// let x = true;\n/// debug_assert!(x, \"x wasn't true!\");\n///\n/// let a = 3; let b = 27;\n/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! debug_assert {\n    ($($arg:tt)*) => (if cfg!(debug_assertions) { assert!($($arg)*); })\n}\n\n/// Asserts that two expressions are equal to each other.\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Unlike `assert_eq!`, `debug_assert_eq!` statements are only enabled in non\n/// optimized builds by default. An optimized build will omit all\n/// `debug_assert_eq!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert_eq!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development.\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 1 + 2;\n/// debug_assert_eq!(a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! debug_assert_eq {\n    ($($arg:tt)*) => (if cfg!(debug_assertions) { assert_eq!($($arg)*); })\n}\n\n/// Asserts that two expressions are not equal to each other.\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Unlike `assert_ne!`, `debug_assert_ne!` statements are only enabled in non\n/// optimized builds by default. An optimized build will omit all\n/// `debug_assert_ne!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert_ne!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development.\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 2;\n/// debug_assert_ne!(a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"assert_ne\", since = \"1.13.0\")]\nmacro_rules! debug_assert_ne {\n    ($($arg:tt)*) => (if cfg!(debug_assertions) { assert_ne!($($arg)*); })\n}\n\n/// Helper macro for reducing boilerplate code for matching `Result` together\n/// with converting downstream errors.\n///\n/// Prefer using `?` syntax to `try!`. `?` is built in to the language and is\n/// more succinct than `try!`. It is the standard method for error propagation.\n///\n/// `try!` matches the given `Result`. In case of the `Ok` variant, the\n/// expression has the value of the wrapped value.\n///\n/// In case of the `Err` variant, it retrieves the inner error. `try!` then\n/// performs conversion using `From`. This provides automatic conversion\n/// between specialized errors and more general ones. The resulting\n/// error is then immediately returned.\n///\n/// Because of the early return, `try!` can only be used in functions that\n/// return `Result`.\n///\n/// # Examples\n///\n/// ```\n/// use std::io;\n/// use std::fs::File;\n/// use std::io::prelude::*;\n///\n/// enum MyError {\n///     FileWriteError\n/// }\n///\n/// impl From<io::Error> for MyError {\n///     fn from(e: io::Error) -> MyError {\n///         MyError::FileWriteError\n///     }\n/// }\n///\n/// fn write_to_file_using_try() -> Result<(), MyError> {\n///     let mut file = try!(File::create(\"my_best_friends.txt\"));\n///     try!(file.write_all(b\"This is a list of my best friends.\"));\n///     println!(\"I wrote to the file\");\n///     Ok(())\n/// }\n/// // This is equivalent to:\n/// fn write_to_file_using_match() -> Result<(), MyError> {\n///     let mut file = try!(File::create(\"my_best_friends.txt\"));\n///     match file.write_all(b\"This is a list of my best friends.\") {\n///         Ok(v) => v,\n///         Err(e) => return Err(From::from(e)),\n///     }\n///     println!(\"I wrote to the file\");\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! try {\n    ($expr:expr) => (match $expr {\n        $crate::result::Result::Ok(val) => val,\n        $crate::result::Result::Err(err) => {\n            return $crate::result::Result::Err($crate::convert::From::from(err))\n        }\n    })\n}\n\n/// Write formatted data into a buffer\n///\n/// This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be\n/// formatted according to the specified format string and the result will be passed to the writer.\n/// The writer may be any value with a `write_fmt` method; generally this comes from an\n/// implementation of either the [`std::fmt::Write`] or the [`std::io::Write`] trait. The macro\n/// returns whatever the 'write_fmt' method returns; commonly a [`std::fmt::Result`], or an\n/// [`io::Result`].\n///\n/// See [`std::fmt`] for more information on the format string syntax.\n///\n/// [`std::fmt`]: ../std/fmt/index.html\n/// [`std::fmt::Write`]: ../std/fmt/trait.Write.html\n/// [`std::io::Write`]: ../std/io/trait.Write.html\n/// [`std::fmt::Result`]: ../std/fmt/type.Result.html\n/// [`io::Result`]: ../std/io/type.Result.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::Write;\n///\n/// let mut w = Vec::new();\n/// write!(&mut w, \"test\").unwrap();\n/// write!(&mut w, \"formatted {}\", \"arguments\").unwrap();\n///\n/// assert_eq!(w, b\"testformatted arguments\");\n/// ```\n///\n/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n/// implementing either, as objects do not typically implement both. However, the module must\n/// import the traits qualified so their names do not conflict:\n///\n/// ```\n/// use std::fmt::Write as FmtWrite;\n/// use std::io::Write as IoWrite;\n///\n/// let mut s = String::new();\n/// let mut v = Vec::new();\n/// write!(&mut s, \"{} {}\", \"abc\", 123).unwrap(); // uses fmt::Write::write_fmt\n/// write!(&mut v, \"s = {:?}\", s).unwrap(); // uses io::Write::write_fmt\n/// assert_eq!(v, b\"s = \\\"abc 123\\\"\");\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! write {\n    ($dst:expr, $($arg:tt)*) => ($dst.write_fmt(format_args!($($arg)*)))\n}\n\n/// Write formatted data into a buffer, with a newline appended.\n///\n/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n///\n/// For more information, see [`write!`]. For information on the format string syntax, see\n/// [`std::fmt`].\n///\n/// [`write!`]: macro.write.html\n/// [`std::fmt`]: ../std/fmt/index.html\n///\n///\n/// # Examples\n///\n/// ```\n/// use std::io::Write;\n///\n/// let mut w = Vec::new();\n/// writeln!(&mut w).unwrap();\n/// writeln!(&mut w, \"test\").unwrap();\n/// writeln!(&mut w, \"formatted {}\", \"arguments\").unwrap();\n///\n/// assert_eq!(&w[..], \"\\ntest\\nformatted arguments\\n\".as_bytes());\n/// ```\n///\n/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n/// implementing either, as objects do not typically implement both. However, the module must\n/// import the traits qualified so their names do not conflict:\n///\n/// ```\n/// use std::fmt::Write as FmtWrite;\n/// use std::io::Write as IoWrite;\n///\n/// let mut s = String::new();\n/// let mut v = Vec::new();\n/// writeln!(&mut s, \"{} {}\", \"abc\", 123).unwrap(); // uses fmt::Write::write_fmt\n/// writeln!(&mut v, \"s = {:?}\", s).unwrap(); // uses io::Write::write_fmt\n/// assert_eq!(v, b\"s = \\\"abc 123\\\\n\\\"\\n\");\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! writeln {\n    ($dst:expr) => (\n        write!($dst, \"\\n\")\n    );\n    ($dst:expr, $fmt:expr) => (\n        write!($dst, concat!($fmt, \"\\n\"))\n    );\n    ($dst:expr, $fmt:expr, $($arg:tt)*) => (\n        write!($dst, concat!($fmt, \"\\n\"), $($arg)*)\n    );\n}\n\n/// A utility macro for indicating unreachable code.\n///\n/// This is useful any time that the compiler can't determine that some code is unreachable. For\n/// example:\n///\n/// * Match arms with guard conditions.\n/// * Loops that dynamically terminate.\n/// * Iterators that dynamically terminate.\n///\n/// # Panics\n///\n/// This will always panic.\n///\n/// # Examples\n///\n/// Match arms:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// fn foo(x: Option<i32>) {\n///     match x {\n///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n///         Some(n) if n <  0 => println!(\"Some(Negative)\"),\n///         Some(_)           => unreachable!(), // compile error if commented out\n///         None              => println!(\"None\")\n///     }\n/// }\n/// ```\n///\n/// Iterators:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n///     for i in 0.. {\n///         if 3*i < i { panic!(\"u32 overflow\"); }\n///         if x < 3*i { return i-1; }\n///     }\n///     unreachable!();\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! unreachable {\n    () => ({\n        panic!(\"internal error: entered unreachable code\")\n    });\n    ($msg:expr) => ({\n        unreachable!(\"{}\", $msg)\n    });\n    ($fmt:expr, $($arg:tt)*) => ({\n        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n    });\n}\n\n/// A standardized placeholder for marking unfinished code. It panics with the\n/// message `\"not yet implemented\"` when executed.\n///\n/// This can be useful if you are prototyping and are just looking to have your\n/// code typecheck, or if you're implementing a trait that requires multiple\n/// methods, and you're only planning on using one of them.\n///\n/// # Examples\n///\n/// Here's an example of some in-progress code. We have a trait `Foo`:\n///\n/// ```\n/// trait Foo {\n///     fn bar(&self);\n///     fn baz(&self);\n/// }\n/// ```\n///\n/// We want to implement `Foo` on one of our types, but we also want to work on\n/// just `bar()` first. In order for our code to compile, we need to implement\n/// `baz()`, so we can use `unimplemented!`:\n///\n/// ```\n/// # trait Foo {\n/// #     fn bar(&self);\n/// #     fn baz(&self);\n/// # }\n/// struct MyStruct;\n///\n/// impl Foo for MyStruct {\n///     fn bar(&self) {\n///         // implementation goes here\n///     }\n///\n///     fn baz(&self) {\n///         // let's not worry about implementing baz() for now\n///         unimplemented!();\n///     }\n/// }\n///\n/// fn main() {\n///     let s = MyStruct;\n///     s.bar();\n///\n///     // we aren't even using baz() yet, so this is fine.\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! unimplemented {\n    () => (panic!(\"not yet implemented\"));\n    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)*)));\n}\n\n/// Built-in macros to the compiler itself.\n///\n/// These macros do not have any corresponding definition with a `macro_rules!`\n/// macro, but are documented here. Their implementations can be found hardcoded\n/// into libsyntax itself.\n///\n/// For more information, see documentation for `std`'s macros.\nmod builtin {\n\n    /// Unconditionally causes compilation to fail with the given error message when encountered.\n    ///\n    /// For more information, see the [RFC].\n    ///\n    /// [RFC]: https://github.com/rust-lang/rfcs/blob/master/text/1695-add-error-macro.md\n    #[unstable(feature = \"compile_error_macro\", issue = \"40872\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! compile_error { ($msg:expr) => ({ /* compiler built-in */ }) }\n\n    /// The core macro for formatted string creation & output.\n    ///\n    /// For more information, see the documentation for [`std::format_args!`].\n    ///\n    /// [`std::format_args!`]: ../std/macro.format_args.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! format_args { ($fmt:expr, $($args:tt)*) => ({\n        /* compiler built-in */\n    }) }\n\n    /// Inspect an environment variable at compile time.\n    ///\n    /// For more information, see the documentation for [`std::env!`].\n    ///\n    /// [`std::env!`]: ../std/macro.env.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! env { ($name:expr) => ({ /* compiler built-in */ }) }\n\n    /// Optionally inspect an environment variable at compile time.\n    ///\n    /// For more information, see the documentation for [`std::option_env!`].\n    ///\n    /// [`std::option_env!`]: ../std/macro.option_env.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n\n    /// Concatenate identifiers into one identifier.\n    ///\n    /// For more information, see the documentation for [`std::concat_idents!`].\n    ///\n    /// [`std::concat_idents!`]: ../std/macro.concat_idents.html\n    #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! concat_idents {\n        ($($e:ident),*) => ({ /* compiler built-in */ })\n    }\n\n    /// Concatenates literals into a static string slice.\n    ///\n    /// For more information, see the documentation for [`std::concat!`].\n    ///\n    /// [`std::concat!`]: ../std/macro.concat.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! concat { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n\n    /// A macro which expands to the line number on which it was invoked.\n    ///\n    /// For more information, see the documentation for [`std::line!`].\n    ///\n    /// [`std::line!`]: ../std/macro.line.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! line { () => ({ /* compiler built-in */ }) }\n\n    /// A macro which expands to the column number on which it was invoked.\n    ///\n    /// For more information, see the documentation for [`std::column!`].\n    ///\n    /// [`std::column!`]: ../std/macro.column.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! column { () => ({ /* compiler built-in */ }) }\n\n    /// A macro which expands to the file name from which it was invoked.\n    ///\n    /// For more information, see the documentation for [`std::file!`].\n    ///\n    /// [`std::file!`]: ../std/macro.file.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! file { () => ({ /* compiler built-in */ }) }\n\n    /// A macro which stringifies its argument.\n    ///\n    /// For more information, see the documentation for [`std::stringify!`].\n    ///\n    /// [`std::stringify!`]: ../std/macro.stringify.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! stringify { ($t:tt) => ({ /* compiler built-in */ }) }\n\n    /// Includes a utf8-encoded file as a string.\n    ///\n    /// For more information, see the documentation for [`std::include_str!`].\n    ///\n    /// [`std::include_str!`]: ../std/macro.include_str.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n\n    /// Includes a file as a reference to a byte array.\n    ///\n    /// For more information, see the documentation for [`std::include_bytes!`].\n    ///\n    /// [`std::include_bytes!`]: ../std/macro.include_bytes.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n\n    /// Expands to a string that represents the current module path.\n    ///\n    /// For more information, see the documentation for [`std::module_path!`].\n    ///\n    /// [`std::module_path!`]: ../std/macro.module_path.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n\n    /// Boolean evaluation of configuration flags.\n    ///\n    /// For more information, see the documentation for [`std::cfg!`].\n    ///\n    /// [`std::cfg!`]: ../std/macro.cfg.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n\n    /// Parse a file as an expression or an item according to the context.\n    ///\n    /// For more information, see the documentation for [`std::include!`].\n    ///\n    /// [`std::include!`]: ../std/macro.include.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! include { ($file:expr) => ({ /* compiler built-in */ }) }\n}\n","// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Thread local storage\n\n#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n\nuse cell::UnsafeCell;\nuse fmt;\nuse mem;\n\n/// A thread local storage key which owns its contents.\n///\n/// This key uses the fastest possible implementation available to it for the\n/// target platform. It is instantiated with the [`thread_local!`] macro and the\n/// primary method is the [`with`] method.\n///\n/// The [`with`] method yields a reference to the contained value which cannot be\n/// sent across threads or escape the given closure.\n///\n/// # Initialization and Destruction\n///\n/// Initialization is dynamically performed on the first call to [`with`]\n/// within a thread, and values that implement [`Drop`] get destructed when a\n/// thread exits. Some caveats apply, which are explained below.\n///\n/// # Examples\n///\n/// ```\n/// use std::cell::RefCell;\n/// use std::thread;\n///\n/// thread_local!(static FOO: RefCell<u32> = RefCell::new(1));\n///\n/// FOO.with(|f| {\n///     assert_eq!(*f.borrow(), 1);\n///     *f.borrow_mut() = 2;\n/// });\n///\n/// // each thread starts out with the initial value of 1\n/// thread::spawn(move|| {\n///     FOO.with(|f| {\n///         assert_eq!(*f.borrow(), 1);\n///         *f.borrow_mut() = 3;\n///     });\n/// });\n///\n/// // we retain our original value of 2 despite the child thread\n/// FOO.with(|f| {\n///     assert_eq!(*f.borrow(), 2);\n/// });\n/// ```\n///\n/// # Platform-specific behavior\n///\n/// Note that a \"best effort\" is made to ensure that destructors for types\n/// stored in thread local storage are run, but not all platforms can guarantee\n/// that destructors will be run for all types in thread local storage. For\n/// example, there are a number of known caveats where destructors are not run:\n///\n/// 1. On Unix systems when pthread-based TLS is being used, destructors will\n///    not be run for TLS values on the main thread when it exits. Note that the\n///    application will exit immediately after the main thread exits as well.\n/// 2. On all platforms it's possible for TLS to re-initialize other TLS slots\n///    during destruction. Some platforms ensure that this cannot happen\n///    infinitely by preventing re-initialization of any slot that has been\n///    destroyed, but not all platforms have this guard. Those platforms that do\n///    not guard typically have a synthetic limit after which point no more\n///    destructors are run.\n/// 3. On macOS, initializing TLS during destruction of other TLS slots can\n///    sometimes cancel *all* destructors for the current thread, whether or not\n///    the slots have already had their destructors run or not.\n///\n/// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n/// [`thread_local!`]: ../../std/macro.thread_local.html\n/// [`Drop`]: ../../std/ops/trait.Drop.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct LocalKey<T: 'static> {\n    // This outer `LocalKey<T>` type is what's going to be stored in statics,\n    // but actual data inside will sometimes be tagged with #[thread_local].\n    // It's not valid for a true static to reference a #[thread_local] static,\n    // so we get around that by exposing an accessor through a layer of function\n    // indirection (this thunk).\n    //\n    // Note that the thunk is itself unsafe because the returned lifetime of the\n    // slot where data lives, `'static`, is not actually valid. The lifetime\n    // here is actually `'thread`!\n    //\n    // Although this is an extra layer of indirection, it should in theory be\n    // trivially devirtualizable by LLVM because the value of `inner` never\n    // changes and the constant should be readonly within a crate. This mainly\n    // only runs into problems when TLS statics are exported across crates.\n    inner: fn() -> Option<&'static UnsafeCell<Option<T>>>,\n\n    // initialization routine to invoke to create a value\n    init: fn() -> T,\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T: 'static> fmt::Debug for LocalKey<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"LocalKey { .. }\")\n    }\n}\n\n/// Declare a new thread local storage key of type [`std::thread::LocalKey`].\n///\n/// # Syntax\n///\n/// The macro wraps any number of static declarations and makes them thread local.\n/// Each static may be public or private, and attributes are allowed. Example:\n///\n/// ```\n/// use std::cell::RefCell;\n/// thread_local! {\n///     pub static FOO: RefCell<u32> = RefCell::new(1);\n///\n///     #[allow(unused)]\n///     static BAR: RefCell<f32> = RefCell::new(1.0);\n/// }\n/// # fn main() {}\n/// ```\n///\n/// See [LocalKey documentation][`std::thread::LocalKey`] for more\n/// information.\n///\n/// [`std::thread::LocalKey`]: ../std/thread/struct.LocalKey.html\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable]\nmacro_rules! thread_local {\n    // rule 0: empty (base case for the recursion)\n    () => {};\n\n    // rule 1: process multiple declarations where the first one is private\n    ($(#[$attr:meta])* static $name:ident: $t:ty = $init:expr; $($rest:tt)*) => (\n        thread_local!($(#[$attr])* static $name: $t = $init); // go to rule 2\n        thread_local!($($rest)*);\n    );\n\n    // rule 2: handle a single private declaration\n    ($(#[$attr:meta])* static $name:ident: $t:ty = $init:expr) => (\n        $(#[$attr])* static $name: $crate::thread::LocalKey<$t> =\n            __thread_local_inner!($t, $init);\n    );\n\n    // rule 3: handle multiple declarations where the first one is public\n    ($(#[$attr:meta])* pub static $name:ident: $t:ty = $init:expr; $($rest:tt)*) => (\n        thread_local!($(#[$attr])* pub static $name: $t = $init); // go to rule 4\n        thread_local!($($rest)*);\n    );\n\n    // rule 4: handle a single public declaration\n    ($(#[$attr:meta])* pub static $name:ident: $t:ty = $init:expr) => (\n        $(#[$attr])* pub static $name: $crate::thread::LocalKey<$t> =\n            __thread_local_inner!($t, $init);\n    );\n}\n\n#[doc(hidden)]\n#[unstable(feature = \"thread_local_internals\",\n           reason = \"should not be necessary\",\n           issue = \"0\")]\n#[macro_export]\n#[allow_internal_unstable]\nmacro_rules! __thread_local_inner {\n    ($t:ty, $init:expr) => {{\n        fn __init() -> $t { $init }\n\n        fn __getit() -> $crate::option::Option<\n            &'static $crate::cell::UnsafeCell<\n                $crate::option::Option<$t>>>\n        {\n            #[thread_local]\n            #[cfg(target_thread_local)]\n            static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n                $crate::thread::__FastLocalKeyInner::new();\n\n            #[cfg(not(target_thread_local))]\n            static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                $crate::thread::__OsLocalKeyInner::new();\n\n            __KEY.get()\n        }\n\n        $crate::thread::LocalKey::new(__getit, __init)\n    }}\n}\n\n/// Indicator of the state of a thread local storage key.\n#[unstable(feature = \"thread_local_state\",\n           reason = \"state querying was recently added\",\n           issue = \"27716\")]\n#[derive(Debug, Eq, PartialEq, Copy, Clone)]\npub enum LocalKeyState {\n    /// All keys are in this state whenever a thread starts. Keys will\n    /// transition to the `Valid` state once the first call to [`with`] happens\n    /// and the initialization expression succeeds.\n    ///\n    /// Keys in the `Uninitialized` state will yield a reference to the closure\n    /// passed to [`with`] so long as the initialization routine does not panic.\n    ///\n    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n    Uninitialized,\n\n    /// Once a key has been accessed successfully, it will enter the `Valid`\n    /// state. Keys in the `Valid` state will remain so until the thread exits,\n    /// at which point the destructor will be run and the key will enter the\n    /// `Destroyed` state.\n    ///\n    /// Keys in the `Valid` state will be guaranteed to yield a reference to the\n    /// closure passed to [`with`].\n    ///\n    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n    Valid,\n\n    /// When a thread exits, the destructors for keys will be run (if\n    /// necessary). While a destructor is running, and possibly after a\n    /// destructor has run, a key is in the `Destroyed` state.\n    ///\n    /// Keys in the `Destroyed` states will trigger a panic when accessed via\n    /// [`with`].\n    ///\n    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n    Destroyed,\n}\n\nimpl<T: 'static> LocalKey<T> {\n    #[doc(hidden)]\n    #[unstable(feature = \"thread_local_internals\",\n               reason = \"recently added to create a key\",\n               issue = \"0\")]\n    pub const fn new(inner: fn() -> Option<&'static UnsafeCell<Option<T>>>,\n                     init: fn() -> T) -> LocalKey<T> {\n        LocalKey {\n            inner: inner,\n            init: init,\n        }\n    }\n\n    /// Acquires a reference to the value in this TLS key.\n    ///\n    /// This will lazily initialize the value if this thread has not referenced\n    /// this key yet.\n    ///\n    /// # Panics\n    ///\n    /// This function will `panic!()` if the key currently has its\n    /// destructor running, and it **may** panic if the destructor has\n    /// previously been run for this thread.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with<F, R>(&'static self, f: F) -> R\n                      where F: FnOnce(&T) -> R {\n        unsafe {\n            let slot = (self.inner)();\n            let slot = slot.expect(\"cannot access a TLS value during or \\\n                                    after it is destroyed\");\n            f(match *slot.get() {\n                Some(ref inner) => inner,\n                None => self.init(slot),\n            })\n        }\n    }\n\n    unsafe fn init(&self, slot: &UnsafeCell<Option<T>>) -> &T {\n        // Execute the initialization up front, *then* move it into our slot,\n        // just in case initialization fails.\n        let value = (self.init)();\n        let ptr = slot.get();\n\n        // note that this can in theory just be `*ptr = Some(value)`, but due to\n        // the compiler will currently codegen that pattern with something like:\n        //\n        //      ptr::drop_in_place(ptr)\n        //      ptr::write(ptr, Some(value))\n        //\n        // Due to this pattern it's possible for the destructor of the value in\n        // `ptr` (e.g. if this is being recursively initialized) to re-access\n        // TLS, in which case there will be a `&` and `&mut` pointer to the same\n        // value (an aliasing violation). To avoid setting the \"I'm running a\n        // destructor\" flag we just use `mem::replace` which should sequence the\n        // operations a little differently and make this safe to call.\n        mem::replace(&mut *ptr, Some(value));\n\n        (*ptr).as_ref().unwrap()\n    }\n\n    /// Query the current state of this key.\n    ///\n    /// A key is initially in the `Uninitialized` state whenever a thread\n    /// starts. It will remain in this state up until the first call to [`with`]\n    /// within a thread has run the initialization expression successfully.\n    ///\n    /// Once the initialization expression succeeds, the key transitions to the\n    /// `Valid` state which will guarantee that future calls to [`with`] will\n    /// succeed within the thread.\n    ///\n    /// When a thread exits, each key will be destroyed in turn, and as keys are\n    /// destroyed they will enter the `Destroyed` state just before the\n    /// destructor starts to run. Keys may remain in the `Destroyed` state after\n    /// destruction has completed. Keys without destructors (e.g. with types\n    /// that are [`Copy`]), may never enter the `Destroyed` state.\n    ///\n    /// Keys in the `Uninitialized` state can be accessed so long as the\n    /// initialization does not panic. Keys in the `Valid` state are guaranteed\n    /// to be able to be accessed. Keys in the `Destroyed` state will panic on\n    /// any call to [`with`].\n    ///\n    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n    /// [`Copy`]: ../../std/marker/trait.Copy.html\n    #[unstable(feature = \"thread_local_state\",\n               reason = \"state querying was recently added\",\n               issue = \"27716\")]\n    pub fn state(&'static self) -> LocalKeyState {\n        unsafe {\n            match (self.inner)() {\n                Some(cell) => {\n                    match *cell.get() {\n                        Some(..) => LocalKeyState::Valid,\n                        None => LocalKeyState::Uninitialized,\n                    }\n                }\n                None => LocalKeyState::Destroyed,\n            }\n        }\n    }\n}\n\n#[doc(hidden)]\n#[cfg(target_thread_local)]\npub mod fast {\n    use cell::{Cell, UnsafeCell};\n    use fmt;\n    use mem;\n    use ptr;\n    use sys::fast_thread_local::{register_dtor, requires_move_before_drop};\n\n    pub struct Key<T> {\n        inner: UnsafeCell<Option<T>>,\n\n        // Metadata to keep track of the state of the destructor. Remember that\n        // these variables are thread-local, not global.\n        dtor_registered: Cell<bool>,\n        dtor_running: Cell<bool>,\n    }\n\n    impl<T> fmt::Debug for Key<T> {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            f.pad(\"Key { .. }\")\n        }\n    }\n\n    unsafe impl<T> ::marker::Sync for Key<T> { }\n\n    impl<T> Key<T> {\n        pub const fn new() -> Key<T> {\n            Key {\n                inner: UnsafeCell::new(None),\n                dtor_registered: Cell::new(false),\n                dtor_running: Cell::new(false)\n            }\n        }\n\n        pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n            unsafe {\n                if mem::needs_drop::<T>() && self.dtor_running.get() {\n                    return None\n                }\n                self.register_dtor();\n            }\n            Some(&self.inner)\n        }\n\n        unsafe fn register_dtor(&self) {\n            if !mem::needs_drop::<T>() || self.dtor_registered.get() {\n                return\n            }\n\n            register_dtor(self as *const _ as *mut u8,\n                          destroy_value::<T>);\n            self.dtor_registered.set(true);\n        }\n    }\n\n    unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n        let ptr = ptr as *mut Key<T>;\n        // Right before we run the user destructor be sure to flag the\n        // destructor as running for this thread so calls to `get` will return\n        // `None`.\n        (*ptr).dtor_running.set(true);\n\n        // Some implementations may require us to move the value before we drop\n        // it as it could get re-initialized in-place during destruction.\n        //\n        // Hence, we use `ptr::read` on those platforms (to move to a \"safe\"\n        // location) instead of drop_in_place.\n        if requires_move_before_drop() {\n            ptr::read((*ptr).inner.get());\n        } else {\n            ptr::drop_in_place((*ptr).inner.get());\n        }\n    }\n}\n\n#[doc(hidden)]\npub mod os {\n    use cell::{Cell, UnsafeCell};\n    use fmt;\n    use marker;\n    use ptr;\n    use sys_common::thread_local::StaticKey as OsStaticKey;\n\n    pub struct Key<T> {\n        // OS-TLS key that we'll use to key off.\n        os: OsStaticKey,\n        marker: marker::PhantomData<Cell<T>>,\n    }\n\n    impl<T> fmt::Debug for Key<T> {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            f.pad(\"Key { .. }\")\n        }\n    }\n\n    unsafe impl<T> ::marker::Sync for Key<T> { }\n\n    struct Value<T: 'static> {\n        key: &'static Key<T>,\n        value: UnsafeCell<Option<T>>,\n    }\n\n    impl<T: 'static> Key<T> {\n        pub const fn new() -> Key<T> {\n            Key {\n                os: OsStaticKey::new(Some(destroy_value::<T>)),\n                marker: marker::PhantomData\n            }\n        }\n\n        pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n            unsafe {\n                let ptr = self.os.get() as *mut Value<T>;\n                if !ptr.is_null() {\n                    if ptr as usize == 1 {\n                        return None\n                    }\n                    return Some(&(*ptr).value);\n                }\n\n                // If the lookup returned null, we haven't initialized our own\n                // local copy, so do that now.\n                let ptr: Box<Value<T>> = box Value {\n                    key: self,\n                    value: UnsafeCell::new(None),\n                };\n                let ptr = Box::into_raw(ptr);\n                self.os.set(ptr as *mut u8);\n                Some(&(*ptr).value)\n            }\n        }\n    }\n\n    unsafe extern fn destroy_value<T: 'static>(ptr: *mut u8) {\n        // The OS TLS ensures that this key contains a NULL value when this\n        // destructor starts to run. We set it back to a sentinel value of 1 to\n        // ensure that any future calls to `get` for this thread will return\n        // `None`.\n        //\n        // Note that to prevent an infinite loop we reset it back to null right\n        // before we return from the destructor ourselves.\n        let ptr = Box::from_raw(ptr as *mut Value<T>);\n        let key = ptr.key;\n        key.os.set(1 as *mut u8);\n        drop(ptr);\n        key.os.set(ptr::null_mut());\n    }\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use sync::mpsc::{channel, Sender};\n    use cell::{Cell, UnsafeCell};\n    use super::LocalKeyState;\n    use thread;\n\n    struct Foo(Sender<()>);\n\n    impl Drop for Foo {\n        fn drop(&mut self) {\n            let Foo(ref s) = *self;\n            s.send(()).unwrap();\n        }\n    }\n\n    #[test]\n    fn smoke_no_dtor() {\n        thread_local!(static FOO: Cell<i32> = Cell::new(1));\n\n        FOO.with(|f| {\n            assert_eq!(f.get(), 1);\n            f.set(2);\n        });\n        let (tx, rx) = channel();\n        let _t = thread::spawn(move|| {\n            FOO.with(|f| {\n                assert_eq!(f.get(), 1);\n            });\n            tx.send(()).unwrap();\n        });\n        rx.recv().unwrap();\n\n        FOO.with(|f| {\n            assert_eq!(f.get(), 2);\n        });\n    }\n\n    #[test]\n    fn states() {\n        struct Foo;\n        impl Drop for Foo {\n            fn drop(&mut self) {\n                assert!(FOO.state() == LocalKeyState::Destroyed);\n            }\n        }\n        fn foo() -> Foo {\n            assert!(FOO.state() == LocalKeyState::Uninitialized);\n            Foo\n        }\n        thread_local!(static FOO: Foo = foo());\n\n        thread::spawn(|| {\n            assert!(FOO.state() == LocalKeyState::Uninitialized);\n            FOO.with(|_| {\n                assert!(FOO.state() == LocalKeyState::Valid);\n            });\n            assert!(FOO.state() == LocalKeyState::Valid);\n        }).join().ok().unwrap();\n    }\n\n    #[test]\n    fn smoke_dtor() {\n        thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n\n        let (tx, rx) = channel();\n        let _t = thread::spawn(move|| unsafe {\n            let mut tx = Some(tx);\n            FOO.with(|f| {\n                *f.get() = Some(Foo(tx.take().unwrap()));\n            });\n        });\n        rx.recv().unwrap();\n    }\n\n    #[test]\n    fn circular() {\n        struct S1;\n        struct S2;\n        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n        thread_local!(static K2: UnsafeCell<Option<S2>> = UnsafeCell::new(None));\n        static mut HITS: u32 = 0;\n\n        impl Drop for S1 {\n            fn drop(&mut self) {\n                unsafe {\n                    HITS += 1;\n                    if K2.state() == LocalKeyState::Destroyed {\n                        assert_eq!(HITS, 3);\n                    } else {\n                        if HITS == 1 {\n                            K2.with(|s| *s.get() = Some(S2));\n                        } else {\n                            assert_eq!(HITS, 3);\n                        }\n                    }\n                }\n            }\n        }\n        impl Drop for S2 {\n            fn drop(&mut self) {\n                unsafe {\n                    HITS += 1;\n                    assert!(K1.state() != LocalKeyState::Destroyed);\n                    assert_eq!(HITS, 2);\n                    K1.with(|s| *s.get() = Some(S1));\n                }\n            }\n        }\n\n        thread::spawn(move|| {\n            drop(S1);\n        }).join().ok().unwrap();\n    }\n\n    #[test]\n    fn self_referential() {\n        struct S1;\n        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n\n        impl Drop for S1 {\n            fn drop(&mut self) {\n                assert!(K1.state() == LocalKeyState::Destroyed);\n            }\n        }\n\n        thread::spawn(move|| unsafe {\n            K1.with(|s| *s.get() = Some(S1));\n        }).join().ok().unwrap();\n    }\n\n    // Note that this test will deadlock if TLS destructors aren't run (this\n    // requires the destructor to be run to pass the test). macOS has a known bug\n    // where dtors-in-dtors may cancel other destructors, so we just ignore this\n    // test on macOS.\n    #[test]\n    #[cfg_attr(target_os = \"macos\", ignore)]\n    fn dtors_in_dtors_in_dtors() {\n        struct S1(Sender<()>);\n        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n        thread_local!(static K2: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n\n        impl Drop for S1 {\n            fn drop(&mut self) {\n                let S1(ref tx) = *self;\n                unsafe {\n                    if K2.state() != LocalKeyState::Destroyed {\n                        K2.with(|s| *s.get() = Some(Foo(tx.clone())));\n                    }\n                }\n            }\n        }\n\n        let (tx, rx) = channel();\n        let _t = thread::spawn(move|| unsafe {\n            let mut tx = Some(tx);\n            K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n        });\n        rx.recv().unwrap();\n    }\n}\n\n#[cfg(test)]\nmod dynamic_tests {\n    use cell::RefCell;\n    use collections::HashMap;\n\n    #[test]\n    fn smoke() {\n        fn square(i: i32) -> i32 { i * i }\n        thread_local!(static FOO: i32 = square(3));\n\n        FOO.with(|f| {\n            assert_eq!(*f, 9);\n        });\n    }\n\n    #[test]\n    fn hashmap() {\n        fn map() -> RefCell<HashMap<i32, i32>> {\n            let mut m = HashMap::new();\n            m.insert(1, 2);\n            RefCell::new(m)\n        }\n        thread_local!(static FOO: RefCell<HashMap<i32, i32>> = map());\n\n        FOO.with(|map| {\n            assert_eq!(map.borrow()[&1], 2);\n        });\n    }\n\n    #[test]\n    fn refcell_vec() {\n        thread_local!(static FOO: RefCell<Vec<u32>> = RefCell::new(vec![1, 2, 3]));\n\n        FOO.with(|vec| {\n            assert_eq!(vec.borrow().len(), 3);\n            vec.borrow_mut().push(4);\n            assert_eq!(vec.borrow()[3], 4);\n        });\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse libc;\nuse cell::UnsafeCell;\nuse sync::atomic::{AtomicUsize, Ordering};\n\npub struct RWLock {\n    inner: UnsafeCell<libc::pthread_rwlock_t>,\n    write_locked: UnsafeCell<bool>,\n    num_readers: AtomicUsize,\n}\n\nunsafe impl Send for RWLock {}\nunsafe impl Sync for RWLock {}\n\nimpl RWLock {\n    pub const fn new() -> RWLock {\n        RWLock {\n            inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n            write_locked: UnsafeCell::new(false),\n            num_readers: AtomicUsize::new(0),\n        }\n    }\n    #[inline]\n    pub unsafe fn read(&self) {\n        let r = libc::pthread_rwlock_rdlock(self.inner.get());\n\n        // According to the pthread_rwlock_rdlock spec, this function **may**\n        // fail with EDEADLK if a deadlock is detected. On the other hand\n        // pthread mutexes will *never* return EDEADLK if they are initialized\n        // as the \"fast\" kind (which ours always are). As a result, a deadlock\n        // situation may actually return from the call to pthread_rwlock_rdlock\n        // instead of blocking forever (as mutexes and Windows rwlocks do). Note\n        // that not all unix implementations, however, will return EDEADLK for\n        // their rwlocks.\n        //\n        // We roughly maintain the deadlocking behavior by panicking to ensure\n        // that this lock acquisition does not succeed.\n        //\n        // We also check whether this lock is already write locked. This\n        // is only possible if it was write locked by the current thread and\n        // the implementation allows recursive locking. The POSIX standard\n        // doesn't require recursively locking a rwlock to deadlock, but we can't\n        // allow that because it could lead to aliasing issues.\n        if r == libc::EAGAIN {\n            panic!(\"rwlock maximum reader count exceeded\");\n        } else if r == libc::EDEADLK || *self.write_locked.get() {\n            if r == 0 {\n                self.raw_unlock();\n            }\n            panic!(\"rwlock read lock would result in deadlock\");\n        } else {\n            debug_assert_eq!(r, 0);\n            self.num_readers.fetch_add(1, Ordering::Relaxed);\n        }\n    }\n    #[inline]\n    pub unsafe fn try_read(&self) -> bool {\n        let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n        if r == 0 {\n            if *self.write_locked.get() {\n                self.raw_unlock();\n                false\n            } else {\n                self.num_readers.fetch_add(1, Ordering::Relaxed);\n                true\n            }\n        } else {\n            false\n        }\n    }\n    #[inline]\n    pub unsafe fn write(&self) {\n        let r = libc::pthread_rwlock_wrlock(self.inner.get());\n        // See comments above for why we check for EDEADLK and write_locked. We\n        // also need to check that num_readers is 0.\n        if r == libc::EDEADLK || *self.write_locked.get() ||\n           self.num_readers.load(Ordering::Relaxed) != 0 {\n            if r == 0 {\n                self.raw_unlock();\n            }\n            panic!(\"rwlock write lock would result in deadlock\");\n        } else {\n            debug_assert_eq!(r, 0);\n        }\n        *self.write_locked.get() = true;\n    }\n    #[inline]\n    pub unsafe fn try_write(&self) -> bool {\n        let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n        if r == 0 {\n            if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n                self.raw_unlock();\n                false\n            } else {\n                *self.write_locked.get() = true;\n                true\n            }\n        } else {\n            false\n        }\n    }\n    #[inline]\n    unsafe fn raw_unlock(&self) {\n        let r = libc::pthread_rwlock_unlock(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    pub unsafe fn read_unlock(&self) {\n        debug_assert!(!*self.write_locked.get());\n        self.num_readers.fetch_sub(1, Ordering::Relaxed);\n        self.raw_unlock();\n    }\n    #[inline]\n    pub unsafe fn write_unlock(&self) {\n        debug_assert_eq!(self.num_readers.load(Ordering::Relaxed), 0);\n        debug_assert!(*self.write_locked.get());\n        *self.write_locked.get() = false;\n        self.raw_unlock();\n    }\n    #[inline]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_rwlock_destroy(self.inner.get());\n        // On DragonFly pthread_rwlock_destroy() returns EINVAL if called on a\n        // rwlock that was just initialized with\n        // libc::PTHREAD_RWLOCK_INITIALIZER. Once it is used (locked/unlocked)\n        // or pthread_rwlock_init() is called, this behaviour no longer occurs.\n        if cfg!(target_os = \"dragonfly\") {\n            debug_assert!(r == 0 || r == libc::EINVAL);\n        } else {\n            debug_assert_eq!(r, 0);\n        }\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Atomic types\n//!\n//! Atomic types provide primitive shared-memory communication between\n//! threads, and are the building blocks of other concurrent\n//! types.\n//!\n//! This module defines atomic versions of a select number of primitive\n//! types, including [`AtomicBool`], [`AtomicIsize`], and [`AtomicUsize`].\n//! Atomic types present operations that, when used correctly, synchronize\n//! updates between threads.\n//!\n//! [`AtomicBool`]: struct.AtomicBool.html\n//! [`AtomicIsize`]: struct.AtomicIsize.html\n//! [`AtomicUsize`]: struct.AtomicUsize.html\n//!\n//! Each method takes an [`Ordering`] which represents the strength of\n//! the memory barrier for that operation. These orderings are the\n//! same as [LLVM atomic orderings][1]. For more information see the [nomicon][2].\n//!\n//! [`Ordering`]: enum.Ordering.html\n//!\n//! [1]: http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n//! [2]: ../../../nomicon/atomics.html\n//!\n//! Atomic variables are safe to share between threads (they implement [`Sync`])\n//! but they do not themselves provide the mechanism for sharing and follow the\n//! [threading model](../../../std/thread/index.html#the-threading-model) of rust.\n//! The most common way to share an atomic variable is to put it into an [`Arc`][arc] (an\n//! atomically-reference-counted shared pointer).\n//!\n//! [`Sync`]: ../../marker/trait.Sync.html\n//! [arc]: ../../../std/sync/struct.Arc.html\n//!\n//! Most atomic types may be stored in static variables, initialized using\n//! the provided static initializers like [`ATOMIC_BOOL_INIT`]. Atomic statics\n//! are often used for lazy global initialization.\n//!\n//! [`ATOMIC_BOOL_INIT`]: constant.ATOMIC_BOOL_INIT.html\n//!\n//! # Examples\n//!\n//! A simple spinlock:\n//!\n//! ```\n//! use std::sync::Arc;\n//! use std::sync::atomic::{AtomicUsize, Ordering};\n//! use std::thread;\n//!\n//! fn main() {\n//!     let spinlock = Arc::new(AtomicUsize::new(1));\n//!\n//!     let spinlock_clone = spinlock.clone();\n//!     let thread = thread::spawn(move|| {\n//!         spinlock_clone.store(0, Ordering::SeqCst);\n//!     });\n//!\n//!     // Wait for the other thread to release the lock\n//!     while spinlock.load(Ordering::SeqCst) != 0 {}\n//!\n//!     if let Err(panic) = thread.join() {\n//!         println!(\"Thread had an error: {:?}\", panic);\n//!     }\n//! }\n//! ```\n//!\n//! Keep a global count of live threads:\n//!\n//! ```\n//! use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n//!\n//! static GLOBAL_THREAD_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n//!\n//! let old_thread_count = GLOBAL_THREAD_COUNT.fetch_add(1, Ordering::SeqCst);\n//! println!(\"live threads: {}\", old_thread_count + 1);\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![cfg_attr(not(target_has_atomic = \"8\"), allow(dead_code))]\n#![cfg_attr(not(target_has_atomic = \"8\"), allow(unused_imports))]\n\nuse self::Ordering::*;\n\nuse intrinsics;\nuse cell::UnsafeCell;\nuse fmt;\n\n/// Save power or switch hyperthreads in a busy-wait spin-loop.\n///\n/// This function is deliberately more primitive than\n/// `std::thread::yield_now` and does not directly yield to the\n/// system's scheduler.  In some cases it might be useful to use a\n/// combination of both functions.  Careful benchmarking is advised.\n///\n/// On some platforms this function may not do anything at all.\n#[inline]\n#[unstable(feature = \"hint_core_should_pause\", issue = \"41196\")]\npub fn hint_core_should_pause()\n{\n    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n    unsafe {\n        asm!(\"pause\" ::: \"memory\" : \"volatile\");\n    }\n\n    #[cfg(target_arch = \"aarch64\")]\n    unsafe {\n        asm!(\"yield\" ::: \"memory\" : \"volatile\");\n    }\n}\n\n/// A boolean type which can be safely shared between threads.\n///\n/// This type has the same in-memory representation as a `bool`.\n#[cfg(target_has_atomic = \"8\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct AtomicBool {\n    v: UnsafeCell<u8>,\n}\n\n#[cfg(target_has_atomic = \"8\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Default for AtomicBool {\n    /// Creates an `AtomicBool` initialized to `false`.\n    fn default() -> Self {\n        Self::new(false)\n    }\n}\n\n// Send is implicitly implemented for AtomicBool.\n#[cfg(target_has_atomic = \"8\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl Sync for AtomicBool {}\n\n/// A raw pointer type which can be safely shared between threads.\n///\n/// This type has the same in-memory representation as a `*mut T`.\n#[cfg(target_has_atomic = \"ptr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct AtomicPtr<T> {\n    p: UnsafeCell<*mut T>,\n}\n\n#[cfg(target_has_atomic = \"ptr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for AtomicPtr<T> {\n    /// Creates a null `AtomicPtr<T>`.\n    fn default() -> AtomicPtr<T> {\n        AtomicPtr::new(::ptr::null_mut())\n    }\n}\n\n#[cfg(target_has_atomic = \"ptr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T> Send for AtomicPtr<T> {}\n#[cfg(target_has_atomic = \"ptr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T> Sync for AtomicPtr<T> {}\n\n/// Atomic memory orderings\n///\n/// Memory orderings limit the ways that both the compiler and CPU may reorder\n/// instructions around atomic operations. At its most restrictive,\n/// \"sequentially consistent\" atomics allow neither reads nor writes\n/// to be moved either before or after the atomic operation; on the other end\n/// \"relaxed\" atomics allow all reorderings.\n///\n/// Rust's memory orderings are [the same as\n/// LLVM's](http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n///\n/// For more information see the [nomicon].\n///\n/// [nomicon]: ../../../nomicon/atomics.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone, Debug)]\npub enum Ordering {\n    /// No ordering constraints, only atomic operations.\n    ///\n    /// Corresponds to LLVM's [`Monotonic`] ordering.\n    ///\n    /// [`Monotonic`]: http://llvm.org/docs/Atomics.html#monotonic\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Relaxed,\n    /// When coupled with a store, all previous writes become visible\n    /// to the other threads that perform a load with [`Acquire`] ordering\n    /// on the same value.\n    ///\n    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Release,\n    /// When coupled with a load, all subsequent loads will see data\n    /// written before a store with [`Release`] ordering on the same value\n    /// in other threads.\n    ///\n    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Acquire,\n    /// When coupled with a load, uses [`Acquire`] ordering, and with a store\n    /// [`Release`] ordering.\n    ///\n    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AcqRel,\n    /// Like `AcqRel` with the additional guarantee that all threads see all\n    /// sequentially consistent operations in the same order.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    SeqCst,\n    // Prevent exhaustive matching to allow for future extension\n    #[doc(hidden)]\n    #[unstable(feature = \"future_atomic_orderings\", issue = \"0\")]\n    __Nonexhaustive,\n}\n\n/// An [`AtomicBool`] initialized to `false`.\n///\n/// [`AtomicBool`]: struct.AtomicBool.html\n#[cfg(target_has_atomic = \"8\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n\n#[cfg(target_has_atomic = \"8\")]\nimpl AtomicBool {\n    /// Creates a new `AtomicBool`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicBool;\n    ///\n    /// let atomic_true  = AtomicBool::new(true);\n    /// let atomic_false = AtomicBool::new(false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn new(v: bool) -> AtomicBool {\n        AtomicBool { v: UnsafeCell::new(v as u8) }\n    }\n\n    /// Returns a mutable reference to the underlying `bool`.\n    ///\n    /// This is safe because the mutable reference guarantees that no other threads are\n    /// concurrently accessing the atomic data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let mut some_bool = AtomicBool::new(true);\n    /// assert_eq!(*some_bool.get_mut(), true);\n    /// *some_bool.get_mut() = false;\n    /// assert_eq!(some_bool.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n    pub fn get_mut(&mut self) -> &mut bool {\n        unsafe { &mut *(self.v.get() as *mut bool) }\n    }\n\n    /// Consumes the atomic and returns the contained value.\n    ///\n    /// This is safe because passing `self` by value guarantees that no other threads are\n    /// concurrently accessing the atomic data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicBool;\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    /// assert_eq!(some_bool.into_inner(), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n    pub fn into_inner(self) -> bool {\n        unsafe { self.v.into_inner() != 0 }\n    }\n\n    /// Loads a value from the bool.\n    ///\n    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `order` is [`Release`] or [`AcqRel`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn load(&self, order: Ordering) -> bool {\n        unsafe { atomic_load(self.v.get(), order) != 0 }\n    }\n\n    /// Stores a value into the bool.\n    ///\n    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation.\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// some_bool.store(false, Ordering::Relaxed);\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n    ///\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn store(&self, val: bool, order: Ordering) {\n        unsafe {\n            atomic_store(self.v.get(), val as u8, order);\n        }\n    }\n\n    /// Stores a value into the bool, returning the previous value.\n    ///\n    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation.\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// assert_eq!(some_bool.swap(false, Ordering::Relaxed), true);\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn swap(&self, val: bool, order: Ordering) -> bool {\n        unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n    }\n\n    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n    ///\n    /// The return value is always the previous value. If it is equal to `current`, then the value\n    /// was updated.\n    ///\n    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n    /// ordering of this operation.\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// assert_eq!(some_bool.compare_and_swap(true, false, Ordering::Relaxed), true);\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    ///\n    /// assert_eq!(some_bool.compare_and_swap(true, true, Ordering::Relaxed), false);\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n            Ok(x) => x,\n            Err(x) => x,\n        }\n    }\n\n    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n    ///\n    /// The return value is a result indicating whether the new value was written and containing\n    /// the previous value. On success this value is guaranteed to be equal to `current`.\n    ///\n    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. The first describes the required ordering if the\n    /// operation succeeds while the second describes the required ordering when the\n    /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and must\n    /// be equivalent or weaker than the success ordering.\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// assert_eq!(some_bool.compare_exchange(true,\n    ///                                       false,\n    ///                                       Ordering::Acquire,\n    ///                                       Ordering::Relaxed),\n    ///            Ok(true));\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    ///\n    /// assert_eq!(some_bool.compare_exchange(true, true,\n    ///                                       Ordering::SeqCst,\n    ///                                       Ordering::Acquire),\n    ///            Err(false));\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n    pub fn compare_exchange(&self,\n                            current: bool,\n                            new: bool,\n                            success: Ordering,\n                            failure: Ordering)\n                            -> Result<bool, bool> {\n        match unsafe {\n            atomic_compare_exchange(self.v.get(), current as u8, new as u8, success, failure)\n        } {\n            Ok(x) => Ok(x != 0),\n            Err(x) => Err(x != 0),\n        }\n    }\n\n    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n    ///\n    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n    /// comparison succeeds, which can result in more efficient code on some platforms. The\n    /// return value is a result indicating whether the new value was written and containing the\n    /// previous value.\n    ///\n    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. The first describes the required ordering if the operation\n    /// succeeds while the second describes the required ordering when the operation fails. The\n    /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n    /// weaker than the success ordering.\n    ///\n    /// [`compare_exchange`]: #method.compare_exchange\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let val = AtomicBool::new(false);\n    ///\n    /// let new = true;\n    /// let mut old = val.load(Ordering::Relaxed);\n    /// loop {\n    ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n    ///         Ok(_) => break,\n    ///         Err(x) => old = x,\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n    pub fn compare_exchange_weak(&self,\n                                 current: bool,\n                                 new: bool,\n                                 success: Ordering,\n                                 failure: Ordering)\n                                 -> Result<bool, bool> {\n        match unsafe {\n            atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8, success, failure)\n        } {\n            Ok(x) => Ok(x != 0),\n            Err(x) => Err(x != 0),\n        }\n    }\n\n    /// Logical \"and\" with a boolean value.\n    ///\n    /// Performs a logical \"and\" operation on the current value and the argument `val`, and sets\n    /// the new value to the result.\n    ///\n    /// Returns the previous value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_and(false, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_and(true, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(false);\n    /// assert_eq!(foo.fetch_and(false, Ordering::SeqCst), false);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n        unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n    }\n\n    /// Logical \"nand\" with a boolean value.\n    ///\n    /// Performs a logical \"nand\" operation on the current value and the argument `val`, and sets\n    /// the new value to the result.\n    ///\n    /// Returns the previous value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_nand(false, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_nand(true, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst) as usize, 0);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    ///\n    /// let foo = AtomicBool::new(false);\n    /// assert_eq!(foo.fetch_nand(false, Ordering::SeqCst), false);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n        // We can't use atomic_nand here because it can result in a bool with\n        // an invalid value. This happens because the atomic operation is done\n        // with an 8-bit integer internally, which would set the upper 7 bits.\n        // So we just use fetch_xor or swap instead.\n        if val {\n            // !(x & true) == !x\n            // We must invert the bool.\n            self.fetch_xor(true, order)\n        } else {\n            // !(x & false) == true\n            // We must set the bool to true.\n            self.swap(true, order)\n        }\n    }\n\n    /// Logical \"or\" with a boolean value.\n    ///\n    /// Performs a logical \"or\" operation on the current value and the argument `val`, and sets the\n    /// new value to the result.\n    ///\n    /// Returns the previous value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_or(false, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_or(true, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(false);\n    /// assert_eq!(foo.fetch_or(false, Ordering::SeqCst), false);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n        unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n    }\n\n    /// Logical \"xor\" with a boolean value.\n    ///\n    /// Performs a logical \"xor\" operation on the current value and the argument `val`, and sets\n    /// the new value to the result.\n    ///\n    /// Returns the previous value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_xor(false, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_xor(true, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    ///\n    /// let foo = AtomicBool::new(false);\n    /// assert_eq!(foo.fetch_xor(false, Ordering::SeqCst), false);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n        unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n    }\n}\n\n#[cfg(target_has_atomic = \"ptr\")]\nimpl<T> AtomicPtr<T> {\n    /// Creates a new `AtomicPtr`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicPtr;\n    ///\n    /// let ptr = &mut 5;\n    /// let atomic_ptr  = AtomicPtr::new(ptr);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn new(p: *mut T) -> AtomicPtr<T> {\n        AtomicPtr { p: UnsafeCell::new(p) }\n    }\n\n    /// Returns a mutable reference to the underlying pointer.\n    ///\n    /// This is safe because the mutable reference guarantees that no other threads are\n    /// concurrently accessing the atomic data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let mut atomic_ptr = AtomicPtr::new(&mut 10);\n    /// *atomic_ptr.get_mut() = &mut 5;\n    /// assert_eq!(unsafe { *atomic_ptr.load(Ordering::SeqCst) }, 5);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n    pub fn get_mut(&mut self) -> &mut *mut T {\n        unsafe { &mut *self.p.get() }\n    }\n\n    /// Consumes the atomic and returns the contained value.\n    ///\n    /// This is safe because passing `self` by value guarantees that no other threads are\n    /// concurrently accessing the atomic data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicPtr;\n    ///\n    /// let atomic_ptr = AtomicPtr::new(&mut 5);\n    /// assert_eq!(unsafe { *atomic_ptr.into_inner() }, 5);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n    pub fn into_inner(self) -> *mut T {\n        unsafe { self.p.into_inner() }\n    }\n\n    /// Loads a value from the pointer.\n    ///\n    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `order` is [`Release`] or [`AcqRel`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let value = some_ptr.load(Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn load(&self, order: Ordering) -> *mut T {\n        unsafe { atomic_load(self.p.get() as *mut usize, order) as *mut T }\n    }\n\n    /// Stores a value into the pointer.\n    ///\n    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation.\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let other_ptr = &mut 10;\n    ///\n    /// some_ptr.store(other_ptr, Ordering::Relaxed);\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n    ///\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn store(&self, ptr: *mut T, order: Ordering) {\n        unsafe {\n            atomic_store(self.p.get() as *mut usize, ptr as usize, order);\n        }\n    }\n\n    /// Stores a value into the pointer, returning the previous value.\n    ///\n    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation.\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let other_ptr = &mut 10;\n    ///\n    /// let value = some_ptr.swap(other_ptr, Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n        unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n    }\n\n    /// Stores a value into the pointer if the current value is the same as the `current` value.\n    ///\n    /// The return value is always the previous value. If it is equal to `current`, then the value\n    /// was updated.\n    ///\n    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n    /// ordering of this operation.\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let other_ptr   = &mut 10;\n    /// let another_ptr = &mut 10;\n    ///\n    /// let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n            Ok(x) => x,\n            Err(x) => x,\n        }\n    }\n\n    /// Stores a value into the pointer if the current value is the same as the `current` value.\n    ///\n    /// The return value is a result indicating whether the new value was written and containing\n    /// the previous value. On success this value is guaranteed to be equal to `current`.\n    ///\n    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. The first describes the required ordering if\n    /// the operation succeeds while the second describes the required ordering when\n    /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`]\n    /// and must be equivalent or weaker than the success ordering.\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let other_ptr   = &mut 10;\n    /// let another_ptr = &mut 10;\n    ///\n    /// let value = some_ptr.compare_exchange(other_ptr, another_ptr,\n    ///                                       Ordering::SeqCst, Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n    pub fn compare_exchange(&self,\n                            current: *mut T,\n                            new: *mut T,\n                            success: Ordering,\n                            failure: Ordering)\n                            -> Result<*mut T, *mut T> {\n        unsafe {\n            let res = atomic_compare_exchange(self.p.get() as *mut usize,\n                                              current as usize,\n                                              new as usize,\n                                              success,\n                                              failure);\n            match res {\n                Ok(x) => Ok(x as *mut T),\n                Err(x) => Err(x as *mut T),\n            }\n        }\n    }\n\n    /// Stores a value into the pointer if the current value is the same as the `current` value.\n    ///\n    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n    /// comparison succeeds, which can result in more efficient code on some platforms. The\n    /// return value is a result indicating whether the new value was written and containing the\n    /// previous value.\n    ///\n    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. The first describes the required ordering if the operation\n    /// succeeds while the second describes the required ordering when the operation fails. The\n    /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n    /// weaker than the success ordering.\n    ///\n    /// [`compare_exchange`]: #method.compare_exchange\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let some_ptr = AtomicPtr::new(&mut 5);\n    ///\n    /// let new = &mut 10;\n    /// let mut old = some_ptr.load(Ordering::Relaxed);\n    /// loop {\n    ///     match some_ptr.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n    ///         Ok(_) => break,\n    ///         Err(x) => old = x,\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n    pub fn compare_exchange_weak(&self,\n                                 current: *mut T,\n                                 new: *mut T,\n                                 success: Ordering,\n                                 failure: Ordering)\n                                 -> Result<*mut T, *mut T> {\n        unsafe {\n            let res = atomic_compare_exchange_weak(self.p.get() as *mut usize,\n                                                   current as usize,\n                                                   new as usize,\n                                                   success,\n                                                   failure);\n            match res {\n                Ok(x) => Ok(x as *mut T),\n                Err(x) => Err(x as *mut T),\n            }\n        }\n    }\n}\n\n#[cfg(target_has_atomic = \"ptr\")]\nmacro_rules! atomic_int {\n    ($stable:meta,\n     $stable_cxchg:meta,\n     $stable_debug:meta,\n     $stable_access:meta,\n     $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n        /// An integer type which can be safely shared between threads.\n        ///\n        /// This type has the same in-memory representation as the underlying integer type.\n        #[$stable]\n        pub struct $atomic_type {\n            v: UnsafeCell<$int_type>,\n        }\n\n        /// An atomic integer initialized to `0`.\n        #[$stable]\n        pub const $atomic_init: $atomic_type = $atomic_type::new(0);\n\n        #[$stable]\n        impl Default for $atomic_type {\n            fn default() -> Self {\n                Self::new(Default::default())\n            }\n        }\n\n        #[$stable_debug]\n        impl fmt::Debug for $atomic_type {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                f.debug_tuple(stringify!($atomic_type))\n                 .field(&self.load(Ordering::SeqCst))\n                 .finish()\n            }\n        }\n\n        // Send is implicitly implemented.\n        #[$stable]\n        unsafe impl Sync for $atomic_type {}\n\n        impl $atomic_type {\n            /// Creates a new atomic integer.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::AtomicIsize;\n            ///\n            /// let atomic_forty_two  = AtomicIsize::new(42);\n            /// ```\n            #[inline]\n            #[$stable]\n            pub const fn new(v: $int_type) -> Self {\n                $atomic_type {v: UnsafeCell::new(v)}\n            }\n\n            /// Returns a mutable reference to the underlying integer.\n            ///\n            /// This is safe because the mutable reference guarantees that no other threads are\n            /// concurrently accessing the atomic data.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::{AtomicIsize, Ordering};\n            ///\n            /// let mut some_isize = AtomicIsize::new(10);\n            /// assert_eq!(*some_isize.get_mut(), 10);\n            /// *some_isize.get_mut() = 5;\n            /// assert_eq!(some_isize.load(Ordering::SeqCst), 5);\n            /// ```\n            #[inline]\n            #[$stable_access]\n            pub fn get_mut(&mut self) -> &mut $int_type {\n                unsafe { &mut *self.v.get() }\n            }\n\n            /// Consumes the atomic and returns the contained value.\n            ///\n            /// This is safe because passing `self` by value guarantees that no other threads are\n            /// concurrently accessing the atomic data.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::AtomicIsize;\n            ///\n            /// let some_isize = AtomicIsize::new(5);\n            /// assert_eq!(some_isize.into_inner(), 5);\n            /// ```\n            #[inline]\n            #[$stable_access]\n            pub fn into_inner(self) -> $int_type {\n                unsafe { self.v.into_inner() }\n            }\n\n            /// Loads a value from the atomic integer.\n            ///\n            /// `load` takes an [`Ordering`] argument which describes the memory ordering of this\n            /// operation.\n            ///\n            /// # Panics\n            ///\n            /// Panics if `order` is [`Release`] or [`AcqRel`].\n            ///\n            /// [`Ordering`]: enum.Ordering.html\n            /// [`Release`]: enum.Ordering.html#variant.Release\n            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::{AtomicIsize, Ordering};\n            ///\n            /// let some_isize = AtomicIsize::new(5);\n            ///\n            /// assert_eq!(some_isize.load(Ordering::Relaxed), 5);\n            /// ```\n            #[inline]\n            #[$stable]\n            pub fn load(&self, order: Ordering) -> $int_type {\n                unsafe { atomic_load(self.v.get(), order) }\n            }\n\n            /// Stores a value into the atomic integer.\n            ///\n            /// `store` takes an [`Ordering`] argument which describes the memory ordering of this\n            /// operation.\n            ///\n            /// [`Ordering`]: enum.Ordering.html\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::{AtomicIsize, Ordering};\n            ///\n            /// let some_isize = AtomicIsize::new(5);\n            ///\n            /// some_isize.store(10, Ordering::Relaxed);\n            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n            /// ```\n            ///\n            /// # Panics\n            ///\n            /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n            ///\n            /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n            #[inline]\n            #[$stable]\n            pub fn store(&self, val: $int_type, order: Ordering) {\n                unsafe { atomic_store(self.v.get(), val, order); }\n            }\n\n            /// Stores a value into the atomic integer, returning the previous value.\n            ///\n            /// `swap` takes an [`Ordering`] argument which describes the memory ordering of this\n            /// operation.\n            ///\n            /// [`Ordering`]: enum.Ordering.html\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::{AtomicIsize, Ordering};\n            ///\n            /// let some_isize = AtomicIsize::new(5);\n            ///\n            /// assert_eq!(some_isize.swap(10, Ordering::Relaxed), 5);\n            /// ```\n            #[inline]\n            #[$stable]\n            pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n                unsafe { atomic_swap(self.v.get(), val, order) }\n            }\n\n            /// Stores a value into the atomic integer if the current value is the same as the\n            /// `current` value.\n            ///\n            /// The return value is always the previous value. If it is equal to `current`, then the\n            /// value was updated.\n            ///\n            /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n            /// ordering of this operation.\n            ///\n            /// [`Ordering`]: enum.Ordering.html\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::{AtomicIsize, Ordering};\n            ///\n            /// let some_isize = AtomicIsize::new(5);\n            ///\n            /// assert_eq!(some_isize.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n            ///\n            /// assert_eq!(some_isize.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n            /// ```\n            #[inline]\n            #[$stable]\n            pub fn compare_and_swap(&self,\n                                    current: $int_type,\n                                    new: $int_type,\n                                    order: Ordering) -> $int_type {\n                match self.compare_exchange(current,\n                                            new,\n                                            order,\n                                            strongest_failure_ordering(order)) {\n                    Ok(x) => x,\n                    Err(x) => x,\n                }\n            }\n\n            /// Stores a value into the atomic integer if the current value is the same as the\n            /// `current` value.\n            ///\n            /// The return value is a result indicating whether the new value was written and\n            /// containing the previous value. On success this value is guaranteed to be equal to\n            /// `current`.\n            ///\n            /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n            /// ordering of this operation. The first describes the required ordering if\n            /// the operation succeeds while the second describes the required ordering when\n            /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n            /// must be equivalent or weaker than the success ordering.\n            ///\n            /// [`Ordering`]: enum.Ordering.html\n            /// [`Release`]: enum.Ordering.html#variant.Release\n            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::{AtomicIsize, Ordering};\n            ///\n            /// let some_isize = AtomicIsize::new(5);\n            ///\n            /// assert_eq!(some_isize.compare_exchange(5, 10,\n            ///                                        Ordering::Acquire,\n            ///                                        Ordering::Relaxed),\n            ///            Ok(5));\n            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n            ///\n            /// assert_eq!(some_isize.compare_exchange(6, 12,\n            ///                                        Ordering::SeqCst,\n            ///                                        Ordering::Acquire),\n            ///            Err(10));\n            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n            /// ```\n            #[inline]\n            #[$stable_cxchg]\n            pub fn compare_exchange(&self,\n                                    current: $int_type,\n                                    new: $int_type,\n                                    success: Ordering,\n                                    failure: Ordering) -> Result<$int_type, $int_type> {\n                unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n            }\n\n            /// Stores a value into the atomic integer if the current value is the same as the\n            /// `current` value.\n            ///\n            /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n            /// when the comparison succeeds, which can result in more efficient code on some\n            /// platforms. The return value is a result indicating whether the new value was\n            /// written and containing the previous value.\n            ///\n            /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n            /// ordering of this operation. The first describes the required ordering if the\n            /// operation succeeds while the second describes the required ordering when the\n            /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n            /// must be equivalent or weaker than the success ordering.\n            ///\n            /// [`compare_exchange`]: #method.compare_exchange\n            /// [`Ordering`]: enum.Ordering.html\n            /// [`Release`]: enum.Ordering.html#variant.Release\n            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::{AtomicIsize, Ordering};\n            ///\n            /// let val = AtomicIsize::new(4);\n            ///\n            /// let mut old = val.load(Ordering::Relaxed);\n            /// loop {\n            ///     let new = old * 2;\n            ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n            ///         Ok(_) => break,\n            ///         Err(x) => old = x,\n            ///     }\n            /// }\n            /// ```\n            #[inline]\n            #[$stable_cxchg]\n            pub fn compare_exchange_weak(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n                                         success: Ordering,\n                                         failure: Ordering) -> Result<$int_type, $int_type> {\n                unsafe {\n                    atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n                }\n            }\n\n            /// Adds to the current value, returning the previous value.\n            ///\n            /// This operation wraps around on overflow.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::{AtomicIsize, Ordering};\n            ///\n            /// let foo = AtomicIsize::new(0);\n            /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n            /// ```\n            #[inline]\n            #[$stable]\n            pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                unsafe { atomic_add(self.v.get(), val, order) }\n            }\n\n            /// Subtracts from the current value, returning the previous value.\n            ///\n            /// This operation wraps around on overflow.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::{AtomicIsize, Ordering};\n            ///\n            /// let foo = AtomicIsize::new(0);\n            /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 0);\n            /// assert_eq!(foo.load(Ordering::SeqCst), -10);\n            /// ```\n            #[inline]\n            #[$stable]\n            pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                unsafe { atomic_sub(self.v.get(), val, order) }\n            }\n\n            /// Bitwise \"and\" with the current value.\n            ///\n            /// Performs a bitwise \"and\" operation on the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::{AtomicIsize, Ordering};\n            ///\n            /// let foo = AtomicIsize::new(0b101101);\n            /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n            #[inline]\n            #[$stable]\n            pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                unsafe { atomic_and(self.v.get(), val, order) }\n            }\n\n            /// Bitwise \"or\" with the current value.\n            ///\n            /// Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::{AtomicIsize, Ordering};\n            ///\n            /// let foo = AtomicIsize::new(0b101101);\n            /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n            #[inline]\n            #[$stable]\n            pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                unsafe { atomic_or(self.v.get(), val, order) }\n            }\n\n            /// Bitwise \"xor\" with the current value.\n            ///\n            /// Performs a bitwise \"xor\" operation on the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use std::sync::atomic::{AtomicIsize, Ordering};\n            ///\n            /// let foo = AtomicIsize::new(0b101101);\n            /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n            #[inline]\n            #[$stable]\n            pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                unsafe { atomic_xor(self.v.get(), val, order) }\n            }\n        }\n    }\n}\n\n#[cfg(target_has_atomic = \"8\")]\natomic_int! {\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    i8 AtomicI8 ATOMIC_I8_INIT\n}\n#[cfg(target_has_atomic = \"8\")]\natomic_int! {\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    u8 AtomicU8 ATOMIC_U8_INIT\n}\n#[cfg(target_has_atomic = \"16\")]\natomic_int! {\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    i16 AtomicI16 ATOMIC_I16_INIT\n}\n#[cfg(target_has_atomic = \"16\")]\natomic_int! {\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    u16 AtomicU16 ATOMIC_U16_INIT\n}\n#[cfg(target_has_atomic = \"32\")]\natomic_int! {\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    i32 AtomicI32 ATOMIC_I32_INIT\n}\n#[cfg(target_has_atomic = \"32\")]\natomic_int! {\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    u32 AtomicU32 ATOMIC_U32_INIT\n}\n#[cfg(target_has_atomic = \"64\")]\natomic_int! {\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    i64 AtomicI64 ATOMIC_I64_INIT\n}\n#[cfg(target_has_atomic = \"64\")]\natomic_int! {\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    u64 AtomicU64 ATOMIC_U64_INIT\n}\n#[cfg(target_has_atomic = \"ptr\")]\natomic_int!{\n    stable(feature = \"rust1\", since = \"1.0.0\"),\n    stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n    stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n    stable(feature = \"atomic_access\", since = \"1.15.0\"),\n    isize AtomicIsize ATOMIC_ISIZE_INIT\n}\n#[cfg(target_has_atomic = \"ptr\")]\natomic_int!{\n    stable(feature = \"rust1\", since = \"1.0.0\"),\n    stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n    stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n    stable(feature = \"atomic_access\", since = \"1.15.0\"),\n    usize AtomicUsize ATOMIC_USIZE_INIT\n}\n\n#[inline]\nfn strongest_failure_ordering(order: Ordering) -> Ordering {\n    match order {\n        Release => Relaxed,\n        Relaxed => Relaxed,\n        SeqCst => SeqCst,\n        Acquire => Acquire,\n        AcqRel => Acquire,\n        __Nonexhaustive => __Nonexhaustive,\n    }\n}\n\n#[inline]\nunsafe fn atomic_store<T>(dst: *mut T, val: T, order: Ordering) {\n    match order {\n        Release => intrinsics::atomic_store_rel(dst, val),\n        Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n        SeqCst => intrinsics::atomic_store(dst, val),\n        Acquire => panic!(\"there is no such thing as an acquire store\"),\n        AcqRel => panic!(\"there is no such thing as an acquire/release store\"),\n        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n    }\n}\n\n#[inline]\nunsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n    match order {\n        Acquire => intrinsics::atomic_load_acq(dst),\n        Relaxed => intrinsics::atomic_load_relaxed(dst),\n        SeqCst => intrinsics::atomic_load(dst),\n        Release => panic!(\"there is no such thing as a release load\"),\n        AcqRel => panic!(\"there is no such thing as an acquire/release load\"),\n        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n    }\n}\n\n#[inline]\nunsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n    match order {\n        Acquire => intrinsics::atomic_xchg_acq(dst, val),\n        Release => intrinsics::atomic_xchg_rel(dst, val),\n        AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n        Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n        SeqCst => intrinsics::atomic_xchg(dst, val),\n        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n    }\n}\n\n/// Returns the previous value (like __sync_fetch_and_add).\n#[inline]\nunsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n    match order {\n        Acquire => intrinsics::atomic_xadd_acq(dst, val),\n        Release => intrinsics::atomic_xadd_rel(dst, val),\n        AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n        Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n        SeqCst => intrinsics::atomic_xadd(dst, val),\n        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n    }\n}\n\n/// Returns the previous value (like __sync_fetch_and_sub).\n#[inline]\nunsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n    match order {\n        Acquire => intrinsics::atomic_xsub_acq(dst, val),\n        Release => intrinsics::atomic_xsub_rel(dst, val),\n        AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n        Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n        SeqCst => intrinsics::atomic_xsub(dst, val),\n        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n    }\n}\n\n#[inline]\nunsafe fn atomic_compare_exchange<T>(dst: *mut T,\n                                     old: T,\n                                     new: T,\n                                     success: Ordering,\n                                     failure: Ordering)\n                                     -> Result<T, T> {\n    let (val, ok) = match (success, failure) {\n        (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n        (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n        (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n        (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n        (SeqCst, SeqCst) => intrinsics::atomic_cxchg(dst, old, new),\n        (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n        (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n        (SeqCst, Relaxed) => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n        (SeqCst, Acquire) => intrinsics::atomic_cxchg_failacq(dst, old, new),\n        (__Nonexhaustive, _) => panic!(\"invalid memory ordering\"),\n        (_, __Nonexhaustive) => panic!(\"invalid memory ordering\"),\n        (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n        (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n        _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n    };\n    if ok { Ok(val) } else { Err(val) }\n}\n\n#[inline]\nunsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                          old: T,\n                                          new: T,\n                                          success: Ordering,\n                                          failure: Ordering)\n                                          -> Result<T, T> {\n    let (val, ok) = match (success, failure) {\n        (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n        (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n        (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n        (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n        (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak(dst, old, new),\n        (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n        (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n        (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n        (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n        (__Nonexhaustive, _) => panic!(\"invalid memory ordering\"),\n        (_, __Nonexhaustive) => panic!(\"invalid memory ordering\"),\n        (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n        (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n        _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n    };\n    if ok { Ok(val) } else { Err(val) }\n}\n\n#[inline]\nunsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n    match order {\n        Acquire => intrinsics::atomic_and_acq(dst, val),\n        Release => intrinsics::atomic_and_rel(dst, val),\n        AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n        Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n        SeqCst => intrinsics::atomic_and(dst, val),\n        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n    }\n}\n\n#[inline]\nunsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n    match order {\n        Acquire => intrinsics::atomic_or_acq(dst, val),\n        Release => intrinsics::atomic_or_rel(dst, val),\n        AcqRel => intrinsics::atomic_or_acqrel(dst, val),\n        Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n        SeqCst => intrinsics::atomic_or(dst, val),\n        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n    }\n}\n\n#[inline]\nunsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n    match order {\n        Acquire => intrinsics::atomic_xor_acq(dst, val),\n        Release => intrinsics::atomic_xor_rel(dst, val),\n        AcqRel => intrinsics::atomic_xor_acqrel(dst, val),\n        Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n        SeqCst => intrinsics::atomic_xor(dst, val),\n        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n    }\n}\n\n/// An atomic fence.\n///\n/// Depending on the specified order, a fence prevents the compiler and CPU from\n/// reordering certain types of memory operations around it.\n/// That creates synchronizes-with relationships between it and atomic operations\n/// or fences in other threads.\n///\n/// A fence 'A' which has (at least) [`Release`] ordering semantics, synchronizes\n/// with a fence 'B' with (at least) [`Acquire`] semantics, if and only if there\n/// exist operations X and Y, both operating on some atomic object 'M' such\n/// that A is sequenced before X, Y is synchronized before B and Y observes\n/// the change to M. This provides a happens-before dependence between A and B.\n///\n/// ```text\n///     Thread 1                                          Thread 2\n///\n/// fence(Release);      A --------------\n/// x.store(3, Relaxed); X ---------    |\n///                                |    |\n///                                |    |\n///                                -------------> Y  if x.load(Relaxed) == 3 {\n///                                     |-------> B      fence(Acquire);\n///                                                      ...\n///                                                  }\n/// ```\n///\n/// Atomic operations with [`Release`] or [`Acquire`] semantics can also synchronize\n/// with a fence.\n///\n/// A fence which has [`SeqCst`] ordering, in addition to having both [`Acquire`]\n/// and [`Release`] semantics, participates in the global program order of the\n/// other [`SeqCst`] operations and/or fences.\n///\n/// Accepts [`Acquire`], [`Release`], [`AcqRel`] and [`SeqCst`] orderings.\n///\n/// # Panics\n///\n/// Panics if `order` is [`Relaxed`].\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::atomic::AtomicBool;\n/// use std::sync::atomic::fence;\n/// use std::sync::atomic::Ordering;\n///\n/// // A mutual exclusion primitive based on spinlock.\n/// pub struct Mutex {\n///     flag: AtomicBool,\n/// }\n///\n/// impl Mutex {\n///     pub fn new() -> Mutex {\n///         Mutex {\n///             flag: AtomicBool::new(false),\n///         }\n///     }\n///\n///     pub fn lock(&self) {\n///         while !self.flag.compare_and_swap(false, true, Ordering::Relaxed) {}\n///         // This fence syncronizes-with store in `unlock`.\n///         fence(Ordering::Acquire);\n///     }\n///\n///     pub fn unlock(&self) {\n///         self.flag.store(false, Ordering::Release);\n///     }\n/// }\n/// ```\n///\n/// [`Ordering`]: enum.Ordering.html\n/// [`Acquire`]: enum.Ordering.html#variant.Acquire\n/// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n/// [`Release`]: enum.Ordering.html#variant.Release\n/// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n/// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn fence(order: Ordering) {\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_fence_acq(),\n            Release => intrinsics::atomic_fence_rel(),\n            AcqRel => intrinsics::atomic_fence_acqrel(),\n            SeqCst => intrinsics::atomic_fence(),\n            Relaxed => panic!(\"there is no such thing as a relaxed fence\"),\n            __Nonexhaustive => panic!(\"invalid memory ordering\"),\n        }\n    }\n}\n\n\n/// A compiler memory fence.\n///\n/// `compiler_fence` does not emit any machine code, but prevents the compiler from re-ordering\n/// memory operations across this point. Which reorderings are disallowed is dictated by the given\n/// [`Ordering`]. Note that `compiler_fence` does *not* introduce inter-thread memory\n/// synchronization; for that, a [`fence`] is needed.\n///\n/// The re-ordering prevented by the different ordering semantics are:\n///\n///  - with [`SeqCst`], no re-ordering of reads and writes across this point is allowed.\n///  - with [`Release`], preceding reads and writes cannot be moved past subsequent writes.\n///  - with [`Acquire`], subsequent reads and writes cannot be moved ahead of preceding reads.\n///  - with [`AcqRel`], both of the above rules are enforced.\n///\n/// # Panics\n///\n/// Panics if `order` is [`Relaxed`].\n///\n/// [`fence`]: fn.fence.html\n/// [`Ordering`]: enum.Ordering.html\n/// [`Acquire`]: enum.Ordering.html#variant.Acquire\n/// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n/// [`Release`]: enum.Ordering.html#variant.Release\n/// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n/// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n#[inline]\n#[unstable(feature = \"compiler_fences\", issue = \"41091\")]\npub fn compiler_fence(order: Ordering) {\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_singlethreadfence_acq(),\n            Release => intrinsics::atomic_singlethreadfence_rel(),\n            AcqRel => intrinsics::atomic_singlethreadfence_acqrel(),\n            SeqCst => intrinsics::atomic_singlethreadfence(),\n            Relaxed => panic!(\"there is no such thing as a relaxed compiler fence\"),\n            __Nonexhaustive => panic!(\"invalid memory ordering\"),\n        }\n    }\n}\n\n\n#[cfg(target_has_atomic = \"8\")]\n#[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\nimpl fmt::Debug for AtomicBool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"AtomicBool\").field(&self.load(Ordering::SeqCst)).finish()\n    }\n}\n\n#[cfg(target_has_atomic = \"ptr\")]\n#[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\nimpl<T> fmt::Debug for AtomicPtr<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"AtomicPtr\").field(&self.load(Ordering::SeqCst)).finish()\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! OS-based thread local storage\n//!\n//! This module provides an implementation of OS-based thread local storage,\n//! using the native OS-provided facilities (think `TlsAlloc` or\n//! `pthread_setspecific`). The interface of this differs from the other types\n//! of thread-local-storage provided in this crate in that OS-based TLS can only\n//! get/set pointers,\n//!\n//! This module also provides two flavors of TLS. One is intended for static\n//! initialization, and does not contain a `Drop` implementation to deallocate\n//! the OS-TLS key. The other is a type which does implement `Drop` and hence\n//! has a safe interface.\n//!\n//! # Usage\n//!\n//! This module should likely not be used directly unless other primitives are\n//! being built on. types such as `thread_local::spawn::Key` are likely much\n//! more useful in practice than this OS-based version which likely requires\n//! unsafe code to interoperate with.\n//!\n//! # Examples\n//!\n//! Using a dynamically allocated TLS key. Note that this key can be shared\n//! among many threads via an `Arc`.\n//!\n//! ```ignore (cannot-doctest-private-modules)\n//! let key = Key::new(None);\n//! assert!(key.get().is_null());\n//! key.set(1 as *mut u8);\n//! assert!(!key.get().is_null());\n//!\n//! drop(key); // deallocate this TLS slot.\n//! ```\n//!\n//! Sometimes a statically allocated key is either required or easier to work\n//! with, however.\n//!\n//! ```ignore (cannot-doctest-private-modules)\n//! static KEY: StaticKey = INIT;\n//!\n//! unsafe {\n//!     assert!(KEY.get().is_null());\n//!     KEY.set(1 as *mut u8);\n//! }\n//! ```\n\n#![allow(non_camel_case_types)]\n#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n#![allow(dead_code)] // sys isn't exported yet\n\nuse ptr;\nuse sync::atomic::{self, AtomicUsize, Ordering};\nuse sys::thread_local as imp;\nuse sys_common::mutex::Mutex;\n\n/// A type for TLS keys that are statically allocated.\n///\n/// This type is entirely `unsafe` to use as it does not protect against\n/// use-after-deallocation or use-during-deallocation.\n///\n/// The actual OS-TLS key is lazily allocated when this is used for the first\n/// time. The key is also deallocated when the Rust runtime exits or `destroy`\n/// is called, whichever comes first.\n///\n/// # Examples\n///\n/// ```ignore (cannot-doctest-private-modules)\n/// use tls::os::{StaticKey, INIT};\n///\n/// static KEY: StaticKey = INIT;\n///\n/// unsafe {\n///     assert!(KEY.get().is_null());\n///     KEY.set(1 as *mut u8);\n/// }\n/// ```\npub struct StaticKey {\n    /// Inner static TLS key (internals).\n    key: AtomicUsize,\n    /// Destructor for the TLS value.\n    ///\n    /// See `Key::new` for information about when the destructor runs and how\n    /// it runs.\n    dtor: Option<unsafe extern fn(*mut u8)>,\n}\n\n/// A type for a safely managed OS-based TLS slot.\n///\n/// This type allocates an OS TLS key when it is initialized and will deallocate\n/// the key when it falls out of scope. When compared with `StaticKey`, this\n/// type is entirely safe to use.\n///\n/// Implementations will likely, however, contain unsafe code as this type only\n/// operates on `*mut u8`, a raw pointer.\n///\n/// # Examples\n///\n/// ```ignore (cannot-doctest-private-modules)\n/// use tls::os::Key;\n///\n/// let key = Key::new(None);\n/// assert!(key.get().is_null());\n/// key.set(1 as *mut u8);\n/// assert!(!key.get().is_null());\n///\n/// drop(key); // deallocate this TLS slot.\n/// ```\npub struct Key {\n    key: imp::Key,\n}\n\n/// Constant initialization value for static TLS keys.\n///\n/// This value specifies no destructor by default.\npub const INIT: StaticKey = StaticKey::new(None);\n\nimpl StaticKey {\n    pub const fn new(dtor: Option<unsafe extern fn(*mut u8)>) -> StaticKey {\n        StaticKey {\n            key: atomic::AtomicUsize::new(0),\n            dtor: dtor\n        }\n    }\n\n    /// Gets the value associated with this TLS key\n    ///\n    /// This will lazily allocate a TLS key from the OS if one has not already\n    /// been allocated.\n    #[inline]\n    pub unsafe fn get(&self) -> *mut u8 { imp::get(self.key()) }\n\n    /// Sets this TLS key to a new value.\n    ///\n    /// This will lazily allocate a TLS key from the OS if one has not already\n    /// been allocated.\n    #[inline]\n    pub unsafe fn set(&self, val: *mut u8) { imp::set(self.key(), val) }\n\n    #[inline]\n    unsafe fn key(&self) -> imp::Key {\n        match self.key.load(Ordering::Relaxed) {\n            0 => self.lazy_init() as imp::Key,\n            n => n as imp::Key\n        }\n    }\n\n    unsafe fn lazy_init(&self) -> usize {\n        // Currently the Windows implementation of TLS is pretty hairy, and\n        // it greatly simplifies creation if we just synchronize everything.\n        //\n        // Additionally a 0-index of a tls key hasn't been seen on windows, so\n        // we just simplify the whole branch.\n        if imp::requires_synchronized_create() {\n            static INIT_LOCK: Mutex = Mutex::new();\n            INIT_LOCK.lock();\n            let mut key = self.key.load(Ordering::SeqCst);\n            if key == 0 {\n                key = imp::create(self.dtor) as usize;\n                self.key.store(key, Ordering::SeqCst);\n            }\n            INIT_LOCK.unlock();\n            assert!(key != 0);\n            return key\n        }\n\n        // POSIX allows the key created here to be 0, but the compare_and_swap\n        // below relies on using 0 as a sentinel value to check who won the\n        // race to set the shared TLS key. As far as I know, there is no\n        // guaranteed value that cannot be returned as a posix_key_create key,\n        // so there is no value we can initialize the inner key with to\n        // prove that it has not yet been set. As such, we'll continue using a\n        // value of 0, but with some gyrations to make sure we have a non-0\n        // value returned from the creation routine.\n        // FIXME: this is clearly a hack, and should be cleaned up.\n        let key1 = imp::create(self.dtor);\n        let key = if key1 != 0 {\n            key1\n        } else {\n            let key2 = imp::create(self.dtor);\n            imp::destroy(key1);\n            key2\n        };\n        assert!(key != 0);\n        match self.key.compare_and_swap(0, key as usize, Ordering::SeqCst) {\n            // The CAS succeeded, so we've created the actual key\n            0 => key as usize,\n            // If someone beat us to the punch, use their key instead\n            n => { imp::destroy(key); n }\n        }\n    }\n}\n\nimpl Key {\n    /// Creates a new managed OS TLS key.\n    ///\n    /// This key will be deallocated when the key falls out of scope.\n    ///\n    /// The argument provided is an optionally-specified destructor for the\n    /// value of this TLS key. When a thread exits and the value for this key\n    /// is non-null the destructor will be invoked. The TLS value will be reset\n    /// to null before the destructor is invoked.\n    ///\n    /// Note that the destructor will not be run when the `Key` goes out of\n    /// scope.\n    #[inline]\n    pub fn new(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n        Key { key: unsafe { imp::create(dtor) } }\n    }\n\n    /// See StaticKey::get\n    #[inline]\n    pub fn get(&self) -> *mut u8 {\n        unsafe { imp::get(self.key) }\n    }\n\n    /// See StaticKey::set\n    #[inline]\n    pub fn set(&self, val: *mut u8) {\n        unsafe { imp::set(self.key, val) }\n    }\n}\n\nimpl Drop for Key {\n    fn drop(&mut self) {\n        // Right now Windows doesn't support TLS key destruction, but this also\n        // isn't used anywhere other than tests, so just leak the TLS key.\n        // unsafe { imp::destroy(self.key) }\n    }\n}\n\npub unsafe fn register_dtor_fallback(t: *mut u8,\n                                     dtor: unsafe extern fn(*mut u8)) {\n    // The fallback implementation uses a vanilla OS-based TLS key to track\n    // the list of destructors that need to be run for this thread. The key\n    // then has its own destructor which runs all the other destructors.\n    //\n    // The destructor for DTORS is a little special in that it has a `while`\n    // loop to continuously drain the list of registered destructors. It\n    // *should* be the case that this loop always terminates because we\n    // provide the guarantee that a TLS key cannot be set after it is\n    // flagged for destruction.\n\n    static DTORS: StaticKey = StaticKey::new(Some(run_dtors));\n    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n    if DTORS.get().is_null() {\n        let v: Box<List> = box Vec::new();\n        DTORS.set(Box::into_raw(v) as *mut u8);\n    }\n    let list: &mut List = &mut *(DTORS.get() as *mut List);\n    list.push((t, dtor));\n\n    unsafe extern fn run_dtors(mut ptr: *mut u8) {\n        while !ptr.is_null() {\n            let list: Box<List> = Box::from_raw(ptr as *mut List);\n            for &(ptr, dtor) in list.iter() {\n                dtor(ptr);\n            }\n            ptr = DTORS.get();\n            DTORS.set(ptr::null_mut());\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{Key, StaticKey};\n\n    fn assert_sync<T: Sync>() {}\n    fn assert_send<T: Send>() {}\n\n    #[test]\n    fn smoke() {\n        assert_sync::<Key>();\n        assert_send::<Key>();\n\n        let k1 = Key::new(None);\n        let k2 = Key::new(None);\n        assert!(k1.get().is_null());\n        assert!(k2.get().is_null());\n        k1.set(1 as *mut _);\n        k2.set(2 as *mut _);\n        assert_eq!(k1.get() as usize, 1);\n        assert_eq!(k2.get() as usize, 2);\n    }\n\n    #[test]\n    fn statik() {\n        static K1: StaticKey = StaticKey::new(None);\n        static K2: StaticKey = StaticKey::new(None);\n\n        unsafe {\n            assert!(K1.get().is_null());\n            assert!(K2.get().is_null());\n            K1.set(1 as *mut _);\n            K2.set(2 as *mut _);\n            assert_eq!(K1.get() as usize, 1);\n            assert_eq!(K2.get() as usize, 2);\n        }\n    }\n}\n","// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![allow(dead_code)] // not used on all platforms\n\nuse mem;\nuse libc;\n\npub type Key = libc::pthread_key_t;\n\n#[inline]\npub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n    let mut key = 0;\n    assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n    key\n}\n\n#[inline]\npub unsafe fn set(key: Key, value: *mut u8) {\n    let r = libc::pthread_setspecific(key, value as *mut _);\n    debug_assert_eq!(r, 0);\n}\n\n#[inline]\npub unsafe fn get(key: Key) -> *mut u8 {\n    libc::pthread_getspecific(key) as *mut u8\n}\n\n#[inline]\npub unsafe fn destroy(key: Key) {\n    let r = libc::pthread_key_delete(key);\n    debug_assert_eq!(r, 0);\n}\n\n#[inline]\npub fn requires_synchronized_create() -> bool {\n    false\n}\n","// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse env;\nuse fmt;\nuse io::prelude::*;\nuse sync::atomic::{self, Ordering};\nuse sys::stdio::Stderr;\nuse thread;\n\npub fn min_stack() -> usize {\n    static MIN: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n    match MIN.load(Ordering::SeqCst) {\n        0 => {}\n        n => return n - 1,\n    }\n    let amt = env::var(\"RUST_MIN_STACK\").ok().and_then(|s| s.parse().ok());\n    let amt = amt.unwrap_or(2 * 1024 * 1024);\n    // 0 is our sentinel value, so ensure that we'll never see 0 after\n    // initialization has run\n    MIN.store(amt + 1, Ordering::SeqCst);\n    amt\n}\n\npub fn dumb_print(args: fmt::Arguments) {\n    let _ = Stderr::new().map(|mut stderr| stderr.write_fmt(args));\n}\n\n// Other platforms should use the appropriate platform-specific mechanism for\n// aborting the process.  If no platform-specific mechanism is available,\n// ::intrinsics::abort() may be used instead.  The above implementations cover\n// all targets currently supported by libstd.\n\npub fn abort(args: fmt::Arguments) -> ! {\n    dumb_print(format_args!(\"fatal runtime error: {}\\n\", args));\n    unsafe { ::sys::abort_internal(); }\n}\n\n#[allow(dead_code)] // stack overflow detection not enabled on all platforms\npub unsafe fn report_overflow() {\n    dumb_print(format_args!(\"\\nthread '{}' has overflowed its stack\\n\",\n                            thread::current().name().unwrap_or(\"<unknown>\")));\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Error handling with the `Result` type.\n//!\n//! [`Result<T, E>`][`Result`] is the type used for returning and propagating\n//! errors. It is an enum with the variants, [`Ok(T)`], representing\n//! success and containing a value, and [`Err(E)`], representing error\n//! and containing an error value.\n//!\n//! ```\n//! # #[allow(dead_code)]\n//! enum Result<T, E> {\n//!    Ok(T),\n//!    Err(E),\n//! }\n//! ```\n//!\n//! Functions return [`Result`] whenever errors are expected and\n//! recoverable. In the `std` crate, [`Result`] is most prominently used\n//! for [I/O](../../std/io/index.html).\n//!\n//! A simple function returning [`Result`] might be\n//! defined and used like so:\n//!\n//! ```\n//! #[derive(Debug)]\n//! enum Version { Version1, Version2 }\n//!\n//! fn parse_version(header: &[u8]) -> Result<Version, &'static str> {\n//!     match header.get(0) {\n//!         None => Err(\"invalid header length\"),\n//!         Some(&1) => Ok(Version::Version1),\n//!         Some(&2) => Ok(Version::Version2),\n//!         Some(_) => Err(\"invalid version\"),\n//!     }\n//! }\n//!\n//! let version = parse_version(&[1, 2, 3, 4]);\n//! match version {\n//!     Ok(v) => println!(\"working with version: {:?}\", v),\n//!     Err(e) => println!(\"error parsing header: {:?}\", e),\n//! }\n//! ```\n//!\n//! Pattern matching on [`Result`]s is clear and straightforward for\n//! simple cases, but [`Result`] comes with some convenience methods\n//! that make working with it more succinct.\n//!\n//! ```\n//! let good_result: Result<i32, i32> = Ok(10);\n//! let bad_result: Result<i32, i32> = Err(10);\n//!\n//! // The `is_ok` and `is_err` methods do what they say.\n//! assert!(good_result.is_ok() && !good_result.is_err());\n//! assert!(bad_result.is_err() && !bad_result.is_ok());\n//!\n//! // `map` consumes the `Result` and produces another.\n//! let good_result: Result<i32, i32> = good_result.map(|i| i + 1);\n//! let bad_result: Result<i32, i32> = bad_result.map(|i| i - 1);\n//!\n//! // Use `and_then` to continue the computation.\n//! let good_result: Result<bool, i32> = good_result.and_then(|i| Ok(i == 11));\n//!\n//! // Use `or_else` to handle the error.\n//! let bad_result: Result<i32, i32> = bad_result.or_else(|i| Ok(i + 20));\n//!\n//! // Consume the result and return the contents with `unwrap`.\n//! let final_awesome_result = good_result.unwrap();\n//! ```\n//!\n//! # Results must be used\n//!\n//! A common problem with using return values to indicate errors is\n//! that it is easy to ignore the return value, thus failing to handle\n//! the error. [`Result`] is annotated with the `#[must_use]` attribute,\n//! which will cause the compiler to issue a warning when a Result\n//! value is ignored. This makes [`Result`] especially useful with\n//! functions that may encounter errors but don't otherwise return a\n//! useful value.\n//!\n//! Consider the [`write_all`] method defined for I/O types\n//! by the [`Write`] trait:\n//!\n//! ```\n//! use std::io;\n//!\n//! trait Write {\n//!     fn write_all(&mut self, bytes: &[u8]) -> Result<(), io::Error>;\n//! }\n//! ```\n//!\n//! *Note: The actual definition of [`Write`] uses [`io::Result`], which\n//! is just a synonym for [`Result`]`<T, `[`io::Error`]`>`.*\n//!\n//! This method doesn't produce a value, but the write may\n//! fail. It's crucial to handle the error case, and *not* write\n//! something like this:\n//!\n//! ```no_run\n//! # #![allow(unused_must_use)] // \\o/\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//!\n//! let mut file = File::create(\"valuable_data.txt\").unwrap();\n//! // If `write_all` errors, then we'll never know, because the return\n//! // value is ignored.\n//! file.write_all(b\"important message\");\n//! ```\n//!\n//! If you *do* write that in Rust, the compiler will give you a\n//! warning (by default, controlled by the `unused_must_use` lint).\n//!\n//! You might instead, if you don't want to handle the error, simply\n//! assert success with [`expect`]. This will panic if the\n//! write fails, providing a marginally useful message indicating why:\n//!\n//! ```{.no_run}\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//!\n//! let mut file = File::create(\"valuable_data.txt\").unwrap();\n//! file.write_all(b\"important message\").expect(\"failed to write message\");\n//! ```\n//!\n//! You might also simply assert success:\n//!\n//! ```{.no_run}\n//! # use std::fs::File;\n//! # use std::io::prelude::*;\n//! # let mut file = File::create(\"valuable_data.txt\").unwrap();\n//! assert!(file.write_all(b\"important message\").is_ok());\n//! ```\n//!\n//! Or propagate the error up the call stack with [`?`]:\n//!\n//! ```\n//! # use std::fs::File;\n//! # use std::io::prelude::*;\n//! # use std::io;\n//! # #[allow(dead_code)]\n//! fn write_message() -> io::Result<()> {\n//!     let mut file = File::create(\"valuable_data.txt\")?;\n//!     file.write_all(b\"important message\")?;\n//!     Ok(())\n//! }\n//! ```\n//!\n//! # The `?` syntax\n//!\n//! When writing code that calls many functions that return the\n//! [`Result`] type, the error handling can be tedious. The [`?`]\n//! syntax hides some of the boilerplate of propagating errors up the\n//! call stack.\n//!\n//! It replaces this:\n//!\n//! ```\n//! # #![allow(dead_code)]\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//! use std::io;\n//!\n//! struct Info {\n//!     name: String,\n//!     age: i32,\n//!     rating: i32,\n//! }\n//!\n//! fn write_info(info: &Info) -> io::Result<()> {\n//!     // Early return on error\n//!     let mut file = match File::create(\"my_best_friends.txt\") {\n//!            Err(e) => return Err(e),\n//!            Ok(f) => f,\n//!     };\n//!     if let Err(e) = file.write_all(format!(\"name: {}\\n\", info.name).as_bytes()) {\n//!         return Err(e)\n//!     }\n//!     if let Err(e) = file.write_all(format!(\"age: {}\\n\", info.age).as_bytes()) {\n//!         return Err(e)\n//!     }\n//!     if let Err(e) = file.write_all(format!(\"rating: {}\\n\", info.rating).as_bytes()) {\n//!         return Err(e)\n//!     }\n//!     Ok(())\n//! }\n//! ```\n//!\n//! With this:\n//!\n//! ```\n//! # #![allow(dead_code)]\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//! use std::io;\n//!\n//! struct Info {\n//!     name: String,\n//!     age: i32,\n//!     rating: i32,\n//! }\n//!\n//! fn write_info(info: &Info) -> io::Result<()> {\n//!     let mut file = File::create(\"my_best_friends.txt\")?;\n//!     // Early return on error\n//!     file.write_all(format!(\"name: {}\\n\", info.name).as_bytes())?;\n//!     file.write_all(format!(\"age: {}\\n\", info.age).as_bytes())?;\n//!     file.write_all(format!(\"rating: {}\\n\", info.rating).as_bytes())?;\n//!     Ok(())\n//! }\n//! ```\n//!\n//! *It's much nicer!*\n//!\n//! Ending the expression with [`?`] will result in the unwrapped\n//! success ([`Ok`]) value, unless the result is [`Err`], in which case\n//! [`Err`] is returned early from the enclosing function.\n//!\n//! [`?`] can only be used in functions that return [`Result`] because of the\n//! early return of [`Err`] that it provides.\n//!\n//! [`expect`]: enum.Result.html#method.expect\n//! [`Write`]: ../../std/io/trait.Write.html\n//! [`write_all`]: ../../std/io/trait.Write.html#method.write_all\n//! [`io::Result`]: ../../std/io/type.Result.html\n//! [`?`]: ../../std/macro.try.html\n//! [`Result`]: enum.Result.html\n//! [`Ok(T)`]: enum.Result.html#variant.Ok\n//! [`Err(E)`]: enum.Result.html#variant.Err\n//! [`io::Error`]: ../../std/io/struct.Error.html\n//! [`Ok`]: enum.Result.html#variant.Ok\n//! [`Err`]: enum.Result.html#variant.Err\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse fmt;\nuse iter::{FromIterator, FusedIterator, TrustedLen};\nuse ops;\n\n/// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n///\n/// See the [`std::result`](index.html) module documentation for details.\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n#[must_use]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Result<T, E> {\n    /// Contains the success value\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n\n    /// Contains the error value\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Type implementation\n/////////////////////////////////////////////////////////////////////////////\n\nimpl<T, E> Result<T, E> {\n    /////////////////////////////////////////////////////////////////////////\n    // Querying the contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns `true` if the result is `Ok`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<i32, &str> = Ok(-3);\n    /// assert_eq!(x.is_ok(), true);\n    ///\n    /// let x: Result<i32, &str> = Err(\"Some error message\");\n    /// assert_eq!(x.is_ok(), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_ok(&self) -> bool {\n        match *self {\n            Ok(_) => true,\n            Err(_) => false\n        }\n    }\n\n    /// Returns `true` if the result is `Err`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<i32, &str> = Ok(-3);\n    /// assert_eq!(x.is_err(), false);\n    ///\n    /// let x: Result<i32, &str> = Err(\"Some error message\");\n    /// assert_eq!(x.is_err(), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_err(&self) -> bool {\n        !self.is_ok()\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Adapter for each variant\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Converts from `Result<T, E>` to [`Option<T>`].\n    ///\n    /// Converts `self` into an [`Option<T>`], consuming `self`,\n    /// and discarding the error, if any.\n    ///\n    /// [`Option<T>`]: ../../std/option/enum.Option.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.ok(), Some(2));\n    ///\n    /// let x: Result<u32, &str> = Err(\"Nothing here\");\n    /// assert_eq!(x.ok(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ok(self) -> Option<T> {\n        match self {\n            Ok(x)  => Some(x),\n            Err(_) => None,\n        }\n    }\n\n    /// Converts from `Result<T, E>` to [`Option<E>`].\n    ///\n    /// Converts `self` into an [`Option<E>`], consuming `self`,\n    /// and discarding the success value, if any.\n    ///\n    /// [`Option<E>`]: ../../std/option/enum.Option.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.err(), None);\n    ///\n    /// let x: Result<u32, &str> = Err(\"Nothing here\");\n    /// assert_eq!(x.err(), Some(\"Nothing here\"));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn err(self) -> Option<E> {\n        match self {\n            Ok(_)  => None,\n            Err(x) => Some(x),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Adapter for working with references\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Converts from `Result<T, E>` to `Result<&T, &E>`.\n    ///\n    /// Produces a new `Result`, containing a reference\n    /// into the original, leaving the original in place.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.as_ref(), Ok(&2));\n    ///\n    /// let x: Result<u32, &str> = Err(\"Error\");\n    /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_ref(&self) -> Result<&T, &E> {\n        match *self {\n            Ok(ref x) => Ok(x),\n            Err(ref x) => Err(x),\n        }\n    }\n\n    /// Converts from `Result<T, E>` to `Result<&mut T, &mut E>`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn mutate(r: &mut Result<i32, i32>) {\n    ///     match r.as_mut() {\n    ///         Ok(v) => *v = 42,\n    ///         Err(e) => *e = 0,\n    ///     }\n    /// }\n    ///\n    /// let mut x: Result<i32, i32> = Ok(2);\n    /// mutate(&mut x);\n    /// assert_eq!(x.unwrap(), 42);\n    ///\n    /// let mut x: Result<i32, i32> = Err(13);\n    /// mutate(&mut x);\n    /// assert_eq!(x.unwrap_err(), 0);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_mut(&mut self) -> Result<&mut T, &mut E> {\n        match *self {\n            Ok(ref mut x) => Ok(x),\n            Err(ref mut x) => Err(x),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Transforming contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n    /// contained `Ok` value, leaving an `Err` value untouched.\n    ///\n    /// This function can be used to compose the results of two functions.\n    ///\n    /// # Examples\n    ///\n    /// Print the numbers on each line of a string multiplied by two.\n    ///\n    /// ```\n    /// let line = \"1\\n2\\n3\\n4\\n\";\n    ///\n    /// for num in line.lines() {\n    ///     match num.parse::<i32>().map(|i| i * 2) {\n    ///         Ok(n) => println!(\"{}\", n),\n    ///         Err(..) => {}\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U,E> {\n        match self {\n            Ok(t) => Ok(op(t)),\n            Err(e) => Err(e)\n        }\n    }\n\n    /// Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n    /// contained `Err` value, leaving an `Ok` value untouched.\n    ///\n    /// This function can be used to pass through a successful result while handling\n    /// an error.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn stringify(x: u32) -> String { format!(\"error code: {}\", x) }\n    ///\n    /// let x: Result<u32, u32> = Ok(2);\n    /// assert_eq!(x.map_err(stringify), Ok(2));\n    ///\n    /// let x: Result<u32, u32> = Err(13);\n    /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T,F> {\n        match self {\n            Ok(t) => Ok(t),\n            Err(e) => Err(op(e))\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Iterator constructors\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns an iterator over the possibly contained value.\n    ///\n    /// The iterator yields one value if the result is [`Ok`], otherwise none.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(7);\n    /// assert_eq!(x.iter().next(), Some(&7));\n    ///\n    /// let x: Result<u32, &str> = Err(\"nothing!\");\n    /// assert_eq!(x.iter().next(), None);\n    /// ```\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<T> {\n        Iter { inner: self.as_ref().ok() }\n    }\n\n    /// Returns a mutable iterator over the possibly contained value.\n    ///\n    /// The iterator yields one value if the result is [`Ok`], otherwise none.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut x: Result<u32, &str> = Ok(7);\n    /// match x.iter_mut().next() {\n    ///     Some(v) => *v = 40,\n    ///     None => {},\n    /// }\n    /// assert_eq!(x, Ok(40));\n    ///\n    /// let mut x: Result<u32, &str> = Err(\"nothing!\");\n    /// assert_eq!(x.iter_mut().next(), None);\n    /// ```\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut { inner: self.as_mut().ok() }\n    }\n\n    ////////////////////////////////////////////////////////////////////////\n    // Boolean operations on the values, eager and lazy\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// let y: Result<&str, &str> = Err(\"late error\");\n    /// assert_eq!(x.and(y), Err(\"late error\"));\n    ///\n    /// let x: Result<u32, &str> = Err(\"early error\");\n    /// let y: Result<&str, &str> = Ok(\"foo\");\n    /// assert_eq!(x.and(y), Err(\"early error\"));\n    ///\n    /// let x: Result<u32, &str> = Err(\"not a 2\");\n    /// let y: Result<&str, &str> = Err(\"late error\");\n    /// assert_eq!(x.and(y), Err(\"not a 2\"));\n    ///\n    /// let x: Result<u32, &str> = Ok(2);\n    /// let y: Result<&str, &str> = Ok(\"different result type\");\n    /// assert_eq!(x.and(y), Ok(\"different result type\"));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n        match self {\n            Ok(_) => res,\n            Err(e) => Err(e),\n        }\n    }\n\n    /// Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n    ///\n    /// This function can be used for control flow based on `Result` values.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n    ///\n    /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n    /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n    /// assert_eq!(Ok(2).and_then(err).and_then(sq), Err(2));\n    /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n        match self {\n            Ok(t) => op(t),\n            Err(e) => Err(e),\n        }\n    }\n\n    /// Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// let y: Result<u32, &str> = Err(\"late error\");\n    /// assert_eq!(x.or(y), Ok(2));\n    ///\n    /// let x: Result<u32, &str> = Err(\"early error\");\n    /// let y: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.or(y), Ok(2));\n    ///\n    /// let x: Result<u32, &str> = Err(\"not a 2\");\n    /// let y: Result<u32, &str> = Err(\"late error\");\n    /// assert_eq!(x.or(y), Err(\"late error\"));\n    ///\n    /// let x: Result<u32, &str> = Ok(2);\n    /// let y: Result<u32, &str> = Ok(100);\n    /// assert_eq!(x.or(y), Ok(2));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> {\n        match self {\n            Ok(v) => Ok(v),\n            Err(_) => res,\n        }\n    }\n\n    /// Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n    ///\n    /// This function can be used for control flow based on result values.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n    ///\n    /// assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));\n    /// assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));\n    /// assert_eq!(Err(3).or_else(sq).or_else(err), Ok(9));\n    /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n        match self {\n            Ok(t) => Ok(t),\n            Err(e) => op(e),\n        }\n    }\n\n    /// Unwraps a result, yielding the content of an `Ok`.\n    /// Else, it returns `optb`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let optb = 2;\n    /// let x: Result<u32, &str> = Ok(9);\n    /// assert_eq!(x.unwrap_or(optb), 9);\n    ///\n    /// let x: Result<u32, &str> = Err(\"error\");\n    /// assert_eq!(x.unwrap_or(optb), optb);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or(self, optb: T) -> T {\n        match self {\n            Ok(t) => t,\n            Err(_) => optb\n        }\n    }\n\n    /// Unwraps a result, yielding the content of an `Ok`.\n    /// If the value is an `Err` then it calls `op` with its value.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn count(x: &str) -> usize { x.len() }\n    ///\n    /// assert_eq!(Ok(2).unwrap_or_else(count), 2);\n    /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n        match self {\n            Ok(t) => t,\n            Err(e) => op(e)\n        }\n    }\n}\n\nimpl<T, E: fmt::Debug> Result<T, E> {\n    /// Unwraps a result, yielding the content of an `Ok`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is an `Err`, with a panic message provided by the\n    /// `Err`'s value.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.unwrap(), 2);\n    /// ```\n    ///\n    /// ```{.should_panic}\n    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n    /// x.unwrap(); // panics with `emergency failure`\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap(self) -> T {\n        match self {\n            Ok(t) => t,\n            Err(e) => unwrap_failed(\"called `Result::unwrap()` on an `Err` value\", e),\n        }\n    }\n\n    /// Unwraps a result, yielding the content of an `Ok`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is an `Err`, with a panic message including the\n    /// passed message, and the content of the `Err`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```{.should_panic}\n    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n    /// ```\n    #[inline]\n    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n    pub fn expect(self, msg: &str) -> T {\n        match self {\n            Ok(t) => t,\n            Err(e) => unwrap_failed(msg, e),\n        }\n    }\n}\n\nimpl<T: fmt::Debug, E> Result<T, E> {\n    /// Unwraps a result, yielding the content of an `Err`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is an `Ok`, with a custom panic message provided\n    /// by the `Ok`'s value.\n    ///\n    /// # Examples\n    ///\n    /// ```{.should_panic}\n    /// let x: Result<u32, &str> = Ok(2);\n    /// x.unwrap_err(); // panics with `2`\n    /// ```\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n    /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_err(self) -> E {\n        match self {\n            Ok(t) => unwrap_failed(\"called `Result::unwrap_err()` on an `Ok` value\", t),\n            Err(e) => e,\n        }\n    }\n\n    /// Unwraps a result, yielding the content of an `Err`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is an `Ok`, with a panic message including the\n    /// passed message, and the content of the `Ok`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```{.should_panic}\n    /// let x: Result<u32, &str> = Ok(10);\n    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n    /// ```\n    #[inline]\n    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n    pub fn expect_err(self, msg: &str) -> E {\n        match self {\n            Ok(t) => unwrap_failed(msg, t),\n            Err(e) => e,\n        }\n    }\n}\n\nimpl<T: Default, E> Result<T, E> {\n    /// Returns the contained value or a default\n    ///\n    /// Consumes the `self` argument then, if `Ok`, returns the contained\n    /// value, otherwise if `Err`, returns the default value for that\n    /// type.\n    ///\n    /// # Examples\n    ///\n    /// Convert a string to an integer, turning poorly-formed strings\n    /// into 0 (the default value for integers). [`parse`] converts\n    /// a string to any other type that implements [`FromStr`], returning an\n    /// `Err` on error.\n    ///\n    /// ```\n    /// let good_year_from_input = \"1909\";\n    /// let bad_year_from_input = \"190blarg\";\n    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n    ///\n    /// assert_eq!(1909, good_year);\n    /// assert_eq!(0, bad_year);\n    /// ```\n    ///\n    /// [`parse`]: ../../std/primitive.str.html#method.parse\n    /// [`FromStr`]: ../../std/str/trait.FromStr.html\n    #[inline]\n    #[stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")]\n    pub fn unwrap_or_default(self) -> T {\n        match self {\n            Ok(x) => x,\n            Err(_) => Default::default(),\n        }\n    }\n}\n\n// This is a separate function to reduce the code size of the methods\n#[inline(never)]\n#[cold]\nfn unwrap_failed<E: fmt::Debug>(msg: &str, error: E) -> ! {\n    panic!(\"{}: {:?}\", msg, error)\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Trait implementations\n/////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, E> IntoIterator for Result<T, E> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Returns a consuming iterator over the possibly contained value.\n    ///\n    /// The iterator yields one value if the result is [`Ok`], otherwise none.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(5);\n    /// let v: Vec<u32> = x.into_iter().collect();\n    /// assert_eq!(v, [5]);\n    ///\n    /// let x: Result<u32, &str> = Err(\"nothing!\");\n    /// let v: Vec<u32> = x.into_iter().collect();\n    /// assert_eq!(v, []);\n    /// ```\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n        IntoIter { inner: self.ok() }\n    }\n}\n\n#[stable(since = \"1.4.0\", feature = \"result_iter\")]\nimpl<'a, T, E> IntoIterator for &'a Result<T, E> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(since = \"1.4.0\", feature = \"result_iter\")]\nimpl<'a, T, E> IntoIterator for &'a mut Result<T, E> {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(mut self) -> IterMut<'a, T> {\n        self.iter_mut()\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The Result Iterators\n/////////////////////////////////////////////////////////////////////////////\n\n/// An iterator over a reference to the [`Ok`] variant of a [`Result`].\n///\n/// The iterator yields one value if the result is [`Ok`], otherwise none.\n///\n/// Created by [`Result::iter`].\n///\n/// [`Ok`]: enum.Result.html#variant.Ok\n/// [`Result`]: enum.Result.html\n/// [`Result::iter`]: enum.Result.html#method.iter\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> { self.inner.take() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = if self.inner.is_some() {1} else {0};\n        (n, Some(n))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for Iter<'a, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, A> TrustedLen for Iter<'a, A> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Clone for Iter<'a, T> {\n    fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n}\n\n/// An iterator over a mutable reference to the [`Ok`] variant of a [`Result`].\n///\n/// Created by [`Result::iter_mut`].\n///\n/// [`Ok`]: enum.Result.html#variant.Ok\n/// [`Result`]: enum.Result.html\n/// [`Result::iter_mut`]: enum.Result.html#method.iter_mut\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut T> { self.inner.take() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = if self.inner.is_some() {1} else {0};\n        (n, Some(n))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for IterMut<'a, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n\n/// An iterator over the value in a [`Ok`] variant of a [`Result`].\n///\n/// The iterator yields one value if the result is [`Ok`], otherwise none.\n///\n/// This struct is created by the [`into_iter`] method on\n/// [`Result`][`Result`] (provided by the [`IntoIterator`] trait).\n///\n/// [`Ok`]: enum.Result.html#variant.Ok\n/// [`Result`]: enum.Result.html\n/// [`into_iter`]: ../iter/trait.IntoIterator.html#tymethod.into_iter\n/// [`IntoIterator`]: ../iter/trait.IntoIterator.html\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<T> { inner: Option<T> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> { self.inner.take() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = if self.inner.is_some() {1} else {0};\n        (n, Some(n))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> { self.inner.take() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for IntoIter<T> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<T> FusedIterator for IntoIter<T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A> TrustedLen for IntoIter<A> {}\n\n/////////////////////////////////////////////////////////////////////////////\n// FromIterator\n/////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n    /// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n    /// container with the values of each `Result` is returned.\n    ///\n    /// Here is an example which increments every integer in a vector,\n    /// checking for overflow:\n    ///\n    /// ```\n    /// let v = vec![1, 2];\n    /// let res: Result<Vec<u32>, &'static str> = v.iter().map(|x: &u32|\n    ///     x.checked_add(1).ok_or(\"Overflow!\")\n    /// ).collect();\n    /// assert!(res == Ok(vec![2, 3]));\n    /// ```\n    #[inline]\n    fn from_iter<I: IntoIterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {\n        // FIXME(#11084): This could be replaced with Iterator::scan when this\n        // performance bug is closed.\n\n        struct Adapter<Iter, E> {\n            iter: Iter,\n            err: Option<E>,\n        }\n\n        impl<T, E, Iter: Iterator<Item=Result<T, E>>> Iterator for Adapter<Iter, E> {\n            type Item = T;\n\n            #[inline]\n            fn next(&mut self) -> Option<T> {\n                match self.iter.next() {\n                    Some(Ok(value)) => Some(value),\n                    Some(Err(err)) => {\n                        self.err = Some(err);\n                        None\n                    }\n                    None => None,\n                }\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let (_min, max) = self.iter.size_hint();\n                (0, max)\n            }\n        }\n\n        let mut adapter = Adapter { iter: iter.into_iter(), err: None };\n        let v: V = FromIterator::from_iter(adapter.by_ref());\n\n        match adapter.err {\n            Some(err) => Err(err),\n            None => Ok(v),\n        }\n    }\n}\n\n#[unstable(feature = \"try_trait\", issue = \"42327\")]\nimpl<T,E> ops::Try for Result<T, E> {\n    type Ok = T;\n    type Error = E;\n\n    fn into_result(self) -> Self {\n        self\n    }\n\n    fn from_ok(v: T) -> Self {\n        Ok(v)\n    }\n\n    fn from_error(v: E) -> Self {\n        Err(v)\n    }\n}\n","// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Inspection and manipulation of the process's environment.\n//!\n//! This module contains functions to inspect various aspects such as\n//! environment variables, process arguments, the current directory, and various\n//! other important directories.\n//!\n//! There are several functions and structs in this module that have a\n//! counterpart ending in `os`. Those ending in `os` will return an [`OsString`]\n//! and those without will be returning a [`String`].\n//!\n//! [`OsString`]: ../../std/ffi/struct.OsString.html\n//! [`String`]: ../string/struct.String.html\n\n#![stable(feature = \"env\", since = \"1.0.0\")]\n\nuse error::Error;\nuse ffi::{OsStr, OsString};\nuse fmt;\nuse io;\nuse path::{Path, PathBuf};\nuse sys;\nuse sys::os as os_imp;\n\n/// Returns the current working directory as a [`PathBuf`].\n///\n/// # Errors\n///\n/// Returns an [`Err`] if the current working directory value is invalid.\n/// Possible cases:\n///\n/// * Current directory does not exist.\n/// * There are insufficient permissions to access the current directory.\n///\n/// [`PathBuf`]: ../../std/path/struct.PathBuf.html\n/// [`Err`]: ../../std/result/enum.Result.html#method.err\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// // We assume that we are in a valid directory.\n/// let path = env::current_dir().unwrap();\n/// println!(\"The current directory is {}\", path.display());\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn current_dir() -> io::Result<PathBuf> {\n    os_imp::getcwd()\n}\n\n/// Changes the current working directory to the specified path.\n///\n/// Returns an [`Err`] if the operation fails.\n///\n/// [`Err`]: ../../std/result/enum.Result.html#method.err\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n/// use std::path::Path;\n///\n/// let root = Path::new(\"/\");\n/// assert!(env::set_current_dir(&root).is_ok());\n/// println!(\"Successfully changed working directory to {}!\", root.display());\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn set_current_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n    os_imp::chdir(path.as_ref())\n}\n\n/// An iterator over a snapshot of the environment variables of this process.\n///\n/// This structure is created by the [`std::env::vars`] function. See its\n/// documentation for more.\n///\n/// [`std::env::vars`]: fn.vars.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub struct Vars { inner: VarsOs }\n\n/// An iterator over a snapshot of the environment variables of this process.\n///\n/// This structure is created by the [`std::env::vars_os`] function. See\n/// its documentation for more.\n///\n/// [`std::env::vars_os`]: fn.vars_os.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub struct VarsOs { inner: os_imp::Env }\n\n/// Returns an iterator of (variable, value) pairs of strings, for all the\n/// environment variables of the current process.\n///\n/// The returned iterator contains a snapshot of the process's environment\n/// variables at the time of this invocation. Modifications to environment\n/// variables afterwards will not be reflected in the returned iterator.\n///\n/// # Panics\n///\n/// While iterating, the returned iterator will panic if any key or value in the\n/// environment is not valid unicode. If this is not desired, consider using the\n/// [`env::vars_os`] function.\n///\n/// [`env::vars_os`]: fn.vars_os.html\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// // We will iterate through the references to the element returned by\n/// // env::vars();\n/// for (key, value) in env::vars() {\n///     println!(\"{}: {}\", key, value);\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn vars() -> Vars {\n    Vars { inner: vars_os() }\n}\n\n/// Returns an iterator of (variable, value) pairs of OS strings, for all the\n/// environment variables of the current process.\n///\n/// The returned iterator contains a snapshot of the process's environment\n/// variables at the time of this invocation. Modifications to environment\n/// variables afterwards will not be reflected in the returned iterator.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// // We will iterate through the references to the element returned by\n/// // env::vars_os();\n/// for (key, value) in env::vars_os() {\n///     println!(\"{:?}: {:?}\", key, value);\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn vars_os() -> VarsOs {\n    VarsOs { inner: os_imp::env() }\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl Iterator for Vars {\n    type Item = (String, String);\n    fn next(&mut self) -> Option<(String, String)> {\n        self.inner.next().map(|(a, b)| {\n            (a.into_string().unwrap(), b.into_string().unwrap())\n        })\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Vars {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"Vars { .. }\")\n    }\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl Iterator for VarsOs {\n    type Item = (OsString, OsString);\n    fn next(&mut self) -> Option<(OsString, OsString)> { self.inner.next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for VarsOs {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"VarsOs { .. }\")\n    }\n}\n\n/// Fetches the environment variable `key` from the current process.\n///\n/// # Errors\n///\n/// * Environment variable is not present\n/// * Environment variable is not valid unicode\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// let key = \"HOME\";\n/// match env::var(key) {\n///     Ok(val) => println!(\"{}: {:?}\", key, val),\n///     Err(e) => println!(\"couldn't interpret {}: {}\", key, e),\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn var<K: AsRef<OsStr>>(key: K) -> Result<String, VarError> {\n    _var(key.as_ref())\n}\n\nfn _var(key: &OsStr) -> Result<String, VarError> {\n    match var_os(key) {\n        Some(s) => s.into_string().map_err(VarError::NotUnicode),\n        None => Err(VarError::NotPresent),\n    }\n}\n\n/// Fetches the environment variable `key` from the current process, returning\n/// [`None`] if the variable isn't set.\n///\n/// [`None`]: ../option/enum.Option.html#variant.None\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// let key = \"HOME\";\n/// match env::var_os(key) {\n///     Some(val) => println!(\"{}: {:?}\", key, val),\n///     None => println!(\"{} is not defined in the environment.\", key)\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn var_os<K: AsRef<OsStr>>(key: K) -> Option<OsString> {\n    _var_os(key.as_ref())\n}\n\nfn _var_os(key: &OsStr) -> Option<OsString> {\n    os_imp::getenv(key).unwrap_or_else(|e| {\n        panic!(\"failed to get environment variable `{:?}`: {}\", key, e)\n    })\n}\n\n/// The error type for operations interacting with environment variables.\n/// Possibly returned from the [`env::var`] function.\n///\n/// [`env::var`]: fn.var.html\n#[derive(Debug, PartialEq, Eq, Clone)]\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub enum VarError {\n    /// The specified environment variable was not present in the current\n    /// process's environment.\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    NotPresent,\n\n    /// The specified environment variable was found, but it did not contain\n    /// valid unicode data. The found data is returned as a payload of this\n    /// variant.\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    NotUnicode(#[stable(feature = \"env\", since = \"1.0.0\")] OsString),\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl fmt::Display for VarError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            VarError::NotPresent => write!(f, \"environment variable not found\"),\n            VarError::NotUnicode(ref s) => {\n                write!(f, \"environment variable was not valid unicode: {:?}\", s)\n            }\n        }\n    }\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl Error for VarError {\n    fn description(&self) -> &str {\n        match *self {\n            VarError::NotPresent => \"environment variable not found\",\n            VarError::NotUnicode(..) => \"environment variable was not valid unicode\",\n        }\n    }\n}\n\n/// Sets the environment variable `k` to the value `v` for the currently running\n/// process.\n///\n/// Note that while concurrent access to environment variables is safe in Rust,\n/// some platforms only expose inherently unsafe non-threadsafe APIs for\n/// inspecting the environment. As a result extra care needs to be taken when\n/// auditing calls to unsafe external FFI functions to ensure that any external\n/// environment accesses are properly synchronized with accesses in Rust.\n///\n/// Discussion of this unsafety on Unix may be found in:\n///\n///  - [Austin Group Bugzilla](http://austingroupbugs.net/view.php?id=188)\n///  - [GNU C library Bugzilla](https://sourceware.org/bugzilla/show_bug.cgi?id=15607#c2)\n///\n/// # Panics\n///\n/// This function may panic if `key` is empty, contains an ASCII equals sign\n/// `'='` or the NUL character `'\\0'`, or when the value contains the NUL\n/// character.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// let key = \"KEY\";\n/// env::set_var(key, \"VALUE\");\n/// assert_eq!(env::var(key), Ok(\"VALUE\".to_string()));\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn set_var<K: AsRef<OsStr>, V: AsRef<OsStr>>(k: K, v: V) {\n    _set_var(k.as_ref(), v.as_ref())\n}\n\nfn _set_var(k: &OsStr, v: &OsStr) {\n    os_imp::setenv(k, v).unwrap_or_else(|e| {\n        panic!(\"failed to set environment variable `{:?}` to `{:?}`: {}\",\n               k, v, e)\n    })\n}\n\n/// Removes an environment variable from the environment of the currently running process.\n///\n/// Note that while concurrent access to environment variables is safe in Rust,\n/// some platforms only expose inherently unsafe non-threadsafe APIs for\n/// inspecting the environment. As a result extra care needs to be taken when\n/// auditing calls to unsafe external FFI functions to ensure that any external\n/// environment accesses are properly synchronized with accesses in Rust.\n///\n/// Discussion of this unsafety on Unix may be found in:\n///\n///  - [Austin Group Bugzilla](http://austingroupbugs.net/view.php?id=188)\n///  - [GNU C library Bugzilla](https://sourceware.org/bugzilla/show_bug.cgi?id=15607#c2)\n///\n/// # Panics\n///\n/// This function may panic if `key` is empty, contains an ASCII equals sign\n/// `'='` or the NUL character `'\\0'`, or when the value contains the NUL\n/// character.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// let key = \"KEY\";\n/// env::set_var(key, \"VALUE\");\n/// assert_eq!(env::var(key), Ok(\"VALUE\".to_string()));\n///\n/// env::remove_var(key);\n/// assert!(env::var(key).is_err());\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn remove_var<K: AsRef<OsStr>>(k: K) {\n    _remove_var(k.as_ref())\n}\n\nfn _remove_var(k: &OsStr) {\n    os_imp::unsetenv(k).unwrap_or_else(|e| {\n        panic!(\"failed to remove environment variable `{:?}`: {}\", k, e)\n    })\n}\n\n/// An iterator that splits an environment variable into paths according to\n/// platform-specific conventions.\n///\n/// This structure is created by the [`std::env::split_paths`] function. See its\n/// documentation for more.\n///\n/// [`std::env::split_paths`]: fn.split_paths.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub struct SplitPaths<'a> { inner: os_imp::SplitPaths<'a> }\n\n/// Parses input according to platform conventions for the `PATH`\n/// environment variable.\n///\n/// Returns an iterator over the paths contained in `unparsed`.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// let key = \"PATH\";\n/// match env::var_os(key) {\n///     Some(paths) => {\n///         for path in env::split_paths(&paths) {\n///             println!(\"'{}'\", path.display());\n///         }\n///     }\n///     None => println!(\"{} is not defined in the environment.\", key)\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn split_paths<T: AsRef<OsStr> + ?Sized>(unparsed: &T) -> SplitPaths {\n    SplitPaths { inner: os_imp::split_paths(unparsed.as_ref()) }\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl<'a> Iterator for SplitPaths<'a> {\n    type Item = PathBuf;\n    fn next(&mut self) -> Option<PathBuf> { self.inner.next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<'a> fmt::Debug for SplitPaths<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"SplitPaths { .. }\")\n    }\n}\n\n/// The error type for operations on the `PATH` variable. Possibly returned from\n/// the [`env::join_paths`] function.\n///\n/// [`env::join_paths`]: fn.join_paths.html\n#[derive(Debug)]\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub struct JoinPathsError {\n    inner: os_imp::JoinPathsError\n}\n\n/// Joins a collection of [`Path`]s appropriately for the `PATH`\n/// environment variable.\n///\n/// # Errors\n///\n/// Returns an [`Err`][err] (containing an error message) if one of the input\n/// [`Path`]s contains an invalid character for constructing the `PATH`\n/// variable (a double quote on Windows or a colon on Unix).\n///\n/// [`Path`]: ../../std/path/struct.Path.html\n/// [`OsString`]: ../../std/ffi/struct.OsString.html\n/// [err]: ../../std/result/enum.Result.html#variant.Err\n///\n/// # Examples\n///\n/// Joining paths on a Unix-like platform:\n///\n/// ```\n/// # if cfg!(unix) {\n/// use std::env;\n/// use std::ffi::OsString;\n/// use std::path::Path;\n///\n/// let paths = [Path::new(\"/bin\"), Path::new(\"/usr/bin\")];\n/// let path_os_string = env::join_paths(paths.iter()).unwrap();\n/// assert_eq!(path_os_string, OsString::from(\"/bin:/usr/bin\"));\n/// # }\n/// ```\n///\n/// Joining a path containing a colon on a Unix-like platform results in an error:\n///\n/// ```\n/// # if cfg!(unix) {\n/// use std::env;\n/// use std::path::Path;\n///\n/// let paths = [Path::new(\"/bin\"), Path::new(\"/usr/bi:n\")];\n/// assert!(env::join_paths(paths.iter()).is_err());\n/// # }\n/// ```\n///\n/// Using `env::join_paths` with `env::spit_paths` to append an item to the `PATH` environment\n/// variable:\n///\n/// ```\n/// use std::env;\n/// use std::path::PathBuf;\n///\n/// if let Some(path) = env::var_os(\"PATH\") {\n///     let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n///     paths.push(PathBuf::from(\"/home/xyz/bin\"));\n///     let new_path = env::join_paths(paths).unwrap();\n///     env::set_var(\"PATH\", &new_path);\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n    where I: IntoIterator<Item=T>, T: AsRef<OsStr>\n{\n    os_imp::join_paths(paths.into_iter()).map_err(|e| {\n        JoinPathsError { inner: e }\n    })\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl fmt::Display for JoinPathsError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.inner.fmt(f)\n    }\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl Error for JoinPathsError {\n    fn description(&self) -> &str { self.inner.description() }\n}\n\n/// Returns the path of the current user's home directory if known.\n///\n/// # Unix\n///\n/// Returns the value of the 'HOME' environment variable if it is set\n/// and not equal to the empty string. Otherwise, it tries to determine the\n/// home directory by invoking the `getpwuid_r` function on the UID of the\n/// current user.\n///\n/// # Windows\n///\n/// Returns the value of the 'HOME' environment variable if it is\n/// set and not equal to the empty string. Otherwise, returns the value of the\n/// 'USERPROFILE' environment variable if it is set and not equal to the empty\n/// string. If both do not exist, [`GetUserProfileDirectory`][msdn] is used to\n/// return the appropriate path.\n///\n/// [msdn]: https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// match env::home_dir() {\n///     Some(path) => println!(\"{}\", path.display()),\n///     None => println!(\"Impossible to get your home dir!\"),\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn home_dir() -> Option<PathBuf> {\n    os_imp::home_dir()\n}\n\n/// Returns the path of a temporary directory.\n///\n/// # Unix\n///\n/// Returns the value of the `TMPDIR` environment variable if it is\n/// set, otherwise for non-Android it returns `/tmp`. If Android, since there\n/// is no global temporary folder (it is usually allocated per-app), it returns\n/// `/data/local/tmp`.\n///\n/// # Windows\n///\n/// Returns the value of, in order, the `TMP`, `TEMP`,\n/// `USERPROFILE` environment variable if any are set and not the empty\n/// string. Otherwise, `temp_dir` returns the path of the Windows directory.\n/// This behavior is identical to that of [`GetTempPath`][msdn], which this\n/// function uses internally.\n///\n/// [msdn]: https://msdn.microsoft.com/en-us/library/windows/desktop/aa364992(v=vs.85).aspx\n///\n/// ```\n/// use std::env;\n/// use std::fs::File;\n///\n/// # fn foo() -> std::io::Result<()> {\n/// let mut dir = env::temp_dir();\n/// dir.push(\"foo.txt\");\n///\n/// let f = File::create(dir)?;\n/// # Ok(())\n/// # }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn temp_dir() -> PathBuf {\n    os_imp::temp_dir()\n}\n\n/// Returns the full filesystem path of the current running executable.\n///\n/// The path returned is not necessarily a \"real path\" of the executable as\n/// there may be intermediate symlinks.\n///\n/// # Errors\n///\n/// Acquiring the path of the current executable is a platform-specific operation\n/// that can fail for a good number of reasons. Some errors can include, but not\n/// be limited to, filesystem operations failing or general syscall failures.\n///\n/// # Security\n///\n/// The output of this function should not be used in anything that might have\n/// security implications. For example:\n///\n/// ```\n/// fn main() {\n///     println!(\"{:?}\", std::env::current_exe());\n/// }\n/// ```\n///\n/// On Linux systems, if this is compiled as `foo`:\n///\n/// ```bash\n/// $ rustc foo.rs\n/// $ ./foo\n/// Ok(\"/home/alex/foo\")\n/// ```\n///\n/// And you make a symbolic link of the program:\n///\n/// ```bash\n/// $ ln foo bar\n/// ```\n///\n/// When you run it, you won't get the original executable, you'll get the\n/// symlink:\n///\n/// ```bash\n/// $ ./bar\n/// Ok(\"/home/alex/bar\")\n/// ```\n///\n/// This sort of behavior has been known to [lead to privilege escalation] when\n/// used incorrectly, for example.\n///\n/// [lead to privilege escalation]: http://securityvulns.com/Wdocument183.html\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// match env::current_exe() {\n///     Ok(exe_path) => println!(\"Path of this executable is: {}\",\n///                               exe_path.display()),\n///     Err(e) => println!(\"failed to get current exe path: {}\", e),\n/// };\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    os_imp::current_exe()\n}\n\n/// An iterator over the arguments of a process, yielding a [`String`] value for\n/// each argument.\n///\n/// This struct is created by the [`std::env::args`] function. See its\n/// documentation for more.\n///\n/// The first element is traditionally the path of the executable, but it can be\n/// set to arbitrary text, and may not even exist. This means this property\n/// should not be relied upon for security purposes.\n///\n/// [`String`]: ../string/struct.String.html\n/// [`std::env::args`]: ./fn.args.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub struct Args { inner: ArgsOs }\n\n/// An iterator over the arguments of a process, yielding an [`OsString`] value\n/// for each argument.\n///\n/// This struct is created by the [`std::env::args_os`] function. See its\n/// documentation for more.\n///\n/// The first element is traditionally the path of the executable, but it can be\n/// set to arbitrary text, and may not even exist. This means this property\n/// should not be relied upon for security purposes.\n///\n/// [`OsString`]: ../ffi/struct.OsString.html\n/// [`std::env::args_os`]: ./fn.args_os.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub struct ArgsOs { inner: sys::args::Args }\n\n/// Returns the arguments which this program was started with (normally passed\n/// via the command line).\n///\n/// The first element is traditionally the path of the executable, but it can be\n/// set to arbitrary text, and may not even exist. This means this property should\n/// not be relied upon for security purposes.\n///\n/// # Panics\n///\n/// The returned iterator will panic during iteration if any argument to the\n/// process is not valid unicode. If this is not desired,\n/// use the [`args_os`] function instead.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// // Prints each argument on a separate line\n/// for argument in env::args() {\n///     println!(\"{}\", argument);\n/// }\n/// ```\n///\n/// [`args_os`]: ./fn.args_os.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn args() -> Args {\n    Args { inner: args_os() }\n}\n\n/// Returns the arguments which this program was started with (normally passed\n/// via the command line).\n///\n/// The first element is traditionally the path of the executable, but it can be\n/// set to arbitrary text, and it may not even exist, so this property should\n/// not be relied upon for security purposes.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// // Prints each argument on a separate line\n/// for argument in env::args_os() {\n///     println!(\"{:?}\", argument);\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn args_os() -> ArgsOs {\n    ArgsOs { inner: sys::args::args() }\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl Iterator for Args {\n    type Item = String;\n    fn next(&mut self) -> Option<String> {\n        self.inner.next().map(|s| s.into_string().unwrap())\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl ExactSizeIterator for Args {\n    fn len(&self) -> usize { self.inner.len() }\n    fn is_empty(&self) -> bool { self.inner.is_empty() }\n}\n\n#[stable(feature = \"env_iterators\", since = \"1.12.0\")]\nimpl DoubleEndedIterator for Args {\n    fn next_back(&mut self) -> Option<String> {\n        self.inner.next_back().map(|s| s.into_string().unwrap())\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Args {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Args\")\n            .field(\"inner\", &self.inner.inner.inner_debug())\n            .finish()\n    }\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl Iterator for ArgsOs {\n    type Item = OsString;\n    fn next(&mut self) -> Option<OsString> { self.inner.next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl ExactSizeIterator for ArgsOs {\n    fn len(&self) -> usize { self.inner.len() }\n    fn is_empty(&self) -> bool { self.inner.is_empty() }\n}\n\n#[stable(feature = \"env_iterators\", since = \"1.12.0\")]\nimpl DoubleEndedIterator for ArgsOs {\n    fn next_back(&mut self) -> Option<OsString> { self.inner.next_back() }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ArgsOs {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"ArgsOs\")\n            .field(\"inner\", &self.inner.inner_debug())\n            .finish()\n    }\n}\n\n/// Constants associated with the current target\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub mod consts {\n    use sys::env::os;\n\n    /// A string describing the architecture of the CPU that is currently\n    /// in use.\n    ///\n    /// Some possible values:\n    ///\n    /// - x86\n    /// - x86_64\n    /// - arm\n    /// - aarch64\n    /// - mips\n    /// - mips64\n    /// - powerpc\n    /// - powerpc64\n    /// - s390x\n    /// - sparc64\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const ARCH: &'static str = super::arch::ARCH;\n\n    /// The family of the operating system. Example value is `unix`.\n    ///\n    /// Some possible values:\n    ///\n    /// - unix\n    /// - windows\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const FAMILY: &'static str = os::FAMILY;\n\n    /// A string describing the specific operating system in use.\n    /// Example value is `linux`.\n    ///\n    /// Some possible values:\n    ///\n    /// - linux\n    /// - macos\n    /// - ios\n    /// - freebsd\n    /// - dragonfly\n    /// - bitrig\n    /// - netbsd\n    /// - openbsd\n    /// - solaris\n    /// - android\n    /// - windows\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const OS: &'static str = os::OS;\n\n    /// Specifies the filename prefix used for shared libraries on this\n    /// platform. Example value is `lib`.\n    ///\n    /// Some possible values:\n    ///\n    /// - lib\n    /// - `\"\"` (an empty string)\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const DLL_PREFIX: &'static str = os::DLL_PREFIX;\n\n    /// Specifies the filename suffix used for shared libraries on this\n    /// platform. Example value is `.so`.\n    ///\n    /// Some possible values:\n    ///\n    /// - .so\n    /// - .dylib\n    /// - .dll\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const DLL_SUFFIX: &'static str = os::DLL_SUFFIX;\n\n    /// Specifies the file extension used for shared libraries on this\n    /// platform that goes after the dot. Example value is `so`.\n    ///\n    /// Some possible values:\n    ///\n    /// - so\n    /// - dylib\n    /// - dll\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const DLL_EXTENSION: &'static str = os::DLL_EXTENSION;\n\n    /// Specifies the filename suffix used for executable binaries on this\n    /// platform. Example value is `.exe`.\n    ///\n    /// Some possible values:\n    ///\n    /// - .exe\n    /// - .nexe\n    /// - .pexe\n    /// - `\"\"` (an empty string)\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const EXE_SUFFIX: &'static str = os::EXE_SUFFIX;\n\n    /// Specifies the file extension, if any, used for executable binaries\n    /// on this platform. Example value is `exe`.\n    ///\n    /// Some possible values:\n    ///\n    /// - exe\n    /// - `\"\"` (an empty string)\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const EXE_EXTENSION: &'static str = os::EXE_EXTENSION;\n}\n\n#[cfg(target_arch = \"x86\")]\nmod arch {\n    pub const ARCH: &'static str = \"x86\";\n}\n\n#[cfg(target_arch = \"x86_64\")]\nmod arch {\n    pub const ARCH: &'static str = \"x86_64\";\n}\n\n#[cfg(target_arch = \"arm\")]\nmod arch {\n    pub const ARCH: &'static str = \"arm\";\n}\n\n#[cfg(target_arch = \"aarch64\")]\nmod arch {\n    pub const ARCH: &'static str = \"aarch64\";\n}\n\n#[cfg(target_arch = \"mips\")]\nmod arch {\n    pub const ARCH: &'static str = \"mips\";\n}\n\n#[cfg(target_arch = \"mips64\")]\nmod arch {\n    pub const ARCH: &'static str = \"mips64\";\n}\n\n#[cfg(target_arch = \"powerpc\")]\nmod arch {\n    pub const ARCH: &'static str = \"powerpc\";\n}\n\n#[cfg(target_arch = \"powerpc64\")]\nmod arch {\n    pub const ARCH: &'static str = \"powerpc64\";\n}\n\n#[cfg(target_arch = \"s390x\")]\nmod arch {\n    pub const ARCH: &'static str = \"s390x\";\n}\n\n#[cfg(target_arch = \"sparc64\")]\nmod arch {\n    pub const ARCH: &'static str = \"sparc64\";\n}\n\n#[cfg(target_arch = \"le32\")]\nmod arch {\n    pub const ARCH: &'static str = \"le32\";\n}\n\n#[cfg(target_arch = \"asmjs\")]\nmod arch {\n    pub const ARCH: &'static str = \"asmjs\";\n}\n\n#[cfg(target_arch = \"wasm32\")]\nmod arch {\n    pub const ARCH: &'static str = \"wasm32\";\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use ffi::OsStr;\n    use path::{Path, PathBuf};\n\n    #[test]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn test_self_exe_path() {\n        let path = current_exe();\n        assert!(path.is_ok());\n        let path = path.unwrap();\n\n        // Hard to test this function\n        assert!(path.is_absolute());\n    }\n\n    #[test]\n    fn test() {\n        assert!((!Path::new(\"test-path\").is_absolute()));\n\n        current_dir().unwrap();\n    }\n\n    #[test]\n    #[cfg(windows)]\n    fn split_paths_windows() {\n        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n            split_paths(unparsed).collect::<Vec<_>>() ==\n                parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n        }\n\n        assert!(check_parse(\"\", &mut [\"\"]));\n        assert!(check_parse(r#\"\"\"\"#, &mut [\"\"]));\n        assert!(check_parse(\";;\", &mut [\"\", \"\", \"\"]));\n        assert!(check_parse(r\"c:\\\", &mut [r\"c:\\\"]));\n        assert!(check_parse(r\"c:\\;\", &mut [r\"c:\\\", \"\"]));\n        assert!(check_parse(r\"c:\\;c:\\Program Files\\\",\n                            &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n        assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, &mut [r\"c:\\\", r\"c:\\foo\\\"]));\n        assert!(check_parse(r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n                            &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n    }\n\n    #[test]\n    #[cfg(unix)]\n    fn split_paths_unix() {\n        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n            split_paths(unparsed).collect::<Vec<_>>() ==\n                parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n        }\n\n        assert!(check_parse(\"\", &mut [\"\"]));\n        assert!(check_parse(\"::\", &mut [\"\", \"\", \"\"]));\n        assert!(check_parse(\"/\", &mut [\"/\"]));\n        assert!(check_parse(\"/:\", &mut [\"/\", \"\"]));\n        assert!(check_parse(\"/:/usr/local\", &mut [\"/\", \"/usr/local\"]));\n    }\n\n    #[test]\n    #[cfg(unix)]\n    fn join_paths_unix() {\n        fn test_eq(input: &[&str], output: &str) -> bool {\n            &*join_paths(input.iter().cloned()).unwrap() ==\n                OsStr::new(output)\n        }\n\n        assert!(test_eq(&[], \"\"));\n        assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"],\n                         \"/bin:/usr/bin:/usr/local/bin\"));\n        assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"],\n                         \":/bin:::/usr/bin:\"));\n        assert!(join_paths([\"/te:st\"].iter().cloned()).is_err());\n    }\n\n    #[test]\n    #[cfg(windows)]\n    fn join_paths_windows() {\n        fn test_eq(input: &[&str], output: &str) -> bool {\n            &*join_paths(input.iter().cloned()).unwrap() ==\n                OsStr::new(output)\n        }\n\n        assert!(test_eq(&[], \"\"));\n        assert!(test_eq(&[r\"c:\\windows\", r\"c:\\\"],\n                        r\"c:\\windows;c:\\\"));\n        assert!(test_eq(&[\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"],\n                        r\";c:\\windows;;;c:\\;\"));\n        assert!(test_eq(&[r\"c:\\te;st\", r\"c:\\\"],\n                        r#\"\"c:\\te;st\";c:\\\"#));\n        assert!(join_paths([r#\"c:\\te\"st\"#].iter().cloned()).is_err());\n    }\n\n    #[test]\n    fn args_debug() {\n        assert_eq!(\n            format!(\"Args {{ inner: {:?} }}\", args().collect::<Vec<_>>()),\n            format!(\"{:?}\", args()));\n        assert_eq!(\n            format!(\"ArgsOs {{ inner: {:?} }}\", args_os().collect::<Vec<_>>()),\n            format!(\"{:?}\", args_os()));\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![cfg_attr(target_os = \"nacl\", allow(dead_code))]\n\n/// Common code for printing the backtrace in the same way across the different\n/// supported platforms.\n\nuse env;\nuse io::prelude::*;\nuse io;\nuse libc;\nuse str;\nuse sync::atomic::{self, Ordering};\nuse path::{self, Path};\nuse sys::mutex::Mutex;\nuse ptr;\n\npub use sys::backtrace::{\n    unwind_backtrace,\n    resolve_symname,\n    foreach_symbol_fileline,\n    BacktraceContext\n};\n\n#[cfg(target_pointer_width = \"64\")]\npub const HEX_WIDTH: usize = 18;\n\n#[cfg(target_pointer_width = \"32\")]\npub const HEX_WIDTH: usize = 10;\n\n/// Represents an item in the backtrace list. See `unwind_backtrace` for how\n/// it is created.\n#[derive(Debug, Copy, Clone)]\npub struct Frame {\n    /// Exact address of the call that failed.\n    pub exact_position: *const libc::c_void,\n    /// Address of the enclosing function.\n    pub symbol_addr: *const libc::c_void,\n}\n\n/// Max number of frames to print.\nconst MAX_NB_FRAMES: usize = 100;\n\n/// Prints the current backtrace.\npub fn print(w: &mut Write, format: PrintFormat) -> io::Result<()> {\n    static LOCK: Mutex = Mutex::new();\n\n    // Use a lock to prevent mixed output in multithreading context.\n    // Some platforms also requires it, like `SymFromAddr` on Windows.\n    unsafe {\n        LOCK.lock();\n        let res = _print(w, format);\n        LOCK.unlock();\n        res\n    }\n}\n\nfn _print(w: &mut Write, format: PrintFormat) -> io::Result<()> {\n    let mut frames = [Frame {\n        exact_position: ptr::null(),\n        symbol_addr: ptr::null(),\n    }; MAX_NB_FRAMES];\n    let (nb_frames, context) = unwind_backtrace(&mut frames)?;\n    let (skipped_before, skipped_after) =\n        filter_frames(&frames[..nb_frames], format, &context);\n    if skipped_before + skipped_after > 0 {\n        writeln!(w, \"note: Some details are omitted, \\\n                     run with `RUST_BACKTRACE=full` for a verbose backtrace.\")?;\n    }\n    writeln!(w, \"stack backtrace:\")?;\n\n    let filtered_frames = &frames[..nb_frames - skipped_after];\n    for (index, frame) in filtered_frames.iter().skip(skipped_before).enumerate() {\n        resolve_symname(*frame, |symname| {\n            output(w, index, *frame, symname, format)\n        }, &context)?;\n        let has_more_filenames = foreach_symbol_fileline(*frame, |file, line| {\n            output_fileline(w, file, line, format)\n        }, &context)?;\n        if has_more_filenames {\n            w.write_all(b\" <... and possibly more>\")?;\n        }\n    }\n\n    Ok(())\n}\n\n/// Returns a number of frames to remove at the beginning and at the end of the\n/// backtrace, according to the backtrace format.\nfn filter_frames(frames: &[Frame],\n                 format: PrintFormat,\n                 context: &BacktraceContext) -> (usize, usize)\n{\n    if format == PrintFormat::Full {\n        return (0, 0);\n    }\n\n    let skipped_before = 0;\n\n    let skipped_after = frames.len() - frames.iter().position(|frame| {\n        let mut is_marker = false;\n        let _ = resolve_symname(*frame, |symname| {\n            if let Some(mangled_symbol_name) = symname {\n                // Use grep to find the concerned functions\n                if mangled_symbol_name.contains(\"__rust_begin_short_backtrace\") {\n                    is_marker = true;\n                }\n            }\n            Ok(())\n        }, context);\n        is_marker\n    }).unwrap_or(frames.len());\n\n    if skipped_before + skipped_after >= frames.len() {\n        // Avoid showing completely empty backtraces\n        return (0, 0);\n    }\n\n    (skipped_before, skipped_after)\n}\n\n\n/// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`.\n#[inline(never)]\npub fn __rust_begin_short_backtrace<F, T>(f: F) -> T\n    where F: FnOnce() -> T, F: Send + 'static, T: Send + 'static\n{\n    f()\n}\n\n/// Controls how the backtrace should be formated.\n#[derive(Debug, Copy, Clone, Eq, PartialEq)]\npub enum PrintFormat {\n    /// Show all the frames with absolute path for files.\n    Full = 2,\n    /// Show only relevant data from the backtrace.\n    Short = 3,\n}\n\n// For now logging is turned off by default, and this function checks to see\n// whether the magical environment variable is present to see if it's turned on.\npub fn log_enabled() -> Option<PrintFormat> {\n    static ENABLED: atomic::AtomicIsize = atomic::AtomicIsize::new(0);\n    match ENABLED.load(Ordering::SeqCst) {\n        0 => {},\n        1 => return None,\n        2 => return Some(PrintFormat::Full),\n        3 => return Some(PrintFormat::Short),\n        _ => unreachable!(),\n    }\n\n    let val = match env::var_os(\"RUST_BACKTRACE\") {\n        Some(x) => if &x == \"0\" {\n            None\n        } else if &x == \"full\" {\n            Some(PrintFormat::Full)\n        } else {\n            Some(PrintFormat::Short)\n        },\n        None => None,\n    };\n    ENABLED.store(match val {\n        Some(v) => v as isize,\n        None => 1,\n    }, Ordering::SeqCst);\n    val\n}\n\n/// Print the symbol of the backtrace frame.\n///\n/// These output functions should now be used everywhere to ensure consistency.\n/// You may want to also use `output_fileline`.\nfn output(w: &mut Write, idx: usize, frame: Frame,\n              s: Option<&str>, format: PrintFormat) -> io::Result<()> {\n    // Remove the `17: 0x0 - <unknown>` line.\n    if format == PrintFormat::Short && frame.exact_position == ptr::null() {\n        return Ok(());\n    }\n    match format {\n        PrintFormat::Full => write!(w,\n                                    \"  {:2}: {:2$?} - \",\n                                    idx,\n                                    frame.exact_position,\n                                    HEX_WIDTH)?,\n        PrintFormat::Short => write!(w, \"  {:2}: \", idx)?,\n    }\n    match s {\n        Some(string) => demangle(w, string, format)?,\n        None => w.write_all(b\"<unknown>\")?,\n    }\n    w.write_all(b\"\\n\")\n}\n\n/// Print the filename and line number of the backtrace frame.\n///\n/// See also `output`.\n#[allow(dead_code)]\nfn output_fileline(w: &mut Write, file: &[u8], line: libc::c_int,\n                       format: PrintFormat) -> io::Result<()> {\n    // prior line: \"  ##: {:2$} - func\"\n    w.write_all(b\"\")?;\n    match format {\n        PrintFormat::Full => write!(w,\n                                    \"           {:1$}\",\n                                    \"\",\n                                    HEX_WIDTH)?,\n        PrintFormat::Short => write!(w, \"           \")?,\n    }\n\n    let file = str::from_utf8(file).unwrap_or(\"<unknown>\");\n    let file_path = Path::new(file);\n    let mut already_printed = false;\n    if format == PrintFormat::Short && file_path.is_absolute() {\n        if let Ok(cwd) = env::current_dir() {\n            if let Ok(stripped) = file_path.strip_prefix(&cwd) {\n                if let Some(s) = stripped.to_str() {\n                    write!(w, \"  at .{}{}:{}\", path::MAIN_SEPARATOR, s, line)?;\n                    already_printed = true;\n                }\n            }\n        }\n    }\n    if !already_printed {\n        write!(w, \"  at {}:{}\", file, line)?;\n    }\n\n    w.write_all(b\"\\n\")\n}\n\n\n// All rust symbols are in theory lists of \"::\"-separated identifiers. Some\n// assemblers, however, can't handle these characters in symbol names. To get\n// around this, we use C++-style mangling. The mangling method is:\n//\n// 1. Prefix the symbol with \"_ZN\"\n// 2. For each element of the path, emit the length plus the element\n// 3. End the path with \"E\"\n//\n// For example, \"_ZN4testE\" => \"test\" and \"_ZN3foo3barE\" => \"foo::bar\".\n//\n// We're the ones printing our backtraces, so we can't rely on anything else to\n// demangle our symbols. It's *much* nicer to look at demangled symbols, so\n// this function is implemented to give us nice pretty output.\n//\n// Note that this demangler isn't quite as fancy as it could be. We have lots\n// of other information in our symbols like hashes, version, type information,\n// etc. Additionally, this doesn't handle glue symbols at all.\npub fn demangle(writer: &mut Write, s: &str, format: PrintFormat) -> io::Result<()> {\n    // First validate the symbol. If it doesn't look like anything we're\n    // expecting, we just print it literally. Note that we must handle non-rust\n    // symbols because we could have any function in the backtrace.\n    let mut valid = true;\n    let mut inner = s;\n    if s.len() > 4 && s.starts_with(\"_ZN\") && s.ends_with(\"E\") {\n        inner = &s[3 .. s.len() - 1];\n    // On Windows, dbghelp strips leading underscores, so we accept \"ZN...E\" form too.\n    } else if s.len() > 3 && s.starts_with(\"ZN\") && s.ends_with(\"E\") {\n        inner = &s[2 .. s.len() - 1];\n    } else {\n        valid = false;\n    }\n\n    if valid {\n        let mut chars = inner.chars();\n        while valid {\n            let mut i = 0;\n            for c in chars.by_ref() {\n                if c.is_numeric() {\n                    i = i * 10 + c as usize - '0' as usize;\n                } else {\n                    break\n                }\n            }\n            if i == 0 {\n                valid = chars.next().is_none();\n                break\n            } else if chars.by_ref().take(i - 1).count() != i - 1 {\n                valid = false;\n            }\n        }\n    }\n\n    // Alright, let's do this.\n    if !valid {\n        writer.write_all(s.as_bytes())?;\n    } else {\n        // remove the `::hfc2edb670e5eda97` part at the end of the symbol.\n        if format == PrintFormat::Short {\n            // The symbol in still mangled.\n            let mut split = inner.rsplitn(2, \"17h\");\n            match (split.next(), split.next()) {\n                (Some(addr), rest) => {\n                    if addr.len() == 16 &&\n                       addr.chars().all(|c| c.is_digit(16))\n                    {\n                        inner = rest.unwrap_or(\"\");\n                    }\n                }\n                _ => (),\n            }\n        }\n\n        let mut first = true;\n        while !inner.is_empty() {\n            if !first {\n                writer.write_all(b\"::\")?;\n            } else {\n                first = false;\n            }\n            let mut rest = inner;\n            while rest.chars().next().unwrap().is_numeric() {\n                rest = &rest[1..];\n            }\n            let i: usize = inner[.. (inner.len() - rest.len())].parse().unwrap();\n            inner = &rest[i..];\n            rest = &rest[..i];\n            if rest.starts_with(\"_$\") {\n                rest = &rest[1..];\n            }\n            while !rest.is_empty() {\n                if rest.starts_with(\".\") {\n                    if let Some('.') = rest[1..].chars().next() {\n                        writer.write_all(b\"::\")?;\n                        rest = &rest[2..];\n                    } else {\n                        writer.write_all(b\".\")?;\n                        rest = &rest[1..];\n                    }\n                } else if rest.starts_with(\"$\") {\n                    macro_rules! demangle {\n                        ($($pat:expr => $demangled:expr),*) => ({\n                            $(if rest.starts_with($pat) {\n                                writer.write_all($demangled)?;\n                                rest = &rest[$pat.len()..];\n                              } else)*\n                            {\n                                writer.write_all(rest.as_bytes())?;\n                                break;\n                            }\n\n                        })\n                    }\n\n                    // see src/librustc/back/link.rs for these mappings\n                    demangle! (\n                        \"$SP$\" => b\"@\",\n                        \"$BP$\" => b\"*\",\n                        \"$RF$\" => b\"&\",\n                        \"$LT$\" => b\"<\",\n                        \"$GT$\" => b\">\",\n                        \"$LP$\" => b\"(\",\n                        \"$RP$\" => b\")\",\n                        \"$C$\" => b\",\",\n\n                        // in theory we can demangle any Unicode code point, but\n                        // for simplicity we just catch the common ones.\n                        \"$u7e$\" => b\"~\",\n                        \"$u20$\" => b\" \",\n                        \"$u27$\" => b\"'\",\n                        \"$u5b$\" => b\"[\",\n                        \"$u5d$\" => b\"]\",\n                        \"$u7b$\" => b\"{\",\n                        \"$u7d$\" => b\"}\",\n                        \"$u3b$\" => b\";\",\n                        \"$u2b$\" => b\"+\",\n                        \"$u22$\" => b\"\\\"\"\n                    )\n                } else {\n                    let idx = match rest.char_indices().find(|&(_, c)| c == '$' || c == '.') {\n                        None => rest.len(),\n                        Some((i, _)) => i,\n                    };\n                    writer.write_all(rest[..idx].as_bytes())?;\n                    rest = &rest[idx..];\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use sys_common;\n    macro_rules! t { ($a:expr, $b:expr) => ({\n        let mut m = Vec::new();\n        sys_common::backtrace::demangle(&mut m,\n                                        $a,\n                                        super::PrintFormat::Full).unwrap();\n        assert_eq!(String::from_utf8(m).unwrap(), $b);\n    }) }\n\n    #[test]\n    fn demangle() {\n        t!(\"test\", \"test\");\n        t!(\"_ZN4testE\", \"test\");\n        t!(\"_ZN4test\", \"_ZN4test\");\n        t!(\"_ZN4test1a2bcE\", \"test::a::bc\");\n    }\n\n    #[test]\n    fn demangle_dollars() {\n        t!(\"_ZN4$RP$E\", \")\");\n        t!(\"_ZN8$RF$testE\", \"&test\");\n        t!(\"_ZN8$BP$test4foobE\", \"*test::foob\");\n        t!(\"_ZN9$u20$test4foobE\", \" test::foob\");\n        t!(\"_ZN35Bar$LT$$u5b$u32$u3b$$u20$4$u5d$$GT$E\", \"Bar<[u32; 4]>\");\n    }\n\n    #[test]\n    fn demangle_many_dollars() {\n        t!(\"_ZN13test$u20$test4foobE\", \"test test::foob\");\n        t!(\"_ZN12test$BP$test4foobE\", \"test*test::foob\");\n    }\n\n    #[test]\n    fn demangle_windows() {\n        t!(\"ZN4testE\", \"test\");\n        t!(\"ZN13test$u20$test4foobE\", \"test test::foob\");\n        t!(\"ZN12test$RF$test4foobE\", \"test&test::foob\");\n    }\n\n    #[test]\n    fn demangle_elements_beginning_with_underscore() {\n        t!(\"_ZN13_$LT$test$GT$E\", \"<test>\");\n        t!(\"_ZN28_$u7b$$u7b$closure$u7d$$u7d$E\", \"{{closure}}\");\n        t!(\"_ZN15__STATIC_FMTSTRE\", \"__STATIC_FMTSTR\");\n    }\n\n    #[test]\n    fn demangle_trait_impls() {\n        t!(\"_ZN71_$LT$Test$u20$$u2b$$u20$$u27$static$u20$as$u20$foo..Bar$LT$Test$GT$$GT$3barE\",\n           \"<Test + 'static as foo::Bar<Test>>::bar\");\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A contiguous growable array type with heap-allocated contents, written\n//! `Vec<T>`.\n//!\n//! Vectors have `O(1)` indexing, amortized `O(1)` push (to the end) and\n//! `O(1)` pop (from the end).\n//!\n//! # Examples\n//!\n//! You can explicitly create a [`Vec<T>`] with [`new`]:\n//!\n//! ```\n//! let v: Vec<i32> = Vec::new();\n//! ```\n//!\n//! ...or by using the [`vec!`] macro:\n//!\n//! ```\n//! let v: Vec<i32> = vec![];\n//!\n//! let v = vec![1, 2, 3, 4, 5];\n//!\n//! let v = vec![0; 10]; // ten zeroes\n//! ```\n//!\n//! You can [`push`] values onto the end of a vector (which will grow the vector\n//! as needed):\n//!\n//! ```\n//! let mut v = vec![1, 2];\n//!\n//! v.push(3);\n//! ```\n//!\n//! Popping values works in much the same way:\n//!\n//! ```\n//! let mut v = vec![1, 2];\n//!\n//! let two = v.pop();\n//! ```\n//!\n//! Vectors also support indexing (through the [`Index`] and [`IndexMut`] traits):\n//!\n//! ```\n//! let mut v = vec![1, 2, 3];\n//! let three = v[2];\n//! v[1] = v[1] + 5;\n//! ```\n//!\n//! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n//! [`new`]: ../../std/vec/struct.Vec.html#method.new\n//! [`push`]: ../../std/vec/struct.Vec.html#method.push\n//! [`Index`]: ../../std/ops/trait.Index.html\n//! [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n//! [`vec!`]: ../../std/macro.vec.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::cmp::Ordering;\nuse core::fmt;\nuse core::hash::{self, Hash};\nuse core::intrinsics::{arith_offset, assume};\nuse core::iter::{FromIterator, FusedIterator, TrustedLen};\nuse core::mem;\n#[cfg(not(test))]\nuse core::num::Float;\nuse core::ops::{InPlace, Index, IndexMut, Place, Placer};\nuse core::ops;\nuse core::ptr;\nuse core::ptr::Shared;\nuse core::slice;\n\nuse borrow::ToOwned;\nuse borrow::Cow;\nuse boxed::Box;\nuse raw_vec::RawVec;\nuse super::range::RangeArgument;\nuse Bound::{Excluded, Included, Unbounded};\n\n/// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n///\n/// # Examples\n///\n/// ```\n/// let mut vec = Vec::new();\n/// vec.push(1);\n/// vec.push(2);\n///\n/// assert_eq!(vec.len(), 2);\n/// assert_eq!(vec[0], 1);\n///\n/// assert_eq!(vec.pop(), Some(2));\n/// assert_eq!(vec.len(), 1);\n///\n/// vec[0] = 7;\n/// assert_eq!(vec[0], 7);\n///\n/// vec.extend([1, 2, 3].iter().cloned());\n///\n/// for x in &vec {\n///     println!(\"{}\", x);\n/// }\n/// assert_eq!(vec, [7, 1, 2, 3]);\n/// ```\n///\n/// The [`vec!`] macro is provided to make initialization more convenient:\n///\n/// ```\n/// let mut vec = vec![1, 2, 3];\n/// vec.push(4);\n/// assert_eq!(vec, [1, 2, 3, 4]);\n/// ```\n///\n/// It can also initialize each element of a `Vec<T>` with a given value:\n///\n/// ```\n/// let vec = vec![0; 5];\n/// assert_eq!(vec, [0, 0, 0, 0, 0]);\n/// ```\n///\n/// Use a `Vec<T>` as an efficient stack:\n///\n/// ```\n/// let mut stack = Vec::new();\n///\n/// stack.push(1);\n/// stack.push(2);\n/// stack.push(3);\n///\n/// while let Some(top) = stack.pop() {\n///     // Prints 3, 2, 1\n///     println!(\"{}\", top);\n/// }\n/// ```\n///\n/// # Indexing\n///\n/// The `Vec` type allows to access values by index, because it implements the\n/// [`Index`] trait. An example will be more explicit:\n///\n/// ```\n/// let v = vec![0, 2, 4, 6];\n/// println!(\"{}\", v[1]); // it will display '2'\n/// ```\n///\n/// However be careful: if you try to access an index which isn't in the `Vec`,\n/// your software will panic! You cannot do this:\n///\n/// ```should_panic\n/// let v = vec![0, 2, 4, 6];\n/// println!(\"{}\", v[6]); // it will panic!\n/// ```\n///\n/// In conclusion: always check if the index you want to get really exists\n/// before doing it.\n///\n/// # Slicing\n///\n/// A `Vec` can be mutable. Slices, on the other hand, are read-only objects.\n/// To get a slice, use `&`. Example:\n///\n/// ```\n/// fn read_slice(slice: &[usize]) {\n///     // ...\n/// }\n///\n/// let v = vec![0, 1];\n/// read_slice(&v);\n///\n/// // ... and that's all!\n/// // you can also do it like this:\n/// let x : &[usize] = &v;\n/// ```\n///\n/// In Rust, it's more common to pass slices as arguments rather than vectors\n/// when you just want to provide a read access. The same goes for [`String`] and\n/// [`&str`].\n///\n/// # Capacity and reallocation\n///\n/// The capacity of a vector is the amount of space allocated for any future\n/// elements that will be added onto the vector. This is not to be confused with\n/// the *length* of a vector, which specifies the number of actual elements\n/// within the vector. If a vector's length exceeds its capacity, its capacity\n/// will automatically be increased, but its elements will have to be\n/// reallocated.\n///\n/// For example, a vector with capacity 10 and length 0 would be an empty vector\n/// with space for 10 more elements. Pushing 10 or fewer elements onto the\n/// vector will not change its capacity or cause reallocation to occur. However,\n/// if the vector's length is increased to 11, it will have to reallocate, which\n/// can be slow. For this reason, it is recommended to use [`Vec::with_capacity`]\n/// whenever possible to specify how big the vector is expected to get.\n///\n/// # Guarantees\n///\n/// Due to its incredibly fundamental nature, `Vec` makes a lot of guarantees\n/// about its design. This ensures that it's as low-overhead as possible in\n/// the general case, and can be correctly manipulated in primitive ways\n/// by unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\n/// If additional type parameters are added (e.g. to support custom allocators),\n/// overriding their defaults may change the behavior.\n///\n/// Most fundamentally, `Vec` is and always will be a (pointer, capacity, length)\n/// triplet. No more, no less. The order of these fields is completely\n/// unspecified, and you should use the appropriate methods to modify these.\n/// The pointer will never be null, so this type is null-pointer-optimized.\n///\n/// However, the pointer may not actually point to allocated memory. In particular,\n/// if you construct a `Vec` with capacity 0 via [`Vec::new`], [`vec![]`][`vec!`],\n/// [`Vec::with_capacity(0)`][`Vec::with_capacity`], or by calling [`shrink_to_fit`]\n/// on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\n/// types inside a `Vec`, it will not allocate space for them. *Note that in this case\n/// the `Vec` may not report a [`capacity`] of 0*. `Vec` will allocate if and only\n/// if [`mem::size_of::<T>`]`() * capacity() > 0`. In general, `Vec`'s allocation\n/// details are subtle enough that it is strongly recommended that you only\n/// free memory allocated by a `Vec` by creating a new `Vec` and dropping it.\n///\n/// If a `Vec` *has* allocated memory, then the memory it points to is on the heap\n/// (as defined by the allocator Rust is configured to use by default), and its\n/// pointer points to [`len`] initialized elements in order (what you would see\n/// if you coerced it to a slice), followed by [`capacity`]` - `[`len`]\n/// logically uninitialized elements.\n///\n/// `Vec` will never perform a \"small optimization\" where elements are actually\n/// stored on the stack for two reasons:\n///\n/// * It would make it more difficult for unsafe code to correctly manipulate\n///   a `Vec`. The contents of a `Vec` wouldn't have a stable address if it were\n///   only moved, and it would be more difficult to determine if a `Vec` had\n///   actually allocated memory.\n///\n/// * It would penalize the general case, incurring an additional branch\n///   on every access.\n///\n/// `Vec` will never automatically shrink itself, even if completely empty. This\n/// ensures no unnecessary allocations or deallocations occur. Emptying a `Vec`\n/// and then filling it back up to the same [`len`] should incur no calls to\n/// the allocator. If you wish to free up unused memory, use\n/// [`shrink_to_fit`][`shrink_to_fit`].\n///\n/// [`push`] and [`insert`] will never (re)allocate if the reported capacity is\n/// sufficient. [`push`] and [`insert`] *will* (re)allocate if\n/// [`len`]` == `[`capacity`]. That is, the reported capacity is completely\n/// accurate, and can be relied on. It can even be used to manually free the memory\n/// allocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\n/// when not necessary.\n///\n/// `Vec` does not guarantee any particular growth strategy when reallocating\n/// when full, nor when [`reserve`] is called. The current strategy is basic\n/// and it may prove desirable to use a non-constant growth factor. Whatever\n/// strategy is used will of course guarantee `O(1)` amortized [`push`].\n///\n/// `vec![x; n]`, `vec![a, b, c, d]`, and\n/// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`\n/// with exactly the requested capacity. If [`len`]` == `[`capacity`],\n/// (as is the case for the [`vec!`] macro), then a `Vec<T>` can be converted to\n/// and from a [`Box<[T]>`][owned slice] without reallocating or moving the elements.\n///\n/// `Vec` will not specifically overwrite any data that is removed from it,\n/// but also won't specifically preserve it. Its uninitialized memory is\n/// scratch space that it may use however it wants. It will generally just do\n/// whatever is most efficient or otherwise easy to implement. Do not rely on\n/// removed data to be erased for security purposes. Even if you drop a `Vec`, its\n/// buffer may simply be reused by another `Vec`. Even if you zero a `Vec`'s memory\n/// first, that may not actually happen because the optimizer does not consider\n/// this a side-effect that must be preserved. There is one case which we will\n/// not break, however: using `unsafe` code to write to the excess capacity,\n/// and then increasing the length to match, is always valid.\n///\n/// `Vec` does not currently guarantee the order in which elements are dropped\n/// (the order has changed in the past, and may change again).\n///\n/// [`vec!`]: ../../std/macro.vec.html\n/// [`Index`]: ../../std/ops/trait.Index.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [`&str`]: ../../std/primitive.str.html\n/// [`Vec::with_capacity`]: ../../std/vec/struct.Vec.html#method.with_capacity\n/// [`Vec::new`]: ../../std/vec/struct.Vec.html#method.new\n/// [`shrink_to_fit`]: ../../std/vec/struct.Vec.html#method.shrink_to_fit\n/// [`capacity`]: ../../std/vec/struct.Vec.html#method.capacity\n/// [`mem::size_of::<T>`]: ../../std/mem/fn.size_of.html\n/// [`len`]: ../../std/vec/struct.Vec.html#method.len\n/// [`push`]: ../../std/vec/struct.Vec.html#method.push\n/// [`insert`]: ../../std/vec/struct.Vec.html#method.insert\n/// [`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n/// [owned slice]: ../../std/boxed/struct.Box.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Vec<T> {\n    buf: RawVec<T>,\n    len: usize,\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Inherent methods\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Vec<T> {\n    /// Constructs a new, empty `Vec<T>`.\n    ///\n    /// The vector will not allocate until elements are pushed onto it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![allow(unused_mut)]\n    /// let mut vec: Vec<i32> = Vec::new();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> Vec<T> {\n        Vec {\n            buf: RawVec::new(),\n            len: 0,\n        }\n    }\n\n    /// Constructs a new, empty `Vec<T>` with the specified capacity.\n    ///\n    /// The vector will be able to hold exactly `capacity` elements without\n    /// reallocating. If `capacity` is 0, the vector will not allocate.\n    ///\n    /// It is important to note that this function does not specify the *length*\n    /// of the returned vector, but only the *capacity*. For an explanation of\n    /// the difference between length and capacity, see *[Capacity and reallocation]*.\n    ///\n    /// [Capacity and reallocation]: #capacity-and-reallocation\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    ///\n    /// // The vector contains no items, even though it has capacity for more\n    /// assert_eq!(vec.len(), 0);\n    ///\n    /// // These are all done without reallocating...\n    /// for i in 0..10 {\n    ///     vec.push(i);\n    /// }\n    ///\n    /// // ...but this may make the vector reallocate\n    /// vec.push(11);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> Vec<T> {\n        Vec {\n            buf: RawVec::with_capacity(capacity),\n            len: 0,\n        }\n    }\n\n    /// Creates a `Vec<T>` directly from the raw components of another vector.\n    ///\n    /// # Safety\n    ///\n    /// This is highly unsafe, due to the number of invariants that aren't\n    /// checked:\n    ///\n    /// * `ptr` needs to have been previously allocated via [`String`]/`Vec<T>`\n    ///   (at least, it's highly likely to be incorrect if it wasn't).\n    /// * `length` needs to be less than or equal to `capacity`.\n    /// * `capacity` needs to be the capacity that the pointer was allocated with.\n    ///\n    /// Violating these may cause problems like corrupting the allocator's\n    /// internal datastructures. For example it is **not** safe\n    /// to build a `Vec<u8>` from a pointer to a C `char` array and a `size_t`.\n    ///\n    /// The ownership of `ptr` is effectively transferred to the\n    /// `Vec<T>` which may then deallocate, reallocate or change the\n    /// contents of memory pointed to by the pointer at will. Ensure\n    /// that nothing else uses the pointer after calling this\n    /// function.\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ptr;\n    /// use std::mem;\n    ///\n    /// fn main() {\n    ///     let mut v = vec![1, 2, 3];\n    ///\n    ///     // Pull out the various important pieces of information about `v`\n    ///     let p = v.as_mut_ptr();\n    ///     let len = v.len();\n    ///     let cap = v.capacity();\n    ///\n    ///     unsafe {\n    ///         // Cast `v` into the void: no destructor run, so we are in\n    ///         // complete control of the allocation to which `p` points.\n    ///         mem::forget(v);\n    ///\n    ///         // Overwrite memory with 4, 5, 6\n    ///         for i in 0..len as isize {\n    ///             ptr::write(p.offset(i), 4 + i);\n    ///         }\n    ///\n    ///         // Put everything back together into a Vec\n    ///         let rebuilt = Vec::from_raw_parts(p, len, cap);\n    ///         assert_eq!(rebuilt, [4, 5, 6]);\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -> Vec<T> {\n        Vec {\n            buf: RawVec::from_raw_parts(ptr, capacity),\n            len: length,\n        }\n    }\n\n    /// Returns the number of elements the vector can hold without\n    /// reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let vec: Vec<i32> = Vec::with_capacity(10);\n    /// assert_eq!(vec.capacity(), 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n        self.buf.cap()\n    }\n\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the given `Vec<T>`. The collection may reserve more space to avoid\n    /// frequent reallocations. After calling `reserve`, capacity will be\n    /// greater than or equal to `self.len() + additional`. Does nothing if\n    /// capacity is already sufficient.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.reserve(10);\n    /// assert!(vec.capacity() >= 11);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n        self.buf.reserve(self.len, additional);\n    }\n\n    /// Reserves the minimum capacity for exactly `additional` more elements to\n    /// be inserted in the given `Vec<T>`. After calling `reserve_exact`,\n    /// capacity will be greater than or equal to `self.len() + additional`.\n    /// Does nothing if the capacity is already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it\n    /// requests. Therefore capacity can not be relied upon to be precisely\n    /// minimal. Prefer `reserve` if future insertions are expected.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.reserve_exact(10);\n    /// assert!(vec.capacity() >= 11);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.buf.reserve_exact(self.len, additional);\n    }\n\n    /// Shrinks the capacity of the vector as much as possible.\n    ///\n    /// It will drop down as close as possible to the length but the allocator\n    /// may still inform the vector that there is space for a few more elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    /// vec.extend([1, 2, 3].iter().cloned());\n    /// assert_eq!(vec.capacity(), 10);\n    /// vec.shrink_to_fit();\n    /// assert!(vec.capacity() >= 3);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n        self.buf.shrink_to_fit(self.len);\n    }\n\n    /// Converts the vector into [`Box<[T]>`][owned slice].\n    ///\n    /// Note that this will drop any excess capacity. Calling this and\n    /// converting back to a vector with [`into_vec`] is equivalent to calling\n    /// [`shrink_to_fit`].\n    ///\n    /// [owned slice]: ../../std/boxed/struct.Box.html\n    /// [`into_vec`]: ../../std/primitive.slice.html#method.into_vec\n    /// [`shrink_to_fit`]: #method.shrink_to_fit\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = vec![1, 2, 3];\n    ///\n    /// let slice = v.into_boxed_slice();\n    /// ```\n    ///\n    /// Any excess capacity is removed:\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    /// vec.extend([1, 2, 3].iter().cloned());\n    ///\n    /// assert_eq!(vec.capacity(), 10);\n    /// let slice = vec.into_boxed_slice();\n    /// assert_eq!(slice.into_vec().capacity(), 3);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_boxed_slice(mut self) -> Box<[T]> {\n        unsafe {\n            self.shrink_to_fit();\n            let buf = ptr::read(&self.buf);\n            mem::forget(self);\n            buf.into_box()\n        }\n    }\n\n    /// Shortens the vector, keeping the first `len` elements and dropping\n    /// the rest.\n    ///\n    /// If `len` is greater than the vector's current length, this has no\n    /// effect.\n    ///\n    /// The [`drain`] method can emulate `truncate`, but causes the excess\n    /// elements to be returned instead of dropped.\n    ///\n    /// Note that this method has no effect on the allocated capacity\n    /// of the vector.\n    ///\n    /// # Examples\n    ///\n    /// Truncating a five element vector to two elements:\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3, 4, 5];\n    /// vec.truncate(2);\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    ///\n    /// No truncation occurs when `len` is greater than the vector's current\n    /// length:\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.truncate(8);\n    /// assert_eq!(vec, [1, 2, 3]);\n    /// ```\n    ///\n    /// Truncating when `len == 0` is equivalent to calling the [`clear`]\n    /// method.\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.truncate(0);\n    /// assert_eq!(vec, []);\n    /// ```\n    ///\n    /// [`clear`]: #method.clear\n    /// [`drain`]: #method.drain\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn truncate(&mut self, len: usize) {\n        unsafe {\n            // drop any extra elements\n            while len < self.len {\n                // decrement len before the drop_in_place(), so a panic on Drop\n                // doesn't re-drop the just-failed value.\n                self.len -= 1;\n                let len = self.len;\n                ptr::drop_in_place(self.get_unchecked_mut(len));\n            }\n        }\n    }\n\n    /// Extracts a slice containing the entire vector.\n    ///\n    /// Equivalent to `&s[..]`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Write};\n    /// let buffer = vec![1, 2, 3, 5, 8];\n    /// io::sink().write(buffer.as_slice()).unwrap();\n    /// ```\n    #[inline]\n    #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n    pub fn as_slice(&self) -> &[T] {\n        self\n    }\n\n    /// Extracts a mutable slice of the entire vector.\n    ///\n    /// Equivalent to `&mut s[..]`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Read};\n    /// let mut buffer = vec![0; 3];\n    /// io::repeat(0b101).read_exact(buffer.as_mut_slice()).unwrap();\n    /// ```\n    #[inline]\n    #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n        self\n    }\n\n    /// Sets the length of a vector.\n    ///\n    /// This will explicitly set the size of the vector, without actually\n    /// modifying its buffers, so it is up to the caller to ensure that the\n    /// vector is actually the specified size.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ptr;\n    ///\n    /// let mut vec = vec!['r', 'u', 's', 't'];\n    ///\n    /// unsafe {\n    ///     ptr::drop_in_place(&mut vec[3]);\n    ///     vec.set_len(3);\n    /// }\n    /// assert_eq!(vec, ['r', 'u', 's']);\n    /// ```\n    ///\n    /// In this example, there is a memory leak since the memory locations\n    /// owned by the inner vectors were not freed prior to the `set_len` call:\n    ///\n    /// ```\n    /// let mut vec = vec![vec![1, 0, 0],\n    ///                    vec![0, 1, 0],\n    ///                    vec![0, 0, 1]];\n    /// unsafe {\n    ///     vec.set_len(0);\n    /// }\n    /// ```\n    ///\n    /// In this example, the vector gets expanded from zero to four items\n    /// without any memory allocations occurring, resulting in vector\n    /// values of unallocated memory:\n    ///\n    /// ```\n    /// let mut vec: Vec<char> = Vec::new();\n    ///\n    /// unsafe {\n    ///     vec.set_len(4);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn set_len(&mut self, len: usize) {\n        self.len = len;\n    }\n\n    /// Removes an element from the vector and returns it.\n    ///\n    /// The removed element is replaced by the last element of the vector.\n    ///\n    /// This does not preserve ordering, but is O(1).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index` is out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n    ///\n    /// assert_eq!(v.swap_remove(1), \"bar\");\n    /// assert_eq!(v, [\"foo\", \"qux\", \"baz\"]);\n    ///\n    /// assert_eq!(v.swap_remove(0), \"foo\");\n    /// assert_eq!(v, [\"baz\", \"qux\"]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn swap_remove(&mut self, index: usize) -> T {\n        let length = self.len();\n        self.swap(index, length - 1);\n        self.pop().unwrap()\n    }\n\n    /// Inserts an element at position `index` within the vector, shifting all\n    /// elements after it to the right.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index` is out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.insert(1, 4);\n    /// assert_eq!(vec, [1, 4, 2, 3]);\n    /// vec.insert(4, 5);\n    /// assert_eq!(vec, [1, 4, 2, 3, 5]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, index: usize, element: T) {\n        let len = self.len();\n        assert!(index <= len);\n\n        // space for the new element\n        if len == self.buf.cap() {\n            self.buf.double();\n        }\n\n        unsafe {\n            // infallible\n            // The spot to put the new value\n            {\n                let p = self.as_mut_ptr().offset(index as isize);\n                // Shift everything over to make space. (Duplicating the\n                // `index`th element into two consecutive places.)\n                ptr::copy(p, p.offset(1), len - index);\n                // Write it in, overwriting the first copy of the `index`th\n                // element.\n                ptr::write(p, element);\n            }\n            self.set_len(len + 1);\n        }\n    }\n\n    /// Removes and returns the element at position `index` within the vector,\n    /// shifting all elements after it to the left.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index` is out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    /// assert_eq!(v.remove(1), 2);\n    /// assert_eq!(v, [1, 3]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove(&mut self, index: usize) -> T {\n        let len = self.len();\n        assert!(index < len);\n        unsafe {\n            // infallible\n            let ret;\n            {\n                // the place we are taking from.\n                let ptr = self.as_mut_ptr().offset(index as isize);\n                // copy it out, unsafely having a copy of the value on\n                // the stack and in the vector at the same time.\n                ret = ptr::read(ptr);\n\n                // Shift everything down to fill in that spot.\n                ptr::copy(ptr.offset(1), ptr, len - index - 1);\n            }\n            self.set_len(len - 1);\n            ret\n        }\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n    /// This method operates in place and preserves the order of the retained\n    /// elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.retain(|&x| x%2 == 0);\n    /// assert_eq!(vec, [2, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn retain<F>(&mut self, mut f: F)\n        where F: FnMut(&T) -> bool\n    {\n        let len = self.len();\n        let mut del = 0;\n        {\n            let v = &mut **self;\n\n            for i in 0..len {\n                if !f(&v[i]) {\n                    del += 1;\n                } else if del > 0 {\n                    v.swap(i - del, i);\n                }\n            }\n        }\n        if del > 0 {\n            self.truncate(len - del);\n        }\n    }\n\n    /// Removes all but the first of consecutive elements in the vector that resolve to the same\n    /// key.\n    ///\n    /// If the vector is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![10, 20, 21, 30, 20];\n    ///\n    /// vec.dedup_by_key(|i| *i / 10);\n    ///\n    /// assert_eq!(vec, [10, 20, 30, 20]);\n    /// ```\n    #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n    #[inline]\n    pub fn dedup_by_key<F, K>(&mut self, mut key: F) where F: FnMut(&mut T) -> K, K: PartialEq {\n        self.dedup_by(|a, b| key(a) == key(b))\n    }\n\n    /// Removes all but the first of consecutive elements in the vector satisfying a given equality\n    /// relation.\n    ///\n    /// The `same_bucket` function is passed references to two elements from the vector, and\n    /// returns `true` if the elements compare equal, or `false` if they do not. The elements are\n    /// passed in opposite order from their order in the vector, so if `same_bucket(a, b)` returns\n    /// `true`, `a` is removed.\n    ///\n    /// If the vector is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ascii::AsciiExt;\n    ///\n    /// let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n    ///\n    /// vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n    ///\n    /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n    /// ```\n    #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n    pub fn dedup_by<F>(&mut self, mut same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n        unsafe {\n            // Although we have a mutable reference to `self`, we cannot make\n            // *arbitrary* changes. The `same_bucket` calls could panic, so we\n            // must ensure that the vector is in a valid state at all time.\n            //\n            // The way that we handle this is by using swaps; we iterate\n            // over all the elements, swapping as we go so that at the end\n            // the elements we wish to keep are in the front, and those we\n            // wish to reject are at the back. We can then truncate the\n            // vector. This operation is still O(n).\n            //\n            // Example: We start in this state, where `r` represents \"next\n            // read\" and `w` represents \"next_write`.\n            //\n            //           r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //           w\n            //\n            // Comparing self[r] against self[w-1], this is not a duplicate, so\n            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n            // r and w, leaving us with:\n            //\n            //               r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //               w\n            //\n            // Comparing self[r] against self[w-1], this value is a duplicate,\n            // so we increment `r` but leave everything else unchanged:\n            //\n            //                   r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //               w\n            //\n            // Comparing self[r] against self[w-1], this is not a duplicate,\n            // so swap self[r] and self[w] and advance r and w:\n            //\n            //                       r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //                   w\n            //\n            // Not a duplicate, repeat:\n            //\n            //                           r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n            //     +---+---+---+---+---+---+\n            //                       w\n            //\n            // Duplicate, advance r. End of vec. Truncate to w.\n\n            let ln = self.len();\n            if ln <= 1 {\n                return;\n            }\n\n            // Avoid bounds checks by using raw pointers.\n            let p = self.as_mut_ptr();\n            let mut r: usize = 1;\n            let mut w: usize = 1;\n\n            while r < ln {\n                let p_r = p.offset(r as isize);\n                let p_wm1 = p.offset((w - 1) as isize);\n                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n                    if r != w {\n                        let p_w = p_wm1.offset(1);\n                        mem::swap(&mut *p_r, &mut *p_w);\n                    }\n                    w += 1;\n                }\n                r += 1;\n            }\n\n            self.truncate(w);\n        }\n    }\n\n    /// Appends an element to the back of a collection.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the number of elements in the vector overflows a `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2];\n    /// vec.push(3);\n    /// assert_eq!(vec, [1, 2, 3]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push(&mut self, value: T) {\n        // This will panic or abort if we would allocate > isize::MAX bytes\n        // or if the length increment would overflow for zero-sized types.\n        if self.len == self.buf.cap() {\n            self.buf.double();\n        }\n        unsafe {\n            let end = self.as_mut_ptr().offset(self.len as isize);\n            ptr::write(end, value);\n            self.len += 1;\n        }\n    }\n\n    /// Returns a place for insertion at the back of the `Vec`.\n    ///\n    /// Using this method with placement syntax is equivalent to [`push`](#method.push),\n    /// but may be more efficient.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(collection_placement)]\n    /// #![feature(placement_in_syntax)]\n    ///\n    /// let mut vec = vec![1, 2];\n    /// vec.place_back() <- 3;\n    /// vec.place_back() <- 4;\n    /// assert_eq!(&vec, &[1, 2, 3, 4]);\n    /// ```\n    #[unstable(feature = \"collection_placement\",\n               reason = \"placement protocol is subject to change\",\n               issue = \"30172\")]\n    pub fn place_back(&mut self) -> PlaceBack<T> {\n        PlaceBack { vec: self }\n    }\n\n    /// Removes the last element from a vector and returns it, or [`None`] if it\n    /// is empty.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// assert_eq!(vec.pop(), Some(3));\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            unsafe {\n                self.len -= 1;\n                Some(ptr::read(self.get_unchecked(self.len())))\n            }\n        }\n    }\n\n    /// Moves all the elements of `other` into `Self`, leaving `other` empty.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the number of elements in the vector overflows a `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// let mut vec2 = vec![4, 5, 6];\n    /// vec.append(&mut vec2);\n    /// assert_eq!(vec, [1, 2, 3, 4, 5, 6]);\n    /// assert_eq!(vec2, []);\n    /// ```\n    #[inline]\n    #[stable(feature = \"append\", since = \"1.4.0\")]\n    pub fn append(&mut self, other: &mut Self) {\n        unsafe {\n            self.append_elements(other.as_slice() as _);\n            other.set_len(0);\n        }\n    }\n\n    /// Appends elements to `Self` from other buffer.\n    #[inline]\n    unsafe fn append_elements(&mut self, other: *const [T]) {\n        let count = (*other).len();\n        self.reserve(count);\n        let len = self.len();\n        ptr::copy_nonoverlapping(other as *const T, self.get_unchecked_mut(len), count);\n        self.len += count;\n    }\n\n    /// Creates a draining iterator that removes the specified range in the vector\n    /// and yields the removed items.\n    ///\n    /// Note 1: The element range is removed even if the iterator is only\n    /// partially consumed or not consumed at all.\n    ///\n    /// Note 2: It is unspecified how many elements are removed from the vector\n    /// if the `Drain` value is leaked.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    /// let u: Vec<_> = v.drain(1..).collect();\n    /// assert_eq!(v, &[1]);\n    /// assert_eq!(u, &[2, 3]);\n    ///\n    /// // A full range clears the vector\n    /// v.drain(..);\n    /// assert_eq!(v, &[]);\n    /// ```\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain<R>(&mut self, range: R) -> Drain<T>\n        where R: RangeArgument<usize>\n    {\n        // Memory safety\n        //\n        // When the Drain is first created, it shortens the length of\n        // the source vector to make sure no uninitalized or moved-from elements\n        // are accessible at all if the Drain's destructor never gets to run.\n        //\n        // Drain will ptr::read out the values to remove.\n        // When finished, remaining tail of the vec is copied back to cover\n        // the hole, and the vector length is restored to the new length.\n        //\n        let len = self.len();\n        let start = match range.start() {\n            Included(&n) => n,\n            Excluded(&n) => n + 1,\n            Unbounded    => 0,\n        };\n        let end = match range.end() {\n            Included(&n) => n + 1,\n            Excluded(&n) => n,\n            Unbounded    => len,\n        };\n        assert!(start <= end);\n        assert!(end <= len);\n\n        unsafe {\n            // set self.vec length's to start, to be safe in case Drain is leaked\n            self.set_len(start);\n            // Use the borrow in the IterMut to indicate borrowing behavior of the\n            // whole Drain iterator (like &mut T).\n            let range_slice = slice::from_raw_parts_mut(self.as_mut_ptr().offset(start as isize),\n                                                        end - start);\n            Drain {\n                tail_start: end,\n                tail_len: len - end,\n                iter: range_slice.iter(),\n                vec: Shared::new(self as *mut _),\n            }\n        }\n    }\n\n    /// Clears the vector, removing all values.\n    ///\n    /// Note that this method has no effect on the allocated capacity\n    /// of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    ///\n    /// v.clear();\n    ///\n    /// assert!(v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n        self.truncate(0)\n    }\n\n    /// Returns the number of elements in the vector, also referred to\n    /// as its 'length'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = vec![1, 2, 3];\n    /// assert_eq!(a.len(), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n        self.len\n    }\n\n    /// Returns `true` if the vector contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = Vec::new();\n    /// assert!(v.is_empty());\n    ///\n    /// v.push(1);\n    /// assert!(!v.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Splits the collection into two at the given index.\n    ///\n    /// Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n    /// and the returned `Self` contains elements `[at, len)`.\n    ///\n    /// Note that the capacity of `self` does not change.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1,2,3];\n    /// let vec2 = vec.split_off(1);\n    /// assert_eq!(vec, [1]);\n    /// assert_eq!(vec2, [2, 3]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"split_off\", since = \"1.4.0\")]\n    pub fn split_off(&mut self, at: usize) -> Self {\n        assert!(at <= self.len(), \"`at` out of bounds\");\n\n        let other_len = self.len - at;\n        let mut other = Vec::with_capacity(other_len);\n\n        // Unsafely `set_len` and copy items to `other`.\n        unsafe {\n            self.set_len(at);\n            other.set_len(other_len);\n\n            ptr::copy_nonoverlapping(self.as_ptr().offset(at as isize),\n                                     other.as_mut_ptr(),\n                                     other.len());\n        }\n        other\n    }\n}\n\nimpl<T: Clone> Vec<T> {\n    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n    ///\n    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n    /// difference, with each additional slot filled with `value`.\n    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n    ///\n    /// This method requires `Clone` to clone the passed value. If you'd\n    /// rather create a value with `Default` instead, see [`resize_default`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![\"hello\"];\n    /// vec.resize(3, \"world\");\n    /// assert_eq!(vec, [\"hello\", \"world\", \"world\"]);\n    ///\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.resize(2, 0);\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    ///\n    /// [`resize_default`]: #method.resize_default\n    #[stable(feature = \"vec_resize\", since = \"1.5.0\")]\n    pub fn resize(&mut self, new_len: usize, value: T) {\n        let len = self.len();\n\n        if new_len > len {\n            self.extend_with(new_len - len, ExtendElement(value))\n        } else {\n            self.truncate(new_len);\n        }\n    }\n\n    /// Clones and appends all elements in a slice to the `Vec`.\n    ///\n    /// Iterates over the slice `other`, clones each element, and then appends\n    /// it to this `Vec`. The `other` vector is traversed in-order.\n    ///\n    /// Note that this function is same as `extend` except that it is\n    /// specialized to work with slices instead. If and when Rust gets\n    /// specialization this function will likely be deprecated (but still\n    /// available).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.extend_from_slice(&[2, 3, 4]);\n    /// assert_eq!(vec, [1, 2, 3, 4]);\n    /// ```\n    #[stable(feature = \"vec_extend_from_slice\", since = \"1.6.0\")]\n    pub fn extend_from_slice(&mut self, other: &[T]) {\n        self.spec_extend(other.iter())\n    }\n}\n\nimpl<T: Default> Vec<T> {\n    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n    ///\n    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n    /// difference, with each additional slot filled with `Default::default()`.\n    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n    ///\n    /// This method uses `Default` to create new values on every push. If\n    /// you'd rather `Clone` a given value, use [`resize`].\n    ///\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(vec_resize_default)]\n    ///\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.resize_default(5);\n    /// assert_eq!(vec, [1, 2, 3, 0, 0]);\n    ///\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.resize_default(2);\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    ///\n    /// [`resize`]: #method.resize\n    #[unstable(feature = \"vec_resize_default\", issue = \"41758\")]\n    pub fn resize_default(&mut self, new_len: usize) {\n        let len = self.len();\n\n        if new_len > len {\n            self.extend_with(new_len - len, ExtendDefault);\n        } else {\n            self.truncate(new_len);\n        }\n    }\n}\n\n// This code generalises `extend_with_{element,default}`.\ntrait ExtendWith<T> {\n    fn next(&self) -> T;\n    fn last(self) -> T;\n}\n\nstruct ExtendElement<T>(T);\nimpl<T: Clone> ExtendWith<T> for ExtendElement<T> {\n    fn next(&self) -> T { self.0.clone() }\n    fn last(self) -> T { self.0 }\n}\n\nstruct ExtendDefault;\nimpl<T: Default> ExtendWith<T> for ExtendDefault {\n    fn next(&self) -> T { Default::default() }\n    fn last(self) -> T { Default::default() }\n}\nimpl<T> Vec<T> {\n    /// Extend the vector by `n` values, using the given generator.\n    fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, value: E) {\n        self.reserve(n);\n\n        unsafe {\n            let mut ptr = self.as_mut_ptr().offset(self.len() as isize);\n            // Use SetLenOnDrop to work around bug where compiler\n            // may not realize the store through `ptr` through self.set_len()\n            // don't alias.\n            let mut local_len = SetLenOnDrop::new(&mut self.len);\n\n            // Write all elements except the last one\n            for _ in 1..n {\n                ptr::write(ptr, value.next());\n                ptr = ptr.offset(1);\n                // Increment the length in every step in case next() panics\n                local_len.increment_len(1);\n            }\n\n            if n > 0 {\n                // We can write the last element directly without cloning needlessly\n                ptr::write(ptr, value.last());\n                local_len.increment_len(1);\n            }\n\n            // len set by scope guard\n        }\n    }\n}\n\n// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n//\n// The idea is: The length field in SetLenOnDrop is a local variable\n// that the optimizer will see does not alias with any stores through the Vec's data\n// pointer. This is a workaround for alias analysis issue #32155\nstruct SetLenOnDrop<'a> {\n    len: &'a mut usize,\n    local_len: usize,\n}\n\nimpl<'a> SetLenOnDrop<'a> {\n    #[inline]\n    fn new(len: &'a mut usize) -> Self {\n        SetLenOnDrop { local_len: *len, len: len }\n    }\n\n    #[inline]\n    fn increment_len(&mut self, increment: usize) {\n        self.local_len += increment;\n    }\n}\n\nimpl<'a> Drop for SetLenOnDrop<'a> {\n    #[inline]\n    fn drop(&mut self) {\n        *self.len = self.local_len;\n    }\n}\n\nimpl<T: PartialEq> Vec<T> {\n    /// Removes consecutive repeated elements in the vector.\n    ///\n    /// If the vector is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 2, 3, 2];\n    ///\n    /// vec.dedup();\n    ///\n    /// assert_eq!(vec, [1, 2, 3, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn dedup(&mut self) {\n        self.dedup_by(|a, b| a == b)\n    }\n\n    /// Removes the first instance of `item` from the vector if the item exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(vec_remove_item)]\n    /// let mut vec = vec![1, 2, 3, 1];\n    ///\n    /// vec.remove_item(&1);\n    ///\n    /// assert_eq!(vec, vec![2, 3, 1]);\n    /// ```\n    #[unstable(feature = \"vec_remove_item\", reason = \"recently added\", issue = \"40062\")]\n    pub fn remove_item(&mut self, item: &T) -> Option<T> {\n        let pos = match self.iter().position(|x| *x == *item) {\n            Some(x) => x,\n            None => return None,\n        };\n        Some(self.remove(pos))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Internal methods and functions\n////////////////////////////////////////////////////////////////////////////////\n\n#[doc(hidden)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n    <T as SpecFromElem>::from_elem(elem, n)\n}\n\n// Specialization trait used for Vec::from_elem\ntrait SpecFromElem: Sized {\n    fn from_elem(elem: Self, n: usize) -> Vec<Self>;\n}\n\nimpl<T: Clone> SpecFromElem for T {\n    default fn from_elem(elem: Self, n: usize) -> Vec<Self> {\n        let mut v = Vec::with_capacity(n);\n        v.extend_with(n, ExtendElement(elem));\n        v\n    }\n}\n\nimpl SpecFromElem for u8 {\n    #[inline]\n    fn from_elem(elem: u8, n: usize) -> Vec<u8> {\n        if elem == 0 {\n            return Vec {\n                buf: RawVec::with_capacity_zeroed(n),\n                len: n,\n            }\n        }\n        unsafe {\n            let mut v = Vec::with_capacity(n);\n            ptr::write_bytes(v.as_mut_ptr(), elem, n);\n            v.set_len(n);\n            v\n        }\n    }\n}\n\nmacro_rules! impl_spec_from_elem {\n    ($t: ty, $is_zero: expr) => {\n        impl SpecFromElem for $t {\n            #[inline]\n            fn from_elem(elem: $t, n: usize) -> Vec<$t> {\n                if $is_zero(elem) {\n                    return Vec {\n                        buf: RawVec::with_capacity_zeroed(n),\n                        len: n,\n                    }\n                }\n                let mut v = Vec::with_capacity(n);\n                v.extend_with(n, ExtendElement(elem));\n                v\n            }\n        }\n    };\n}\n\nimpl_spec_from_elem!(i8, |x| x == 0);\nimpl_spec_from_elem!(i16, |x| x == 0);\nimpl_spec_from_elem!(i32, |x| x == 0);\nimpl_spec_from_elem!(i64, |x| x == 0);\nimpl_spec_from_elem!(i128, |x| x == 0);\nimpl_spec_from_elem!(isize, |x| x == 0);\n\nimpl_spec_from_elem!(u16, |x| x == 0);\nimpl_spec_from_elem!(u32, |x| x == 0);\nimpl_spec_from_elem!(u64, |x| x == 0);\nimpl_spec_from_elem!(u128, |x| x == 0);\nimpl_spec_from_elem!(usize, |x| x == 0);\n\nimpl_spec_from_elem!(f32, |x: f32| x == 0. && x.is_sign_positive());\nimpl_spec_from_elem!(f64, |x: f64| x == 0. && x.is_sign_positive());\n\n////////////////////////////////////////////////////////////////////////////////\n// Common trait implementations for Vec\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> Clone for Vec<T> {\n    #[cfg(not(test))]\n    fn clone(&self) -> Vec<T> {\n        <[T]>::to_vec(&**self)\n    }\n\n    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n    // required for this method definition, is not available. Instead use the\n    // `slice::to_vec`  function which is only available with cfg(test)\n    // NB see the slice::hack module in slice.rs for more information\n    #[cfg(test)]\n    fn clone(&self) -> Vec<T> {\n        ::slice::to_vec(&**self)\n    }\n\n    fn clone_from(&mut self, other: &Vec<T>) {\n        other.as_slice().clone_into(self);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Hash> Hash for Vec<T> {\n    #[inline]\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        Hash::hash(&**self, state)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Index<usize> for Vec<T> {\n    type Output = T;\n\n    #[inline]\n    fn index(&self, index: usize) -> &T {\n        // NB built-in indexing via `&[T]`\n        &(**self)[index]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> IndexMut<usize> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: usize) -> &mut T {\n        // NB built-in indexing via `&mut [T]`\n        &mut (**self)[index]\n    }\n}\n\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n    type Output = [T];\n\n    #[inline]\n    fn index(&self, index: ops::Range<usize>) -> &[T] {\n        Index::index(&**self, index)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n    type Output = [T];\n\n    #[inline]\n    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n        Index::index(&**self, index)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n    type Output = [T];\n\n    #[inline]\n    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n        Index::index(&**self, index)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::Index<ops::RangeFull> for Vec<T> {\n    type Output = [T];\n\n    #[inline]\n    fn index(&self, _index: ops::RangeFull) -> &[T] {\n        self\n    }\n}\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n    type Output = [T];\n\n    #[inline]\n    fn index(&self, index: ops::RangeInclusive<usize>) -> &[T] {\n        Index::index(&**self, index)\n    }\n}\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n    type Output = [T];\n\n    #[inline]\n    fn index(&self, index: ops::RangeToInclusive<usize>) -> &[T] {\n        Index::index(&**self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n        self\n    }\n}\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<T> ops::IndexMut<ops::RangeInclusive<usize>> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::Deref for Vec<T> {\n    type Target = [T];\n\n    fn deref(&self) -> &[T] {\n        unsafe {\n            let p = self.buf.ptr();\n            assume(!p.is_null());\n            slice::from_raw_parts(p, self.len)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::DerefMut for Vec<T> {\n    fn deref_mut(&mut self) -> &mut [T] {\n        unsafe {\n            let ptr = self.buf.ptr();\n            assume(!ptr.is_null());\n            slice::from_raw_parts_mut(ptr, self.len)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> FromIterator<T> for Vec<T> {\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Vec<T> {\n        <Self as SpecExtend<T, I::IntoIter>>::from_iter(iter.into_iter())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Creates a consuming iterator, that is, one that moves each value out of\n    /// the vector (from start to end). The vector cannot be used after calling\n    /// this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n    /// for s in v.into_iter() {\n    ///     // s has type String, not &String\n    ///     println!(\"{}\", s);\n    /// }\n    /// ```\n    #[inline]\n    fn into_iter(mut self) -> IntoIter<T> {\n        unsafe {\n            let begin = self.as_mut_ptr();\n            assume(!begin.is_null());\n            let end = if mem::size_of::<T>() == 0 {\n                arith_offset(begin as *const i8, self.len() as isize) as *const T\n            } else {\n                begin.offset(self.len() as isize) as *const T\n            };\n            let cap = self.buf.cap();\n            mem::forget(self);\n            IntoIter {\n                buf: Shared::new(begin),\n                cap: cap,\n                ptr: begin,\n                end: end,\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a Vec<T> {\n    type Item = &'a T;\n    type IntoIter = slice::Iter<'a, T>;\n\n    fn into_iter(self) -> slice::Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a mut Vec<T> {\n    type Item = &'a mut T;\n    type IntoIter = slice::IterMut<'a, T>;\n\n    fn into_iter(mut self) -> slice::IterMut<'a, T> {\n        self.iter_mut()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Extend<T> for Vec<T> {\n    #[inline]\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n        <Self as SpecExtend<T, I::IntoIter>>::spec_extend(self, iter.into_iter())\n    }\n}\n\n// Specialization trait used for Vec::from_iter and Vec::extend\ntrait SpecExtend<T, I> {\n    fn from_iter(iter: I) -> Self;\n    fn spec_extend(&mut self, iter: I);\n}\n\nimpl<T, I> SpecExtend<T, I> for Vec<T>\n    where I: Iterator<Item=T>,\n{\n    default fn from_iter(mut iterator: I) -> Self {\n        // Unroll the first iteration, as the vector is going to be\n        // expanded on this iteration in every case when the iterable is not\n        // empty, but the loop in extend_desugared() is not going to see the\n        // vector being full in the few subsequent loop iterations.\n        // So we get better branch prediction.\n        let mut vector = match iterator.next() {\n            None => return Vec::new(),\n            Some(element) => {\n                let (lower, _) = iterator.size_hint();\n                let mut vector = Vec::with_capacity(lower.saturating_add(1));\n                unsafe {\n                    ptr::write(vector.get_unchecked_mut(0), element);\n                    vector.set_len(1);\n                }\n                vector\n            }\n        };\n        <Vec<T> as SpecExtend<T, I>>::spec_extend(&mut vector, iterator);\n        vector\n    }\n\n    default fn spec_extend(&mut self, iter: I) {\n        self.extend_desugared(iter)\n    }\n}\n\nimpl<T, I> SpecExtend<T, I> for Vec<T>\n    where I: TrustedLen<Item=T>,\n{\n    default fn from_iter(iterator: I) -> Self {\n        let mut vector = Vec::new();\n        vector.spec_extend(iterator);\n        vector\n    }\n\n    default fn spec_extend(&mut self, iterator: I) {\n        // This is the case for a TrustedLen iterator.\n        let (low, high) = iterator.size_hint();\n        if let Some(high_value) = high {\n            debug_assert_eq!(low, high_value,\n                             \"TrustedLen iterator's size hint is not exact: {:?}\",\n                             (low, high));\n        }\n        if let Some(additional) = high {\n            self.reserve(additional);\n            unsafe {\n                let mut ptr = self.as_mut_ptr().offset(self.len() as isize);\n                let mut local_len = SetLenOnDrop::new(&mut self.len);\n                for element in iterator {\n                    ptr::write(ptr, element);\n                    ptr = ptr.offset(1);\n                    // NB can't overflow since we would have had to alloc the address space\n                    local_len.increment_len(1);\n                }\n            }\n        } else {\n            self.extend_desugared(iterator)\n        }\n    }\n}\n\nimpl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n    fn from_iter(iterator: IntoIter<T>) -> Self {\n        // A common case is passing a vector into a function which immediately\n        // re-collects into a vector. We can short circuit this if the IntoIter\n        // has not been advanced at all.\n        if iterator.buf.as_ptr() as *const _ == iterator.ptr {\n            unsafe {\n                let vec = Vec::from_raw_parts(iterator.buf.as_ptr(),\n                                              iterator.len(),\n                                              iterator.cap);\n                mem::forget(iterator);\n                vec\n            }\n        } else {\n            let mut vector = Vec::new();\n            vector.spec_extend(iterator);\n            vector\n        }\n    }\n\n    fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n        unsafe {\n            self.append_elements(iterator.as_slice() as _);\n        }\n        iterator.ptr = iterator.end;\n    }\n}\n\nimpl<'a, T: 'a, I> SpecExtend<&'a T, I> for Vec<T>\n    where I: Iterator<Item=&'a T>,\n          T: Clone,\n{\n    default fn from_iter(iterator: I) -> Self {\n        SpecExtend::from_iter(iterator.cloned())\n    }\n\n    default fn spec_extend(&mut self, iterator: I) {\n        self.spec_extend(iterator.cloned())\n    }\n}\n\nimpl<'a, T: 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T>\n    where T: Copy,\n{\n    fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n        let slice = iterator.as_slice();\n        self.reserve(slice.len());\n        unsafe {\n            let len = self.len();\n            self.set_len(len + slice.len());\n            self.get_unchecked_mut(len..).copy_from_slice(slice);\n        }\n    }\n}\n\nimpl<T> Vec<T> {\n    fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n        // This is the case for a general iterator.\n        //\n        // This function should be the moral equivalent of:\n        //\n        //      for item in iterator {\n        //          self.push(item);\n        //      }\n        while let Some(element) = iterator.next() {\n            let len = self.len();\n            if len == self.capacity() {\n                let (lower, _) = iterator.size_hint();\n                self.reserve(lower.saturating_add(1));\n            }\n            unsafe {\n                ptr::write(self.get_unchecked_mut(len), element);\n                // NB can't overflow since we would have had to alloc the address space\n                self.set_len(len + 1);\n            }\n        }\n    }\n\n    /// Creates a splicing iterator that replaces the specified range in the vector\n    /// with the given `replace_with` iterator and yields the removed items.\n    /// `replace_with` does not need to be the same length as `range`.\n    ///\n    /// Note 1: The element range is removed even if the iterator is not\n    /// consumed until the end.\n    ///\n    /// Note 2: It is unspecified how many elements are removed from the vector,\n    /// if the `Splice` value is leaked.\n    ///\n    /// Note 3: The input iterator `replace_with` is only consumed\n    /// when the `Splice` value is dropped.\n    ///\n    /// Note 4: This is optimal if:\n    ///\n    /// * The tail (elements in the vector after `range`) is empty,\n    /// * or `replace_with` yields fewer elements than `range`s length\n    /// * or the lower bound of its `size_hint()` is exact.\n    ///\n    /// Otherwise, a temporary vector is allocated and the tail is moved twice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(splice)]\n    /// let mut v = vec![1, 2, 3];\n    /// let new = [7, 8];\n    /// let u: Vec<_> = v.splice(..2, new.iter().cloned()).collect();\n    /// assert_eq!(v, &[7, 8, 3]);\n    /// assert_eq!(u, &[1, 2]);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<I::IntoIter>\n        where R: RangeArgument<usize>, I: IntoIterator<Item=T>\n    {\n        Splice {\n            drain: self.drain(range),\n            replace_with: replace_with.into_iter(),\n        }\n    }\n\n}\n\n#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\nimpl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n        self.spec_extend(iter.into_iter())\n    }\n}\n\nmacro_rules! __impl_slice_eq1 {\n    ($Lhs: ty, $Rhs: ty) => {\n        __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n    };\n    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n            #[inline]\n            fn eq(&self, other: &$Rhs) -> bool { self[..] == other[..] }\n            #[inline]\n            fn ne(&self, other: &$Rhs) -> bool { self[..] != other[..] }\n        }\n    }\n}\n\n__impl_slice_eq1! { Vec<A>, Vec<B> }\n__impl_slice_eq1! { Vec<A>, &'b [B] }\n__impl_slice_eq1! { Vec<A>, &'b mut [B] }\n__impl_slice_eq1! { Cow<'a, [A]>, &'b [B], Clone }\n__impl_slice_eq1! { Cow<'a, [A]>, &'b mut [B], Clone }\n__impl_slice_eq1! { Cow<'a, [A]>, Vec<B>, Clone }\n\nmacro_rules! array_impls {\n    ($($N: expr)+) => {\n        $(\n            // NOTE: some less important impls are omitted to reduce code bloat\n            __impl_slice_eq1! { Vec<A>, [B; $N] }\n            __impl_slice_eq1! { Vec<A>, &'b [B; $N] }\n            // __impl_slice_eq1! { Vec<A>, &'b mut [B; $N] }\n            // __impl_slice_eq1! { Cow<'a, [A]>, [B; $N], Clone }\n            // __impl_slice_eq1! { Cow<'a, [A]>, &'b [B; $N], Clone }\n            // __impl_slice_eq1! { Cow<'a, [A]>, &'b mut [B; $N], Clone }\n        )+\n    }\n}\n\narray_impls! {\n     0  1  2  3  4  5  6  7  8  9\n    10 11 12 13 14 15 16 17 18 19\n    20 21 22 23 24 25 26 27 28 29\n    30 31 32\n}\n\n/// Implements comparison of vectors, lexicographically.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: PartialOrd> PartialOrd for Vec<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n        PartialOrd::partial_cmp(&**self, &**other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Eq> Eq for Vec<T> {}\n\n/// Implements ordering of vectors, lexicographically.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord> Ord for Vec<T> {\n    #[inline]\n    fn cmp(&self, other: &Vec<T>) -> Ordering {\n        Ord::cmp(&**self, &**other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T> Drop for Vec<T> {\n    fn drop(&mut self) {\n        unsafe {\n            // use drop for [T]\n            ptr::drop_in_place(&mut self[..]);\n        }\n        // RawVec handles deallocation\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for Vec<T> {\n    /// Creates an empty `Vec<T>`.\n    fn default() -> Vec<T> {\n        Vec::new()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Vec<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsRef<Vec<T>> for Vec<T> {\n    fn as_ref(&self) -> &Vec<T> {\n        self\n    }\n}\n\n#[stable(feature = \"vec_as_mut\", since = \"1.5.0\")]\nimpl<T> AsMut<Vec<T>> for Vec<T> {\n    fn as_mut(&mut self) -> &mut Vec<T> {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsRef<[T]> for Vec<T> {\n    fn as_ref(&self) -> &[T] {\n        self\n    }\n}\n\n#[stable(feature = \"vec_as_mut\", since = \"1.5.0\")]\nimpl<T> AsMut<[T]> for Vec<T> {\n    fn as_mut(&mut self) -> &mut [T] {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: Clone> From<&'a [T]> for Vec<T> {\n    #[cfg(not(test))]\n    fn from(s: &'a [T]) -> Vec<T> {\n        s.to_vec()\n    }\n    #[cfg(test)]\n    fn from(s: &'a [T]) -> Vec<T> {\n        ::slice::to_vec(s)\n    }\n}\n\n#[stable(feature = \"vec_from_mut\", since = \"1.19.0\")]\nimpl<'a, T: Clone> From<&'a mut [T]> for Vec<T> {\n    #[cfg(not(test))]\n    fn from(s: &'a mut [T]) -> Vec<T> {\n        s.to_vec()\n    }\n    #[cfg(test)]\n    fn from(s: &'a mut [T]) -> Vec<T> {\n        ::slice::to_vec(s)\n    }\n}\n\n#[stable(feature = \"vec_from_cow_slice\", since = \"1.14.0\")]\nimpl<'a, T> From<Cow<'a, [T]>> for Vec<T> where [T]: ToOwned<Owned=Vec<T>> {\n    fn from(s: Cow<'a, [T]>) -> Vec<T> {\n        s.into_owned()\n    }\n}\n\n// note: test pulls in libstd, which causes errors here\n#[cfg(not(test))]\n#[stable(feature = \"vec_from_box\", since = \"1.18.0\")]\nimpl<T> From<Box<[T]>> for Vec<T> {\n    fn from(s: Box<[T]>) -> Vec<T> {\n        s.into_vec()\n    }\n}\n\n// note: test pulls in libstd, which causes errors here\n#[cfg(not(test))]\n#[stable(feature = \"box_from_vec\", since = \"1.20.0\")]\nimpl<T> From<Vec<T>> for Box<[T]> {\n    fn from(v: Vec<T>) -> Box<[T]> {\n        v.into_boxed_slice()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<&'a str> for Vec<u8> {\n    fn from(s: &'a str) -> Vec<u8> {\n        From::from(s.as_bytes())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Clone-on-write\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\nimpl<'a, T: Clone> From<&'a [T]> for Cow<'a, [T]> {\n    fn from(s: &'a [T]) -> Cow<'a, [T]> {\n        Cow::Borrowed(s)\n    }\n}\n\n#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\nimpl<'a, T: Clone> From<Vec<T>> for Cow<'a, [T]> {\n    fn from(v: Vec<T>) -> Cow<'a, [T]> {\n        Cow::Owned(v)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n    fn from_iter<I: IntoIterator<Item = T>>(it: I) -> Cow<'a, [T]> {\n        Cow::Owned(FromIterator::from_iter(it))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Iterators\n////////////////////////////////////////////////////////////////////////////////\n\n/// An iterator that moves out of a vector.\n///\n/// This `struct` is created by the `into_iter` method on [`Vec`][`Vec`] (provided\n/// by the [`IntoIterator`] trait).\n///\n/// [`Vec`]: struct.Vec.html\n/// [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<T> {\n    buf: Shared<T>,\n    cap: usize,\n    ptr: *const T,\n    end: *const T,\n}\n\n#[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\nimpl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"IntoIter\")\n            .field(&self.as_slice())\n            .finish()\n    }\n}\n\nimpl<T> IntoIter<T> {\n    /// Returns the remaining items of this iterator as a slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let vec = vec!['a', 'b', 'c'];\n    /// let mut into_iter = vec.into_iter();\n    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n    /// let _ = into_iter.next().unwrap();\n    /// assert_eq!(into_iter.as_slice(), &['b', 'c']);\n    /// ```\n    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n    pub fn as_slice(&self) -> &[T] {\n        unsafe {\n            slice::from_raw_parts(self.ptr, self.len())\n        }\n    }\n\n    /// Returns the remaining items of this iterator as a mutable slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let vec = vec!['a', 'b', 'c'];\n    /// let mut into_iter = vec.into_iter();\n    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n    /// into_iter.as_mut_slice()[2] = 'z';\n    /// assert_eq!(into_iter.next().unwrap(), 'a');\n    /// assert_eq!(into_iter.next().unwrap(), 'b');\n    /// assert_eq!(into_iter.next().unwrap(), 'z');\n    /// ```\n    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n        unsafe {\n            slice::from_raw_parts_mut(self.ptr as *mut T, self.len())\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Send> Send for IntoIter<T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Sync for IntoIter<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        unsafe {\n            if self.ptr as *const _ == self.end {\n                None\n            } else {\n                if mem::size_of::<T>() == 0 {\n                    // purposefully don't use 'ptr.offset' because for\n                    // vectors with 0-size elements this would return the\n                    // same pointer.\n                    self.ptr = arith_offset(self.ptr as *const i8, 1) as *mut T;\n\n                    // Use a non-null pointer value\n                    // (self.ptr might be null because of wrapping)\n                    Some(ptr::read(1 as *mut T))\n                } else {\n                    let old = self.ptr;\n                    self.ptr = self.ptr.offset(1);\n\n                    Some(ptr::read(old))\n                }\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let exact = match self.ptr.offset_to(self.end) {\n            Some(x) => x as usize,\n            None => (self.end as usize).wrapping_sub(self.ptr as usize),\n        };\n        (exact, Some(exact))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n        unsafe {\n            if self.end == self.ptr {\n                None\n            } else {\n                if mem::size_of::<T>() == 0 {\n                    // See above for why 'ptr.offset' isn't used\n                    self.end = arith_offset(self.end as *const i8, -1) as *mut T;\n\n                    // Use a non-null pointer value\n                    // (self.end might be null because of wrapping)\n                    Some(ptr::read(1 as *mut T))\n                } else {\n                    self.end = self.end.offset(-1);\n\n                    Some(ptr::read(self.end))\n                }\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for IntoIter<T> {\n    fn is_empty(&self) -> bool {\n        self.ptr == self.end\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<T> FusedIterator for IntoIter<T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for IntoIter<T> {}\n\n#[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\nimpl<T: Clone> Clone for IntoIter<T> {\n    fn clone(&self) -> IntoIter<T> {\n        self.as_slice().to_owned().into_iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        // destroy the remaining elements\n        for _x in self.by_ref() {}\n\n        // RawVec handles deallocation\n        let _ = unsafe { RawVec::from_raw_parts(self.buf.as_ptr(), self.cap) };\n    }\n}\n\n/// A draining iterator for `Vec<T>`.\n///\n/// This `struct` is created by the [`drain`] method on [`Vec`].\n///\n/// [`drain`]: struct.Vec.html#method.drain\n/// [`Vec`]: struct.Vec.html\n#[stable(feature = \"drain\", since = \"1.6.0\")]\npub struct Drain<'a, T: 'a> {\n    /// Index of tail to preserve\n    tail_start: usize,\n    /// Length of tail\n    tail_len: usize,\n    /// Current remaining range to remove\n    iter: slice::Iter<'a, T>,\n    vec: Shared<Vec<T>>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<'a, T: 'a + fmt::Debug> fmt::Debug for Drain<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"Drain\")\n         .field(&self.iter.as_slice())\n         .finish()\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl<'a, T: Send> Send for Drain<'a, T> {}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a, T> Iterator for Drain<'a, T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a, T> Drop for Drain<'a, T> {\n    fn drop(&mut self) {\n        // exhaust self first\n        while let Some(_) = self.next() {}\n\n        if self.tail_len > 0 {\n            unsafe {\n                let source_vec = self.vec.as_mut();\n                // memmove back untouched tail, update to new length\n                let start = source_vec.len();\n                let tail = self.tail_start;\n                let src = source_vec.as_ptr().offset(tail as isize);\n                let dst = source_vec.as_mut_ptr().offset(start as isize);\n                ptr::copy(src, dst, self.tail_len);\n                source_vec.set_len(start + self.tail_len);\n            }\n        }\n    }\n}\n\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a, T> ExactSizeIterator for Drain<'a, T> {\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for Drain<'a, T> {}\n\n/// A place for insertion at the back of a `Vec`.\n///\n/// See [`Vec::place_back`](struct.Vec.html#method.place_back) for details.\n#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n#[unstable(feature = \"collection_placement\",\n           reason = \"struct name and placement protocol are subject to change\",\n           issue = \"30172\")]\n#[derive(Debug)]\npub struct PlaceBack<'a, T: 'a> {\n    vec: &'a mut Vec<T>,\n}\n\n#[unstable(feature = \"collection_placement\",\n           reason = \"placement protocol is subject to change\",\n           issue = \"30172\")]\nimpl<'a, T> Placer<T> for PlaceBack<'a, T> {\n    type Place = PlaceBack<'a, T>;\n\n    fn make_place(self) -> Self {\n        // This will panic or abort if we would allocate > isize::MAX bytes\n        // or if the length increment would overflow for zero-sized types.\n        if self.vec.len == self.vec.buf.cap() {\n            self.vec.buf.double();\n        }\n        self\n    }\n}\n\n#[unstable(feature = \"collection_placement\",\n           reason = \"placement protocol is subject to change\",\n           issue = \"30172\")]\nimpl<'a, T> Place<T> for PlaceBack<'a, T> {\n    fn pointer(&mut self) -> *mut T {\n        unsafe { self.vec.as_mut_ptr().offset(self.vec.len as isize) }\n    }\n}\n\n#[unstable(feature = \"collection_placement\",\n           reason = \"placement protocol is subject to change\",\n           issue = \"30172\")]\nimpl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n    type Owner = &'a mut T;\n\n    unsafe fn finalize(mut self) -> &'a mut T {\n        let ptr = self.pointer();\n        self.vec.len += 1;\n        &mut *ptr\n    }\n}\n\n\n/// A splicing iterator for `Vec`.\n///\n/// This struct is created by the [`splice()`] method on [`Vec`]. See its\n/// documentation for more.\n///\n/// [`splice()`]: struct.Vec.html#method.splice\n/// [`Vec`]: struct.Vec.html\n#[derive(Debug)]\n#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\npub struct Splice<'a, I: Iterator + 'a> {\n    drain: Drain<'a, I::Item>,\n    replace_with: I,\n}\n\n#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\nimpl<'a, I: Iterator> Iterator for Splice<'a, I> {\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.drain.next()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.drain.size_hint()\n    }\n}\n\n#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\nimpl<'a, I: Iterator> DoubleEndedIterator for Splice<'a, I> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.drain.next_back()\n    }\n}\n\n#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\nimpl<'a, I: Iterator> ExactSizeIterator for Splice<'a, I> {}\n\n\n#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\nimpl<'a, I: Iterator> Drop for Splice<'a, I> {\n    fn drop(&mut self) {\n        // exhaust drain first\n        while let Some(_) = self.drain.next() {}\n\n\n        unsafe {\n            if self.drain.tail_len == 0 {\n                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n                return\n            }\n\n            // First fill the range left by drain().\n            if !self.drain.fill(&mut self.replace_with) {\n                return\n            }\n\n            // There may be more elements. Use the lower bound as an estimate.\n            // FIXME: Is the upper bound a better guess? Or something else?\n            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n            if lower_bound > 0  {\n                self.drain.move_tail(lower_bound);\n                if !self.drain.fill(&mut self.replace_with) {\n                    return\n                }\n            }\n\n            // Collect any remaining elements.\n            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n            let mut collected = self.replace_with.by_ref().collect::<Vec<I::Item>>().into_iter();\n            // Now we have an exact count.\n            if collected.len() > 0 {\n                self.drain.move_tail(collected.len());\n                let filled = self.drain.fill(&mut collected);\n                debug_assert!(filled);\n                debug_assert_eq!(collected.len(), 0);\n            }\n        }\n        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n    }\n}\n\n/// Private helper methods for `Splice::drop`\nimpl<'a, T> Drain<'a, T> {\n    /// The range from `self.vec.len` to `self.tail_start` contains elements\n    /// that have been moved out.\n    /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n    /// Return whether we filled the entire range. (`replace_with.next()` didnt return `None`.)\n    unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n        let vec = self.vec.as_mut();\n        let range_start = vec.len;\n        let range_end = self.tail_start;\n        let range_slice = slice::from_raw_parts_mut(\n            vec.as_mut_ptr().offset(range_start as isize),\n            range_end - range_start);\n\n        for place in range_slice {\n            if let Some(new_item) = replace_with.next() {\n                ptr::write(place, new_item);\n                vec.len += 1;\n            } else {\n                return false\n            }\n        }\n        true\n    }\n\n    /// Make room for inserting more elements before the tail.\n    unsafe fn move_tail(&mut self, extra_capacity: usize) {\n        let vec = self.vec.as_mut();\n        let used_capacity = self.tail_start + self.tail_len;\n        vec.buf.reserve(used_capacity, extra_capacity);\n\n        let new_tail_start = self.tail_start + extra_capacity;\n        let src = vec.as_ptr().offset(self.tail_start as isize);\n        let dst = vec.as_mut_ptr().offset(new_tail_start as isize);\n        ptr::copy(src, dst, self.tail_len);\n        self.tail_start = new_tail_start;\n    }\n}\n","// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Slice management and manipulation\n//!\n//! For more details see [`std::slice`].\n//!\n//! [`std::slice`]: ../../std/slice/index.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n// How this module is organized.\n//\n// The library infrastructure for slices is fairly messy. There's\n// a lot of stuff defined here. Let's keep it clean.\n//\n// Since slices don't support inherent methods; all operations\n// on them are defined on traits, which are then reexported from\n// the prelude for convenience. So there are a lot of traits here.\n//\n// The layout of this file is thus:\n//\n// * Slice-specific 'extension' traits and their implementations. This\n//   is where most of the slice API resides.\n// * Implementations of a few common traits with important slice ops.\n// * Definitions of a bunch of iterators.\n// * Free functions.\n// * The `raw` and `bytes` submodules.\n// * Boilerplate trait implementations.\n\nuse borrow::Borrow;\nuse cmp::Ordering::{self, Less, Equal, Greater};\nuse cmp;\nuse fmt;\nuse intrinsics::assume;\nuse iter::*;\nuse ops::{FnMut, self};\nuse option::Option;\nuse option::Option::{None, Some};\nuse result::Result;\nuse result::Result::{Ok, Err};\nuse ptr;\nuse mem;\nuse marker::{Copy, Send, Sync, Sized, self};\nuse iter_private::TrustedRandomAccess;\n\nmod rotate;\nmod sort;\n\n#[repr(C)]\nstruct Repr<T> {\n    pub data: *const T,\n    pub len: usize,\n}\n\n//\n// Extension traits\n//\n\n/// Extension methods for slices.\n#[unstable(feature = \"core_slice_ext\",\n           reason = \"stable interface provided by `impl [T]` in later crates\",\n           issue = \"32110\")]\n#[allow(missing_docs)] // documented elsewhere\npub trait SliceExt {\n    type Item;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_at(&self, mid: usize) -> (&[Self::Item], &[Self::Item]);\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn iter(&self) -> Iter<Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split<P>(&self, pred: P) -> Split<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n    fn rsplit<P>(&self, pred: P) -> RSplit<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn splitn<P>(&self, n: usize, pred: P) -> SplitN<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn rsplitn<P>(&self,  n: usize, pred: P) -> RSplitN<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn windows(&self, size: usize) -> Windows<Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn chunks(&self, size: usize) -> Chunks<Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn get<I>(&self, index: I) -> Option<&I::Output>\n        where I: SliceIndex<Self>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn first(&self) -> Option<&Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_first(&self) -> Option<(&Self::Item, &[Self::Item])>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_last(&self) -> Option<(&Self::Item, &[Self::Item])>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn last(&self) -> Option<&Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n        where I: SliceIndex<Self>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn as_ptr(&self) -> *const Self::Item;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn binary_search<Q: ?Sized>(&self, x: &Q) -> Result<usize, usize>\n        where Self::Item: Borrow<Q>,\n              Q: Ord;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n        where F: FnMut(&'a Self::Item) -> Ordering;\n\n    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n    fn binary_search_by_key<'a, B, F, Q: ?Sized>(&'a self, b: &Q, f: F) -> Result<usize, usize>\n        where F: FnMut(&'a Self::Item) -> B,\n              B: Borrow<Q>,\n              Q: Ord;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn len(&self) -> usize;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_empty(&self) -> bool { self.len() == 0 }\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n        where I: SliceIndex<Self>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn iter_mut(&mut self) -> IterMut<Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn first_mut(&mut self) -> Option<&mut Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_first_mut(&mut self) -> Option<(&mut Self::Item, &mut [Self::Item])>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_last_mut(&mut self) -> Option<(&mut Self::Item, &mut [Self::Item])>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn last_mut(&mut self) -> Option<&mut Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_mut<P>(&mut self, pred: P) -> SplitMut<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n    fn rsplit_mut<P>(&mut self, pred: P) -> RSplitMut<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn rsplitn_mut<P>(&mut self,  n: usize, pred: P) -> RSplitNMut<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn swap(&mut self, a: usize, b: usize);\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_at_mut(&mut self, mid: usize) -> (&mut [Self::Item], &mut [Self::Item]);\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn reverse(&mut self);\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n        where I: SliceIndex<Self>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n\n    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n    fn rotate(&mut self, mid: usize);\n\n    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n    fn clone_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Clone;\n\n    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n    fn copy_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Copy;\n\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    fn sort_unstable(&mut self)\n        where Self::Item: Ord;\n\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    fn sort_unstable_by<F>(&mut self, compare: F)\n        where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    fn sort_unstable_by_key<B, F>(&mut self, f: F)\n        where F: FnMut(&Self::Item) -> B,\n              B: Ord;\n}\n\n// Use macros to be generic over const/mut\nmacro_rules! slice_offset {\n    ($ptr:expr, $by:expr) => {{\n        let ptr = $ptr;\n        if size_from_ptr(ptr) == 0 {\n            (ptr as *mut i8).wrapping_offset($by) as _\n        } else {\n            ptr.offset($by)\n        }\n    }};\n}\n\n// make a &T from a *const T\nmacro_rules! make_ref {\n    ($ptr:expr) => {{\n        let ptr = $ptr;\n        if size_from_ptr(ptr) == 0 {\n            // Use a non-null pointer value\n            &*(1 as *mut _)\n        } else {\n            &*ptr\n        }\n    }};\n}\n\n// make a &mut T from a *mut T\nmacro_rules! make_ref_mut {\n    ($ptr:expr) => {{\n        let ptr = $ptr;\n        if size_from_ptr(ptr) == 0 {\n            // Use a non-null pointer value\n            &mut *(1 as *mut _)\n        } else {\n            &mut *ptr\n        }\n    }};\n}\n\n#[unstable(feature = \"core_slice_ext\",\n           reason = \"stable interface provided by `impl [T]` in later crates\",\n           issue = \"32110\")]\nimpl<T> SliceExt for [T] {\n    type Item = T;\n\n    #[inline]\n    fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        (&self[..mid], &self[mid..])\n    }\n\n    #[inline]\n    fn iter(&self) -> Iter<T> {\n        unsafe {\n            let p = if mem::size_of::<T>() == 0 {\n                1 as *const _\n            } else {\n                let p = self.as_ptr();\n                assume(!p.is_null());\n                p\n            };\n\n            Iter {\n                ptr: p,\n                end: slice_offset!(p, self.len() as isize),\n                _marker: marker::PhantomData\n            }\n        }\n    }\n\n    #[inline]\n    fn split<P>(&self, pred: P) -> Split<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        Split {\n            v: self,\n            pred: pred,\n            finished: false\n        }\n    }\n\n    #[inline]\n    fn rsplit<P>(&self, pred: P) -> RSplit<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        RSplit { inner: self.split(pred) }\n    }\n\n    #[inline]\n    fn splitn<P>(&self, n: usize, pred: P) -> SplitN<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        SplitN {\n            inner: GenericSplitN {\n                iter: self.split(pred),\n                count: n\n            }\n        }\n    }\n\n    #[inline]\n    fn rsplitn<P>(&self, n: usize, pred: P) -> RSplitN<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        RSplitN {\n            inner: GenericSplitN {\n                iter: self.rsplit(pred),\n                count: n\n            }\n        }\n    }\n\n    #[inline]\n    fn windows(&self, size: usize) -> Windows<T> {\n        assert!(size != 0);\n        Windows { v: self, size: size }\n    }\n\n    #[inline]\n    fn chunks(&self, size: usize) -> Chunks<T> {\n        assert!(size != 0);\n        Chunks { v: self, size: size }\n    }\n\n    #[inline]\n    fn get<I>(&self, index: I) -> Option<&I::Output>\n        where I: SliceIndex<[T]>\n    {\n        index.get(self)\n    }\n\n    #[inline]\n    fn first(&self) -> Option<&T> {\n        if self.is_empty() { None } else { Some(&self[0]) }\n    }\n\n    #[inline]\n    fn split_first(&self) -> Option<(&T, &[T])> {\n        if self.is_empty() { None } else { Some((&self[0], &self[1..])) }\n    }\n\n    #[inline]\n    fn split_last(&self) -> Option<(&T, &[T])> {\n        let len = self.len();\n        if len == 0 { None } else { Some((&self[len - 1], &self[..(len - 1)])) }\n    }\n\n    #[inline]\n    fn last(&self) -> Option<&T> {\n        if self.is_empty() { None } else { Some(&self[self.len() - 1]) }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n        where I: SliceIndex<[T]>\n    {\n        index.get_unchecked(self)\n    }\n\n    #[inline]\n    fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }\n\n    fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n        where F: FnMut(&'a T) -> Ordering\n    {\n        let mut base = 0usize;\n        let mut s = self;\n\n        loop {\n            let (head, tail) = s.split_at(s.len() >> 1);\n            if tail.is_empty() {\n                return Err(base)\n            }\n            match f(&tail[0]) {\n                Less => {\n                    base += head.len() + 1;\n                    s = &tail[1..];\n                }\n                Greater => s = head,\n                Equal => return Ok(base + head.len()),\n            }\n        }\n    }\n\n    #[inline]\n    fn len(&self) -> usize {\n        unsafe {\n            mem::transmute::<&[T], Repr<T>>(self).len\n        }\n    }\n\n    #[inline]\n    fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n        where I: SliceIndex<[T]>\n    {\n        index.get_mut(self)\n    }\n\n    #[inline]\n    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n        let len = self.len();\n        let ptr = self.as_mut_ptr();\n\n        unsafe {\n            assert!(mid <= len);\n\n            (from_raw_parts_mut(ptr, mid),\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n        }\n    }\n\n    #[inline]\n    fn iter_mut(&mut self) -> IterMut<T> {\n        unsafe {\n            let p = if mem::size_of::<T>() == 0 {\n                1 as *mut _\n            } else {\n                let p = self.as_mut_ptr();\n                assume(!p.is_null());\n                p\n            };\n\n            IterMut {\n                ptr: p,\n                end: slice_offset!(p, self.len() as isize),\n                _marker: marker::PhantomData\n            }\n        }\n    }\n\n    #[inline]\n    fn last_mut(&mut self) -> Option<&mut T> {\n        let len = self.len();\n        if len == 0 { return None; }\n        Some(&mut self[len - 1])\n    }\n\n    #[inline]\n    fn first_mut(&mut self) -> Option<&mut T> {\n        if self.is_empty() { None } else { Some(&mut self[0]) }\n    }\n\n    #[inline]\n    fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n        if self.is_empty() { None } else {\n            let split = self.split_at_mut(1);\n            Some((&mut split.0[0], split.1))\n        }\n    }\n\n    #[inline]\n    fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n        let len = self.len();\n        if len == 0 { None } else {\n            let split = self.split_at_mut(len - 1);\n            Some((&mut split.1[0], split.0))\n        }\n    }\n\n    #[inline]\n    fn split_mut<P>(&mut self, pred: P) -> SplitMut<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        SplitMut { v: self, pred: pred, finished: false }\n    }\n\n    #[inline]\n    fn rsplit_mut<P>(&mut self, pred: P) -> RSplitMut<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        RSplitMut { inner: self.split_mut(pred) }\n    }\n\n    #[inline]\n    fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        SplitNMut {\n            inner: GenericSplitN {\n                iter: self.split_mut(pred),\n                count: n\n            }\n        }\n    }\n\n    #[inline]\n    fn rsplitn_mut<P>(&mut self, n: usize, pred: P) -> RSplitNMut<T, P> where\n        P: FnMut(&T) -> bool,\n    {\n        RSplitNMut {\n            inner: GenericSplitN {\n                iter: self.rsplit_mut(pred),\n                count: n\n            }\n        }\n    }\n\n    #[inline]\n    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n        assert!(chunk_size > 0);\n        ChunksMut { v: self, chunk_size: chunk_size }\n    }\n\n    #[inline]\n    fn swap(&mut self, a: usize, b: usize) {\n        unsafe {\n            // Can't take two mutable loans from one vector, so instead just cast\n            // them to their raw pointers to do the swap\n            let pa: *mut T = &mut self[a];\n            let pb: *mut T = &mut self[b];\n            ptr::swap(pa, pb);\n        }\n    }\n\n    fn reverse(&mut self) {\n        let mut i: usize = 0;\n        let ln = self.len();\n\n        // For very small types, all the individual reads in the normal\n        // path perform poorly.  We can do better, given efficient unaligned\n        // load/store, by loading a larger chunk and reversing a register.\n\n        // Ideally LLVM would do this for us, as it knows better than we do\n        // whether unaligned reads are efficient (since that changes between\n        // different ARM versions, for example) and what the best chunk size\n        // would be.  Unfortunately, as of LLVM 4.0 (2017-05) it only unrolls\n        // the loop, so we need to do this ourselves.  (Hypothesis: reverse\n        // is troublesome because the sides can be aligned differently --\n        // will be, when the length is odd -- so there's no way of emitting\n        // pre- and postludes to use fully-aligned SIMD in the middle.)\n\n        let fast_unaligned =\n            cfg!(any(target_arch = \"x86\", target_arch = \"x86_64\"));\n\n        if fast_unaligned && mem::size_of::<T>() == 1 {\n            // Use the llvm.bswap intrinsic to reverse u8s in a usize\n            let chunk = mem::size_of::<usize>();\n            while i + chunk - 1 < ln / 2 {\n                unsafe {\n                    let pa: *mut T = self.get_unchecked_mut(i);\n                    let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n                    let va = ptr::read_unaligned(pa as *mut usize);\n                    let vb = ptr::read_unaligned(pb as *mut usize);\n                    ptr::write_unaligned(pa as *mut usize, vb.swap_bytes());\n                    ptr::write_unaligned(pb as *mut usize, va.swap_bytes());\n                }\n                i += chunk;\n            }\n        }\n\n        if fast_unaligned && mem::size_of::<T>() == 2 {\n            // Use rotate-by-16 to reverse u16s in a u32\n            let chunk = mem::size_of::<u32>() / 2;\n            while i + chunk - 1 < ln / 2 {\n                unsafe {\n                    let pa: *mut T = self.get_unchecked_mut(i);\n                    let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n                    let va = ptr::read_unaligned(pa as *mut u32);\n                    let vb = ptr::read_unaligned(pb as *mut u32);\n                    ptr::write_unaligned(pa as *mut u32, vb.rotate_left(16));\n                    ptr::write_unaligned(pb as *mut u32, va.rotate_left(16));\n                }\n                i += chunk;\n            }\n        }\n\n        while i < ln / 2 {\n            // Unsafe swap to avoid the bounds check in safe swap.\n            unsafe {\n                let pa: *mut T = self.get_unchecked_mut(i);\n                let pb: *mut T = self.get_unchecked_mut(ln - i - 1);\n                ptr::swap(pa, pb);\n            }\n            i += 1;\n        }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n        where I: SliceIndex<[T]>\n    {\n        index.get_unchecked_mut(self)\n    }\n\n    #[inline]\n    fn as_mut_ptr(&mut self) -> *mut T {\n        self as *mut [T] as *mut T\n    }\n\n    #[inline]\n    fn contains(&self, x: &T) -> bool where T: PartialEq {\n        self.iter().any(|elt| *x == *elt)\n    }\n\n    #[inline]\n    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n        let n = needle.len();\n        self.len() >= n && needle == &self[..n]\n    }\n\n    #[inline]\n    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n        let (m, n) = (self.len(), needle.len());\n        m >= n && needle == &self[m-n..]\n    }\n\n    fn binary_search<Q: ?Sized>(&self, x: &Q) -> Result<usize, usize>\n        where T: Borrow<Q>,\n              Q: Ord\n    {\n        self.binary_search_by(|p| p.borrow().cmp(x))\n    }\n\n    fn rotate(&mut self, mid: usize) {\n        assert!(mid <= self.len());\n        let k = self.len() - mid;\n\n        unsafe {\n            let p = self.as_mut_ptr();\n            rotate::ptr_rotate(mid, p.offset(mid as isize), k);\n        }\n    }\n\n    #[inline]\n    fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n        assert!(self.len() == src.len(),\n                \"destination and source slices have different lengths\");\n        // NOTE: We need to explicitly slice them to the same length\n        // for bounds checking to be elided, and the optimizer will\n        // generate memcpy for simple cases (for example T = u8).\n        let len = self.len();\n        let src = &src[..len];\n        for i in 0..len {\n            self[i].clone_from(&src[i]);\n        }\n    }\n\n    #[inline]\n    fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n        assert!(self.len() == src.len(),\n                \"destination and source slices have different lengths\");\n        unsafe {\n            ptr::copy_nonoverlapping(\n                src.as_ptr(), self.as_mut_ptr(), self.len());\n        }\n    }\n\n    #[inline]\n    fn binary_search_by_key<'a, B, F, Q: ?Sized>(&'a self, b: &Q, mut f: F) -> Result<usize, usize>\n        where F: FnMut(&'a Self::Item) -> B,\n              B: Borrow<Q>,\n              Q: Ord\n    {\n        self.binary_search_by(|k| f(k).borrow().cmp(b))\n    }\n\n    #[inline]\n    fn sort_unstable(&mut self)\n        where Self::Item: Ord\n    {\n        sort::quicksort(self, |a, b| a.lt(b));\n    }\n\n    #[inline]\n    fn sort_unstable_by<F>(&mut self, mut compare: F)\n        where F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        sort::quicksort(self, |a, b| compare(a, b) == Ordering::Less);\n    }\n\n    #[inline]\n    fn sort_unstable_by_key<B, F>(&mut self, mut f: F)\n        where F: FnMut(&Self::Item) -> B,\n              B: Ord\n    {\n        sort::quicksort(self, |a, b| f(a).lt(&f(b)));\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\nimpl<T, I> ops::Index<I> for [T]\n    where I: SliceIndex<[T]>\n{\n    type Output = I::Output;\n\n    #[inline]\n    fn index(&self, index: I) -> &I::Output {\n        index.index(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\nimpl<T, I> ops::IndexMut<I> for [T]\n    where I: SliceIndex<[T]>\n{\n    #[inline]\n    fn index_mut(&mut self, index: I) -> &mut I::Output {\n        index.index_mut(self)\n    }\n}\n\n#[inline(never)]\n#[cold]\nfn slice_index_len_fail(index: usize, len: usize) -> ! {\n    panic!(\"index {} out of range for slice of length {}\", index, len);\n}\n\n#[inline(never)]\n#[cold]\nfn slice_index_order_fail(index: usize, end: usize) -> ! {\n    panic!(\"slice index starts at {} but ends at {}\", index, end);\n}\n\n/// A helper trait used for indexing operations.\n#[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\npub trait SliceIndex<T: ?Sized> {\n    /// The output type returned by methods.\n    type Output: ?Sized;\n\n    /// Returns a shared reference to the output at this location, if in\n    /// bounds.\n    fn get(self, slice: &T) -> Option<&Self::Output>;\n\n    /// Returns a mutable reference to the output at this location, if in\n    /// bounds.\n    fn get_mut(self, slice: &mut T) -> Option<&mut Self::Output>;\n\n    /// Returns a shared reference to the output at this location, without\n    /// performing any bounds checking.\n    unsafe fn get_unchecked(self, slice: &T) -> &Self::Output;\n\n    /// Returns a mutable reference to the output at this location, without\n    /// performing any bounds checking.\n    unsafe fn get_unchecked_mut(self, slice: &mut T) -> &mut Self::Output;\n\n    /// Returns a shared reference to the output at this location, panicking\n    /// if out of bounds.\n    fn index(self, slice: &T) -> &Self::Output;\n\n    /// Returns a mutable reference to the output at this location, panicking\n    /// if out of bounds.\n    fn index_mut(self, slice: &mut T) -> &mut Self::Output;\n}\n\n#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for usize {\n    type Output = T;\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&T> {\n        if self < slice.len() {\n            unsafe {\n                Some(self.get_unchecked(slice))\n            }\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n        if self < slice.len() {\n            unsafe {\n                Some(self.get_unchecked_mut(slice))\n            }\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &T {\n        &*slice.as_ptr().offset(self as isize)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {\n        &mut *slice.as_mut_ptr().offset(self as isize)\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &T {\n        // NB: use intrinsic indexing\n        &(*slice)[self]\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut T {\n        // NB: use intrinsic indexing\n        &mut (*slice)[self]\n    }\n}\n\n#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for  ops::Range<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        if self.start > self.end || self.end > slice.len() {\n            None\n        } else {\n            unsafe {\n                Some(self.get_unchecked(slice))\n            }\n        }\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        if self.start > self.end || self.end > slice.len() {\n            None\n        } else {\n            unsafe {\n                Some(self.get_unchecked_mut(slice))\n            }\n        }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n        from_raw_parts(slice.as_ptr().offset(self.start as isize), self.end - self.start)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n        from_raw_parts_mut(slice.as_mut_ptr().offset(self.start as isize), self.end - self.start)\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        if self.start > self.end {\n            slice_index_order_fail(self.start, self.end);\n        } else if self.end > slice.len() {\n            slice_index_len_fail(self.end, slice.len());\n        }\n        unsafe {\n            self.get_unchecked(slice)\n        }\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        if self.start > self.end {\n            slice_index_order_fail(self.start, self.end);\n        } else if self.end > slice.len() {\n            slice_index_len_fail(self.end, slice.len());\n        }\n        unsafe {\n            self.get_unchecked_mut(slice)\n        }\n    }\n}\n\n#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        (0..self.end).get(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        (0..self.end).get_mut(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n        (0..self.end).get_unchecked(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n        (0..self.end).get_unchecked_mut(slice)\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        (0..self.end).index(slice)\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        (0..self.end).index_mut(slice)\n    }\n}\n\n#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        (self.start..slice.len()).get(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        (self.start..slice.len()).get_mut(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n        (self.start..slice.len()).get_unchecked(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n        (self.start..slice.len()).get_unchecked_mut(slice)\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        (self.start..slice.len()).index(slice)\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        (self.start..slice.len()).index_mut(slice)\n    }\n}\n\n#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for ops::RangeFull {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        Some(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        Some(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n        slice\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n        slice\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        slice\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        slice\n    }\n}\n\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        if self.end == usize::max_value() { None }\n        else { (self.start..self.end + 1).get(slice) }\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        if self.end == usize::max_value() { None }\n        else { (self.start..self.end + 1).get_mut(slice) }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n        (self.start..self.end + 1).get_unchecked(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n        (self.start..self.end + 1).get_unchecked_mut(slice)\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        assert!(self.end != usize::max_value(),\n            \"attempted to index slice up to maximum usize\");\n        (self.start..self.end + 1).index(slice)\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        assert!(self.end != usize::max_value(),\n            \"attempted to index slice up to maximum usize\");\n        (self.start..self.end + 1).index_mut(slice)\n    }\n}\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        (0...self.end).get(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        (0...self.end).get_mut(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n        (0...self.end).get_unchecked(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n        (0...self.end).get_unchecked_mut(slice)\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        (0...self.end).index(slice)\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        (0...self.end).index_mut(slice)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Common traits\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Default for &'a [T] {\n    /// Creates an empty slice.\n    fn default() -> &'a [T] { &[] }\n}\n\n#[stable(feature = \"mut_slice_default\", since = \"1.5.0\")]\nimpl<'a, T> Default for &'a mut [T] {\n    /// Creates a mutable empty slice.\n    fn default() -> &'a mut [T] { &mut [] }\n}\n\n//\n// Iterators\n//\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a [T] {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a mut [T] {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n        self.iter_mut()\n    }\n}\n\n#[inline(always)]\nfn size_from_ptr<T>(_: *const T) -> usize {\n    mem::size_of::<T>()\n}\n\n// The shared definition of the `Iter` and `IterMut` iterators\nmacro_rules! iterator {\n    (struct $name:ident -> $ptr:ty, $elem:ty, $mkref:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n                unsafe {\n                    if mem::size_of::<T>() != 0 {\n                        assume(!self.ptr.is_null());\n                        assume(!self.end.is_null());\n                    }\n                    if self.ptr == self.end {\n                        None\n                    } else {\n                        Some($mkref!(self.ptr.post_inc()))\n                    }\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = ptrdistance(self.ptr, self.end);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                self.len()\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                // Call helper method. Can't put the definition here because mut versus const.\n                self.iter_nth(n)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            fn all<F>(&mut self, mut predicate: F) -> bool\n                where F: FnMut(Self::Item) -> bool,\n            {\n                self.search_while(true, move |elt| {\n                    if predicate(elt) {\n                        SearchWhile::Continue\n                    } else {\n                        SearchWhile::Done(false)\n                    }\n                })\n            }\n\n            fn any<F>(&mut self, mut predicate: F) -> bool\n                where F: FnMut(Self::Item) -> bool,\n            {\n                !self.all(move |elt| !predicate(elt))\n            }\n\n            fn find<F>(&mut self, mut predicate: F) -> Option<Self::Item>\n                where F: FnMut(&Self::Item) -> bool,\n            {\n                self.search_while(None, move |elt| {\n                    if predicate(&elt) {\n                        SearchWhile::Done(Some(elt))\n                    } else {\n                        SearchWhile::Continue\n                    }\n                })\n            }\n\n            fn position<F>(&mut self, mut predicate: F) -> Option<usize>\n                where F: FnMut(Self::Item) -> bool,\n            {\n                let mut index = 0;\n                self.search_while(None, move |elt| {\n                    if predicate(elt) {\n                        SearchWhile::Done(Some(index))\n                    } else {\n                        index += 1;\n                        SearchWhile::Continue\n                    }\n                })\n            }\n\n            fn rposition<F>(&mut self, mut predicate: F) -> Option<usize>\n                where F: FnMut(Self::Item) -> bool,\n            {\n                let mut index = self.len();\n                self.rsearch_while(None, move |elt| {\n                    index -= 1;\n                    if predicate(elt) {\n                        SearchWhile::Done(Some(index))\n                    } else {\n                        SearchWhile::Continue\n                    }\n                })\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n                unsafe {\n                    if mem::size_of::<T>() != 0 {\n                        assume(!self.ptr.is_null());\n                        assume(!self.end.is_null());\n                    }\n                    if self.end == self.ptr {\n                        None\n                    } else {\n                        Some($mkref!(self.end.pre_dec()))\n                    }\n                }\n            }\n\n            fn rfind<F>(&mut self, mut predicate: F) -> Option<Self::Item>\n                where F: FnMut(&Self::Item) -> bool,\n            {\n                self.rsearch_while(None, move |elt| {\n                    if predicate(&elt) {\n                        SearchWhile::Done(Some(elt))\n                    } else {\n                        SearchWhile::Continue\n                    }\n                })\n            }\n\n        }\n\n        // search_while is a generalization of the internal iteration methods.\n        impl<'a, T> $name<'a, T> {\n            // search through the iterator's element using the closure `g`.\n            // if no element was found, return `default`.\n            fn search_while<Acc, G>(&mut self, default: Acc, mut g: G) -> Acc\n                where Self: Sized,\n                      G: FnMut($elem) -> SearchWhile<Acc>\n            {\n                // manual unrolling is needed when there are conditional exits from the loop\n                unsafe {\n                    while ptrdistance(self.ptr, self.end) >= 4 {\n                        search_while!(g($mkref!(self.ptr.post_inc())));\n                        search_while!(g($mkref!(self.ptr.post_inc())));\n                        search_while!(g($mkref!(self.ptr.post_inc())));\n                        search_while!(g($mkref!(self.ptr.post_inc())));\n                    }\n                    while self.ptr != self.end {\n                        search_while!(g($mkref!(self.ptr.post_inc())));\n                    }\n                }\n                default\n            }\n\n            fn rsearch_while<Acc, G>(&mut self, default: Acc, mut g: G) -> Acc\n                where Self: Sized,\n                      G: FnMut($elem) -> SearchWhile<Acc>\n            {\n                unsafe {\n                    while ptrdistance(self.ptr, self.end) >= 4 {\n                        search_while!(g($mkref!(self.end.pre_dec())));\n                        search_while!(g($mkref!(self.end.pre_dec())));\n                        search_while!(g($mkref!(self.end.pre_dec())));\n                        search_while!(g($mkref!(self.end.pre_dec())));\n                    }\n                    while self.ptr != self.end {\n                        search_while!(g($mkref!(self.end.pre_dec())));\n                    }\n                }\n                default\n            }\n        }\n    }\n}\n\nmacro_rules! make_slice {\n    ($start: expr, $end: expr) => {{\n        let start = $start;\n        let diff = ($end as usize).wrapping_sub(start as usize);\n        if size_from_ptr(start) == 0 {\n            // use a non-null pointer value\n            unsafe { from_raw_parts(1 as *const _, diff) }\n        } else {\n            let len = diff / size_from_ptr(start);\n            unsafe { from_raw_parts(start, len) }\n        }\n    }}\n}\n\nmacro_rules! make_mut_slice {\n    ($start: expr, $end: expr) => {{\n        let start = $start;\n        let diff = ($end as usize).wrapping_sub(start as usize);\n        if size_from_ptr(start) == 0 {\n            // use a non-null pointer value\n            unsafe { from_raw_parts_mut(1 as *mut _, diff) }\n        } else {\n            let len = diff / size_from_ptr(start);\n            unsafe { from_raw_parts_mut(start, len) }\n        }\n    }}\n}\n\n// An enum used for controlling the execution of `.search_while()`.\nenum SearchWhile<T> {\n    // Continue searching\n    Continue,\n    // Fold is complete and will return this value\n    Done(T),\n}\n\n// helper macro for search while's control flow\nmacro_rules! search_while {\n    ($e:expr) => {\n        match $e {\n            SearchWhile::Continue => { }\n            SearchWhile::Done(done) => return done,\n        }\n    }\n}\n\n/// Immutable slice iterator\n///\n/// This struct is created by the [`iter`] method on [slices].\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // First, we declare a type which has `iter` method to get the `Iter` struct (&[usize here]):\n/// let slice = &[1, 2, 3];\n///\n/// // Then, we iterate over it:\n/// for element in slice.iter() {\n///     println!(\"{}\", element);\n/// }\n/// ```\n///\n/// [`iter`]: ../../std/primitive.slice.html#method.iter\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> {\n    ptr: *const T,\n    end: *const T,\n    _marker: marker::PhantomData<&'a T>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"Iter\")\n            .field(&self.as_slice())\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<'a, T: Sync> Send for Iter<'a, T> {}\n\nimpl<'a, T> Iter<'a, T> {\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// This has the same lifetime as the original slice, and so the\n    /// iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // First, we declare a type which has the `iter` method to get the `Iter`\n    /// // struct (&[usize here]):\n    /// let slice = &[1, 2, 3];\n    ///\n    /// // Then, we get the iterator:\n    /// let mut iter = slice.iter();\n    /// // So if we print what `as_slice` method returns here, we have \"[1, 2, 3]\":\n    /// println!(\"{:?}\", iter.as_slice());\n    ///\n    /// // Next, we move to the second element of the slice:\n    /// iter.next();\n    /// // Now `as_slice` returns \"[2, 3]\":\n    /// println!(\"{:?}\", iter.as_slice());\n    /// ```\n    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n    pub fn as_slice(&self) -> &'a [T] {\n        make_slice!(self.ptr, self.end)\n    }\n\n    // Helper function for Iter::nth\n    fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n        match self.as_slice().get(n) {\n            Some(elem_ref) => unsafe {\n                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n                Some(elem_ref)\n            },\n            None => {\n                self.ptr = self.end;\n                None\n            }\n        }\n    }\n}\n\niterator!{struct Iter -> *const T, &'a T, make_ref}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for Iter<'a, T> {\n    fn is_empty(&self) -> bool {\n        self.ptr == self.end\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for Iter<'a, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, T> TrustedLen for Iter<'a, T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Clone for Iter<'a, T> {\n    fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, _marker: self._marker } }\n}\n\n#[stable(feature = \"slice_iter_as_ref\", since = \"1.13.0\")]\nimpl<'a, T> AsRef<[T]> for Iter<'a, T> {\n    fn as_ref(&self) -> &[T] {\n        self.as_slice()\n    }\n}\n\n/// Mutable slice iterator.\n///\n/// This struct is created by the [`iter_mut`] method on [slices].\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // First, we declare a type which has `iter_mut` method to get the `IterMut`\n/// // struct (&[usize here]):\n/// let mut slice = &mut [1, 2, 3];\n///\n/// // Then, we iterate over it and increment each element value:\n/// for element in slice.iter_mut() {\n///     *element += 1;\n/// }\n///\n/// // We now have \"[2, 3, 4]\":\n/// println!(\"{:?}\", slice);\n/// ```\n///\n/// [`iter_mut`]: ../../std/primitive.slice.html#method.iter_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IterMut<'a, T: 'a> {\n    ptr: *mut T,\n    end: *mut T,\n    _marker: marker::PhantomData<&'a mut T>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug> fmt::Debug for IterMut<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"IterMut\")\n            .field(&make_slice!(self.ptr, self.end))\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<'a, T: Send> Send for IterMut<'a, T> {}\n\nimpl<'a, T> IterMut<'a, T> {\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// To avoid creating `&mut` references that alias, this is forced\n    /// to consume the iterator. Consider using the `Slice` and\n    /// `SliceMut` implementations for obtaining slices with more\n    /// restricted lifetimes that do not consume the iterator.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // First, we declare a type which has `iter_mut` method to get the `IterMut`\n    /// // struct (&[usize here]):\n    /// let mut slice = &mut [1, 2, 3];\n    ///\n    /// {\n    ///     // Then, we get the iterator:\n    ///     let mut iter = slice.iter_mut();\n    ///     // We move to next element:\n    ///     iter.next();\n    ///     // So if we print what `into_slice` method returns here, we have \"[2, 3]\":\n    ///     println!(\"{:?}\", iter.into_slice());\n    /// }\n    ///\n    /// // Now let's modify a value of the slice:\n    /// {\n    ///     // First we get back the iterator:\n    ///     let mut iter = slice.iter_mut();\n    ///     // We change the value of the first element of the slice returned by the `next` method:\n    ///     *iter.next().unwrap() += 1;\n    /// }\n    /// // Now slice is \"[2, 2, 3]\":\n    /// println!(\"{:?}\", slice);\n    /// ```\n    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n    pub fn into_slice(self) -> &'a mut [T] {\n        make_mut_slice!(self.ptr, self.end)\n    }\n\n    // Helper function for IterMut::nth\n    fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n        match make_mut_slice!(self.ptr, self.end).get_mut(n) {\n            Some(elem_ref) => unsafe {\n                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n                Some(elem_ref)\n            },\n            None => {\n                self.ptr = self.end;\n                None\n            }\n        }\n    }\n}\n\niterator!{struct IterMut -> *mut T, &'a mut T, make_ref_mut}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n    fn is_empty(&self) -> bool {\n        self.ptr == self.end\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for IterMut<'a, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, T> TrustedLen for IterMut<'a, T> {}\n\n\n// Return the number of elements of `T` from `start` to `end`.\n// Return the arithmetic difference if `T` is zero size.\n#[inline(always)]\nfn ptrdistance<T>(start: *const T, end: *const T) -> usize {\n    match start.offset_to(end) {\n        Some(x) => x as usize,\n        None => (end as usize).wrapping_sub(start as usize),\n    }\n}\n\n// Extension methods for raw pointers, used by the iterators\ntrait PointerExt : Copy {\n    unsafe fn slice_offset(self, i: isize) -> Self;\n\n    /// Increments `self` by 1, but returns the old value.\n    #[inline(always)]\n    unsafe fn post_inc(&mut self) -> Self {\n        let current = *self;\n        *self = self.slice_offset(1);\n        current\n    }\n\n    /// Decrements `self` by 1, and returns the new value.\n    #[inline(always)]\n    unsafe fn pre_dec(&mut self) -> Self {\n        *self = self.slice_offset(-1);\n        *self\n    }\n}\n\nimpl<T> PointerExt for *const T {\n    #[inline(always)]\n    unsafe fn slice_offset(self, i: isize) -> Self {\n        slice_offset!(self, i)\n    }\n}\n\nimpl<T> PointerExt for *mut T {\n    #[inline(always)]\n    unsafe fn slice_offset(self, i: isize) -> Self {\n        slice_offset!(self, i)\n    }\n}\n\n/// An internal abstraction over the splitting iterators, so that\n/// splitn, splitn_mut etc can be implemented once.\n#[doc(hidden)]\ntrait SplitIter: DoubleEndedIterator {\n    /// Marks the underlying iterator as complete, extracting the remaining\n    /// portion of the slice.\n    fn finish(&mut self) -> Option<Self::Item>;\n}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function.\n///\n/// This struct is created by the [`split`] method on [slices].\n///\n/// [`split`]: ../../std/primitive.slice.html#method.split\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool {\n    v: &'a [T],\n    pred: P,\n    finished: bool\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for Split<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Split\")\n            .field(\"v\", &self.v)\n            .field(\"finished\", &self.finished)\n            .finish()\n    }\n}\n\n// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n    fn clone(&self) -> Split<'a, T, P> {\n        Split {\n            v: self.v,\n            pred: self.pred.clone(),\n            finished: self.finished,\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.finished { return None; }\n\n        match self.v.iter().position(|x| (self.pred)(x)) {\n            None => self.finish(),\n            Some(idx) => {\n                let ret = Some(&self.v[..idx]);\n                self.v = &self.v[idx + 1..];\n                ret\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.finished {\n            (0, Some(0))\n        } else {\n            (1, Some(self.v.len() + 1))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.finished { return None; }\n\n        match self.v.iter().rposition(|x| (self.pred)(x)) {\n            None => self.finish(),\n            Some(idx) => {\n                let ret = Some(&self.v[idx + 1..]);\n                self.v = &self.v[..idx];\n                ret\n            }\n        }\n    }\n}\n\nimpl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool {\n    #[inline]\n    fn finish(&mut self) -> Option<&'a [T]> {\n        if self.finished { None } else { self.finished = true; Some(self.v) }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T, P> FusedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over the subslices of the vector which are separated\n/// by elements that match `pred`.\n///\n/// This struct is created by the [`split_mut`] method on [slices].\n///\n/// [`split_mut`]: ../../std/primitive.slice.html#method.split_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n    v: &'a mut [T],\n    pred: P,\n    finished: bool\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"SplitMut\")\n            .field(\"v\", &self.v)\n            .field(\"finished\", &self.finished)\n            .finish()\n    }\n}\n\nimpl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n    #[inline]\n    fn finish(&mut self) -> Option<&'a mut [T]> {\n        if self.finished {\n            None\n        } else {\n            self.finished = true;\n            Some(mem::replace(&mut self.v, &mut []))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        if self.finished { return None; }\n\n        let idx_opt = { // work around borrowck limitations\n            let pred = &mut self.pred;\n            self.v.iter().position(|x| (*pred)(x))\n        };\n        match idx_opt {\n            None => self.finish(),\n            Some(idx) => {\n                let tmp = mem::replace(&mut self.v, &mut []);\n                let (head, tail) = tmp.split_at_mut(idx);\n                self.v = &mut tail[1..];\n                Some(head)\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.finished {\n            (0, Some(0))\n        } else {\n            // if the predicate doesn't match anything, we yield one slice\n            // if it matches every element, we yield len+1 empty slices.\n            (1, Some(self.v.len() + 1))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        if self.finished { return None; }\n\n        let idx_opt = { // work around borrowck limitations\n            let pred = &mut self.pred;\n            self.v.iter().rposition(|x| (*pred)(x))\n        };\n        match idx_opt {\n            None => self.finish(),\n            Some(idx) => {\n                let tmp = mem::replace(&mut self.v, &mut []);\n                let (head, tail) = tmp.split_at_mut(idx);\n                self.v = head;\n                Some(&mut tail[1..])\n            }\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T, P> FusedIterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function, starting from the end of the slice.\n///\n/// This struct is created by the [`rsplit`] method on [slices].\n///\n/// [`rsplit`]: ../../std/primitive.slice.html#method.rsplit\n/// [slices]: ../../std/primitive.slice.html\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n#[derive(Clone)] // Is this correct, or does it incorrectly require `T: Clone`?\npub struct RSplit<'a, T:'a, P> where P: FnMut(&T) -> bool {\n    inner: Split<'a, T, P>\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"RSplit\")\n            .field(\"v\", &self.inner.v)\n            .field(\"finished\", &self.inner.finished)\n            .finish()\n    }\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> Iterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        self.inner.next_back()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> DoubleEndedIterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        self.inner.next()\n    }\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> SplitIter for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n    #[inline]\n    fn finish(&mut self) -> Option<&'a [T]> {\n        self.inner.finish()\n    }\n}\n\n//#[unstable(feature = \"fused\", issue = \"35602\")]\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> FusedIterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over the subslices of the vector which are separated\n/// by elements that match `pred`, starting from the end of the slice.\n///\n/// This struct is created by the [`rsplit_mut`] method on [slices].\n///\n/// [`rsplit_mut`]: ../../std/primitive.slice.html#method.rsplit_mut\n/// [slices]: ../../std/primitive.slice.html\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\npub struct RSplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n    inner: SplitMut<'a, T, P>\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"RSplitMut\")\n            .field(\"v\", &self.inner.v)\n            .field(\"finished\", &self.inner.finished)\n            .finish()\n    }\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> SplitIter for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n    #[inline]\n    fn finish(&mut self) -> Option<&'a mut [T]> {\n        self.inner.finish()\n    }\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> Iterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        self.inner.next_back()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> DoubleEndedIterator for RSplitMut<'a, T, P> where\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        self.inner.next()\n    }\n}\n\n//#[unstable(feature = \"fused\", issue = \"35602\")]\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> FusedIterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n\n/// An private iterator over subslices separated by elements that\n/// match a predicate function, splitting at most a fixed number of\n/// times.\n#[derive(Debug)]\nstruct GenericSplitN<I> {\n    iter: I,\n    count: usize,\n}\n\nimpl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        match self.count {\n            0 => None,\n            1 => { self.count -= 1; self.iter.finish() }\n            _ => { self.count -= 1; self.iter.next() }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (lower, upper_opt) = self.iter.size_hint();\n        (lower, upper_opt.map(|upper| cmp::min(self.count, upper)))\n    }\n}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function, limited to a given number of splits.\n///\n/// This struct is created by the [`splitn`] method on [slices].\n///\n/// [`splitn`]: ../../std/primitive.slice.html#method.splitn\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n    inner: GenericSplitN<Split<'a, T, P>>\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitN<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"SplitN\")\n            .field(\"inner\", &self.inner)\n            .finish()\n    }\n}\n\n/// An iterator over subslices separated by elements that match a\n/// predicate function, limited to a given number of splits, starting\n/// from the end of the slice.\n///\n/// This struct is created by the [`rsplitn`] method on [slices].\n///\n/// [`rsplitn`]: ../../std/primitive.slice.html#method.rsplitn\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n    inner: GenericSplitN<RSplit<'a, T, P>>\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplitN<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"RSplitN\")\n            .field(\"inner\", &self.inner)\n            .finish()\n    }\n}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function, limited to a given number of splits.\n///\n/// This struct is created by the [`splitn_mut`] method on [slices].\n///\n/// [`splitn_mut`]: ../../std/primitive.slice.html#method.splitn_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n    inner: GenericSplitN<SplitMut<'a, T, P>>\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitNMut<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"SplitNMut\")\n            .field(\"inner\", &self.inner)\n            .finish()\n    }\n}\n\n/// An iterator over subslices separated by elements that match a\n/// predicate function, limited to a given number of splits, starting\n/// from the end of the slice.\n///\n/// This struct is created by the [`rsplitn_mut`] method on [slices].\n///\n/// [`rsplitn_mut`]: ../../std/primitive.slice.html#method.rsplitn_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n    inner: GenericSplitN<RSplitMut<'a, T, P>>\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplitNMut<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"RSplitNMut\")\n            .field(\"inner\", &self.inner)\n            .finish()\n    }\n}\n\nmacro_rules! forward_iterator {\n    ($name:ident: $elem:ident, $iter_of:ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, $elem, P> Iterator for $name<'a, $elem, P> where\n            P: FnMut(&T) -> bool\n        {\n            type Item = $iter_of;\n\n            #[inline]\n            fn next(&mut self) -> Option<$iter_of> {\n                self.inner.next()\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.inner.size_hint()\n            }\n        }\n\n        #[unstable(feature = \"fused\", issue = \"35602\")]\n        impl<'a, $elem, P> FusedIterator for $name<'a, $elem, P>\n            where P: FnMut(&T) -> bool {}\n    }\n}\n\nforward_iterator! { SplitN: T, &'a [T] }\nforward_iterator! { RSplitN: T, &'a [T] }\nforward_iterator! { SplitNMut: T, &'a mut [T] }\nforward_iterator! { RSplitNMut: T, &'a mut [T] }\n\n/// An iterator over overlapping subslices of length `size`.\n///\n/// This struct is created by the [`windows`] method on [slices].\n///\n/// [`windows`]: ../../std/primitive.slice.html#method.windows\n/// [slices]: ../../std/primitive.slice.html\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Windows<'a, T:'a> {\n    v: &'a [T],\n    size: usize\n}\n\n// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Clone for Windows<'a, T> {\n    fn clone(&self) -> Windows<'a, T> {\n        Windows {\n            v: self.v,\n            size: self.size,\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Windows<'a, T> {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.size > self.v.len() {\n            None\n        } else {\n            let ret = Some(&self.v[..self.size]);\n            self.v = &self.v[1..];\n            ret\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.size > self.v.len() {\n            (0, Some(0))\n        } else {\n            let size = self.v.len() - self.size + 1;\n            (size, Some(size))\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        let (end, overflow) = self.size.overflowing_add(n);\n        if end > self.v.len() || overflow {\n            self.v = &[];\n            None\n        } else {\n            let nth = &self.v[n..end];\n            self.v = &self.v[n+1..];\n            Some(nth)\n        }\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        if self.size > self.v.len() {\n            None\n        } else {\n            let start = self.v.len() - self.size;\n            Some(&self.v[start..])\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.size > self.v.len() {\n            None\n        } else {\n            let ret = Some(&self.v[self.v.len()-self.size..]);\n            self.v = &self.v[..self.v.len()-1];\n            ret\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for Windows<'a, T> {}\n\n/// An iterator over a slice in (non-overlapping) chunks (`size` elements at a\n/// time).\n///\n/// When the slice len is not evenly divided by the chunk size, the last slice\n/// of the iteration will be the remainder.\n///\n/// This struct is created by the [`chunks`] method on [slices].\n///\n/// [`chunks`]: ../../std/primitive.slice.html#method.chunks\n/// [slices]: ../../std/primitive.slice.html\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Chunks<'a, T:'a> {\n    v: &'a [T],\n    size: usize\n}\n\n// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Clone for Chunks<'a, T> {\n    fn clone(&self) -> Chunks<'a, T> {\n        Chunks {\n            v: self.v,\n            size: self.size,\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Chunks<'a, T> {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let chunksz = cmp::min(self.v.len(), self.size);\n            let (fst, snd) = self.v.split_at(chunksz);\n            self.v = snd;\n            Some(fst)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.v.is_empty() {\n            (0, Some(0))\n        } else {\n            let n = self.v.len() / self.size;\n            let rem = self.v.len() % self.size;\n            let n = if rem > 0 { n+1 } else { n };\n            (n, Some(n))\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        let (start, overflow) = n.overflowing_mul(self.size);\n        if start >= self.v.len() || overflow {\n            self.v = &[];\n            None\n        } else {\n            let end = match start.checked_add(self.size) {\n                Some(sum) => cmp::min(self.v.len(), sum),\n                None => self.v.len(),\n            };\n            let nth = &self.v[start..end];\n            self.v = &self.v[end..];\n            Some(nth)\n        }\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let start = (self.v.len() - 1) / self.size * self.size;\n            Some(&self.v[start..])\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let remainder = self.v.len() % self.size;\n            let chunksz = if remainder != 0 { remainder } else { self.size };\n            let (fst, snd) = self.v.split_at(self.v.len() - chunksz);\n            self.v = fst;\n            Some(snd)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for Chunks<'a, T> {}\n\n/// An iterator over a slice in (non-overlapping) mutable chunks (`size`\n/// elements at a time). When the slice len is not evenly divided by the chunk\n/// size, the last slice of the iteration will be the remainder.\n///\n/// This struct is created by the [`chunks_mut`] method on [slices].\n///\n/// [`chunks_mut`]: ../../std/primitive.slice.html#method.chunks_mut\n/// [slices]: ../../std/primitive.slice.html\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ChunksMut<'a, T:'a> {\n    v: &'a mut [T],\n    chunk_size: usize\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for ChunksMut<'a, T> {\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let sz = cmp::min(self.v.len(), self.chunk_size);\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(sz);\n            self.v = tail;\n            Some(head)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.v.is_empty() {\n            (0, Some(0))\n        } else {\n            let n = self.v.len() / self.chunk_size;\n            let rem = self.v.len() % self.chunk_size;\n            let n = if rem > 0 { n + 1 } else { n };\n            (n, Some(n))\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n        if start >= self.v.len() || overflow {\n            self.v = &mut [];\n            None\n        } else {\n            let end = match start.checked_add(self.chunk_size) {\n                Some(sum) => cmp::min(self.v.len(), sum),\n                None => self.v.len(),\n            };\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(end);\n            let (_, nth) =  head.split_at_mut(start);\n            self.v = tail;\n            Some(nth)\n        }\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n            Some(&mut self.v[start..])\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let remainder = self.v.len() % self.chunk_size;\n            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let tmp_len = tmp.len();\n            let (head, tail) = tmp.split_at_mut(tmp_len - sz);\n            self.v = head;\n            Some(tail)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for ChunksMut<'a, T> {}\n\n//\n// Free functions\n//\n\n/// Forms a slice from a pointer and a length.\n///\n/// The `len` argument is the number of **elements**, not the number of bytes.\n///\n/// # Safety\n///\n/// This function is unsafe as there is no guarantee that the given pointer is\n/// valid for `len` elements, nor whether the lifetime inferred is a suitable\n/// lifetime for the returned slice.\n///\n/// `p` must be non-null, even for zero-length slices, because non-zero bits\n/// are required to distinguish between a zero-length slice within `Some()`\n/// from `None`. `p` can be a bogus non-dereferencable pointer, such as `0x1`,\n/// for zero-length slices, though.\n///\n/// # Caveat\n///\n/// The lifetime for the returned slice is inferred from its usage. To\n/// prevent accidental misuse, it's suggested to tie the lifetime to whichever\n/// source lifetime is safe in the context, such as by providing a helper\n/// function taking the lifetime of a host value for the slice, or by explicit\n/// annotation.\n///\n/// # Examples\n///\n/// ```\n/// use std::slice;\n///\n/// // manifest a slice out of thin air!\n/// let ptr = 0x1234 as *const usize;\n/// let amt = 10;\n/// unsafe {\n///     let slice = slice::from_raw_parts(ptr, amt);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn from_raw_parts<'a, T>(p: *const T, len: usize) -> &'a [T] {\n    mem::transmute(Repr { data: p, len: len })\n}\n\n/// Performs the same functionality as `from_raw_parts`, except that a mutable\n/// slice is returned.\n///\n/// This function is unsafe for the same reasons as `from_raw_parts`, as well\n/// as not being able to provide a non-aliasing guarantee of the returned\n/// mutable slice. `p` must be non-null even for zero-length slices as with\n/// `from_raw_parts`.\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n    mem::transmute(Repr { data: p, len: len })\n}\n\n// This function is public only because there is no other way to unit test heapsort.\n#[unstable(feature = \"sort_internals\", reason = \"internal to sort module\", issue = \"0\")]\n#[doc(hidden)]\npub fn heapsort<T, F>(v: &mut [T], mut is_less: F)\n    where F: FnMut(&T, &T) -> bool\n{\n    sort::heapsort(v, &mut is_less);\n}\n\n//\n// Comparison traits\n//\n\nextern {\n    /// Calls implementation provided memcmp.\n    ///\n    /// Interprets the data as u8.\n    ///\n    /// Returns 0 for equal, < 0 for less than and > 0 for greater\n    /// than.\n    // FIXME(#32610): Return type should be c_int\n    fn memcmp(s1: *const u8, s2: *const u8, n: usize) -> i32;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n    fn eq(&self, other: &[B]) -> bool {\n        SlicePartialEq::equal(self, other)\n    }\n\n    fn ne(&self, other: &[B]) -> bool {\n        SlicePartialEq::not_equal(self, other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Eq> Eq for [T] {}\n\n/// Implements comparison of vectors lexicographically.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord> Ord for [T] {\n    fn cmp(&self, other: &[T]) -> Ordering {\n        SliceOrd::compare(self, other)\n    }\n}\n\n/// Implements comparison of vectors lexicographically.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: PartialOrd> PartialOrd for [T] {\n    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n        SlicePartialOrd::partial_compare(self, other)\n    }\n}\n\n#[doc(hidden)]\n// intermediate trait for specialization of slice's PartialEq\ntrait SlicePartialEq<B> {\n    fn equal(&self, other: &[B]) -> bool;\n\n    fn not_equal(&self, other: &[B]) -> bool { !self.equal(other) }\n}\n\n// Generic slice equality\nimpl<A, B> SlicePartialEq<B> for [A]\n    where A: PartialEq<B>\n{\n    default fn equal(&self, other: &[B]) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        for i in 0..self.len() {\n            if !self[i].eq(&other[i]) {\n                return false;\n            }\n        }\n\n        true\n    }\n}\n\n// Use memcmp for bytewise equality when the types allow\nimpl<A> SlicePartialEq<A> for [A]\n    where A: PartialEq<A> + BytewiseEquality\n{\n    fn equal(&self, other: &[A]) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n        if self.as_ptr() == other.as_ptr() {\n            return true;\n        }\n        unsafe {\n            let size = mem::size_of_val(self);\n            memcmp(self.as_ptr() as *const u8,\n                   other.as_ptr() as *const u8, size) == 0\n        }\n    }\n}\n\n#[doc(hidden)]\n// intermediate trait for specialization of slice's PartialOrd\ntrait SlicePartialOrd<B> {\n    fn partial_compare(&self, other: &[B]) -> Option<Ordering>;\n}\n\nimpl<A> SlicePartialOrd<A> for [A]\n    where A: PartialOrd\n{\n    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n        let l = cmp::min(self.len(), other.len());\n\n        // Slice to the loop iteration range to enable bound check\n        // elimination in the compiler\n        let lhs = &self[..l];\n        let rhs = &other[..l];\n\n        for i in 0..l {\n            match lhs[i].partial_cmp(&rhs[i]) {\n                Some(Ordering::Equal) => (),\n                non_eq => return non_eq,\n            }\n        }\n\n        self.len().partial_cmp(&other.len())\n    }\n}\n\nimpl<A> SlicePartialOrd<A> for [A]\n    where A: Ord\n{\n    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n        Some(SliceOrd::compare(self, other))\n    }\n}\n\n#[doc(hidden)]\n// intermediate trait for specialization of slice's Ord\ntrait SliceOrd<B> {\n    fn compare(&self, other: &[B]) -> Ordering;\n}\n\nimpl<A> SliceOrd<A> for [A]\n    where A: Ord\n{\n    default fn compare(&self, other: &[A]) -> Ordering {\n        let l = cmp::min(self.len(), other.len());\n\n        // Slice to the loop iteration range to enable bound check\n        // elimination in the compiler\n        let lhs = &self[..l];\n        let rhs = &other[..l];\n\n        for i in 0..l {\n            match lhs[i].cmp(&rhs[i]) {\n                Ordering::Equal => (),\n                non_eq => return non_eq,\n            }\n        }\n\n        self.len().cmp(&other.len())\n    }\n}\n\n// memcmp compares a sequence of unsigned bytes lexicographically.\n// this matches the order we want for [u8], but no others (not even [i8]).\nimpl SliceOrd<u8> for [u8] {\n    #[inline]\n    fn compare(&self, other: &[u8]) -> Ordering {\n        let order = unsafe {\n            memcmp(self.as_ptr(), other.as_ptr(),\n                   cmp::min(self.len(), other.len()))\n        };\n        if order == 0 {\n            self.len().cmp(&other.len())\n        } else if order < 0 {\n            Less\n        } else {\n            Greater\n        }\n    }\n}\n\n#[doc(hidden)]\n/// Trait implemented for types that can be compared for equality using\n/// their bytewise representation\ntrait BytewiseEquality { }\n\nmacro_rules! impl_marker_for {\n    ($traitname:ident, $($ty:ty)*) => {\n        $(\n            impl $traitname for $ty { }\n        )*\n    }\n}\n\nimpl_marker_for!(BytewiseEquality,\n                 u8 i8 u16 i16 u32 i32 u64 i64 usize isize char bool);\n\n#[doc(hidden)]\nunsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n        &*self.ptr.offset(i as isize)\n    }\n    fn may_have_side_effect() -> bool { false }\n}\n\n#[doc(hidden)]\nunsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n        &mut *self.ptr.offset(i as isize)\n    }\n    fn may_have_side_effect() -> bool { false }\n}\n","// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! This module implements the `Any` trait, which enables dynamic typing\n//! of any `'static` type through runtime reflection.\n//!\n//! `Any` itself can be used to get a `TypeId`, and has more features when used\n//! as a trait object. As `&Any` (a borrowed trait object), it has the `is` and\n//! `downcast_ref` methods, to test if the contained value is of a given type,\n//! and to get a reference to the inner value as a type. As `&mut Any`, there\n//! is also the `downcast_mut` method, for getting a mutable reference to the\n//! inner value. `Box<Any>` adds the `downcast` method, which attempts to\n//! convert to a `Box<T>`. See the [`Box`] documentation for the full details.\n//!\n//! Note that &Any is limited to testing whether a value is of a specified\n//! concrete type, and cannot be used to test whether a type implements a trait.\n//!\n//! [`Box`]: ../../std/boxed/struct.Box.html\n//!\n//! # Examples\n//!\n//! Consider a situation where we want to log out a value passed to a function.\n//! We know the value we're working on implements Debug, but we don't know its\n//! concrete type.  We want to give special treatment to certain types: in this\n//! case printing out the length of String values prior to their value.\n//! We don't know the concrete type of our value at compile time, so we need to\n//! use runtime reflection instead.\n//!\n//! ```rust\n//! use std::fmt::Debug;\n//! use std::any::Any;\n//!\n//! // Logger function for any type that implements Debug.\n//! fn log<T: Any + Debug>(value: &T) {\n//!     let value_any = value as &Any;\n//!\n//!     // try to convert our value to a String.  If successful, we want to\n//!     // output the String's length as well as its value.  If not, it's a\n//!     // different type: just print it out unadorned.\n//!     match value_any.downcast_ref::<String>() {\n//!         Some(as_string) => {\n//!             println!(\"String ({}): {}\", as_string.len(), as_string);\n//!         }\n//!         None => {\n//!             println!(\"{:?}\", value);\n//!         }\n//!     }\n//! }\n//!\n//! // This function wants to log its parameter out prior to doing work with it.\n//! fn do_work<T: Any + Debug>(value: &T) {\n//!     log(value);\n//!     // ...do some other work\n//! }\n//!\n//! fn main() {\n//!     let my_string = \"Hello World\".to_string();\n//!     do_work(&my_string);\n//!\n//!     let my_i8: i8 = 100;\n//!     do_work(&my_i8);\n//! }\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse fmt;\nuse intrinsics;\n\n///////////////////////////////////////////////////////////////////////////////\n// Any trait\n///////////////////////////////////////////////////////////////////////////////\n\n/// A type to emulate dynamic typing.\n///\n/// Most types implement `Any`. However, any type which contains a non-`'static` reference does not.\n/// See the [module-level documentation][mod] for more details.\n///\n/// [mod]: index.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Any: 'static {\n    /// Gets the `TypeId` of `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(get_type_id)]\n    ///\n    /// use std::any::{Any, TypeId};\n    ///\n    /// fn is_string(s: &Any) -> bool {\n    ///     TypeId::of::<String>() == s.get_type_id()\n    /// }\n    ///\n    /// fn main() {\n    ///     assert_eq!(is_string(&0), false);\n    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n    /// }\n    /// ```\n    #[unstable(feature = \"get_type_id\",\n               reason = \"this method will likely be replaced by an associated static\",\n               issue = \"27745\")]\n    fn get_type_id(&self) -> TypeId;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: 'static + ?Sized > Any for T {\n    fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Extension methods for Any trait objects.\n///////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Any {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"Any\")\n    }\n}\n\n// Ensure that the result of e.g. joining a thread can be printed and\n// hence used with `unwrap`. May eventually no longer be needed if\n// dispatch works with upcasting.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Any + Send {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"Any\")\n    }\n}\n\nimpl Any {\n    /// Returns `true` if the boxed type is the same as `T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn is_string(s: &Any) {\n    ///     if s.is::<String>() {\n    ///         println!(\"It's a string!\");\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     is_string(&0);\n    ///     is_string(&\"cookie monster\".to_string());\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is<T: Any>(&self) -> bool {\n        // Get TypeId of the type this function is instantiated with\n        let t = TypeId::of::<T>();\n\n        // Get TypeId of the type in the trait object\n        let boxed = self.get_type_id();\n\n        // Compare both TypeIds on equality\n        t == boxed\n    }\n\n    /// Returns some reference to the boxed value if it is of type `T`, or\n    /// `None` if it isn't.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(s: &Any) {\n    ///     if let Some(string) = s.downcast_ref::<String>() {\n    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     print_if_string(&0);\n    ///     print_if_string(&\"cookie monster\".to_string());\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n        if self.is::<T>() {\n            unsafe {\n                Some(&*(self as *const Any as *const T))\n            }\n        } else {\n            None\n        }\n    }\n\n    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n    /// `None` if it isn't.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn modify_if_u32(s: &mut Any) {\n    ///     if let Some(num) = s.downcast_mut::<u32>() {\n    ///         *num = 42;\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     let mut x = 10u32;\n    ///     let mut s = \"starlord\".to_string();\n    ///\n    ///     modify_if_u32(&mut x);\n    ///     modify_if_u32(&mut s);\n    ///\n    ///     assert_eq!(x, 42);\n    ///     assert_eq!(&s, \"starlord\");\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n        if self.is::<T>() {\n            unsafe {\n                Some(&mut *(self as *mut Any as *mut T))\n            }\n        } else {\n            None\n        }\n    }\n}\n\nimpl Any+Send {\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn is_string(s: &(Any + Send)) {\n    ///     if s.is::<String>() {\n    ///         println!(\"It's a string!\");\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     is_string(&0);\n    ///     is_string(&\"cookie monster\".to_string());\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is<T: Any>(&self) -> bool {\n        Any::is::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(s: &(Any + Send)) {\n    ///     if let Some(string) = s.downcast_ref::<String>() {\n    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     print_if_string(&0);\n    ///     print_if_string(&\"cookie monster\".to_string());\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n        Any::downcast_ref::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn modify_if_u32(s: &mut (Any+ Send)) {\n    ///     if let Some(num) = s.downcast_mut::<u32>() {\n    ///         *num = 42;\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     let mut x = 10u32;\n    ///     let mut s = \"starlord\".to_string();\n    ///\n    ///     modify_if_u32(&mut x);\n    ///     modify_if_u32(&mut s);\n    ///\n    ///     assert_eq!(x, 42);\n    ///     assert_eq!(&s, \"starlord\");\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n        Any::downcast_mut::<T>(self)\n    }\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n// TypeID and its methods\n///////////////////////////////////////////////////////////////////////////////\n\n/// A `TypeId` represents a globally unique identifier for a type.\n///\n/// Each `TypeId` is an opaque object which does not allow inspection of what's\n/// inside but does allow basic operations such as cloning, comparison,\n/// printing, and showing.\n///\n/// A `TypeId` is currently only available for types which ascribe to `'static`,\n/// but this limitation may be removed in the future.\n///\n/// While `TypeId` implements `Hash`, `PartialOrd`, and `Ord`, it is worth\n/// noting that the hashes and ordering will vary between Rust releases. Beware\n/// of relying on them outside of your code!\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct TypeId {\n    t: u64,\n}\n\nimpl TypeId {\n    /// Returns the `TypeId` of the type this generic function has been\n    /// instantiated with.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::{Any, TypeId};\n    ///\n    /// fn is_string<T: ?Sized + Any>(_s: &T) -> bool {\n    ///     TypeId::of::<String>() == TypeId::of::<T>()\n    /// }\n    ///\n    /// fn main() {\n    ///     assert_eq!(is_string(&0), false);\n    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn of<T: ?Sized + 'static>() -> TypeId {\n        TypeId {\n            t: unsafe { intrinsics::type_id::<T>() },\n        }\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![allow(dead_code)] // stack_guard isn't used right now on all platforms\n\nuse cell::RefCell;\nuse thread::Thread;\nuse thread::LocalKeyState;\n\nstruct ThreadInfo {\n    stack_guard: Option<usize>,\n    thread: Thread,\n}\n\nthread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(None) }\n\nimpl ThreadInfo {\n    fn with<R, F>(f: F) -> Option<R> where F: FnOnce(&mut ThreadInfo) -> R {\n        if THREAD_INFO.state() == LocalKeyState::Destroyed {\n            return None\n        }\n\n        THREAD_INFO.with(move |c| {\n            if c.borrow().is_none() {\n                *c.borrow_mut() = Some(ThreadInfo {\n                    stack_guard: None,\n                    thread: Thread::new(None),\n                })\n            }\n            Some(f(c.borrow_mut().as_mut().unwrap()))\n        })\n    }\n}\n\npub fn current_thread() -> Option<Thread> {\n    ThreadInfo::with(|info| info.thread.clone())\n}\n\npub fn stack_guard() -> Option<usize> {\n    ThreadInfo::with(|info| info.stack_guard).and_then(|o| o)\n}\n\npub fn set(stack_guard: Option<usize>, thread: Thread) {\n    THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n    THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo{\n        stack_guard: stack_guard,\n        thread: thread,\n    }));\n}\n","// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse ascii;\nuse borrow::{Cow, Borrow};\nuse cmp::Ordering;\nuse error::Error;\nuse fmt::{self, Write};\nuse io;\nuse libc;\nuse mem;\nuse memchr;\nuse ops;\nuse os::raw::c_char;\nuse ptr;\nuse slice;\nuse str::{self, Utf8Error};\n\n/// A type representing an owned C-compatible string.\n///\n/// This type serves the primary purpose of being able to safely generate a\n/// C-compatible string from a Rust byte slice or vector. An instance of this\n/// type is a static guarantee that the underlying bytes contain no interior 0\n/// bytes and the final byte is 0.\n///\n/// A `CString` is created from either a byte slice or a byte vector. A [`u8`]\n/// slice can be obtained with the `as_bytes` method. Slices produced from a\n/// `CString` do *not* contain the trailing nul terminator unless otherwise\n/// specified.\n///\n/// [`u8`]: ../primitive.u8.html\n///\n/// # Examples\n///\n/// ```no_run\n/// # fn main() {\n/// use std::ffi::CString;\n/// use std::os::raw::c_char;\n///\n/// extern {\n///     fn my_printer(s: *const c_char);\n/// }\n///\n/// let c_to_print = CString::new(\"Hello, world!\").unwrap();\n/// unsafe {\n///     my_printer(c_to_print.as_ptr());\n/// }\n/// # }\n/// ```\n///\n/// # Safety\n///\n/// `CString` is intended for working with traditional C-style strings\n/// (a sequence of non-null bytes terminated by a single null byte); the\n/// primary use case for these kinds of strings is interoperating with C-like\n/// code. Often you will need to transfer ownership to/from that external\n/// code. It is strongly recommended that you thoroughly read through the\n/// documentation of `CString` before use, as improper ownership management\n/// of `CString` instances can lead to invalid memory accesses, memory leaks,\n/// and other memory errors.\n\n#[derive(PartialEq, PartialOrd, Eq, Ord, Hash, Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct CString {\n    // Invariant 1: the slice ends with a zero byte and has a length of at least one.\n    // Invariant 2: the slice contains only one zero byte.\n    // Improper usage of unsafe function can break Invariant 2, but not Invariant 1.\n    inner: Box<[u8]>,\n}\n\n/// Representation of a borrowed C string.\n///\n/// This dynamically sized type is only safely constructed via a borrowed\n/// version of an instance of `CString`. This type can be constructed from a raw\n/// C string as well and represents a C string borrowed from another location.\n///\n/// Note that this structure is **not** `repr(C)` and is not recommended to be\n/// placed in the signatures of FFI functions. Instead safe wrappers of FFI\n/// functions may leverage the unsafe [`from_ptr`] constructor to provide a safe\n/// interface to other consumers.\n///\n/// [`from_ptr`]: #method.from_ptr\n///\n/// # Examples\n///\n/// Inspecting a foreign C string:\n///\n/// ```no_run\n/// use std::ffi::CStr;\n/// use std::os::raw::c_char;\n///\n/// extern { fn my_string() -> *const c_char; }\n///\n/// unsafe {\n///     let slice = CStr::from_ptr(my_string());\n///     println!(\"string length: {}\", slice.to_bytes().len());\n/// }\n/// ```\n///\n/// Passing a Rust-originating C string:\n///\n/// ```no_run\n/// use std::ffi::{CString, CStr};\n/// use std::os::raw::c_char;\n///\n/// fn work(data: &CStr) {\n///     extern { fn work_with(data: *const c_char); }\n///\n///     unsafe { work_with(data.as_ptr()) }\n/// }\n///\n/// let s = CString::new(\"data data data data\").unwrap();\n/// work(&s);\n/// ```\n///\n/// Converting a foreign C string into a Rust [`String`]:\n///\n/// [`String`]: ../string/struct.String.html\n///\n/// ```no_run\n/// use std::ffi::CStr;\n/// use std::os::raw::c_char;\n///\n/// extern { fn my_string() -> *const c_char; }\n///\n/// fn my_string_safe() -> String {\n///     unsafe {\n///         CStr::from_ptr(my_string()).to_string_lossy().into_owned()\n///     }\n/// }\n///\n/// println!(\"string: {}\", my_string_safe());\n/// ```\n#[derive(Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct CStr {\n    // FIXME: this should not be represented with a DST slice but rather with\n    //        just a raw `c_char` along with some form of marker to make\n    //        this an unsized type. Essentially `sizeof(&CStr)` should be the\n    //        same as `sizeof(&c_char)` but `CStr` should be an unsized type.\n    inner: [c_char]\n}\n\n/// An error returned from [`CString::new`] to indicate that a nul byte was found\n/// in the vector provided.\n///\n/// [`CString::new`]: struct.CString.html#method.new\n///\n/// # Examples\n///\n/// ```\n/// use std::ffi::{CString, NulError};\n///\n/// let _: NulError = CString::new(b\"f\\0oo\".to_vec()).unwrap_err();\n/// ```\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct NulError(usize, Vec<u8>);\n\n/// An error returned from [`CStr::from_bytes_with_nul`] to indicate that a nul\n/// byte was found too early in the slice provided or one wasn't found at all.\n///\n/// [`CStr::from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n///\n/// # Examples\n///\n/// ```\n/// use std::ffi::{CStr, FromBytesWithNulError};\n///\n/// let _: FromBytesWithNulError = CStr::from_bytes_with_nul(b\"f\\0oo\").unwrap_err();\n/// ```\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\npub struct FromBytesWithNulError {\n    kind: FromBytesWithNulErrorKind,\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\nenum FromBytesWithNulErrorKind {\n    InteriorNul(usize),\n    NotNulTerminated,\n}\n\nimpl FromBytesWithNulError {\n    fn interior_nul(pos: usize) -> FromBytesWithNulError {\n        FromBytesWithNulError {\n            kind: FromBytesWithNulErrorKind::InteriorNul(pos),\n        }\n    }\n    fn not_nul_terminated() -> FromBytesWithNulError {\n        FromBytesWithNulError {\n            kind: FromBytesWithNulErrorKind::NotNulTerminated,\n        }\n    }\n}\n\n/// An error returned from [`CString::into_string`] to indicate that a UTF-8 error\n/// was encountered during the conversion.\n///\n/// [`CString::into_string`]: struct.CString.html#method.into_string\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\npub struct IntoStringError {\n    inner: CString,\n    error: Utf8Error,\n}\n\nimpl CString {\n    /// Creates a new C-compatible string from a container of bytes.\n    ///\n    /// This method will consume the provided data and use the underlying bytes\n    /// to construct a new string, ensuring that there is a trailing 0 byte.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::ffi::CString;\n    /// use std::os::raw::c_char;\n    ///\n    /// extern { fn puts(s: *const c_char); }\n    ///\n    /// let to_print = CString::new(\"Hello!\").unwrap();\n    /// unsafe {\n    ///     puts(to_print.as_ptr());\n    /// }\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the bytes yielded contain an\n    /// internal 0 byte. The error returned will contain the bytes as well as\n    /// the position of the nul byte.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n        Self::_new(t.into())\n    }\n\n    fn _new(bytes: Vec<u8>) -> Result<CString, NulError> {\n        match memchr::memchr(0, &bytes) {\n            Some(i) => Err(NulError(i, bytes)),\n            None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n        }\n    }\n\n    /// Creates a C-compatible string from a byte vector without checking for\n    /// interior 0 bytes.\n    ///\n    /// This method is equivalent to [`new`] except that no runtime assertion\n    /// is made that `v` contains no 0 bytes, and it requires an actual\n    /// byte vector, not anything that can be converted to one with Into.\n    ///\n    /// [`new`]: #method.new\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let raw = b\"foo\".to_vec();\n    /// unsafe {\n    ///     let c_string = CString::from_vec_unchecked(raw);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString {\n        v.reserve_exact(1);\n        v.push(0);\n        CString { inner: v.into_boxed_slice() }\n    }\n\n    /// Retakes ownership of a `CString` that was transferred to C.\n    ///\n    /// Additionally, the length of the string will be recalculated from the pointer.\n    ///\n    /// # Safety\n    ///\n    /// This should only ever be called with a pointer that was earlier\n    /// obtained by calling [`into_raw`] on a `CString`. Other usage (e.g. trying to take\n    /// ownership of a string that was allocated by foreign code) is likely to lead\n    /// to undefined behavior or allocator corruption.\n    ///\n    /// [`into_raw`]: #method.into_raw\n    ///\n    /// # Examples\n    ///\n    /// Create a `CString`, pass ownership to an `extern` function (via raw pointer), then retake\n    /// ownership with `from_raw`:\n    ///\n    /// ```no_run\n    /// use std::ffi::CString;\n    /// use std::os::raw::c_char;\n    ///\n    /// extern {\n    ///     fn some_extern_function(s: *mut c_char);\n    /// }\n    ///\n    /// let c_string = CString::new(\"Hello!\").unwrap();\n    /// let raw = c_string.into_raw();\n    /// unsafe {\n    ///     some_extern_function(raw);\n    ///     let c_string = CString::from_raw(raw);\n    /// }\n    /// ```\n    #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n    pub unsafe fn from_raw(ptr: *mut c_char) -> CString {\n        let len = libc::strlen(ptr) + 1; // Including the NUL byte\n        let slice = slice::from_raw_parts(ptr, len as usize);\n        CString { inner: mem::transmute(slice) }\n    }\n\n    /// Transfers ownership of the string to a C caller.\n    ///\n    /// The pointer must be returned to Rust and reconstituted using\n    /// [`from_raw`] to be properly deallocated. Specifically, one\n    /// should *not* use the standard C `free` function to deallocate\n    /// this string.\n    ///\n    /// Failure to call [`from_raw`] will lead to a memory leak.\n    ///\n    /// [`from_raw`]: #method.from_raw\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").unwrap();\n    ///\n    /// let ptr = c_string.into_raw();\n    ///\n    /// unsafe {\n    ///     assert_eq!(b'f', *ptr as u8);\n    ///     assert_eq!(b'o', *ptr.offset(1) as u8);\n    ///     assert_eq!(b'o', *ptr.offset(2) as u8);\n    ///     assert_eq!(b'\\0', *ptr.offset(3) as u8);\n    ///\n    ///     // retake pointer to free memory\n    ///     let _ = CString::from_raw(ptr);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n    pub fn into_raw(self) -> *mut c_char {\n        Box::into_raw(self.into_inner()) as *mut c_char\n    }\n\n    /// Converts the `CString` into a [`String`] if it contains valid Unicode data.\n    ///\n    /// On failure, ownership of the original `CString` is returned.\n    ///\n    /// [`String`]: ../string/struct.String.html\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn into_string(self) -> Result<String, IntoStringError> {\n        String::from_utf8(self.into_bytes())\n            .map_err(|e| IntoStringError {\n                error: e.utf8_error(),\n                inner: unsafe { CString::from_vec_unchecked(e.into_bytes()) },\n            })\n    }\n\n    /// Returns the underlying byte buffer.\n    ///\n    /// The returned buffer does **not** contain the trailing nul separator and\n    /// it is guaranteed to not have any interior nul bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").unwrap();\n    /// let bytes = c_string.into_bytes();\n    /// assert_eq!(bytes, vec![b'f', b'o', b'o']);\n    /// ```\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn into_bytes(self) -> Vec<u8> {\n        let mut vec = self.into_inner().into_vec();\n        let _nul = vec.pop();\n        debug_assert_eq!(_nul, Some(0u8));\n        vec\n    }\n\n    /// Equivalent to the [`into_bytes`] function except that the returned vector\n    /// includes the trailing nul byte.\n    ///\n    /// [`into_bytes`]: #method.into_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").unwrap();\n    /// let bytes = c_string.into_bytes_with_nul();\n    /// assert_eq!(bytes, vec![b'f', b'o', b'o', b'\\0']);\n    /// ```\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn into_bytes_with_nul(self) -> Vec<u8> {\n        self.into_inner().into_vec()\n    }\n\n    /// Returns the contents of this `CString` as a slice of bytes.\n    ///\n    /// The returned slice does **not** contain the trailing nul separator and\n    /// it is guaranteed to not have any interior nul bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").unwrap();\n    /// let bytes = c_string.as_bytes();\n    /// assert_eq!(bytes, &[b'f', b'o', b'o']);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_bytes(&self) -> &[u8] {\n        &self.inner[..self.inner.len() - 1]\n    }\n\n    /// Equivalent to the [`as_bytes`] function except that the returned slice\n    /// includes the trailing nul byte.\n    ///\n    /// [`as_bytes`]: #method.as_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").unwrap();\n    /// let bytes = c_string.as_bytes_with_nul();\n    /// assert_eq!(bytes, &[b'f', b'o', b'o', b'\\0']);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_bytes_with_nul(&self) -> &[u8] {\n        &self.inner\n    }\n\n    /// Extracts a [`CStr`] slice containing the entire string.\n    ///\n    /// [`CStr`]: struct.CStr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(as_c_str)]\n    ///\n    /// use std::ffi::{CString, CStr};\n    ///\n    /// let c_string = CString::new(b\"foo\".to_vec()).unwrap();\n    /// let c_str = c_string.as_c_str();\n    /// assert_eq!(c_str, CStr::from_bytes_with_nul(b\"foo\\0\").unwrap());\n    /// ```\n    #[inline]\n    #[unstable(feature = \"as_c_str\", issue = \"40380\")]\n    pub fn as_c_str(&self) -> &CStr {\n        &*self\n    }\n\n    /// Converts this `CString` into a boxed [`CStr`].\n    ///\n    /// [`CStr`]: struct.CStr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(into_boxed_c_str)]\n    ///\n    /// use std::ffi::{CString, CStr};\n    ///\n    /// let c_string = CString::new(b\"foo\".to_vec()).unwrap();\n    /// let boxed = c_string.into_boxed_c_str();\n    /// assert_eq!(&*boxed, CStr::from_bytes_with_nul(b\"foo\\0\").unwrap());\n    /// ```\n    #[unstable(feature = \"into_boxed_c_str\", issue = \"40380\")]\n    pub fn into_boxed_c_str(self) -> Box<CStr> {\n        unsafe { mem::transmute(self.into_inner()) }\n    }\n\n    // Bypass \"move out of struct which implements [`Drop`] trait\" restriction.\n    ///\n    /// [`Drop`]: ../ops/trait.Drop.html\n    fn into_inner(self) -> Box<[u8]> {\n        unsafe {\n            let result = ptr::read(&self.inner);\n            mem::forget(self);\n            result\n        }\n    }\n}\n\n// Turns this `CString` into an empty string to prevent\n// memory unsafe code from working by accident. Inline\n// to prevent LLVM from optimizing it away in debug builds.\n#[stable(feature = \"cstring_drop\", since = \"1.13.0\")]\nimpl Drop for CString {\n    #[inline]\n    fn drop(&mut self) {\n        unsafe { *self.inner.get_unchecked_mut(0) = 0; }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Deref for CString {\n    type Target = CStr;\n\n    #[inline]\n    fn deref(&self) -> &CStr {\n        unsafe { CStr::from_bytes_with_nul_unchecked(self.as_bytes_with_nul()) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for CString {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\nimpl From<CString> for Vec<u8> {\n    #[inline]\n    fn from(s: CString) -> Vec<u8> {\n        s.into_bytes()\n    }\n}\n\n#[stable(feature = \"cstr_debug\", since = \"1.3.0\")]\nimpl fmt::Debug for CStr {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"\\\"\")?;\n        for byte in self.to_bytes().iter().flat_map(|&b| ascii::escape_default(b)) {\n            f.write_char(byte as char)?;\n        }\n        write!(f, \"\\\"\")\n    }\n}\n\n#[stable(feature = \"cstr_default\", since = \"1.10.0\")]\nimpl<'a> Default for &'a CStr {\n    fn default() -> &'a CStr {\n        static SLICE: &'static [c_char] = &[0];\n        unsafe { CStr::from_ptr(SLICE.as_ptr()) }\n    }\n}\n\n#[stable(feature = \"cstr_default\", since = \"1.10.0\")]\nimpl Default for CString {\n    /// Creates an empty `CString`.\n    fn default() -> CString {\n        let a: &CStr = Default::default();\n        a.to_owned()\n    }\n}\n\n#[stable(feature = \"cstr_borrow\", since = \"1.3.0\")]\nimpl Borrow<CStr> for CString {\n    #[inline]\n    fn borrow(&self) -> &CStr { self }\n}\n\n#[stable(feature = \"box_from_c_str\", since = \"1.17.0\")]\nimpl<'a> From<&'a CStr> for Box<CStr> {\n    fn from(s: &'a CStr) -> Box<CStr> {\n        let boxed: Box<[u8]> = Box::from(s.to_bytes_with_nul());\n        unsafe { mem::transmute(boxed) }\n    }\n}\n\n#[stable(feature = \"c_string_from_box\", since = \"1.18.0\")]\nimpl From<Box<CStr>> for CString {\n    #[inline]\n    fn from(s: Box<CStr>) -> CString {\n        s.into_c_string()\n    }\n}\n\n#[stable(feature = \"box_from_c_string\", since = \"1.20.0\")]\nimpl From<CString> for Box<CStr> {\n    #[inline]\n    fn from(s: CString) -> Box<CStr> {\n        s.into_boxed_c_str()\n    }\n}\n\n#[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\nimpl Default for Box<CStr> {\n    fn default() -> Box<CStr> {\n        let boxed: Box<[u8]> = Box::from([0]);\n        unsafe { mem::transmute(boxed) }\n    }\n}\n\nimpl NulError {\n    /// Returns the position of the nul byte in the slice that was provided to\n    /// [`CString::new`].\n    ///\n    /// [`CString::new`]: struct.CString.html#method.new\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let nul_error = CString::new(\"foo\\0bar\").unwrap_err();\n    /// assert_eq!(nul_error.nul_position(), 3);\n    ///\n    /// let nul_error = CString::new(\"foo bar\\0\").unwrap_err();\n    /// assert_eq!(nul_error.nul_position(), 7);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn nul_position(&self) -> usize { self.0 }\n\n    /// Consumes this error, returning the underlying vector of bytes which\n    /// generated the error in the first place.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let nul_error = CString::new(\"foo\\0bar\").unwrap_err();\n    /// assert_eq!(nul_error.into_vec(), b\"foo\\0bar\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_vec(self) -> Vec<u8> { self.1 }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for NulError {\n    fn description(&self) -> &str { \"nul byte found in data\" }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for NulError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"nul byte found in provided data at position: {}\", self.0)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<NulError> for io::Error {\n    fn from(_: NulError) -> io::Error {\n        io::Error::new(io::ErrorKind::InvalidInput,\n                       \"data provided contains a nul byte\")\n    }\n}\n\n#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\nimpl Error for FromBytesWithNulError {\n    fn description(&self) -> &str {\n        match self.kind {\n            FromBytesWithNulErrorKind::InteriorNul(..) =>\n                \"data provided contains an interior nul byte\",\n            FromBytesWithNulErrorKind::NotNulTerminated =>\n                \"data provided is not nul terminated\",\n        }\n    }\n}\n\n#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\nimpl fmt::Display for FromBytesWithNulError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_str(self.description())?;\n        if let FromBytesWithNulErrorKind::InteriorNul(pos) = self.kind {\n            write!(f, \" at byte pos {}\", pos)?;\n        }\n        Ok(())\n    }\n}\n\nimpl IntoStringError {\n    /// Consumes this error, returning original [`CString`] which generated the\n    /// error.\n    ///\n    /// [`CString`]: struct.CString.html\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn into_cstring(self) -> CString {\n        self.inner\n    }\n\n    /// Access the underlying UTF-8 error that was the cause of this error.\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn utf8_error(&self) -> Utf8Error {\n        self.error\n    }\n}\n\n#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\nimpl Error for IntoStringError {\n    fn description(&self) -> &str {\n        \"C string contained non-utf8 bytes\"\n    }\n\n    fn cause(&self) -> Option<&Error> {\n        Some(&self.error)\n    }\n}\n\n#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\nimpl fmt::Display for IntoStringError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.description().fmt(f)\n    }\n}\n\nimpl CStr {\n    /// Casts a raw C string to a safe C string wrapper.\n    ///\n    /// This function will cast the provided `ptr` to the `CStr` wrapper which\n    /// allows inspection and interoperation of non-owned C strings. This method\n    /// is unsafe for a number of reasons:\n    ///\n    /// * There is no guarantee to the validity of `ptr`.\n    /// * The returned lifetime is not guaranteed to be the actual lifetime of\n    ///   `ptr`.\n    /// * There is no guarantee that the memory pointed to by `ptr` contains a\n    ///   valid nul terminator byte at the end of the string.\n    ///\n    /// > **Note**: This operation is intended to be a 0-cost cast but it is\n    /// > currently implemented with an up-front calculation of the length of\n    /// > the string. This is not guaranteed to always be the case.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # fn main() {\n    /// use std::ffi::CStr;\n    /// use std::os::raw::c_char;\n    ///\n    /// extern {\n    ///     fn my_string() -> *const c_char;\n    /// }\n    ///\n    /// unsafe {\n    ///     let slice = CStr::from_ptr(my_string());\n    ///     println!(\"string returned: {}\", slice.to_str().unwrap());\n    /// }\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr {\n        let len = libc::strlen(ptr);\n        let ptr = ptr as *const u8;\n        CStr::from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n    }\n\n    /// Creates a C string wrapper from a byte slice.\n    ///\n    /// This function will cast the provided `bytes` to a `CStr` wrapper after\n    /// ensuring that it is null terminated and does not contain any interior\n    /// nul bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"hello\\0\");\n    /// assert!(cstr.is_ok());\n    /// ```\n    ///\n    /// Creating a `CStr` without a trailing nul byte is an error:\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let c_str = CStr::from_bytes_with_nul(b\"hello\");\n    /// assert!(c_str.is_err());\n    /// ```\n    ///\n    /// Creating a `CStr` with an interior nul byte is an error:\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let c_str = CStr::from_bytes_with_nul(b\"he\\0llo\\0\");\n    /// assert!(c_str.is_err());\n    /// ```\n    #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n    pub fn from_bytes_with_nul(bytes: &[u8])\n                               -> Result<&CStr, FromBytesWithNulError> {\n        let nul_pos = memchr::memchr(0, bytes);\n        if let Some(nul_pos) = nul_pos {\n            if nul_pos + 1 != bytes.len() {\n                return Err(FromBytesWithNulError::interior_nul(nul_pos));\n            }\n            Ok(unsafe { CStr::from_bytes_with_nul_unchecked(bytes) })\n        } else {\n            Err(FromBytesWithNulError::not_nul_terminated())\n        }\n    }\n\n    /// Unsafely creates a C string wrapper from a byte slice.\n    ///\n    /// This function will cast the provided `bytes` to a `CStr` wrapper without\n    /// performing any sanity checks. The provided slice must be null terminated\n    /// and not contain any interior nul bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{CStr, CString};\n    ///\n    /// unsafe {\n    ///     let cstring = CString::new(\"hello\").unwrap();\n    ///     let cstr = CStr::from_bytes_with_nul_unchecked(cstring.to_bytes_with_nul());\n    ///     assert_eq!(cstr, &*cstring);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n    pub unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n        mem::transmute(bytes)\n    }\n\n    /// Returns the inner pointer to this C string.\n    ///\n    /// The returned pointer will be valid for as long as `self` is and points\n    /// to a contiguous region of memory terminated with a 0 byte to represent\n    /// the end of the string.\n    ///\n    /// **WARNING**\n    ///\n    /// It is your responsibility to make sure that the underlying memory is not\n    /// freed too early. For example, the following code will cause undefined\n    /// behaviour when `ptr` is used inside the `unsafe` block:\n    ///\n    /// ```no_run\n    /// use std::ffi::{CString};\n    ///\n    /// let ptr = CString::new(\"Hello\").unwrap().as_ptr();\n    /// unsafe {\n    ///     // `ptr` is dangling\n    ///     *ptr;\n    /// }\n    /// ```\n    ///\n    /// This happens because the pointer returned by `as_ptr` does not carry any\n    /// lifetime information and the string is deallocated immediately after\n    /// the `CString::new(\"Hello\").unwrap().as_ptr()` expression is evaluated.\n    /// To fix the problem, bind the string to a local variable:\n    ///\n    /// ```no_run\n    /// use std::ffi::{CString};\n    ///\n    /// let hello = CString::new(\"Hello\").unwrap();\n    /// let ptr = hello.as_ptr();\n    /// unsafe {\n    ///     // `ptr` is valid because `hello` is in scope\n    ///     *ptr;\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_ptr(&self) -> *const c_char {\n        self.inner.as_ptr()\n    }\n\n    /// Converts this C string to a byte slice.\n    ///\n    /// This function will calculate the length of this string (which normally\n    /// requires a linear amount of work to be done) and then return the\n    /// resulting slice of `u8` elements.\n    ///\n    /// The returned slice will **not** contain the trailing nul that this C\n    /// string has.\n    ///\n    /// > **Note**: This method is currently implemented as a 0-cost cast, but\n    /// > it is planned to alter its definition in the future to perform the\n    /// > length calculation whenever this method is called.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n    /// assert_eq!(c_str.to_bytes(), b\"foo\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_bytes(&self) -> &[u8] {\n        let bytes = self.to_bytes_with_nul();\n        &bytes[..bytes.len() - 1]\n    }\n\n    /// Converts this C string to a byte slice containing the trailing 0 byte.\n    ///\n    /// This function is the equivalent of [`to_bytes`] except that it will retain\n    /// the trailing nul instead of chopping it off.\n    ///\n    /// > **Note**: This method is currently implemented as a 0-cost cast, but\n    /// > it is planned to alter its definition in the future to perform the\n    /// > length calculation whenever this method is called.\n    ///\n    /// [`to_bytes`]: #method.to_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n    /// assert_eq!(c_str.to_bytes_with_nul(), b\"foo\\0\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_bytes_with_nul(&self) -> &[u8] {\n        unsafe { mem::transmute(&self.inner) }\n    }\n\n    /// Yields a [`&str`] slice if the `CStr` contains valid UTF-8.\n    ///\n    /// This function will calculate the length of this string and check for\n    /// UTF-8 validity, and then return the [`&str`] if it's valid.\n    ///\n    /// > **Note**: This method is currently implemented to check for validity\n    /// > after a 0-cost cast, but it is planned to alter its definition in the\n    /// > future to perform the length calculation in addition to the UTF-8\n    /// > check whenever this method is called.\n    ///\n    /// [`&str`]: ../primitive.str.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n    /// assert_eq!(c_str.to_str(), Ok(\"foo\"));\n    /// ```\n    #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n    pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n        // NB: When CStr is changed to perform the length check in .to_bytes()\n        // instead of in from_ptr(), it may be worth considering if this should\n        // be rewritten to do the UTF-8 check inline with the length calculation\n        // instead of doing it afterwards.\n        str::from_utf8(self.to_bytes())\n    }\n\n    /// Converts a `CStr` into a [`Cow`]`<`[`str`]`>`.\n    ///\n    /// This function will calculate the length of this string (which normally\n    /// requires a linear amount of work to be done) and then return the\n    /// resulting slice as a [`Cow`]`<`[`str`]`>`, replacing any invalid UTF-8 sequences\n    /// with `U+FFFD REPLACEMENT CHARACTER`.\n    ///\n    /// > **Note**: This method is currently implemented to check for validity\n    /// > after a 0-cost cast, but it is planned to alter its definition in the\n    /// > future to perform the length calculation in addition to the UTF-8\n    /// > check whenever this method is called.\n    ///\n    /// [`Cow`]: ../borrow/enum.Cow.html\n    /// [`str`]: ../primitive.str.html\n    ///\n    /// # Examples\n    ///\n    /// Calling `to_string_lossy` on a `CStr` containing valid UTF-8:\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    /// use std::ffi::CStr;\n    ///\n    /// let c_str = CStr::from_bytes_with_nul(b\"Hello World\\0\").unwrap();\n    /// assert_eq!(c_str.to_string_lossy(), Cow::Borrowed(\"Hello World\"));\n    /// ```\n    ///\n    /// Calling `to_string_lossy` on a `CStr` containing invalid UTF-8:\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    /// use std::ffi::CStr;\n    ///\n    /// let c_str = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\").unwrap();\n    /// assert_eq!(\n    ///     c_str.to_string_lossy(),\n    ///     Cow::Owned(String::from(\"Hello World\")) as Cow<str>\n    /// );\n    /// ```\n    #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n    pub fn to_string_lossy(&self) -> Cow<str> {\n        String::from_utf8_lossy(self.to_bytes())\n    }\n\n    /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n    ///\n    /// [`Box`]: ../boxed/struct.Box.html\n    /// [`CString`]: struct.CString.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(into_boxed_c_str)]\n    ///\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(b\"foo\".to_vec()).unwrap();\n    /// let boxed = c_string.into_boxed_c_str();\n    /// assert_eq!(boxed.into_c_string(), CString::new(\"foo\").unwrap());\n    /// ```\n    #[unstable(feature = \"into_boxed_c_str\", issue = \"40380\")]\n    pub fn into_c_string(self: Box<CStr>) -> CString {\n        unsafe { mem::transmute(self) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for CStr {\n    fn eq(&self, other: &CStr) -> bool {\n        self.to_bytes().eq(other.to_bytes())\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for CStr {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for CStr {\n    fn partial_cmp(&self, other: &CStr) -> Option<Ordering> {\n        self.to_bytes().partial_cmp(&other.to_bytes())\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for CStr {\n    fn cmp(&self, other: &CStr) -> Ordering {\n        self.to_bytes().cmp(&other.to_bytes())\n    }\n}\n\n#[stable(feature = \"cstr_borrow\", since = \"1.3.0\")]\nimpl ToOwned for CStr {\n    type Owned = CString;\n\n    fn to_owned(&self) -> CString {\n        CString { inner: self.to_bytes_with_nul().into() }\n    }\n}\n\n#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\nimpl<'a> From<&'a CStr> for CString {\n    fn from(s: &'a CStr) -> CString {\n        s.to_owned()\n    }\n}\n\n#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\nimpl ops::Index<ops::RangeFull> for CString {\n    type Output = CStr;\n\n    #[inline]\n    fn index(&self, _index: ops::RangeFull) -> &CStr {\n        self\n    }\n}\n\n#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\nimpl AsRef<CStr> for CStr {\n    #[inline]\n    fn as_ref(&self) -> &CStr {\n        self\n    }\n}\n\n#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\nimpl AsRef<CStr> for CString {\n    #[inline]\n    fn as_ref(&self) -> &CStr {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use os::raw::c_char;\n    use borrow::Cow::{Borrowed, Owned};\n    use hash::{Hash, Hasher};\n    use collections::hash_map::DefaultHasher;\n\n    #[test]\n    fn c_to_rust() {\n        let data = b\"123\\0\";\n        let ptr = data.as_ptr() as *const c_char;\n        unsafe {\n            assert_eq!(CStr::from_ptr(ptr).to_bytes(), b\"123\");\n            assert_eq!(CStr::from_ptr(ptr).to_bytes_with_nul(), b\"123\\0\");\n        }\n    }\n\n    #[test]\n    fn simple() {\n        let s = CString::new(\"1234\").unwrap();\n        assert_eq!(s.as_bytes(), b\"1234\");\n        assert_eq!(s.as_bytes_with_nul(), b\"1234\\0\");\n    }\n\n    #[test]\n    fn build_with_zero1() {\n        assert!(CString::new(&b\"\\0\"[..]).is_err());\n    }\n    #[test]\n    fn build_with_zero2() {\n        assert!(CString::new(vec![0]).is_err());\n    }\n\n    #[test]\n    fn build_with_zero3() {\n        unsafe {\n            let s = CString::from_vec_unchecked(vec![0]);\n            assert_eq!(s.as_bytes(), b\"\\0\");\n        }\n    }\n\n    #[test]\n    fn formatted() {\n        let s = CString::new(&b\"abc\\x01\\x02\\n\\xE2\\x80\\xA6\\xFF\"[..]).unwrap();\n        assert_eq!(format!(\"{:?}\", s), r#\"\"abc\\x01\\x02\\n\\xe2\\x80\\xa6\\xff\"\"#);\n    }\n\n    #[test]\n    fn borrowed() {\n        unsafe {\n            let s = CStr::from_ptr(b\"12\\0\".as_ptr() as *const _);\n            assert_eq!(s.to_bytes(), b\"12\");\n            assert_eq!(s.to_bytes_with_nul(), b\"12\\0\");\n        }\n    }\n\n    #[test]\n    fn to_str() {\n        let data = b\"123\\xE2\\x80\\xA6\\0\";\n        let ptr = data.as_ptr() as *const c_char;\n        unsafe {\n            assert_eq!(CStr::from_ptr(ptr).to_str(), Ok(\"123\"));\n            assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Borrowed(\"123\"));\n        }\n        let data = b\"123\\xE2\\0\";\n        let ptr = data.as_ptr() as *const c_char;\n        unsafe {\n            assert!(CStr::from_ptr(ptr).to_str().is_err());\n            assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Owned::<str>(format!(\"123\\u{FFFD}\")));\n        }\n    }\n\n    #[test]\n    fn to_owned() {\n        let data = b\"123\\0\";\n        let ptr = data.as_ptr() as *const c_char;\n\n        let owned = unsafe { CStr::from_ptr(ptr).to_owned() };\n        assert_eq!(owned.as_bytes_with_nul(), data);\n    }\n\n    #[test]\n    fn equal_hash() {\n        let data = b\"123\\xE2\\xFA\\xA6\\0\";\n        let ptr = data.as_ptr() as *const c_char;\n        let cstr: &'static CStr = unsafe { CStr::from_ptr(ptr) };\n\n        let mut s = DefaultHasher::new();\n        cstr.hash(&mut s);\n        let cstr_hash = s.finish();\n        let mut s = DefaultHasher::new();\n        CString::new(&data[..data.len() - 1]).unwrap().hash(&mut s);\n        let cstring_hash = s.finish();\n\n        assert_eq!(cstr_hash, cstring_hash);\n    }\n\n    #[test]\n    fn from_bytes_with_nul() {\n        let data = b\"123\\0\";\n        let cstr = CStr::from_bytes_with_nul(data);\n        assert_eq!(cstr.map(CStr::to_bytes), Ok(&b\"123\"[..]));\n        let cstr = CStr::from_bytes_with_nul(data);\n        assert_eq!(cstr.map(CStr::to_bytes_with_nul), Ok(&b\"123\\0\"[..]));\n\n        unsafe {\n            let cstr = CStr::from_bytes_with_nul(data);\n            let cstr_unchecked = CStr::from_bytes_with_nul_unchecked(data);\n            assert_eq!(cstr, Ok(cstr_unchecked));\n        }\n    }\n\n    #[test]\n    fn from_bytes_with_nul_unterminated() {\n        let data = b\"123\";\n        let cstr = CStr::from_bytes_with_nul(data);\n        assert!(cstr.is_err());\n    }\n\n    #[test]\n    fn from_bytes_with_nul_interior() {\n        let data = b\"1\\023\\0\";\n        let cstr = CStr::from_bytes_with_nul(data);\n        assert!(cstr.is_err());\n    }\n\n    #[test]\n    fn into_boxed() {\n        let orig: &[u8] = b\"Hello, world!\\0\";\n        let cstr = CStr::from_bytes_with_nul(orig).unwrap();\n        let boxed: Box<CStr> = Box::from(cstr);\n        let cstring = cstr.to_owned().into_boxed_c_str().into_c_string();\n        assert_eq!(cstr, &*boxed);\n        assert_eq!(&*boxed, &*cstring);\n        assert_eq!(&*cstring, cstr);\n    }\n\n    #[test]\n    fn boxed_default() {\n        let boxed = <Box<CStr>>::default();\n        assert_eq!(boxed.to_bytes_with_nul(), &[0]);\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Shareable mutable containers.\n//!\n//! Values of the `Cell<T>` and `RefCell<T>` types may be mutated through shared references (i.e.\n//! the common `&T` type), whereas most Rust types can only be mutated through unique (`&mut T`)\n//! references. We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast\n//! with typical Rust types that exhibit 'inherited mutability'.\n//!\n//! Cell types come in two flavors: `Cell<T>` and `RefCell<T>`. `Cell<T>` implements interior\n//! mutability by moving values in and out of the `Cell<T>`. To use references instead of values,\n//! one must use the `RefCell<T>` type, acquiring a write lock before mutating. `Cell<T>` provides\n//! methods to retrieve and change the current interior value:\n//!\n//!  - For types that implement `Copy`, the `get` method retrieves the current interior value.\n//!  - For types that implement `Default`, the `take` method replaces the current interior value\n//!    with `Default::default()` and returns the replaced value.\n//!  - For all types, the `replace` method replaces the current interior value and returns the\n//!    replaced value and the `into_inner` method consumes the `Cell<T>` and returns the interior\n//!    value. Additionally, the `set` method replaces the interior value, dropping the replaced\n//!    value.\n//!\n//! `RefCell<T>` uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can\n//! claim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are\n//! tracked 'at runtime', unlike Rust's native reference types which are entirely tracked\n//! statically, at compile time. Because `RefCell<T>` borrows are dynamic it is possible to attempt\n//! to borrow a value that is already mutably borrowed; when this happens it results in thread\n//! panic.\n//!\n//! # When to choose interior mutability\n//!\n//! The more common inherited mutability, where one must have unique access to mutate a value, is\n//! one of the key language elements that enables Rust to reason strongly about pointer aliasing,\n//! statically preventing crash bugs. Because of that, inherited mutability is preferred, and\n//! interior mutability is something of a last resort. Since cell types enable mutation where it\n//! would otherwise be disallowed though, there are occasions when interior mutability might be\n//! appropriate, or even *must* be used, e.g.\n//!\n//! * Introducing mutability 'inside' of something immutable\n//! * Implementation details of logically-immutable methods.\n//! * Mutating implementations of `Clone`.\n//!\n//! ## Introducing mutability 'inside' of something immutable\n//!\n//! Many shared smart pointer types, including `Rc<T>` and `Arc<T>`, provide containers that can be\n//! cloned and shared between multiple parties. Because the contained values may be\n//! multiply-aliased, they can only be borrowed with `&`, not `&mut`. Without cells it would be\n//! impossible to mutate data inside of these smart pointers at all.\n//!\n//! It's very common then to put a `RefCell<T>` inside shared pointer types to reintroduce\n//! mutability:\n//!\n//! ```\n//! use std::collections::HashMap;\n//! use std::cell::RefCell;\n//! use std::rc::Rc;\n//!\n//! fn main() {\n//!     let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));\n//!     shared_map.borrow_mut().insert(\"africa\", 92388);\n//!     shared_map.borrow_mut().insert(\"kyoto\", 11837);\n//!     shared_map.borrow_mut().insert(\"piccadilly\", 11826);\n//!     shared_map.borrow_mut().insert(\"marbles\", 38);\n//! }\n//! ```\n//!\n//! Note that this example uses `Rc<T>` and not `Arc<T>`. `RefCell<T>`s are for single-threaded\n//! scenarios. Consider using `RwLock<T>` or `Mutex<T>` if you need shared mutability in a\n//! multi-threaded situation.\n//!\n//! ## Implementation details of logically-immutable methods\n//!\n//! Occasionally it may be desirable not to expose in an API that there is mutation happening\n//! \"under the hood\". This may be because logically the operation is immutable, but e.g. caching\n//! forces the implementation to perform mutation; or because you must employ mutation to implement\n//! a trait method that was originally defined to take `&self`.\n//!\n//! ```\n//! # #![allow(dead_code)]\n//! use std::cell::RefCell;\n//!\n//! struct Graph {\n//!     edges: Vec<(i32, i32)>,\n//!     span_tree_cache: RefCell<Option<Vec<(i32, i32)>>>\n//! }\n//!\n//! impl Graph {\n//!     fn minimum_spanning_tree(&self) -> Vec<(i32, i32)> {\n//!         // Create a new scope to contain the lifetime of the\n//!         // dynamic borrow\n//!         {\n//!             // Take a reference to the inside of cache cell\n//!             let mut cache = self.span_tree_cache.borrow_mut();\n//!             if cache.is_some() {\n//!                 return cache.as_ref().unwrap().clone();\n//!             }\n//!\n//!             let span_tree = self.calc_span_tree();\n//!             *cache = Some(span_tree);\n//!         }\n//!\n//!         // Recursive call to return the just-cached value.\n//!         // Note that if we had not let the previous borrow\n//!         // of the cache fall out of scope then the subsequent\n//!         // recursive borrow would cause a dynamic thread panic.\n//!         // This is the major hazard of using `RefCell`.\n//!         self.minimum_spanning_tree()\n//!     }\n//! #   fn calc_span_tree(&self) -> Vec<(i32, i32)> { vec![] }\n//! }\n//! ```\n//!\n//! ## Mutating implementations of `Clone`\n//!\n//! This is simply a special - but common - case of the previous: hiding mutability for operations\n//! that appear to be immutable. The `clone` method is expected to not change the source value, and\n//! is declared to take `&self`, not `&mut self`. Therefore any mutation that happens in the\n//! `clone` method must use cell types. For example, `Rc<T>` maintains its reference counts within a\n//! `Cell<T>`.\n//!\n//! ```\n//! #![feature(core_intrinsics)]\n//! #![feature(shared)]\n//! use std::cell::Cell;\n//! use std::ptr::Shared;\n//! use std::intrinsics::abort;\n//!\n//! struct Rc<T: ?Sized> {\n//!     ptr: Shared<RcBox<T>>\n//! }\n//!\n//! struct RcBox<T: ?Sized> {\n//!     strong: Cell<usize>,\n//!     refcount: Cell<usize>,\n//!     value: T,\n//! }\n//!\n//! impl<T: ?Sized> Clone for Rc<T> {\n//!     fn clone(&self) -> Rc<T> {\n//!         self.inc_strong();\n//!         Rc { ptr: self.ptr }\n//!     }\n//! }\n//!\n//! trait RcBoxPtr<T: ?Sized> {\n//!\n//!     fn inner(&self) -> &RcBox<T>;\n//!\n//!     fn strong(&self) -> usize {\n//!         self.inner().strong.get()\n//!     }\n//!\n//!     fn inc_strong(&self) {\n//!         self.inner()\n//!             .strong\n//!             .set(self.strong()\n//!                      .checked_add(1)\n//!                      .unwrap_or_else(|| unsafe { abort() }));\n//!     }\n//! }\n//!\n//! impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n//!    fn inner(&self) -> &RcBox<T> {\n//!        unsafe {\n//!            self.ptr.as_ref()\n//!        }\n//!    }\n//! }\n//! ```\n//!\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse cmp::Ordering;\nuse fmt::{self, Debug, Display};\nuse marker::Unsize;\nuse mem;\nuse ops::{Deref, DerefMut, CoerceUnsized};\nuse ptr;\n\n/// A mutable memory location.\n///\n/// See the [module-level documentation](index.html) for more.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Cell<T> {\n    value: UnsafeCell<T>,\n}\n\nimpl<T:Copy> Cell<T> {\n    /// Returns a copy of the contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    ///\n    /// let five = c.get();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get(&self) -> T {\n        unsafe{ *self.value.get() }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T> Send for Cell<T> where T: Send {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> !Sync for Cell<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T:Copy> Clone for Cell<T> {\n    #[inline]\n    fn clone(&self) -> Cell<T> {\n        Cell::new(self.get())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T:Default> Default for Cell<T> {\n    /// Creates a `Cell<T>`, with the `Default` value for T.\n    #[inline]\n    fn default() -> Cell<T> {\n        Cell::new(Default::default())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T:PartialEq + Copy> PartialEq for Cell<T> {\n    #[inline]\n    fn eq(&self, other: &Cell<T>) -> bool {\n        self.get() == other.get()\n    }\n}\n\n#[stable(feature = \"cell_eq\", since = \"1.2.0\")]\nimpl<T:Eq + Copy> Eq for Cell<T> {}\n\n#[stable(feature = \"cell_ord\", since = \"1.10.0\")]\nimpl<T:PartialOrd + Copy> PartialOrd for Cell<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Cell<T>) -> Option<Ordering> {\n        self.get().partial_cmp(&other.get())\n    }\n\n    #[inline]\n    fn lt(&self, other: &Cell<T>) -> bool {\n        self.get() < other.get()\n    }\n\n    #[inline]\n    fn le(&self, other: &Cell<T>) -> bool {\n        self.get() <= other.get()\n    }\n\n    #[inline]\n    fn gt(&self, other: &Cell<T>) -> bool {\n        self.get() > other.get()\n    }\n\n    #[inline]\n    fn ge(&self, other: &Cell<T>) -> bool {\n        self.get() >= other.get()\n    }\n}\n\n#[stable(feature = \"cell_ord\", since = \"1.10.0\")]\nimpl<T:Ord + Copy> Ord for Cell<T> {\n    #[inline]\n    fn cmp(&self, other: &Cell<T>) -> Ordering {\n        self.get().cmp(&other.get())\n    }\n}\n\n#[stable(feature = \"cell_from\", since = \"1.12.0\")]\nimpl<T> From<T> for Cell<T> {\n    fn from(t: T) -> Cell<T> {\n        Cell::new(t)\n    }\n}\n\nimpl<T> Cell<T> {\n    /// Creates a new `Cell` containing the given value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub const fn new(value: T) -> Cell<T> {\n        Cell {\n            value: UnsafeCell::new(value),\n        }\n    }\n\n    /// Returns a raw pointer to the underlying data in this cell.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    ///\n    /// let ptr = c.as_ptr();\n    /// ```\n    #[inline]\n    #[stable(feature = \"cell_as_ptr\", since = \"1.12.0\")]\n    pub fn as_ptr(&self) -> *mut T {\n        self.value.get()\n    }\n\n    /// Returns a mutable reference to the underlying data.\n    ///\n    /// This call borrows `Cell` mutably (at compile-time) which guarantees\n    /// that we possess the only reference.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let mut c = Cell::new(5);\n    /// *c.get_mut() += 1;\n    ///\n    /// assert_eq!(c.get(), 6);\n    /// ```\n    #[inline]\n    #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n    pub fn get_mut(&mut self) -> &mut T {\n        unsafe {\n            &mut *self.value.get()\n        }\n    }\n\n    /// Sets the contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    ///\n    /// c.set(10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set(&self, val: T) {\n        let old = self.replace(val);\n        drop(old);\n    }\n\n    /// Swaps the values of two Cells.\n    /// Difference with `std::mem::swap` is that this function doesn't require `&mut` reference.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c1 = Cell::new(5i32);\n    /// let c2 = Cell::new(10i32);\n    /// c1.swap(&c2);\n    /// assert_eq!(10, c1.get());\n    /// assert_eq!(5, c2.get());\n    /// ```\n    #[inline]\n    #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n    pub fn swap(&self, other: &Self) {\n        if ptr::eq(self, other) {\n            return;\n        }\n        unsafe {\n            ptr::swap(self.value.get(), other.value.get());\n        }\n    }\n\n    /// Replaces the contained value, and returns it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let cell = Cell::new(5);\n    /// assert_eq!(cell.get(), 5);\n    /// assert_eq!(cell.replace(10), 5);\n    /// assert_eq!(cell.get(), 10);\n    /// ```\n    #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n    pub fn replace(&self, val: T) -> T {\n        mem::replace(unsafe { &mut *self.value.get() }, val)\n    }\n\n    /// Unwraps the value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    /// let five = c.into_inner();\n    ///\n    /// assert_eq!(five, 5);\n    /// ```\n    #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n    pub fn into_inner(self) -> T {\n        unsafe { self.value.into_inner() }\n    }\n}\n\nimpl<T: Default> Cell<T> {\n    /// Takes the value of the cell, leaving `Default::default()` in its place.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    /// let five = c.take();\n    ///\n    /// assert_eq!(five, 5);\n    /// assert_eq!(c.into_inner(), 0);\n    /// ```\n    #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n    pub fn take(&self) -> T {\n        self.replace(Default::default())\n    }\n}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: CoerceUnsized<U>, U> CoerceUnsized<Cell<U>> for Cell<T> {}\n\n/// A mutable memory location with dynamically checked borrow rules\n///\n/// See the [module-level documentation](index.html) for more.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RefCell<T: ?Sized> {\n    borrow: Cell<BorrowFlag>,\n    value: UnsafeCell<T>,\n}\n\n/// An error returned by [`RefCell::try_borrow`](struct.RefCell.html#method.try_borrow).\n#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\npub struct BorrowError {\n    _private: (),\n}\n\n#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\nimpl Debug for BorrowError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"BorrowError\").finish()\n    }\n}\n\n#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\nimpl Display for BorrowError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(\"already mutably borrowed\", f)\n    }\n}\n\n/// An error returned by [`RefCell::try_borrow_mut`](struct.RefCell.html#method.try_borrow_mut).\n#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\npub struct BorrowMutError {\n    _private: (),\n}\n\n#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\nimpl Debug for BorrowMutError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"BorrowMutError\").finish()\n    }\n}\n\n#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\nimpl Display for BorrowMutError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(\"already borrowed\", f)\n    }\n}\n\n// Values [1, MAX-1] represent the number of `Ref` active\n// (will not outgrow its range since `usize` is the size of the address space)\ntype BorrowFlag = usize;\nconst UNUSED: BorrowFlag = 0;\nconst WRITING: BorrowFlag = !0;\n\nimpl<T> RefCell<T> {\n    /// Creates a new `RefCell` containing `value`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::RefCell;\n    ///\n    /// let c = RefCell::new(5);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub const fn new(value: T) -> RefCell<T> {\n        RefCell {\n            value: UnsafeCell::new(value),\n            borrow: Cell::new(UNUSED),\n        }\n    }\n\n    /// Consumes the `RefCell`, returning the wrapped value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::RefCell;\n    ///\n    /// let c = RefCell::new(5);\n    ///\n    /// let five = c.into_inner();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn into_inner(self) -> T {\n        // Since this function takes `self` (the `RefCell`) by value, the\n        // compiler statically verifies that it is not currently borrowed.\n        // Therefore the following assertion is just a `debug_assert!`.\n        debug_assert!(self.borrow.get() == UNUSED);\n        unsafe { self.value.into_inner() }\n    }\n}\n\nimpl<T: ?Sized> RefCell<T> {\n    /// Immutably borrows the wrapped value.\n    ///\n    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n    /// immutable borrows can be taken out at the same time.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is currently mutably borrowed. For a non-panicking variant, use\n    /// [`try_borrow`](#method.try_borrow).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::RefCell;\n    ///\n    /// let c = RefCell::new(5);\n    ///\n    /// let borrowed_five = c.borrow();\n    /// let borrowed_five2 = c.borrow();\n    /// ```\n    ///\n    /// An example of panic:\n    ///\n    /// ```\n    /// use std::cell::RefCell;\n    /// use std::thread;\n    ///\n    /// let result = thread::spawn(move || {\n    ///    let c = RefCell::new(5);\n    ///    let m = c.borrow_mut();\n    ///\n    ///    let b = c.borrow(); // this causes a panic\n    /// }).join();\n    ///\n    /// assert!(result.is_err());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn borrow(&self) -> Ref<T> {\n        self.try_borrow().expect(\"already mutably borrowed\")\n    }\n\n    /// Immutably borrows the wrapped value, returning an error if the value is currently mutably\n    /// borrowed.\n    ///\n    /// The borrow lasts until the returned `Ref` exits scope. Multiple immutable borrows can be\n    /// taken out at the same time.\n    ///\n    /// This is the non-panicking variant of [`borrow`](#method.borrow).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::RefCell;\n    ///\n    /// let c = RefCell::new(5);\n    ///\n    /// {\n    ///     let m = c.borrow_mut();\n    ///     assert!(c.try_borrow().is_err());\n    /// }\n    ///\n    /// {\n    ///     let m = c.borrow();\n    ///     assert!(c.try_borrow().is_ok());\n    /// }\n    /// ```\n    #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n    #[inline]\n    pub fn try_borrow(&self) -> Result<Ref<T>, BorrowError> {\n        match BorrowRef::new(&self.borrow) {\n            Some(b) => Ok(Ref {\n                value: unsafe { &*self.value.get() },\n                borrow: b,\n            }),\n            None => Err(BorrowError { _private: () }),\n        }\n    }\n\n    /// Mutably borrows the wrapped value.\n    ///\n    /// The borrow lasts until the returned `RefMut` exits scope. The value\n    /// cannot be borrowed while this borrow is active.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is currently borrowed. For a non-panicking variant, use\n    /// [`try_borrow_mut`](#method.try_borrow_mut).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::RefCell;\n    ///\n    /// let c = RefCell::new(5);\n    ///\n    /// *c.borrow_mut() = 7;\n    ///\n    /// assert_eq!(*c.borrow(), 7);\n    /// ```\n    ///\n    /// An example of panic:\n    ///\n    /// ```\n    /// use std::cell::RefCell;\n    /// use std::thread;\n    ///\n    /// let result = thread::spawn(move || {\n    ///    let c = RefCell::new(5);\n    ///    let m = c.borrow();\n    ///\n    ///    let b = c.borrow_mut(); // this causes a panic\n    /// }).join();\n    ///\n    /// assert!(result.is_err());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn borrow_mut(&self) -> RefMut<T> {\n        self.try_borrow_mut().expect(\"already borrowed\")\n    }\n\n    /// Mutably borrows the wrapped value, returning an error if the value is currently borrowed.\n    ///\n    /// The borrow lasts until the returned `RefMut` exits scope. The value cannot be borrowed\n    /// while this borrow is active.\n    ///\n    /// This is the non-panicking variant of [`borrow_mut`](#method.borrow_mut).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::RefCell;\n    ///\n    /// let c = RefCell::new(5);\n    ///\n    /// {\n    ///     let m = c.borrow();\n    ///     assert!(c.try_borrow_mut().is_err());\n    /// }\n    ///\n    /// assert!(c.try_borrow_mut().is_ok());\n    /// ```\n    #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n    #[inline]\n    pub fn try_borrow_mut(&self) -> Result<RefMut<T>, BorrowMutError> {\n        match BorrowRefMut::new(&self.borrow) {\n            Some(b) => Ok(RefMut {\n                value: unsafe { &mut *self.value.get() },\n                borrow: b,\n            }),\n            None => Err(BorrowMutError { _private: () }),\n        }\n    }\n\n    /// Returns a raw pointer to the underlying data in this cell.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::RefCell;\n    ///\n    /// let c = RefCell::new(5);\n    ///\n    /// let ptr = c.as_ptr();\n    /// ```\n    #[inline]\n    #[stable(feature = \"cell_as_ptr\", since = \"1.12.0\")]\n    pub fn as_ptr(&self) -> *mut T {\n        self.value.get()\n    }\n\n    /// Returns a mutable reference to the underlying data.\n    ///\n    /// This call borrows `RefCell` mutably (at compile-time) so there is no\n    /// need for dynamic checks.\n    ///\n    /// However be cautious: this method expects `self` to be mutable, which is\n    /// generally not the case when using a `RefCell`. Take a look at the\n    /// [`borrow_mut`] method instead if `self` isn't mutable.\n    ///\n    /// Also, please be aware that this method is only for special circumstances and is usually\n    /// not you want. In case of doubt, use [`borrow_mut`] instead.\n    ///\n    /// [`borrow_mut`]: #method.borrow_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::RefCell;\n    ///\n    /// let mut c = RefCell::new(5);\n    /// *c.get_mut() += 1;\n    ///\n    /// assert_eq!(c, RefCell::new(6));\n    /// ```\n    #[inline]\n    #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n    pub fn get_mut(&mut self) -> &mut T {\n        unsafe {\n            &mut *self.value.get()\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: ?Sized> Send for RefCell<T> where T: Send {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !Sync for RefCell<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> Clone for RefCell<T> {\n    #[inline]\n    fn clone(&self) -> RefCell<T> {\n        RefCell::new(self.borrow().clone())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T:Default> Default for RefCell<T> {\n    /// Creates a `RefCell<T>`, with the `Default` value for T.\n    #[inline]\n    fn default() -> RefCell<T> {\n        RefCell::new(Default::default())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + PartialEq> PartialEq for RefCell<T> {\n    #[inline]\n    fn eq(&self, other: &RefCell<T>) -> bool {\n        *self.borrow() == *other.borrow()\n    }\n}\n\n#[stable(feature = \"cell_eq\", since = \"1.2.0\")]\nimpl<T: ?Sized + Eq> Eq for RefCell<T> {}\n\n#[stable(feature = \"cell_ord\", since = \"1.10.0\")]\nimpl<T: ?Sized + PartialOrd> PartialOrd for RefCell<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &RefCell<T>) -> Option<Ordering> {\n        self.borrow().partial_cmp(&*other.borrow())\n    }\n\n    #[inline]\n    fn lt(&self, other: &RefCell<T>) -> bool {\n        *self.borrow() < *other.borrow()\n    }\n\n    #[inline]\n    fn le(&self, other: &RefCell<T>) -> bool {\n        *self.borrow() <= *other.borrow()\n    }\n\n    #[inline]\n    fn gt(&self, other: &RefCell<T>) -> bool {\n        *self.borrow() > *other.borrow()\n    }\n\n    #[inline]\n    fn ge(&self, other: &RefCell<T>) -> bool {\n        *self.borrow() >= *other.borrow()\n    }\n}\n\n#[stable(feature = \"cell_ord\", since = \"1.10.0\")]\nimpl<T: ?Sized + Ord> Ord for RefCell<T> {\n    #[inline]\n    fn cmp(&self, other: &RefCell<T>) -> Ordering {\n        self.borrow().cmp(&*other.borrow())\n    }\n}\n\n#[stable(feature = \"cell_from\", since = \"1.12.0\")]\nimpl<T> From<T> for RefCell<T> {\n    fn from(t: T) -> RefCell<T> {\n        RefCell::new(t)\n    }\n}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: CoerceUnsized<U>, U> CoerceUnsized<RefCell<U>> for RefCell<T> {}\n\nstruct BorrowRef<'b> {\n    borrow: &'b Cell<BorrowFlag>,\n}\n\nimpl<'b> BorrowRef<'b> {\n    #[inline]\n    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRef<'b>> {\n        match borrow.get() {\n            WRITING => None,\n            b => {\n                borrow.set(b + 1);\n                Some(BorrowRef { borrow: borrow })\n            },\n        }\n    }\n}\n\nimpl<'b> Drop for BorrowRef<'b> {\n    #[inline]\n    fn drop(&mut self) {\n        let borrow = self.borrow.get();\n        debug_assert!(borrow != WRITING && borrow != UNUSED);\n        self.borrow.set(borrow - 1);\n    }\n}\n\nimpl<'b> Clone for BorrowRef<'b> {\n    #[inline]\n    fn clone(&self) -> BorrowRef<'b> {\n        // Since this Ref exists, we know the borrow flag\n        // is not set to WRITING.\n        let borrow = self.borrow.get();\n        debug_assert!(borrow != UNUSED);\n        // Prevent the borrow counter from overflowing.\n        assert!(borrow != WRITING);\n        self.borrow.set(borrow + 1);\n        BorrowRef { borrow: self.borrow }\n    }\n}\n\n/// Wraps a borrowed reference to a value in a `RefCell` box.\n/// A wrapper type for an immutably borrowed value from a `RefCell<T>`.\n///\n/// See the [module-level documentation](index.html) for more.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Ref<'b, T: ?Sized + 'b> {\n    value: &'b T,\n    borrow: BorrowRef<'b>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'b, T: ?Sized> Deref for Ref<'b, T> {\n    type Target = T;\n\n    #[inline]\n    fn deref(&self) -> &T {\n        self.value\n    }\n}\n\nimpl<'b, T: ?Sized> Ref<'b, T> {\n    /// Copies a `Ref`.\n    ///\n    /// The `RefCell` is already immutably borrowed, so this cannot fail.\n    ///\n    /// This is an associated function that needs to be used as\n    /// `Ref::clone(...)`.  A `Clone` implementation or a method would interfere\n    /// with the widespread use of `r.borrow().clone()` to clone the contents of\n    /// a `RefCell`.\n    #[stable(feature = \"cell_extras\", since = \"1.15.0\")]\n    #[inline]\n    pub fn clone(orig: &Ref<'b, T>) -> Ref<'b, T> {\n        Ref {\n            value: orig.value,\n            borrow: orig.borrow.clone(),\n        }\n    }\n\n    /// Make a new `Ref` for a component of the borrowed data.\n    ///\n    /// The `RefCell` is already immutably borrowed, so this cannot fail.\n    ///\n    /// This is an associated function that needs to be used as `Ref::map(...)`.\n    /// A method would interfere with methods of the same name on the contents\n    /// of a `RefCell` used through `Deref`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::cell::{RefCell, Ref};\n    ///\n    /// let c = RefCell::new((5, 'b'));\n    /// let b1: Ref<(u32, char)> = c.borrow();\n    /// let b2: Ref<u32> = Ref::map(b1, |t| &t.0);\n    /// assert_eq!(*b2, 5)\n    /// ```\n    #[stable(feature = \"cell_map\", since = \"1.8.0\")]\n    #[inline]\n    pub fn map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Ref<'b, U>\n        where F: FnOnce(&T) -> &U\n    {\n        Ref {\n            value: f(orig.value),\n            borrow: orig.borrow,\n        }\n    }\n}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<'b, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Ref<'b, U>> for Ref<'b, T> {}\n\n#[stable(feature = \"std_guard_impls\", since = \"1.20\")]\nimpl<'a, T: ?Sized + fmt::Display> fmt::Display for Ref<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.value.fmt(f)\n    }\n}\n\nimpl<'b, T: ?Sized> RefMut<'b, T> {\n    /// Make a new `RefMut` for a component of the borrowed data, e.g. an enum\n    /// variant.\n    ///\n    /// The `RefCell` is already mutably borrowed, so this cannot fail.\n    ///\n    /// This is an associated function that needs to be used as\n    /// `RefMut::map(...)`.  A method would interfere with methods of the same\n    /// name on the contents of a `RefCell` used through `Deref`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::cell::{RefCell, RefMut};\n    ///\n    /// let c = RefCell::new((5, 'b'));\n    /// {\n    ///     let b1: RefMut<(u32, char)> = c.borrow_mut();\n    ///     let mut b2: RefMut<u32> = RefMut::map(b1, |t| &mut t.0);\n    ///     assert_eq!(*b2, 5);\n    ///     *b2 = 42;\n    /// }\n    /// assert_eq!(*c.borrow(), (42, 'b'));\n    /// ```\n    #[stable(feature = \"cell_map\", since = \"1.8.0\")]\n    #[inline]\n    pub fn map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> RefMut<'b, U>\n        where F: FnOnce(&mut T) -> &mut U\n    {\n        RefMut {\n            value: f(orig.value),\n            borrow: orig.borrow,\n        }\n    }\n}\n\nstruct BorrowRefMut<'b> {\n    borrow: &'b Cell<BorrowFlag>,\n}\n\nimpl<'b> Drop for BorrowRefMut<'b> {\n    #[inline]\n    fn drop(&mut self) {\n        let borrow = self.borrow.get();\n        debug_assert!(borrow == WRITING);\n        self.borrow.set(UNUSED);\n    }\n}\n\nimpl<'b> BorrowRefMut<'b> {\n    #[inline]\n    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRefMut<'b>> {\n        match borrow.get() {\n            UNUSED => {\n                borrow.set(WRITING);\n                Some(BorrowRefMut { borrow: borrow })\n            },\n            _ => None,\n        }\n    }\n}\n\n/// A wrapper type for a mutably borrowed value from a `RefCell<T>`.\n///\n/// See the [module-level documentation](index.html) for more.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RefMut<'b, T: ?Sized + 'b> {\n    value: &'b mut T,\n    borrow: BorrowRefMut<'b>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'b, T: ?Sized> Deref for RefMut<'b, T> {\n    type Target = T;\n\n    #[inline]\n    fn deref(&self) -> &T {\n        self.value\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'b, T: ?Sized> DerefMut for RefMut<'b, T> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut T {\n        self.value\n    }\n}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<'b, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<RefMut<'b, U>> for RefMut<'b, T> {}\n\n#[stable(feature = \"std_guard_impls\", since = \"1.20\")]\nimpl<'a, T: ?Sized + fmt::Display> fmt::Display for RefMut<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.value.fmt(f)\n    }\n}\n\n/// The core primitive for interior mutability in Rust.\n///\n/// `UnsafeCell<T>` is a type that wraps some `T` and indicates unsafe interior operations on the\n/// wrapped type. Types with an `UnsafeCell<T>` field are considered to have an 'unsafe interior'.\n/// The `UnsafeCell<T>` type is the only legal way to obtain aliasable data that is considered\n/// mutable. In general, transmuting an `&T` type into an `&mut T` is considered undefined behavior.\n///\n/// The compiler makes optimizations based on the knowledge that `&T` is not mutably aliased or\n/// mutated, and that `&mut T` is unique. When building abstractions like `Cell`, `RefCell`,\n/// `Mutex`, etc, you need to turn these optimizations off. `UnsafeCell` is the only legal way\n/// to do this. When `UnsafeCell<T>` is immutably aliased, it is still safe to obtain a mutable\n/// reference to its interior and/or to mutate it. However, it is up to the abstraction designer\n/// to ensure that no two mutable references obtained this way are active at the same time, and\n/// that there are no active mutable references or mutations when an immutable reference is obtained\n/// from the cell. This is often done via runtime checks.\n///\n/// Note that while mutating or mutably aliasing the contents of an `& UnsafeCell<T>` is\n/// okay (provided you enforce the invariants some other way); it is still undefined behavior\n/// to have multiple `&mut UnsafeCell<T>` aliases.\n///\n///\n/// Types like `Cell<T>` and `RefCell<T>` use this type to wrap their internal data.\n///\n/// # Examples\n///\n/// ```\n/// use std::cell::UnsafeCell;\n/// use std::marker::Sync;\n///\n/// # #[allow(dead_code)]\n/// struct NotThreadSafe<T> {\n///     value: UnsafeCell<T>,\n/// }\n///\n/// unsafe impl<T> Sync for NotThreadSafe<T> {}\n/// ```\n#[lang = \"unsafe_cell\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct UnsafeCell<T: ?Sized> {\n    value: T,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !Sync for UnsafeCell<T> {}\n\nimpl<T> UnsafeCell<T> {\n    /// Constructs a new instance of `UnsafeCell` which will wrap the specified\n    /// value.\n    ///\n    /// All access to the inner value through methods is `unsafe`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::UnsafeCell;\n    ///\n    /// let uc = UnsafeCell::new(5);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub const fn new(value: T) -> UnsafeCell<T> {\n        UnsafeCell { value: value }\n    }\n\n    /// Unwraps the value.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because this thread or another thread may currently be\n    /// inspecting the inner value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::UnsafeCell;\n    ///\n    /// let uc = UnsafeCell::new(5);\n    ///\n    /// let five = unsafe { uc.into_inner() };\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn into_inner(self) -> T {\n        self.value\n    }\n}\n\nimpl<T: ?Sized> UnsafeCell<T> {\n    /// Gets a mutable pointer to the wrapped value.\n    ///\n    /// This can be cast to a pointer of any kind.\n    /// Ensure that the access is unique when casting to\n    /// `&mut T`, and ensure that there are no mutations or mutable\n    /// aliases going on when casting to `&T`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::UnsafeCell;\n    ///\n    /// let uc = UnsafeCell::new(5);\n    ///\n    /// let five = uc.get();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get(&self) -> *mut T {\n        &self.value as *const T as *mut T\n    }\n}\n\n#[stable(feature = \"unsafe_cell_default\", since = \"1.10.0\")]\nimpl<T: Default> Default for UnsafeCell<T> {\n    /// Creates an `UnsafeCell`, with the `Default` value for T.\n    fn default() -> UnsafeCell<T> {\n        UnsafeCell::new(Default::default())\n    }\n}\n\n#[stable(feature = \"cell_from\", since = \"1.12.0\")]\nimpl<T> From<T> for UnsafeCell<T> {\n    fn from(t: T) -> UnsafeCell<T> {\n        UnsafeCell::new(t)\n    }\n}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: CoerceUnsized<U>, U> CoerceUnsized<UnsafeCell<U>> for UnsafeCell<T> {}\n\n#[allow(unused)]\nfn assert_coerce_unsized(a: UnsafeCell<&i32>, b: Cell<&i32>, c: RefCell<&i32>) {\n    let _: UnsafeCell<&Send> = a;\n    let _: Cell<&Send> = b;\n    let _: RefCell<&Send> = c;\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Basic functions for dealing with memory.\n//!\n//! This module contains functions for querying the size and alignment of\n//! types, initializing and manipulating memory.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse clone;\nuse cmp;\nuse fmt;\nuse hash;\nuse intrinsics;\nuse marker::{Copy, PhantomData, Sized};\nuse ptr;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use intrinsics::transmute;\n\n/// Leaks a value: takes ownership and \"forgets\" about the value **without running\n/// its destructor**.\n///\n/// Any resources the value manages, such as heap memory or a file handle, will linger\n/// forever in an unreachable state.\n///\n/// If you want to dispose of a value properly, running its destructor, see\n/// [`mem::drop`][drop].\n///\n/// # Safety\n///\n/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n/// do not include a guarantee that destructors will always run. For example,\n/// a program can create a reference cycle using [`Rc`][rc], or call\n/// [`process::exit`][exit] to exit without running destructors. Thus, allowing\n/// `mem::forget` from safe code does not fundamentally change Rust's safety\n/// guarantees.\n///\n/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n/// so `forget` is only recommended for specialized use cases like those shown below.\n///\n/// Because forgetting a value is allowed, any `unsafe` code you write must\n/// allow for this possibility. You cannot return a value and expect that the\n/// caller will necessarily run the value's destructor.\n///\n/// [rc]: ../../std/rc/struct.Rc.html\n/// [exit]: ../../std/process/fn.exit.html\n///\n/// # Examples\n///\n/// Leak some heap memory by never deallocating it:\n///\n/// ```\n/// use std::mem;\n///\n/// let heap_memory = Box::new(3);\n/// mem::forget(heap_memory);\n/// ```\n///\n/// Leak an I/O object, never closing the file:\n///\n/// ```no_run\n/// use std::mem;\n/// use std::fs::File;\n///\n/// let file = File::open(\"foo.txt\").unwrap();\n/// mem::forget(file);\n/// ```\n///\n/// The practical use cases for `forget` are rather specialized and mainly come\n/// up in unsafe or FFI code.\n///\n/// ## Use case 1\n///\n/// You have created an uninitialized value using [`mem::uninitialized`][uninit].\n/// You must either initialize or `forget` it on every computation path before\n/// Rust drops it automatically, like at the end of a scope or after a panic.\n/// Running the destructor on an uninitialized value would be [undefined behavior][ub].\n///\n/// ```\n/// use std::mem;\n/// use std::ptr;\n///\n/// # let some_condition = false;\n/// unsafe {\n///     let mut uninit_vec: Vec<u32> = mem::uninitialized();\n///\n///     if some_condition {\n///         // Initialize the variable.\n///         ptr::write(&mut uninit_vec, Vec::new());\n///     } else {\n///         // Forget the uninitialized value so its destructor doesn't run.\n///         mem::forget(uninit_vec);\n///     }\n/// }\n/// ```\n///\n/// ## Use case 2\n///\n/// You have duplicated the bytes making up a value, without doing a proper\n/// [`Clone`][clone]. You need the value's destructor to run only once,\n/// because a double `free` is undefined behavior.\n///\n/// An example is a possible implementation of [`mem::swap`][swap]:\n///\n/// ```\n/// use std::mem;\n/// use std::ptr;\n///\n/// # #[allow(dead_code)]\n/// fn swap<T>(x: &mut T, y: &mut T) {\n///     unsafe {\n///         // Give ourselves some scratch space to work with\n///         let mut t: T = mem::uninitialized();\n///\n///         // Perform the swap, `&mut` pointers never alias\n///         ptr::copy_nonoverlapping(&*x, &mut t, 1);\n///         ptr::copy_nonoverlapping(&*y, x, 1);\n///         ptr::copy_nonoverlapping(&t, y, 1);\n///\n///         // y and t now point to the same thing, but we need to completely\n///         // forget `t` because we do not want to run the destructor for `T`\n///         // on its value, which is still owned somewhere outside this function.\n///         mem::forget(t);\n///     }\n/// }\n/// ```\n///\n/// ## Use case 3\n///\n/// You are transferring ownership across a [FFI] boundary to code written in\n/// another language. You need to `forget` the value on the Rust side because Rust\n/// code is no longer responsible for it.\n///\n/// ```no_run\n/// use std::mem;\n///\n/// extern \"C\" {\n///     fn my_c_function(x: *const u32);\n/// }\n///\n/// let x: Box<u32> = Box::new(3);\n///\n/// // Transfer ownership into C code.\n/// unsafe {\n///     my_c_function(&*x);\n/// }\n/// mem::forget(x);\n/// ```\n///\n/// In this case, C code must call back into Rust to free the object. Calling C's `free`\n/// function on a [`Box`][box] is *not* safe! Also, `Box` provides an [`into_raw`][into_raw]\n/// method which is the preferred way to do this in practice.\n///\n/// [drop]: fn.drop.html\n/// [uninit]: fn.uninitialized.html\n/// [clone]: ../clone/trait.Clone.html\n/// [swap]: fn.swap.html\n/// [FFI]: ../../book/first-edition/ffi.html\n/// [box]: ../../std/boxed/struct.Box.html\n/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n/// [ub]: ../../reference/behavior-considered-undefined.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn forget<T>(t: T) {\n    ManuallyDrop::new(t);\n}\n\n/// Returns the size of a type in bytes.\n///\n/// More specifically, this is the offset in bytes between successive\n/// items of the same type, including alignment padding.\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::size_of::<i32>());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn size_of<T>() -> usize {\n    unsafe { intrinsics::size_of::<T>() }\n}\n\n/// Returns the size of the pointed-to value in bytes.\n///\n/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n/// statically known size, e.g. a slice [`[T]`][slice] or a [trait object],\n/// then `size_of_val` can be used to get the dynamically-known size.\n///\n/// [slice]: ../../std/primitive.slice.html\n/// [trait object]: ../../book/first-edition/trait-objects.html\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::size_of_val(&5i32));\n///\n/// let x: [u8; 13] = [0; 13];\n/// let y: &[u8] = &x;\n/// assert_eq!(13, mem::size_of_val(y));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n    unsafe { intrinsics::size_of_val(val) }\n}\n\n/// Returns the [ABI]-required minimum alignment of a type.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// # #![allow(deprecated)]\n/// use std::mem;\n///\n/// assert_eq!(4, mem::min_align_of::<i32>());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\npub fn min_align_of<T>() -> usize {\n    unsafe { intrinsics::min_align_of::<T>() }\n}\n\n/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// # #![allow(deprecated)]\n/// use std::mem;\n///\n/// assert_eq!(4, mem::min_align_of_val(&5i32));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\npub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n    unsafe { intrinsics::min_align_of_val(val) }\n}\n\n/// Returns the [ABI]-required minimum alignment of a type.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::align_of::<i32>());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn align_of<T>() -> usize {\n    unsafe { intrinsics::min_align_of::<T>() }\n}\n\n/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::align_of_val(&5i32));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n    unsafe { intrinsics::min_align_of_val(val) }\n}\n\n/// Returns whether dropping values of type `T` matters.\n///\n/// This is purely an optimization hint, and may be implemented conservatively.\n/// For instance, always returning `true` would be a valid implementation of\n/// this function.\n///\n/// Low level implementations of things like collections, which need to manually\n/// drop their data, should use this function to avoid unnecessarily\n/// trying to drop all their contents when they are destroyed. This might not\n/// make a difference in release builds (where a loop that has no side-effects\n/// is easily detected and eliminated), but is often a big win for debug builds.\n///\n/// Note that `ptr::drop_in_place` already performs this check, so if your workload\n/// can be reduced to some small number of drop_in_place calls, using this is\n/// unnecessary. In particular note that you can drop_in_place a slice, and that\n/// will do a single needs_drop check for all the values.\n///\n/// Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n/// needs_drop explicitly. Types like HashMap, on the other hand, have to drop\n/// values one at a time and should use this API.\n///\n///\n/// # Examples\n///\n/// Here's an example of how a collection might make use of needs_drop:\n///\n/// ```\n/// #![feature(needs_drop)]\n/// use std::{mem, ptr};\n///\n/// pub struct MyCollection<T> {\n/// #   data: [T; 1],\n///     /* ... */\n/// }\n/// # impl<T> MyCollection<T> {\n/// #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n/// #   fn free_buffer(&mut self) {}\n/// # }\n///\n/// impl<T> Drop for MyCollection<T> {\n///     fn drop(&mut self) {\n///         unsafe {\n///             // drop the data\n///             if mem::needs_drop::<T>() {\n///                 for x in self.iter_mut() {\n///                     ptr::drop_in_place(x);\n///                 }\n///             }\n///             self.free_buffer();\n///         }\n///     }\n/// }\n/// ```\n#[inline]\n#[unstable(feature = \"needs_drop\", issue = \"41890\")]\npub fn needs_drop<T>() -> bool {\n    unsafe { intrinsics::needs_drop::<T>() }\n}\n\n/// Creates a value whose bytes are all zero.\n///\n/// This has the same effect as allocating space with\n/// [`mem::uninitialized`][uninit] and then zeroing it out. It is useful for\n/// [FFI] sometimes, but should generally be avoided.\n///\n/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n/// some type `T`. If `T` has a destructor and the value is destroyed (due to\n/// a panic or the end of a scope) before being initialized, then the destructor\n/// will run on zeroed data, likely leading to [undefined behavior][ub].\n///\n/// See also the documentation for [`mem::uninitialized`][uninit], which has\n/// many of the same caveats.\n///\n/// [uninit]: fn.uninitialized.html\n/// [FFI]: ../../book/first-edition/ffi.html\n/// [ub]: ../../reference/behavior-considered-undefined.html\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// let x: i32 = unsafe { mem::zeroed() };\n/// assert_eq!(0, x);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn zeroed<T>() -> T {\n    intrinsics::init()\n}\n\n/// Bypasses Rust's normal memory-initialization checks by pretending to\n/// produce a value of type `T`, while doing nothing at all.\n///\n/// **This is incredibly dangerous and should not be done lightly. Deeply\n/// consider initializing your memory with a default value instead.**\n///\n/// This is useful for [FFI] functions and initializing arrays sometimes,\n/// but should generally be avoided.\n///\n/// [FFI]: ../../book/first-edition/ffi.html\n///\n/// # Undefined behavior\n///\n/// It is [undefined behavior][ub] to read uninitialized memory, even just an\n/// uninitialized boolean. For instance, if you branch on the value of such\n/// a boolean, your program may take one, both, or neither of the branches.\n///\n/// Writing to the uninitialized value is similarly dangerous. Rust believes the\n/// value is initialized, and will therefore try to [`Drop`] the uninitialized\n/// value and its fields if you try to overwrite it in a normal manner. The only way\n/// to safely initialize an uninitialized value is with [`ptr::write`][write],\n/// [`ptr::copy`][copy], or [`ptr::copy_nonoverlapping`][copy_no].\n///\n/// If the value does implement [`Drop`], it must be initialized before\n/// it goes out of scope (and therefore would be dropped). Note that this\n/// includes a `panic` occurring and unwinding the stack suddenly.\n///\n/// # Examples\n///\n/// Here's how to safely initialize an array of [`Vec`]s.\n///\n/// ```\n/// use std::mem;\n/// use std::ptr;\n///\n/// // Only declare the array. This safely leaves it\n/// // uninitialized in a way that Rust will track for us.\n/// // However we can't initialize it element-by-element\n/// // safely, and we can't use the `[value; 1000]`\n/// // constructor because it only works with `Copy` data.\n/// let mut data: [Vec<u32>; 1000];\n///\n/// unsafe {\n///     // So we need to do this to initialize it.\n///     data = mem::uninitialized();\n///\n///     // DANGER ZONE: if anything panics or otherwise\n///     // incorrectly reads the array here, we will have\n///     // Undefined Behavior.\n///\n///     // It's ok to mutably iterate the data, since this\n///     // doesn't involve reading it at all.\n///     // (ptr and len are statically known for arrays)\n///     for elem in &mut data[..] {\n///         // *elem = Vec::new() would try to drop the\n///         // uninitialized memory at `elem` -- bad!\n///         //\n///         // Vec::new doesn't allocate or do really\n///         // anything. It's only safe to call here\n///         // because we know it won't panic.\n///         ptr::write(elem, Vec::new());\n///     }\n///\n///     // SAFE ZONE: everything is initialized.\n/// }\n///\n/// println!(\"{:?}\", &data[0]);\n/// ```\n///\n/// This example emphasizes exactly how delicate and dangerous using `mem::uninitialized`\n/// can be. Note that the [`vec!`] macro *does* let you initialize every element with a\n/// value that is only [`Clone`], so the following is semantically equivalent and\n/// vastly less dangerous, as long as you can live with an extra heap\n/// allocation:\n///\n/// ```\n/// let data: Vec<Vec<u32>> = vec![Vec::new(); 1000];\n/// println!(\"{:?}\", &data[0]);\n/// ```\n///\n/// [`Vec`]: ../../std/vec/struct.Vec.html\n/// [`vec!`]: ../../std/macro.vec.html\n/// [`Clone`]: ../../std/clone/trait.Clone.html\n/// [ub]: ../../reference/behavior-considered-undefined.html\n/// [write]: ../ptr/fn.write.html\n/// [copy]: ../intrinsics/fn.copy.html\n/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n/// [`Drop`]: ../ops/trait.Drop.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn uninitialized<T>() -> T {\n    intrinsics::uninit()\n}\n\n/// Swaps the values at two mutable locations, without deinitializing either one.\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// let mut x = 5;\n/// let mut y = 42;\n///\n/// mem::swap(&mut x, &mut y);\n///\n/// assert_eq!(42, x);\n/// assert_eq!(5, y);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn swap<T>(x: &mut T, y: &mut T) {\n    unsafe {\n        ptr::swap_nonoverlapping(x, y, 1);\n    }\n}\n\n/// Replaces the value at a mutable location with a new one, returning the old value, without\n/// deinitializing either one.\n///\n/// # Examples\n///\n/// A simple example:\n///\n/// ```\n/// use std::mem;\n///\n/// let mut v: Vec<i32> = vec![1, 2];\n///\n/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n/// assert_eq!(2, old_v.len());\n/// assert_eq!(3, v.len());\n/// ```\n///\n/// `replace` allows consumption of a struct field by replacing it with another value.\n/// Without `replace` you can run into issues like these:\n///\n/// ```compile_fail,E0507\n/// struct Buffer<T> { buf: Vec<T> }\n///\n/// impl<T> Buffer<T> {\n///     fn get_and_reset(&mut self) -> Vec<T> {\n///         // error: cannot move out of dereference of `&mut`-pointer\n///         let buf = self.buf;\n///         self.buf = Vec::new();\n///         buf\n///     }\n/// }\n/// ```\n///\n/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n/// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n/// `self`, allowing it to be returned:\n///\n/// ```\n/// # #![allow(dead_code)]\n/// use std::mem;\n///\n/// # struct Buffer<T> { buf: Vec<T> }\n/// impl<T> Buffer<T> {\n///     fn get_and_reset(&mut self) -> Vec<T> {\n///         mem::replace(&mut self.buf, Vec::new())\n///     }\n/// }\n/// ```\n///\n/// [`Clone`]: ../../std/clone/trait.Clone.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn replace<T>(dest: &mut T, mut src: T) -> T {\n    swap(dest, &mut src);\n    src\n}\n\n/// Disposes of a value.\n///\n/// While this does call the argument's implementation of [`Drop`][drop],\n/// it will not release any borrows, as borrows are based on lexical scope.\n///\n/// This effectively does nothing for\n/// [types which implement `Copy`](../../book/first-edition/ownership.html#copy-types),\n/// e.g. integers. Such values are copied and _then_ moved into the function,\n/// so the value persists after this function call.\n///\n/// This function is not magic; it is literally defined as\n///\n/// ```\n/// pub fn drop<T>(_x: T) { }\n/// ```\n///\n/// Because `_x` is moved into the function, it is automatically dropped before\n/// the function returns.\n///\n/// [drop]: ../ops/trait.Drop.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let v = vec![1, 2, 3];\n///\n/// drop(v); // explicitly drop the vector\n/// ```\n///\n/// Borrows are based on lexical scope, so this produces an error:\n///\n/// ```compile_fail,E0502\n/// let mut v = vec![1, 2, 3];\n/// let x = &v[0];\n///\n/// drop(x); // explicitly drop the reference, but the borrow still exists\n///\n/// v.push(4); // error: cannot borrow `v` as mutable because it is also\n///            // borrowed as immutable\n/// ```\n///\n/// An inner scope is needed to fix this:\n///\n/// ```\n/// let mut v = vec![1, 2, 3];\n///\n/// {\n///     let x = &v[0];\n///\n///     drop(x); // this is now redundant, as `x` is going out of scope anyway\n/// }\n///\n/// v.push(4); // no problems\n/// ```\n///\n/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n/// release a [`RefCell`] borrow:\n///\n/// ```\n/// use std::cell::RefCell;\n///\n/// let x = RefCell::new(1);\n///\n/// let mut mutable_borrow = x.borrow_mut();\n/// *mutable_borrow = 1;\n///\n/// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n///\n/// let borrow = x.borrow();\n/// println!(\"{}\", *borrow);\n/// ```\n///\n/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n///\n/// ```\n/// #[derive(Copy, Clone)]\n/// struct Foo(u8);\n///\n/// let x = 1;\n/// let y = Foo(2);\n/// drop(x); // a copy of `x` is moved and dropped\n/// drop(y); // a copy of `y` is moved and dropped\n///\n/// println!(\"x: {}, y: {}\", x, y.0); // still available\n/// ```\n///\n/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n/// [`Copy`]: ../../std/marker/trait.Copy.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn drop<T>(_x: T) { }\n\n/// Interprets `src` as having type `&U`, and then reads `src` without moving\n/// the contained value.\n///\n/// This function will unsafely assume the pointer `src` is valid for\n/// [`size_of::<U>`][size_of] bytes by transmuting `&T` to `&U` and then reading\n/// the `&U`. It will also unsafely create a copy of the contained value instead of\n/// moving out of `src`.\n///\n/// It is not a compile-time error if `T` and `U` have different sizes, but it\n/// is highly encouraged to only invoke this function where `T` and `U` have the\n/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n/// `T`.\n///\n/// [ub]: ../../reference/behavior-considered-undefined.html\n/// [size_of]: fn.size_of.html\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// #[repr(packed)]\n/// struct Foo {\n///     bar: u8,\n/// }\n///\n/// let foo_slice = [10u8];\n///\n/// unsafe {\n///     // Copy the data from 'foo_slice' and treat it as a 'Foo'\n///     let mut foo_struct: Foo = mem::transmute_copy(&foo_slice);\n///     assert_eq!(foo_struct.bar, 10);\n///\n///     // Modify the copied data\n///     foo_struct.bar = 20;\n///     assert_eq!(foo_struct.bar, 20);\n/// }\n///\n/// // The contents of 'foo_slice' should not have changed\n/// assert_eq!(foo_slice, [10]);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n    ptr::read(src as *const T as *const U)\n}\n\n/// Opaque type representing the discriminant of an enum.\n///\n/// See the `discriminant` function in this module for more information.\n#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\npub struct Discriminant<T>(u64, PhantomData<*const T>);\n\n// N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n\n#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\nimpl<T> Copy for Discriminant<T> {}\n\n#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\nimpl<T> clone::Clone for Discriminant<T> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\n#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\nimpl<T> cmp::PartialEq for Discriminant<T> {\n    fn eq(&self, rhs: &Self) -> bool {\n        self.0 == rhs.0\n    }\n}\n\n#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\nimpl<T> cmp::Eq for Discriminant<T> {}\n\n#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\nimpl<T> hash::Hash for Discriminant<T> {\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        self.0.hash(state);\n    }\n}\n\n#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\nimpl<T> fmt::Debug for Discriminant<T> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_tuple(\"Discriminant\")\n           .field(&self.0)\n           .finish()\n    }\n}\n\n/// Returns a value uniquely identifying the enum variant in `v`.\n///\n/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n/// return value is unspecified.\n///\n/// # Stability\n///\n/// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n/// of some variant will not change between compilations with the same compiler.\n///\n/// # Examples\n///\n/// This can be used to compare enums that carry data, while disregarding\n/// the actual data:\n///\n/// ```\n/// #![feature(discriminant_value)]\n/// use std::mem;\n///\n/// enum Foo { A(&'static str), B(i32), C(i32) }\n///\n/// assert!(mem::discriminant(&Foo::A(\"bar\")) == mem::discriminant(&Foo::A(\"baz\")));\n/// assert!(mem::discriminant(&Foo::B(1))     == mem::discriminant(&Foo::B(2)));\n/// assert!(mem::discriminant(&Foo::B(3))     != mem::discriminant(&Foo::C(3)));\n/// ```\n#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\npub fn discriminant<T>(v: &T) -> Discriminant<T> {\n    unsafe {\n        Discriminant(intrinsics::discriminant_value(v), PhantomData)\n    }\n}\n\n\n/// A wrapper to inhibit compiler from automatically calling `T`s destructor.\n///\n/// This wrapper is 0-cost.\n///\n/// # Examples\n///\n/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n/// the type:\n///\n/// ```rust\n/// # #![feature(manually_drop)]\n/// use std::mem::ManuallyDrop;\n/// struct Peach;\n/// struct Banana;\n/// struct Melon;\n/// struct FruitBox {\n///     // Immediately clear theres something non-trivial going on with these fields.\n///     peach: ManuallyDrop<Peach>,\n///     melon: Melon, // Field thats independent of the other two.\n///     banana: ManuallyDrop<Banana>,\n/// }\n///\n/// impl Drop for FruitBox {\n///     fn drop(&mut self) {\n///         unsafe {\n///             // Explicit ordering in which field destructors are run specified in the intuitive\n///             // location  the destructor of the structure containing the fields.\n///             // Moreover, one can now reorder fields within the struct however much they want.\n///             ManuallyDrop::drop(&mut self.peach);\n///             ManuallyDrop::drop(&mut self.banana);\n///         }\n///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n///     }\n/// }\n/// ```\n#[unstable(feature = \"manually_drop\", issue = \"40673\")]\n#[allow(unions_with_drop_fields)]\npub union ManuallyDrop<T>{ value: T }\n\nimpl<T> ManuallyDrop<T> {\n    /// Wrap a value to be manually dropped.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #![feature(manually_drop)]\n    /// use std::mem::ManuallyDrop;\n    /// ManuallyDrop::new(Box::new(()));\n    /// ```\n    #[unstable(feature = \"manually_drop\", issue = \"40673\")]\n    #[inline]\n    pub fn new(value: T) -> ManuallyDrop<T> {\n        ManuallyDrop { value: value }\n    }\n\n    /// Extract the value from the ManuallyDrop container.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #![feature(manually_drop)]\n    /// use std::mem::ManuallyDrop;\n    /// let x = ManuallyDrop::new(Box::new(()));\n    /// let _: Box<()> = ManuallyDrop::into_inner(x);\n    /// ```\n    #[unstable(feature = \"manually_drop\", issue = \"40673\")]\n    #[inline]\n    pub fn into_inner(slot: ManuallyDrop<T>) -> T {\n        unsafe {\n            slot.value\n        }\n    }\n\n    /// Manually drops the contained value.\n    ///\n    /// # Unsafety\n    ///\n    /// This function runs the destructor of the contained value and thus the wrapped value\n    /// now represents uninitialized data. It is up to the user of this method to ensure the\n    /// uninitialized data is not actually used.\n    #[unstable(feature = \"manually_drop\", issue = \"40673\")]\n    #[inline]\n    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n        ptr::drop_in_place(&mut slot.value)\n    }\n}\n\n#[unstable(feature = \"manually_drop\", issue = \"40673\")]\nimpl<T> ::ops::Deref for ManuallyDrop<T> {\n    type Target = T;\n    #[inline]\n    fn deref(&self) -> &Self::Target {\n        unsafe {\n            &self.value\n        }\n    }\n}\n\n#[unstable(feature = \"manually_drop\", issue = \"40673\")]\nimpl<T> ::ops::DerefMut for ManuallyDrop<T> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        unsafe {\n            &mut self.value\n        }\n    }\n}\n\n#[unstable(feature = \"manually_drop\", issue = \"40673\")]\nimpl<T: ::fmt::Debug> ::fmt::Debug for ManuallyDrop<T> {\n    fn fmt(&self, fmt: &mut ::fmt::Formatter) -> ::fmt::Result {\n        unsafe {\n            fmt.debug_tuple(\"ManuallyDrop\").field(&self.value).finish()\n        }\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n//! Thread-safe reference-counting pointers.\n//!\n//! See the [`Arc<T>`][arc] documentation for more details.\n//!\n//! [arc]: struct.Arc.html\n\nuse boxed::Box;\n\nuse core::sync::atomic;\nuse core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\nuse core::borrow;\nuse core::fmt;\nuse core::cmp::Ordering;\nuse core::mem::{align_of_val, size_of_val};\nuse core::intrinsics::abort;\nuse core::mem;\nuse core::mem::uninitialized;\nuse core::ops::Deref;\nuse core::ops::CoerceUnsized;\nuse core::ptr::{self, Shared};\nuse core::marker::Unsize;\nuse core::hash::{Hash, Hasher};\nuse core::{isize, usize};\nuse core::convert::From;\nuse heap::deallocate;\n\n/// A soft limit on the amount of references that may be made to an `Arc`.\n///\n/// Going above this limit will abort your program (although not\n/// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\nconst MAX_REFCOUNT: usize = (isize::MAX) as usize;\n\n/// A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically\n/// Reference Counted'.\n///\n/// The type `Arc<T>` provides shared ownership of a value of type `T`,\n/// allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n/// a new pointer to the same value in the heap. When the last `Arc`\n/// pointer to a given value is destroyed, the pointed-to value is\n/// also destroyed.\n///\n/// Shared references in Rust disallow mutation by default, and `Arc` is no\n/// exception. If you need to mutate through an `Arc`, use [`Mutex`][mutex],\n/// [`RwLock`][rwlock], or one of the [`Atomic`][atomic] types.\n///\n/// ## Thread Safety\n///\n/// Unlike [`Rc<T>`], `Arc<T>` uses atomic operations for its reference\n/// counting  This means that it is thread-safe. The disadvantage is that\n/// atomic operations are more expensive than ordinary memory accesses. If you\n/// are not sharing reference-counted values between threads, consider using\n/// [`Rc<T>`] for lower overhead. [`Rc<T>`] is a safe default, because the\n/// compiler will catch any attempt to send an [`Rc<T>`] between threads.\n/// However, a library might choose `Arc<T>` in order to give library consumers\n/// more flexibility.\n///\n/// `Arc<T>` will implement [`Send`] and [`Sync`] as long as the `T` implements\n/// [`Send`] and [`Sync`]. Why can't you put a non-thread-safe type `T` in an\n/// `Arc<T>` to make it thread-safe? This may be a bit counter-intuitive at\n/// first: after all, isn't the point of `Arc<T>` thread safety? The key is\n/// this: `Arc<T>` makes it thread safe to have multiple ownership of the same\n/// data, but it  doesn't add thread safety to its data. Consider\n/// `Arc<RefCell<T>>`. `RefCell<T>` isn't [`Sync`], and if `Arc<T>` was always\n/// [`Send`], `Arc<RefCell<T>>` would be as well. But then we'd have a problem:\n/// `RefCell<T>` is not thread safe; it keeps track of the borrowing count using\n/// non-atomic operations.\n///\n/// In the end, this means that you may need to pair `Arc<T>` with some sort of\n/// `std::sync` type, usually `Mutex<T>`.\n///\n/// ## Breaking cycles with `Weak`\n///\n/// The [`downgrade`][downgrade] method can be used to create a non-owning\n/// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n/// to an `Arc`, but this will return [`None`] if the value has already been\n/// dropped.\n///\n/// A cycle between `Arc` pointers will never be deallocated. For this reason,\n/// [`Weak`][weak] is used to break cycles. For example, a tree could have\n/// strong `Arc` pointers from parent nodes to children, and [`Weak`][weak]\n/// pointers from children back to their parents.\n///\n/// # Cloning references\n///\n/// Creating a new reference from an existing reference counted pointer is done using the\n/// `Clone` trait implemented for [`Arc<T>`][`arc`] and [`Weak<T>`][`weak`].\n///\n/// ```\n/// use std::sync::Arc;\n/// let foo = Arc::new(vec![1.0, 2.0, 3.0]);\n/// // The two syntaxes below are equivalent.\n/// let a = foo.clone();\n/// let b = Arc::clone(&foo);\n/// // a and b both point to the same memory location as foo.\n/// ```\n///\n/// The `Arc::clone(&from)` syntax is the most idiomatic because it conveys more explicitly\n/// the meaning of the code. In the example above, this syntax makes it easier to see that\n/// this code is creating a new reference rather than copying the whole content of foo.\n///\n/// ## `Deref` behavior\n///\n/// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n/// so you can call `T`'s methods on a value of type `Arc<T>`. To avoid name\n/// clashes with `T`'s methods, the methods of `Arc<T>` itself are [associated\n/// functions][assoc], called using function-like syntax:\n///\n/// ```\n/// use std::sync::Arc;\n/// let my_arc = Arc::new(());\n///\n/// Arc::downgrade(&my_arc);\n/// ```\n///\n/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the value may have\n/// already been destroyed.\n///\n/// [arc]: struct.Arc.html\n/// [weak]: struct.Weak.html\n/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n/// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n/// [mutex]: ../../std/sync/struct.Mutex.html\n/// [rwlock]: ../../std/sync/struct.RwLock.html\n/// [atomic]: ../../std/sync/atomic/index.html\n/// [`Send`]: ../../std/marker/trait.Send.html\n/// [`Sync`]: ../../std/marker/trait.Sync.html\n/// [deref]: ../../std/ops/trait.Deref.html\n/// [downgrade]: struct.Arc.html#method.downgrade\n/// [upgrade]: struct.Weak.html#method.upgrade\n/// [`None`]: ../../std/option/enum.Option.html#variant.None\n/// [assoc]: ../../book/first-edition/method-syntax.html#associated-functions\n///\n/// # Examples\n///\n/// Sharing some immutable data between threads:\n///\n// Note that we **do not** run these tests here. The windows builders get super\n// unhappy if a thread outlives the main thread and then exits at the same time\n// (something deadlocks) so we just avoid this entirely by not running these\n// tests.\n/// ```no_run\n/// use std::sync::Arc;\n/// use std::thread;\n///\n/// let five = Arc::new(5);\n///\n/// for _ in 0..10 {\n///     let five = Arc::clone(&five);\n///\n///     thread::spawn(move || {\n///         println!(\"{:?}\", five);\n///     });\n/// }\n/// ```\n///\n/// Sharing a mutable [`AtomicUsize`]:\n///\n/// [`AtomicUsize`]: ../../std/sync/atomic/struct.AtomicUsize.html\n///\n/// ```no_run\n/// use std::sync::Arc;\n/// use std::sync::atomic::{AtomicUsize, Ordering};\n/// use std::thread;\n///\n/// let val = Arc::new(AtomicUsize::new(5));\n///\n/// for _ in 0..10 {\n///     let val = Arc::clone(&val);\n///\n///     thread::spawn(move || {\n///         let v = val.fetch_add(1, Ordering::SeqCst);\n///         println!(\"{:?}\", v);\n///     });\n/// }\n/// ```\n///\n/// See the [`rc` documentation][rc_examples] for more examples of reference\n/// counting in general.\n///\n/// [rc_examples]: ../../std/rc/index.html#examples\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Arc<T: ?Sized> {\n    ptr: Shared<ArcInner<T>>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n\n/// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n/// pointer, which returns an [`Option`]`<`[`Arc`]`<T>>`.\n///\n/// Since a `Weak` reference does not count towards ownership, it will not\n/// prevent the inner value from being dropped, and `Weak` itself makes no\n/// guarantees about the value still being present and may return [`None`]\n/// when [`upgrade`]d.\n///\n/// A `Weak` pointer is useful for keeping a temporary reference to the value\n/// within [`Arc`] without extending its lifetime. It is also used to prevent\n/// circular references between [`Arc`] pointers, since mutual owning references\n/// would never allow either [`Arc`] to be dropped. For example, a tree could\n/// have strong [`Arc`] pointers from parent nodes to children, and `Weak`\n/// pointers from children back to their parents.\n///\n/// The typical way to obtain a `Weak` pointer is to call [`Arc::downgrade`].\n///\n/// [`Arc`]: struct.Arc.html\n/// [`Arc::downgrade`]: struct.Arc.html#method.downgrade\n/// [`upgrade`]: struct.Weak.html#method.upgrade\n/// [`Option`]: ../../std/option/enum.Option.html\n/// [`None`]: ../../std/option/enum.Option.html#variant.None\n#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\npub struct Weak<T: ?Sized> {\n    ptr: Shared<ArcInner<T>>,\n}\n\n#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\nunsafe impl<T: ?Sized + Sync + Send> Send for Weak<T> {}\n#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\nunsafe impl<T: ?Sized + Sync + Send> Sync for Weak<T> {}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n\n#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\nimpl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"(Weak)\")\n    }\n}\n\nstruct ArcInner<T: ?Sized> {\n    strong: atomic::AtomicUsize,\n\n    // the value usize::MAX acts as a sentinel for temporarily \"locking\" the\n    // ability to upgrade weak pointers or downgrade strong ones; this is used\n    // to avoid races in `make_mut` and `get_mut`.\n    weak: atomic::AtomicUsize,\n\n    data: T,\n}\n\nunsafe impl<T: ?Sized + Sync + Send> Send for ArcInner<T> {}\nunsafe impl<T: ?Sized + Sync + Send> Sync for ArcInner<T> {}\n\nimpl<T> Arc<T> {\n    /// Constructs a new `Arc<T>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(data: T) -> Arc<T> {\n        // Start the weak pointer count as 1 which is the weak pointer that's\n        // held by all the strong pointers (kinda), see std/rc.rs for more info\n        let x: Box<_> = box ArcInner {\n            strong: atomic::AtomicUsize::new(1),\n            weak: atomic::AtomicUsize::new(1),\n            data: data,\n        };\n        Arc { ptr: unsafe { Shared::new(Box::into_raw(x)) } }\n    }\n\n    /// Returns the contained value, if the `Arc` has exactly one strong reference.\n    ///\n    /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was\n    /// passed in.\n    ///\n    /// This will succeed even if there are outstanding weak references.\n    ///\n    /// [result]: ../../std/result/enum.Result.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let x = Arc::new(3);\n    /// assert_eq!(Arc::try_unwrap(x), Ok(3));\n    ///\n    /// let x = Arc::new(4);\n    /// let _y = Arc::clone(&x);\n    /// assert_eq!(*Arc::try_unwrap(x).unwrap_err(), 4);\n    /// ```\n    #[inline]\n    #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n    pub fn try_unwrap(this: Self) -> Result<T, Self> {\n        // See `drop` for why all these atomics are like this\n        if this.inner().strong.compare_exchange(1, 0, Release, Relaxed).is_err() {\n            return Err(this);\n        }\n\n        atomic::fence(Acquire);\n\n        unsafe {\n            let elem = ptr::read(&this.ptr.as_ref().data);\n\n            // Make a weak pointer to clean up the implicit strong-weak reference\n            let _weak = Weak { ptr: this.ptr };\n            mem::forget(this);\n\n            Ok(elem)\n        }\n    }\n\n    /// Consumes the `Arc`, returning the wrapped pointer.\n    ///\n    /// To avoid a memory leak the pointer must be converted back to an `Arc` using\n    /// [`Arc::from_raw`][from_raw].\n    ///\n    /// [from_raw]: struct.Arc.html#method.from_raw\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let x = Arc::new(10);\n    /// let x_ptr = Arc::into_raw(x);\n    /// assert_eq!(unsafe { *x_ptr }, 10);\n    /// ```\n    #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n    pub fn into_raw(this: Self) -> *const T {\n        let ptr: *const T = &*this;\n        mem::forget(this);\n        ptr\n    }\n\n    /// Constructs an `Arc` from a raw pointer.\n    ///\n    /// The raw pointer must have been previously returned by a call to a\n    /// [`Arc::into_raw`][into_raw].\n    ///\n    /// This function is unsafe because improper use may lead to memory problems. For example, a\n    /// double-free may occur if the function is called twice on the same raw pointer.\n    ///\n    /// [into_raw]: struct.Arc.html#method.into_raw\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let x = Arc::new(10);\n    /// let x_ptr = Arc::into_raw(x);\n    ///\n    /// unsafe {\n    ///     // Convert back to an `Arc` to prevent leak.\n    ///     let x = Arc::from_raw(x_ptr);\n    ///     assert_eq!(*x, 10);\n    ///\n    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n    /// }\n    ///\n    /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n    /// ```\n    #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n    pub unsafe fn from_raw(ptr: *const T) -> Self {\n        // To find the corresponding pointer to the `ArcInner` we need to subtract the offset of the\n        // `data` field from the pointer.\n        let ptr = (ptr as *const u8).offset(-offset_of!(ArcInner<T>, data));\n        Arc {\n            ptr: Shared::new(ptr as *mut u8 as *mut _),\n        }\n    }\n}\n\nimpl<T: ?Sized> Arc<T> {\n    /// Creates a new [`Weak`][weak] pointer to this value.\n    ///\n    /// [weak]: struct.Weak.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    ///\n    /// let weak_five = Arc::downgrade(&five);\n    /// ```\n    #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n    pub fn downgrade(this: &Self) -> Weak<T> {\n        // This Relaxed is OK because we're checking the value in the CAS\n        // below.\n        let mut cur = this.inner().weak.load(Relaxed);\n\n        loop {\n            // check if the weak counter is currently \"locked\"; if so, spin.\n            if cur == usize::MAX {\n                cur = this.inner().weak.load(Relaxed);\n                continue;\n            }\n\n            // NOTE: this code currently ignores the possibility of overflow\n            // into usize::MAX; in general both Rc and Arc need to be adjusted\n            // to deal with overflow.\n\n            // Unlike with Clone(), we need this to be an Acquire read to\n            // synchronize with the write coming from `is_unique`, so that the\n            // events prior to that write happen before this read.\n            match this.inner().weak.compare_exchange_weak(cur, cur + 1, Acquire, Relaxed) {\n                Ok(_) => return Weak { ptr: this.ptr },\n                Err(old) => cur = old,\n            }\n        }\n    }\n\n    /// Gets the number of [`Weak`][weak] pointers to this value.\n    ///\n    /// [weak]: struct.Weak.html\n    ///\n    /// # Safety\n    ///\n    /// This method by itself is safe, but using it correctly requires extra care.\n    /// Another thread can change the weak count at any time,\n    /// including potentially between calling this method and acting on the result.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    /// let _weak_five = Arc::downgrade(&five);\n    ///\n    /// // This assertion is deterministic because we haven't shared\n    /// // the `Arc` or `Weak` between threads.\n    /// assert_eq!(1, Arc::weak_count(&five));\n    /// ```\n    #[inline]\n    #[stable(feature = \"arc_counts\", since = \"1.15.0\")]\n    pub fn weak_count(this: &Self) -> usize {\n        this.inner().weak.load(SeqCst) - 1\n    }\n\n    /// Gets the number of strong (`Arc`) pointers to this value.\n    ///\n    /// # Safety\n    ///\n    /// This method by itself is safe, but using it correctly requires extra care.\n    /// Another thread can change the strong count at any time,\n    /// including potentially between calling this method and acting on the result.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    /// let _also_five = Arc::clone(&five);\n    ///\n    /// // This assertion is deterministic because we haven't shared\n    /// // the `Arc` between threads.\n    /// assert_eq!(2, Arc::strong_count(&five));\n    /// ```\n    #[inline]\n    #[stable(feature = \"arc_counts\", since = \"1.15.0\")]\n    pub fn strong_count(this: &Self) -> usize {\n        this.inner().strong.load(SeqCst)\n    }\n\n    #[inline]\n    fn inner(&self) -> &ArcInner<T> {\n        // This unsafety is ok because while this arc is alive we're guaranteed\n        // that the inner pointer is valid. Furthermore, we know that the\n        // `ArcInner` structure itself is `Sync` because the inner data is\n        // `Sync` as well, so we're ok loaning out an immutable pointer to these\n        // contents.\n        unsafe { self.ptr.as_ref() }\n    }\n\n    // Non-inlined part of `drop`.\n    #[inline(never)]\n    unsafe fn drop_slow(&mut self) {\n        let ptr = self.ptr.as_ptr();\n\n        // Destroy the data at this time, even though we may not free the box\n        // allocation itself (there may still be weak pointers lying around).\n        ptr::drop_in_place(&mut self.ptr.as_mut().data);\n\n        if self.inner().weak.fetch_sub(1, Release) == 1 {\n            atomic::fence(Acquire);\n            deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n        }\n    }\n\n    #[inline]\n    #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n    /// Returns true if the two `Arc`s point to the same value (not\n    /// just values that compare as equal).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    /// let same_five = Arc::clone(&five);\n    /// let other_five = Arc::new(5);\n    ///\n    /// assert!(Arc::ptr_eq(&five, &same_five));\n    /// assert!(!Arc::ptr_eq(&five, &other_five));\n    /// ```\n    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n        this.ptr.as_ptr() == other.ptr.as_ptr()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Clone for Arc<T> {\n    /// Makes a clone of the `Arc` pointer.\n    ///\n    /// This creates another pointer to the same inner value, increasing the\n    /// strong reference count.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    ///\n    /// Arc::clone(&five);\n    /// ```\n    #[inline]\n    fn clone(&self) -> Arc<T> {\n        // Using a relaxed ordering is alright here, as knowledge of the\n        // original reference prevents other threads from erroneously deleting\n        // the object.\n        //\n        // As explained in the [Boost documentation][1], Increasing the\n        // reference counter can always be done with memory_order_relaxed: New\n        // references to an object can only be formed from an existing\n        // reference, and passing an existing reference from one thread to\n        // another must already provide any required synchronization.\n        //\n        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n        let old_size = self.inner().strong.fetch_add(1, Relaxed);\n\n        // However we need to guard against massive refcounts in case someone\n        // is `mem::forget`ing Arcs. If we don't do this the count can overflow\n        // and users will use-after free. We racily saturate to `isize::MAX` on\n        // the assumption that there aren't ~2 billion threads incrementing\n        // the reference count at once. This branch will never be taken in\n        // any realistic program.\n        //\n        // We abort because such a program is incredibly degenerate, and we\n        // don't care to support it.\n        if old_size > MAX_REFCOUNT {\n            unsafe {\n                abort();\n            }\n        }\n\n        Arc { ptr: self.ptr }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Deref for Arc<T> {\n    type Target = T;\n\n    #[inline]\n    fn deref(&self) -> &T {\n        &self.inner().data\n    }\n}\n\nimpl<T: Clone> Arc<T> {\n    /// Makes a mutable reference into the given `Arc`.\n    ///\n    /// If there are other `Arc` or [`Weak`][weak] pointers to the same value,\n    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n    /// ensure unique ownership. This is also referred to as clone-on-write.\n    ///\n    /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n    ///\n    /// [weak]: struct.Weak.html\n    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n    /// [get_mut]: struct.Arc.html#method.get_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let mut data = Arc::new(5);\n    ///\n    /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n    /// let mut other_data = Arc::clone(&data); // Won't clone inner data\n    /// *Arc::make_mut(&mut data) += 1;         // Clones inner data\n    /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n    /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n    ///\n    /// // Now `data` and `other_data` point to different values.\n    /// assert_eq!(*data, 8);\n    /// assert_eq!(*other_data, 12);\n    /// ```\n    #[inline]\n    #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n    pub fn make_mut(this: &mut Self) -> &mut T {\n        // Note that we hold both a strong reference and a weak reference.\n        // Thus, releasing our strong reference only will not, by itself, cause\n        // the memory to be deallocated.\n        //\n        // Use Acquire to ensure that we see any writes to `weak` that happen\n        // before release writes (i.e., decrements) to `strong`. Since we hold a\n        // weak count, there's no chance the ArcInner itself could be\n        // deallocated.\n        if this.inner().strong.compare_exchange(1, 0, Acquire, Relaxed).is_err() {\n            // Another strong pointer exists; clone\n            *this = Arc::new((**this).clone());\n        } else if this.inner().weak.load(Relaxed) != 1 {\n            // Relaxed suffices in the above because this is fundamentally an\n            // optimization: we are always racing with weak pointers being\n            // dropped. Worst case, we end up allocated a new Arc unnecessarily.\n\n            // We removed the last strong ref, but there are additional weak\n            // refs remaining. We'll move the contents to a new Arc, and\n            // invalidate the other weak refs.\n\n            // Note that it is not possible for the read of `weak` to yield\n            // usize::MAX (i.e., locked), since the weak count can only be\n            // locked by a thread with a strong reference.\n\n            // Materialize our own implicit weak pointer, so that it can clean\n            // up the ArcInner as needed.\n            let weak = Weak { ptr: this.ptr };\n\n            // mark the data itself as already deallocated\n            unsafe {\n                // there is no data race in the implicit write caused by `read`\n                // here (due to zeroing) because data is no longer accessed by\n                // other threads (due to there being no more strong refs at this\n                // point).\n                let mut swap = Arc::new(ptr::read(&weak.ptr.as_ref().data));\n                mem::swap(this, &mut swap);\n                mem::forget(swap);\n            }\n        } else {\n            // We were the sole reference of either kind; bump back up the\n            // strong ref count.\n            this.inner().strong.store(1, Release);\n        }\n\n        // As with `get_mut()`, the unsafety is ok because our reference was\n        // either unique to begin with, or became one upon cloning the contents.\n        unsafe {\n            &mut this.ptr.as_mut().data\n        }\n    }\n}\n\nimpl<T: ?Sized> Arc<T> {\n    /// Returns a mutable reference to the inner value, if there are\n    /// no other `Arc` or [`Weak`][weak] pointers to the same value.\n    ///\n    /// Returns [`None`][option] otherwise, because it is not safe to\n    /// mutate a shared value.\n    ///\n    /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n    /// the inner value when it's shared.\n    ///\n    /// [weak]: struct.Weak.html\n    /// [option]: ../../std/option/enum.Option.html\n    /// [make_mut]: struct.Arc.html#method.make_mut\n    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let mut x = Arc::new(3);\n    /// *Arc::get_mut(&mut x).unwrap() = 4;\n    /// assert_eq!(*x, 4);\n    ///\n    /// let _y = Arc::clone(&x);\n    /// assert!(Arc::get_mut(&mut x).is_none());\n    /// ```\n    #[inline]\n    #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n    pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n        if this.is_unique() {\n            // This unsafety is ok because we're guaranteed that the pointer\n            // returned is the *only* pointer that will ever be returned to T. Our\n            // reference count is guaranteed to be 1 at this point, and we required\n            // the Arc itself to be `mut`, so we're returning the only possible\n            // reference to the inner data.\n            unsafe {\n                Some(&mut this.ptr.as_mut().data)\n            }\n        } else {\n            None\n        }\n    }\n\n    /// Determine whether this is the unique reference (including weak refs) to\n    /// the underlying data.\n    ///\n    /// Note that this requires locking the weak ref count.\n    fn is_unique(&mut self) -> bool {\n        // lock the weak pointer count if we appear to be the sole weak pointer\n        // holder.\n        //\n        // The acquire label here ensures a happens-before relationship with any\n        // writes to `strong` prior to decrements of the `weak` count (via drop,\n        // which uses Release).\n        if self.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {\n            // Due to the previous acquire read, this will observe any writes to\n            // `strong` that were due to upgrading weak pointers; only strong\n            // clones remain, which require that the strong count is > 1 anyway.\n            let unique = self.inner().strong.load(Relaxed) == 1;\n\n            // The release write here synchronizes with a read in `downgrade`,\n            // effectively preventing the above read of `strong` from happening\n            // after the write.\n            self.inner().weak.store(1, Release); // release the lock\n            unique\n        } else {\n            false\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n    /// Drops the `Arc`.\n    ///\n    /// This will decrement the strong reference count. If the strong reference\n    /// count reaches zero then the only other references (if any) are\n    /// [`Weak`][weak], so we `drop` the inner value.\n    ///\n    /// [weak]: struct.Weak.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// struct Foo;\n    ///\n    /// impl Drop for Foo {\n    ///     fn drop(&mut self) {\n    ///         println!(\"dropped!\");\n    ///     }\n    /// }\n    ///\n    /// let foo  = Arc::new(Foo);\n    /// let foo2 = Arc::clone(&foo);\n    ///\n    /// drop(foo);    // Doesn't print anything\n    /// drop(foo2);   // Prints \"dropped!\"\n    /// ```\n    #[inline]\n    fn drop(&mut self) {\n        // Because `fetch_sub` is already atomic, we do not need to synchronize\n        // with other threads unless we are going to delete the object. This\n        // same logic applies to the below `fetch_sub` to the `weak` count.\n        if self.inner().strong.fetch_sub(1, Release) != 1 {\n            return;\n        }\n\n        // This fence is needed to prevent reordering of use of the data and\n        // deletion of the data.  Because it is marked `Release`, the decreasing\n        // of the reference count synchronizes with this `Acquire` fence. This\n        // means that use of the data happens before decreasing the reference\n        // count, which happens before this fence, which happens before the\n        // deletion of the data.\n        //\n        // As explained in the [Boost documentation][1],\n        //\n        // > It is important to enforce any possible access to the object in one\n        // > thread (through an existing reference) to *happen before* deleting\n        // > the object in a different thread. This is achieved by a \"release\"\n        // > operation after dropping a reference (any access to the object\n        // > through this reference must obviously happened before), and an\n        // > \"acquire\" operation before deleting the object.\n        //\n        // In particular, while the contents of an Arc are usually immutable, it's\n        // possible to have interior writes to something like a Mutex<T>. Since a\n        // Mutex is not acquired when it is deleted, we can't rely on its\n        // synchronization logic to make writes in thread A visible to a destructor\n        // running in thread B.\n        //\n        // Also note that the Acquire fence here could probably be replaced with an\n        // Acquire load, which could improve performance in highly-contended\n        // situations. See [2].\n        //\n        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n        // [2]: (https://github.com/rust-lang/rust/pull/41714)\n        atomic::fence(Acquire);\n\n        unsafe {\n            self.drop_slow();\n        }\n    }\n}\n\nimpl<T> Weak<T> {\n    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n    ///\n    /// [`upgrade`]: struct.Weak.html#method.upgrade\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Weak;\n    ///\n    /// let empty: Weak<i64> = Weak::new();\n    /// assert!(empty.upgrade().is_none());\n    /// ```\n    #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n    pub fn new() -> Weak<T> {\n        unsafe {\n            Weak {\n                ptr: Shared::new(Box::into_raw(box ArcInner {\n                    strong: atomic::AtomicUsize::new(0),\n                    weak: atomic::AtomicUsize::new(1),\n                    data: uninitialized(),\n                })),\n            }\n        }\n    }\n}\n\nimpl<T: ?Sized> Weak<T> {\n    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], extending\n    /// the lifetime of the value if successful.\n    ///\n    /// Returns [`None`] if the value has since been dropped.\n    ///\n    /// [`Arc`]: struct.Arc.html\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    ///\n    /// let weak_five = Arc::downgrade(&five);\n    ///\n    /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n    /// assert!(strong_five.is_some());\n    ///\n    /// // Destroy all strong pointers.\n    /// drop(strong_five);\n    /// drop(five);\n    ///\n    /// assert!(weak_five.upgrade().is_none());\n    /// ```\n    #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n    pub fn upgrade(&self) -> Option<Arc<T>> {\n        // We use a CAS loop to increment the strong count instead of a\n        // fetch_add because once the count hits 0 it must never be above 0.\n        let inner = self.inner();\n\n        // Relaxed load because any write of 0 that we can observe\n        // leaves the field in a permanently zero state (so a\n        // \"stale\" read of 0 is fine), and any other value is\n        // confirmed via the CAS below.\n        let mut n = inner.strong.load(Relaxed);\n\n        loop {\n            if n == 0 {\n                return None;\n            }\n\n            // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n            if n > MAX_REFCOUNT {\n                unsafe {\n                    abort();\n                }\n            }\n\n            // Relaxed is valid for the same reason it is on Arc's Clone impl\n            match inner.strong.compare_exchange_weak(n, n + 1, Relaxed, Relaxed) {\n                Ok(_) => return Some(Arc { ptr: self.ptr }),\n                Err(old) => n = old,\n            }\n        }\n    }\n\n    #[inline]\n    fn inner(&self) -> &ArcInner<T> {\n        // See comments above for why this is \"safe\"\n        unsafe { self.ptr.as_ref() }\n    }\n}\n\n#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\nimpl<T: ?Sized> Clone for Weak<T> {\n    /// Makes a clone of the `Weak` pointer that points to the same value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Weak};\n    ///\n    /// let weak_five = Arc::downgrade(&Arc::new(5));\n    ///\n    /// Weak::clone(&weak_five);\n    /// ```\n    #[inline]\n    fn clone(&self) -> Weak<T> {\n        // See comments in Arc::clone() for why this is relaxed.  This can use a\n        // fetch_add (ignoring the lock) because the weak count is only locked\n        // where are *no other* weak pointers in existence. (So we can't be\n        // running this code in that case).\n        let old_size = self.inner().weak.fetch_add(1, Relaxed);\n\n        // See comments in Arc::clone() for why we do this (for mem::forget).\n        if old_size > MAX_REFCOUNT {\n            unsafe {\n                abort();\n            }\n        }\n\n        return Weak { ptr: self.ptr };\n    }\n}\n\n#[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\nimpl<T> Default for Weak<T> {\n    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n    ///\n    /// [`upgrade`]: struct.Weak.html#method.upgrade\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Weak;\n    ///\n    /// let empty: Weak<i64> = Default::default();\n    /// assert!(empty.upgrade().is_none());\n    /// ```\n    fn default() -> Weak<T> {\n        Weak::new()\n    }\n}\n\n#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\nimpl<T: ?Sized> Drop for Weak<T> {\n    /// Drops the `Weak` pointer.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Weak};\n    ///\n    /// struct Foo;\n    ///\n    /// impl Drop for Foo {\n    ///     fn drop(&mut self) {\n    ///         println!(\"dropped!\");\n    ///     }\n    /// }\n    ///\n    /// let foo = Arc::new(Foo);\n    /// let weak_foo = Arc::downgrade(&foo);\n    /// let other_weak_foo = Weak::clone(&weak_foo);\n    ///\n    /// drop(weak_foo);   // Doesn't print anything\n    /// drop(foo);        // Prints \"dropped!\"\n    ///\n    /// assert!(other_weak_foo.upgrade().is_none());\n    /// ```\n    fn drop(&mut self) {\n        let ptr = self.ptr.as_ptr();\n\n        // If we find out that we were the last weak pointer, then its time to\n        // deallocate the data entirely. See the discussion in Arc::drop() about\n        // the memory orderings\n        //\n        // It's not necessary to check for the locked state here, because the\n        // weak count can only be locked if there was precisely one weak ref,\n        // meaning that drop could only subsequently run ON that remaining weak\n        // ref, which can only happen after the lock is released.\n        if self.inner().weak.fetch_sub(1, Release) == 1 {\n            atomic::fence(Acquire);\n            unsafe { deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr)) }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n    /// Equality for two `Arc`s.\n    ///\n    /// Two `Arc`s are equal if their inner values are equal.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    ///\n    /// assert!(five == Arc::new(5));\n    /// ```\n    fn eq(&self, other: &Arc<T>) -> bool {\n        *(*self) == *(*other)\n    }\n\n    /// Inequality for two `Arc`s.\n    ///\n    /// Two `Arc`s are unequal if their inner values are unequal.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    ///\n    /// assert!(five != Arc::new(6));\n    /// ```\n    fn ne(&self, other: &Arc<T>) -> bool {\n        *(*self) != *(*other)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n    /// Partial comparison for two `Arc`s.\n    ///\n    /// The two are compared by calling `partial_cmp()` on their inner values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    /// use std::cmp::Ordering;\n    ///\n    /// let five = Arc::new(5);\n    ///\n    /// assert_eq!(Some(Ordering::Less), five.partial_cmp(&Arc::new(6)));\n    /// ```\n    fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> {\n        (**self).partial_cmp(&**other)\n    }\n\n    /// Less-than comparison for two `Arc`s.\n    ///\n    /// The two are compared by calling `<` on their inner values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    ///\n    /// assert!(five < Arc::new(6));\n    /// ```\n    fn lt(&self, other: &Arc<T>) -> bool {\n        *(*self) < *(*other)\n    }\n\n    /// 'Less than or equal to' comparison for two `Arc`s.\n    ///\n    /// The two are compared by calling `<=` on their inner values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    ///\n    /// assert!(five <= Arc::new(5));\n    /// ```\n    fn le(&self, other: &Arc<T>) -> bool {\n        *(*self) <= *(*other)\n    }\n\n    /// Greater-than comparison for two `Arc`s.\n    ///\n    /// The two are compared by calling `>` on their inner values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    ///\n    /// assert!(five > Arc::new(4));\n    /// ```\n    fn gt(&self, other: &Arc<T>) -> bool {\n        *(*self) > *(*other)\n    }\n\n    /// 'Greater than or equal to' comparison for two `Arc`s.\n    ///\n    /// The two are compared by calling `>=` on their inner values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let five = Arc::new(5);\n    ///\n    /// assert!(five >= Arc::new(5));\n    /// ```\n    fn ge(&self, other: &Arc<T>) -> bool {\n        *(*self) >= *(*other)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Ord> Ord for Arc<T> {\n    /// Comparison for two `Arc`s.\n    ///\n    /// The two are compared by calling `cmp()` on their inner values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    /// use std::cmp::Ordering;\n    ///\n    /// let five = Arc::new(5);\n    ///\n    /// assert_eq!(Ordering::Less, five.cmp(&Arc::new(6)));\n    /// ```\n    fn cmp(&self, other: &Arc<T>) -> Ordering {\n        (**self).cmp(&**other)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Eq> Eq for Arc<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + fmt::Display> fmt::Display for Arc<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> fmt::Pointer for Arc<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Pointer::fmt(&self.ptr, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Default> Default for Arc<T> {\n    /// Creates a new `Arc<T>`, with the `Default` value for `T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Arc;\n    ///\n    /// let x: Arc<i32> = Default::default();\n    /// assert_eq!(*x, 0);\n    /// ```\n    fn default() -> Arc<T> {\n        Arc::new(Default::default())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Hash> Hash for Arc<T> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        (**self).hash(state)\n    }\n}\n\n#[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\nimpl<T> From<T> for Arc<T> {\n    fn from(t: T) -> Self {\n        Arc::new(t)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::clone::Clone;\n    use std::sync::mpsc::channel;\n    use std::mem::drop;\n    use std::ops::Drop;\n    use std::option::Option;\n    use std::option::Option::{None, Some};\n    use std::sync::atomic;\n    use std::sync::atomic::Ordering::{Acquire, SeqCst};\n    use std::thread;\n    use std::sync::Mutex;\n    use std::convert::From;\n\n    use super::{Arc, Weak};\n    use vec::Vec;\n\n    struct Canary(*mut atomic::AtomicUsize);\n\n    impl Drop for Canary {\n        fn drop(&mut self) {\n            unsafe {\n                match *self {\n                    Canary(c) => {\n                        (*c).fetch_add(1, SeqCst);\n                    }\n                }\n            }\n        }\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn manually_share_arc() {\n        let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let arc_v = Arc::new(v);\n\n        let (tx, rx) = channel();\n\n        let _t = thread::spawn(move || {\n            let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n            assert_eq!((*arc_v)[3], 4);\n        });\n\n        tx.send(arc_v.clone()).unwrap();\n\n        assert_eq!((*arc_v)[2], 3);\n        assert_eq!((*arc_v)[4], 5);\n    }\n\n    #[test]\n    fn test_arc_get_mut() {\n        let mut x = Arc::new(3);\n        *Arc::get_mut(&mut x).unwrap() = 4;\n        assert_eq!(*x, 4);\n        let y = x.clone();\n        assert!(Arc::get_mut(&mut x).is_none());\n        drop(y);\n        assert!(Arc::get_mut(&mut x).is_some());\n        let _w = Arc::downgrade(&x);\n        assert!(Arc::get_mut(&mut x).is_none());\n    }\n\n    #[test]\n    fn try_unwrap() {\n        let x = Arc::new(3);\n        assert_eq!(Arc::try_unwrap(x), Ok(3));\n        let x = Arc::new(4);\n        let _y = x.clone();\n        assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n        let x = Arc::new(5);\n        let _w = Arc::downgrade(&x);\n        assert_eq!(Arc::try_unwrap(x), Ok(5));\n    }\n\n    #[test]\n    fn into_from_raw() {\n        let x = Arc::new(box \"hello\");\n        let y = x.clone();\n\n        let x_ptr = Arc::into_raw(x);\n        drop(y);\n        unsafe {\n            assert_eq!(**x_ptr, \"hello\");\n\n            let x = Arc::from_raw(x_ptr);\n            assert_eq!(**x, \"hello\");\n\n            assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n        }\n    }\n\n    #[test]\n    fn test_cowarc_clone_make_mut() {\n        let mut cow0 = Arc::new(75);\n        let mut cow1 = cow0.clone();\n        let mut cow2 = cow1.clone();\n\n        assert!(75 == *Arc::make_mut(&mut cow0));\n        assert!(75 == *Arc::make_mut(&mut cow1));\n        assert!(75 == *Arc::make_mut(&mut cow2));\n\n        *Arc::make_mut(&mut cow0) += 1;\n        *Arc::make_mut(&mut cow1) += 2;\n        *Arc::make_mut(&mut cow2) += 3;\n\n        assert!(76 == *cow0);\n        assert!(77 == *cow1);\n        assert!(78 == *cow2);\n\n        // none should point to the same backing memory\n        assert!(*cow0 != *cow1);\n        assert!(*cow0 != *cow2);\n        assert!(*cow1 != *cow2);\n    }\n\n    #[test]\n    fn test_cowarc_clone_unique2() {\n        let mut cow0 = Arc::new(75);\n        let cow1 = cow0.clone();\n        let cow2 = cow1.clone();\n\n        assert!(75 == *cow0);\n        assert!(75 == *cow1);\n        assert!(75 == *cow2);\n\n        *Arc::make_mut(&mut cow0) += 1;\n        assert!(76 == *cow0);\n        assert!(75 == *cow1);\n        assert!(75 == *cow2);\n\n        // cow1 and cow2 should share the same contents\n        // cow0 should have a unique reference\n        assert!(*cow0 != *cow1);\n        assert!(*cow0 != *cow2);\n        assert!(*cow1 == *cow2);\n    }\n\n    #[test]\n    fn test_cowarc_clone_weak() {\n        let mut cow0 = Arc::new(75);\n        let cow1_weak = Arc::downgrade(&cow0);\n\n        assert!(75 == *cow0);\n        assert!(75 == *cow1_weak.upgrade().unwrap());\n\n        *Arc::make_mut(&mut cow0) += 1;\n\n        assert!(76 == *cow0);\n        assert!(cow1_weak.upgrade().is_none());\n    }\n\n    #[test]\n    fn test_live() {\n        let x = Arc::new(5);\n        let y = Arc::downgrade(&x);\n        assert!(y.upgrade().is_some());\n    }\n\n    #[test]\n    fn test_dead() {\n        let x = Arc::new(5);\n        let y = Arc::downgrade(&x);\n        drop(x);\n        assert!(y.upgrade().is_none());\n    }\n\n    #[test]\n    fn weak_self_cyclic() {\n        struct Cycle {\n            x: Mutex<Option<Weak<Cycle>>>,\n        }\n\n        let a = Arc::new(Cycle { x: Mutex::new(None) });\n        let b = Arc::downgrade(&a.clone());\n        *a.x.lock().unwrap() = Some(b);\n\n        // hopefully we don't double-free (or leak)...\n    }\n\n    #[test]\n    fn drop_arc() {\n        let mut canary = atomic::AtomicUsize::new(0);\n        let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n        drop(x);\n        assert!(canary.load(Acquire) == 1);\n    }\n\n    #[test]\n    fn drop_arc_weak() {\n        let mut canary = atomic::AtomicUsize::new(0);\n        let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n        let arc_weak = Arc::downgrade(&arc);\n        assert!(canary.load(Acquire) == 0);\n        drop(arc);\n        assert!(canary.load(Acquire) == 1);\n        drop(arc_weak);\n    }\n\n    #[test]\n    fn test_strong_count() {\n        let a = Arc::new(0);\n        assert!(Arc::strong_count(&a) == 1);\n        let w = Arc::downgrade(&a);\n        assert!(Arc::strong_count(&a) == 1);\n        let b = w.upgrade().expect(\"\");\n        assert!(Arc::strong_count(&b) == 2);\n        assert!(Arc::strong_count(&a) == 2);\n        drop(w);\n        drop(a);\n        assert!(Arc::strong_count(&b) == 1);\n        let c = b.clone();\n        assert!(Arc::strong_count(&b) == 2);\n        assert!(Arc::strong_count(&c) == 2);\n    }\n\n    #[test]\n    fn test_weak_count() {\n        let a = Arc::new(0);\n        assert!(Arc::strong_count(&a) == 1);\n        assert!(Arc::weak_count(&a) == 0);\n        let w = Arc::downgrade(&a);\n        assert!(Arc::strong_count(&a) == 1);\n        assert!(Arc::weak_count(&a) == 1);\n        let x = w.clone();\n        assert!(Arc::weak_count(&a) == 2);\n        drop(w);\n        drop(x);\n        assert!(Arc::strong_count(&a) == 1);\n        assert!(Arc::weak_count(&a) == 0);\n        let c = a.clone();\n        assert!(Arc::strong_count(&a) == 2);\n        assert!(Arc::weak_count(&a) == 0);\n        let d = Arc::downgrade(&c);\n        assert!(Arc::weak_count(&c) == 1);\n        assert!(Arc::strong_count(&c) == 2);\n\n        drop(a);\n        drop(c);\n        drop(d);\n    }\n\n    #[test]\n    fn show_arc() {\n        let a = Arc::new(5);\n        assert_eq!(format!(\"{:?}\", a), \"5\");\n    }\n\n    // Make sure deriving works with Arc<T>\n    #[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n    struct Foo {\n        inner: Arc<i32>,\n    }\n\n    #[test]\n    fn test_unsized() {\n        let x: Arc<[i32]> = Arc::new([1, 2, 3]);\n        assert_eq!(format!(\"{:?}\", x), \"[1, 2, 3]\");\n        let y = Arc::downgrade(&x.clone());\n        drop(x);\n        assert!(y.upgrade().is_none());\n    }\n\n    #[test]\n    fn test_from_owned() {\n        let foo = 123;\n        let foo_arc = Arc::from(foo);\n        assert!(123 == *foo_arc);\n    }\n\n    #[test]\n    fn test_new_weak() {\n        let foo: Weak<usize> = Weak::new();\n        assert!(foo.upgrade().is_none());\n    }\n\n    #[test]\n    fn test_ptr_eq() {\n        let five = Arc::new(5);\n        let same_five = five.clone();\n        let other_five = Arc::new(5);\n\n        assert!(Arc::ptr_eq(&five, &same_five));\n        assert!(!Arc::ptr_eq(&five, &other_five));\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> borrow::Borrow<T> for Arc<T> {\n    fn borrow(&self) -> &T {\n        &**self\n    }\n}\n\n#[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\nimpl<T: ?Sized> AsRef<T> for Arc<T> {\n    fn as_ref(&self) -> &T {\n        &**self\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![allow(missing_docs, bad_style)]\n\nuse io::{self, ErrorKind};\nuse libc;\n\n#[cfg(target_os = \"android\")]   pub use os::android as platform;\n#[cfg(target_os = \"bitrig\")]    pub use os::bitrig as platform;\n#[cfg(target_os = \"dragonfly\")] pub use os::dragonfly as platform;\n#[cfg(target_os = \"freebsd\")]   pub use os::freebsd as platform;\n#[cfg(target_os = \"haiku\")]     pub use os::haiku as platform;\n#[cfg(target_os = \"ios\")]       pub use os::ios as platform;\n#[cfg(target_os = \"linux\")]     pub use os::linux as platform;\n#[cfg(target_os = \"macos\")]     pub use os::macos as platform;\n#[cfg(target_os = \"nacl\")]      pub use os::nacl as platform;\n#[cfg(target_os = \"netbsd\")]    pub use os::netbsd as platform;\n#[cfg(target_os = \"openbsd\")]   pub use os::openbsd as platform;\n#[cfg(target_os = \"solaris\")]   pub use os::solaris as platform;\n#[cfg(target_os = \"emscripten\")] pub use os::emscripten as platform;\n#[cfg(target_os = \"fuchsia\")]   pub use os::fuchsia as platform;\n\n#[macro_use]\npub mod weak;\n\npub mod args;\npub mod android;\n#[cfg(feature = \"backtrace\")]\npub mod backtrace;\npub mod condvar;\npub mod env;\npub mod ext;\npub mod fast_thread_local;\npub mod fd;\npub mod fs;\npub mod memchr;\npub mod mutex;\npub mod net;\npub mod os;\npub mod os_str;\npub mod path;\npub mod pipe;\npub mod process;\npub mod rand;\npub mod rwlock;\npub mod stack_overflow;\npub mod thread;\npub mod thread_local;\npub mod time;\npub mod stdio;\n\n#[cfg(not(test))]\npub fn init() {\n    use alloc::oom;\n\n    // By default, some platforms will send a *signal* when an EPIPE error\n    // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n    // handler, causing it to kill the program, which isn't exactly what we\n    // want!\n    //\n    // Hence, we set SIGPIPE to ignore when the program starts up in order\n    // to prevent this problem.\n    unsafe {\n        reset_sigpipe();\n    }\n\n    oom::set_oom_handler(oom_handler);\n\n    // A nicer handler for out-of-memory situations than the default one. This\n    // one prints a message to stderr before aborting. It is critical that this\n    // code does not allocate any memory since we are in an OOM situation. Any\n    // errors are ignored while printing since there's nothing we can do about\n    // them and we are about to exit anyways.\n    fn oom_handler() -> ! {\n        use intrinsics;\n        let msg = \"fatal runtime error: out of memory\\n\";\n        unsafe {\n            libc::write(libc::STDERR_FILENO,\n                        msg.as_ptr() as *const libc::c_void,\n                        msg.len());\n            intrinsics::abort();\n        }\n    }\n\n    #[cfg(not(any(target_os = \"nacl\", target_os = \"emscripten\", target_os=\"fuchsia\")))]\n    unsafe fn reset_sigpipe() {\n        assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != libc::SIG_ERR);\n    }\n    #[cfg(any(target_os = \"nacl\", target_os = \"emscripten\", target_os=\"fuchsia\"))]\n    unsafe fn reset_sigpipe() {}\n}\n\n#[cfg(target_os = \"android\")]\npub use sys::android::signal;\n#[cfg(not(target_os = \"android\"))]\npub use libc::signal;\n\npub fn decode_error_kind(errno: i32) -> ErrorKind {\n    match errno as libc::c_int {\n        libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n        libc::ECONNRESET => ErrorKind::ConnectionReset,\n        libc::EPERM | libc::EACCES => ErrorKind::PermissionDenied,\n        libc::EPIPE => ErrorKind::BrokenPipe,\n        libc::ENOTCONN => ErrorKind::NotConnected,\n        libc::ECONNABORTED => ErrorKind::ConnectionAborted,\n        libc::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n        libc::EADDRINUSE => ErrorKind::AddrInUse,\n        libc::ENOENT => ErrorKind::NotFound,\n        libc::EINTR => ErrorKind::Interrupted,\n        libc::EINVAL => ErrorKind::InvalidInput,\n        libc::ETIMEDOUT => ErrorKind::TimedOut,\n        libc::EEXIST => ErrorKind::AlreadyExists,\n\n        // These two constants can have the same value on some systems,\n        // but different values on others, so we can't use a match\n        // clause\n        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n            ErrorKind::WouldBlock,\n\n        _ => ErrorKind::Other,\n    }\n}\n\n#[doc(hidden)]\npub trait IsMinusOne {\n    fn is_minus_one(&self) -> bool;\n}\n\nmacro_rules! impl_is_minus_one {\n    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n        fn is_minus_one(&self) -> bool {\n            *self == -1\n        }\n    })*)\n}\n\nimpl_is_minus_one! { i8 i16 i32 i64 isize }\n\npub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n    if t.is_minus_one() {\n        Err(io::Error::last_os_error())\n    } else {\n        Ok(t)\n    }\n}\n\npub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n    where T: IsMinusOne,\n          F: FnMut() -> T\n{\n    loop {\n        match cvt(f()) {\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n            other => return other,\n        }\n    }\n}\n\n// On Unix-like platforms, libc::abort will unregister signal handlers\n// including the SIGABRT handler, preventing the abort from being blocked, and\n// fclose streams, with the side effect of flushing them so libc bufferred\n// output will be printed.  Additionally the shell will generally print a more\n// understandable error message like \"Abort trap\" rather than \"Illegal\n// instruction\" that intrinsics::abort would cause, as intrinsics::abort is\n// implemented as an illegal instruction.\npub unsafe fn abort_internal() -> ! {\n    ::libc::abort()\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of `std::os` functionality for unix systems\n\n#![allow(unused_imports)] // lots of cfg code here\n\nuse os::unix::prelude::*;\n\nuse error::Error as StdError;\nuse ffi::{CString, CStr, OsString, OsStr};\nuse fmt;\nuse io;\nuse iter;\nuse libc::{self, c_int, c_char, c_void};\nuse marker::PhantomData;\nuse mem;\nuse memchr;\nuse path::{self, PathBuf};\nuse ptr;\nuse slice;\nuse str;\nuse sys_common::mutex::Mutex;\nuse sys::cvt;\nuse sys::fd;\nuse vec;\n\nconst TMPBUF_SZ: usize = 128;\nstatic ENV_LOCK: Mutex = Mutex::new();\n\n\nextern {\n    #[cfg(not(target_os = \"dragonfly\"))]\n    #[cfg_attr(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"fuchsia\"),\n               link_name = \"__errno_location\")]\n    #[cfg_attr(any(target_os = \"bitrig\",\n                   target_os = \"netbsd\",\n                   target_os = \"openbsd\",\n                   target_os = \"android\",\n                   target_env = \"newlib\"),\n               link_name = \"__errno\")]\n    #[cfg_attr(target_os = \"solaris\", link_name = \"___errno\")]\n    #[cfg_attr(any(target_os = \"macos\",\n                   target_os = \"ios\",\n                   target_os = \"freebsd\"),\n               link_name = \"__error\")]\n    #[cfg_attr(target_os = \"haiku\", link_name = \"_errnop\")]\n    fn errno_location() -> *mut c_int;\n}\n\n/// Returns the platform-specific value of errno\n#[cfg(not(target_os = \"dragonfly\"))]\npub fn errno() -> i32 {\n    unsafe {\n        (*errno_location()) as i32\n    }\n}\n\n/// Sets the platform-specific value of errno\n#[cfg(any(target_os = \"solaris\", target_os = \"fuchsia\"))] // only needed for readdir so far\npub fn set_errno(e: i32) {\n    unsafe {\n        *errno_location() = e as c_int\n    }\n}\n\n#[cfg(target_os = \"dragonfly\")]\npub fn errno() -> i32 {\n    extern {\n        #[thread_local]\n        static errno: c_int;\n    }\n\n    unsafe { errno as i32 }\n}\n\n/// Gets a detailed string description for the given error number.\npub fn error_string(errno: i32) -> String {\n    extern {\n        #[cfg_attr(any(target_os = \"linux\", target_env = \"newlib\"),\n                   link_name = \"__xpg_strerror_r\")]\n        fn strerror_r(errnum: c_int, buf: *mut c_char,\n                      buflen: libc::size_t) -> c_int;\n    }\n\n    let mut buf = [0 as c_char; TMPBUF_SZ];\n\n    let p = buf.as_mut_ptr();\n    unsafe {\n        if strerror_r(errno as c_int, p, buf.len()) < 0 {\n            panic!(\"strerror_r failure\");\n        }\n\n        let p = p as *const _;\n        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n    }\n}\n\npub fn getcwd() -> io::Result<PathBuf> {\n    let mut buf = Vec::with_capacity(512);\n    loop {\n        unsafe {\n            let ptr = buf.as_mut_ptr() as *mut libc::c_char;\n            if !libc::getcwd(ptr, buf.capacity()).is_null() {\n                let len = CStr::from_ptr(buf.as_ptr() as *const libc::c_char).to_bytes().len();\n                buf.set_len(len);\n                buf.shrink_to_fit();\n                return Ok(PathBuf::from(OsString::from_vec(buf)));\n            } else {\n                let error = io::Error::last_os_error();\n                if error.raw_os_error() != Some(libc::ERANGE) {\n                    return Err(error);\n                }\n            }\n\n            // Trigger the internal buffer resizing logic of `Vec` by requiring\n            // more space than the current capacity.\n            let cap = buf.capacity();\n            buf.set_len(cap);\n            buf.reserve(1);\n        }\n    }\n}\n\npub fn chdir(p: &path::Path) -> io::Result<()> {\n    let p: &OsStr = p.as_ref();\n    let p = CString::new(p.as_bytes())?;\n    unsafe {\n        match libc::chdir(p.as_ptr()) == (0 as c_int) {\n            true => Ok(()),\n            false => Err(io::Error::last_os_error()),\n        }\n    }\n}\n\npub struct SplitPaths<'a> {\n    iter: iter::Map<slice::Split<'a, u8, fn(&u8) -> bool>,\n                    fn(&'a [u8]) -> PathBuf>,\n}\n\npub fn split_paths(unparsed: &OsStr) -> SplitPaths {\n    fn bytes_to_path(b: &[u8]) -> PathBuf {\n        PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n    }\n    fn is_colon(b: &u8) -> bool { *b == b':' }\n    let unparsed = unparsed.as_bytes();\n    SplitPaths {\n        iter: unparsed.split(is_colon as fn(&u8) -> bool)\n                      .map(bytes_to_path as fn(&[u8]) -> PathBuf)\n    }\n}\n\nimpl<'a> Iterator for SplitPaths<'a> {\n    type Item = PathBuf;\n    fn next(&mut self) -> Option<PathBuf> { self.iter.next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n}\n\n#[derive(Debug)]\npub struct JoinPathsError;\n\npub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n    where I: Iterator<Item=T>, T: AsRef<OsStr>\n{\n    let mut joined = Vec::new();\n    let sep = b':';\n\n    for (i, path) in paths.enumerate() {\n        let path = path.as_ref().as_bytes();\n        if i > 0 { joined.push(sep) }\n        if path.contains(&sep) {\n            return Err(JoinPathsError)\n        }\n        joined.extend_from_slice(path);\n    }\n    Ok(OsStringExt::from_vec(joined))\n}\n\nimpl fmt::Display for JoinPathsError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        \"path segment contains separator `:`\".fmt(f)\n    }\n}\n\nimpl StdError for JoinPathsError {\n    fn description(&self) -> &str { \"failed to join paths\" }\n}\n\n#[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    unsafe {\n        let mut mib = [libc::CTL_KERN as c_int,\n                       libc::KERN_PROC as c_int,\n                       libc::KERN_PROC_PATHNAME as c_int,\n                       -1 as c_int];\n        let mut sz = 0;\n        cvt(libc::sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n                         ptr::null_mut(), &mut sz, ptr::null_mut(), 0))?;\n        if sz == 0 {\n            return Err(io::Error::last_os_error())\n        }\n        let mut v: Vec<u8> = Vec::with_capacity(sz);\n        cvt(libc::sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n                         v.as_mut_ptr() as *mut libc::c_void, &mut sz,\n                         ptr::null_mut(), 0))?;\n        if sz == 0 {\n            return Err(io::Error::last_os_error());\n        }\n        v.set_len(sz - 1); // chop off trailing NUL\n        Ok(PathBuf::from(OsString::from_vec(v)))\n    }\n}\n\n#[cfg(target_os = \"netbsd\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    ::fs::read_link(\"/proc/curproc/exe\")\n}\n\n#[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    unsafe {\n        let mut mib = [libc::CTL_KERN,\n                       libc::KERN_PROC_ARGS,\n                       libc::getpid(),\n                       libc::KERN_PROC_ARGV];\n        let mib = mib.as_mut_ptr();\n        let mut argv_len = 0;\n        cvt(libc::sysctl(mib, 4, ptr::null_mut(), &mut argv_len,\n                         ptr::null_mut(), 0))?;\n        let mut argv = Vec::<*const libc::c_char>::with_capacity(argv_len as usize);\n        cvt(libc::sysctl(mib, 4, argv.as_mut_ptr() as *mut _,\n                         &mut argv_len, ptr::null_mut(), 0))?;\n        argv.set_len(argv_len as usize);\n        if argv[0].is_null() {\n            return Err(io::Error::new(io::ErrorKind::Other,\n                                      \"no current exe available\"))\n        }\n        let argv0 = CStr::from_ptr(argv[0]).to_bytes();\n        if argv0[0] == b'.' || argv0.iter().any(|b| *b == b'/') {\n            ::fs::canonicalize(OsStr::from_bytes(argv0))\n        } else {\n            Ok(PathBuf::from(OsStr::from_bytes(argv0)))\n        }\n    }\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"emscripten\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    let selfexe = PathBuf::from(\"/proc/self/exe\");\n    if selfexe.exists() {\n        ::fs::read_link(selfexe)\n    } else {\n        Err(io::Error::new(io::ErrorKind::Other, \"no /proc/self/exe available. Is /proc mounted?\"))\n    }\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    extern {\n        fn _NSGetExecutablePath(buf: *mut libc::c_char,\n                                bufsize: *mut u32) -> libc::c_int;\n    }\n    unsafe {\n        let mut sz: u32 = 0;\n        _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n        if sz == 0 { return Err(io::Error::last_os_error()); }\n        let mut v: Vec<u8> = Vec::with_capacity(sz as usize);\n        let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n        if err != 0 { return Err(io::Error::last_os_error()); }\n        v.set_len(sz as usize - 1); // chop off trailing NUL\n        Ok(PathBuf::from(OsString::from_vec(v)))\n    }\n}\n\n#[cfg(any(target_os = \"solaris\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    extern {\n        fn getexecname() -> *const c_char;\n    }\n    unsafe {\n        let path = getexecname();\n        if path.is_null() {\n            Err(io::Error::last_os_error())\n        } else {\n            let filename = CStr::from_ptr(path).to_bytes();\n            let path = PathBuf::from(<OsStr as OsStrExt>::from_bytes(filename));\n\n            // Prepend a current working directory to the path if\n            // it doesn't contain an absolute pathname.\n            if filename[0] == b'/' {\n                Ok(path)\n            } else {\n                getcwd().map(|cwd| cwd.join(path))\n            }\n        }\n    }\n}\n\n#[cfg(target_os = \"haiku\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    // Use Haiku's image info functions\n    #[repr(C)]\n    struct image_info {\n        id: i32,\n        type_: i32,\n        sequence: i32,\n        init_order: i32,\n        init_routine: *mut libc::c_void,    // function pointer\n        term_routine: *mut libc::c_void,    // function pointer\n        device: libc::dev_t,\n        node: libc::ino_t,\n        name: [libc::c_char; 1024],         // MAXPATHLEN\n        text: *mut libc::c_void,\n        data: *mut libc::c_void,\n        text_size: i32,\n        data_size: i32,\n        api_version: i32,\n        abi: i32,\n    }\n\n    unsafe {\n        extern {\n            fn _get_next_image_info(team_id: i32, cookie: *mut i32,\n                info: *mut image_info, size: i32) -> i32;\n        }\n\n        let mut info: image_info = mem::zeroed();\n        let mut cookie: i32 = 0;\n        // the executable can be found at team id 0\n        let result = _get_next_image_info(0, &mut cookie, &mut info,\n            mem::size_of::<image_info>() as i32);\n        if result != 0 {\n            use io::ErrorKind;\n            Err(io::Error::new(ErrorKind::Other, \"Error getting executable path\"))\n        } else {\n            let name = CStr::from_ptr(info.name.as_ptr()).to_bytes();\n            Ok(PathBuf::from(OsStr::from_bytes(name)))\n        }\n    }\n}\n\n#[cfg(target_os = \"fuchsia\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    use io::ErrorKind;\n    Err(io::Error::new(ErrorKind::Other, \"Not yet implemented on fuchsia\"))\n}\n\npub struct Env {\n    iter: vec::IntoIter<(OsString, OsString)>,\n    _dont_send_or_sync_me: PhantomData<*mut ()>,\n}\n\nimpl Iterator for Env {\n    type Item = (OsString, OsString);\n    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n}\n\n#[cfg(target_os = \"macos\")]\npub unsafe fn environ() -> *mut *const *const c_char {\n    extern { fn _NSGetEnviron() -> *mut *const *const c_char; }\n    _NSGetEnviron()\n}\n\n#[cfg(not(target_os = \"macos\"))]\npub unsafe fn environ() -> *mut *const *const c_char {\n    extern { static mut environ: *const *const c_char; }\n    &mut environ\n}\n\n/// Returns a vector of (variable, value) byte-vector pairs for all the\n/// environment variables of the current process.\npub fn env() -> Env {\n    unsafe {\n        ENV_LOCK.lock();\n        let mut environ = *environ();\n        if environ == ptr::null() {\n            ENV_LOCK.unlock();\n            panic!(\"os::env() failure getting env string from OS: {}\",\n                   io::Error::last_os_error());\n        }\n        let mut result = Vec::new();\n        while *environ != ptr::null() {\n            if let Some(key_value) = parse(CStr::from_ptr(*environ).to_bytes()) {\n                result.push(key_value);\n            }\n            environ = environ.offset(1);\n        }\n        let ret = Env {\n            iter: result.into_iter(),\n            _dont_send_or_sync_me: PhantomData,\n        };\n        ENV_LOCK.unlock();\n        return ret\n    }\n\n    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n        // Strategy (copied from glibc): Variable name and value are separated\n        // by an ASCII equals sign '='. Since a variable name must not be\n        // empty, allow variable names starting with an equals sign. Skip all\n        // malformed lines.\n        if input.is_empty() {\n            return None;\n        }\n        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n        pos.map(|p| (\n            OsStringExt::from_vec(input[..p].to_vec()),\n            OsStringExt::from_vec(input[p+1..].to_vec()),\n        ))\n    }\n}\n\npub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n    // environment variables with a nul byte can't be set, so their value is\n    // always None as well\n    let k = CString::new(k.as_bytes())?;\n    unsafe {\n        ENV_LOCK.lock();\n        let s = libc::getenv(k.as_ptr()) as *const _;\n        let ret = if s.is_null() {\n            None\n        } else {\n            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n        };\n        ENV_LOCK.unlock();\n        return Ok(ret)\n    }\n}\n\npub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n    let k = CString::new(k.as_bytes())?;\n    let v = CString::new(v.as_bytes())?;\n\n    unsafe {\n        ENV_LOCK.lock();\n        let ret = cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(|_| ());\n        ENV_LOCK.unlock();\n        return ret\n    }\n}\n\npub fn unsetenv(n: &OsStr) -> io::Result<()> {\n    let nbuf = CString::new(n.as_bytes())?;\n\n    unsafe {\n        ENV_LOCK.lock();\n        let ret = cvt(libc::unsetenv(nbuf.as_ptr())).map(|_| ());\n        ENV_LOCK.unlock();\n        return ret\n    }\n}\n\npub fn page_size() -> usize {\n    unsafe {\n        libc::sysconf(libc::_SC_PAGESIZE) as usize\n    }\n}\n\npub fn temp_dir() -> PathBuf {\n    ::env::var_os(\"TMPDIR\").map(PathBuf::from).unwrap_or_else(|| {\n        if cfg!(target_os = \"android\") {\n            PathBuf::from(\"/data/local/tmp\")\n        } else {\n            PathBuf::from(\"/tmp\")\n        }\n    })\n}\n\npub fn home_dir() -> Option<PathBuf> {\n    return ::env::var_os(\"HOME\").or_else(|| unsafe {\n        fallback()\n    }).map(PathBuf::from);\n\n    #[cfg(any(target_os = \"android\",\n              target_os = \"ios\",\n              target_os = \"nacl\",\n              target_os = \"emscripten\"))]\n    unsafe fn fallback() -> Option<OsString> { None }\n    #[cfg(not(any(target_os = \"android\",\n                  target_os = \"ios\",\n                  target_os = \"nacl\",\n                  target_os = \"emscripten\")))]\n    unsafe fn fallback() -> Option<OsString> {\n        let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {\n            n if n < 0 => 512 as usize,\n            n => n as usize,\n        };\n        let mut buf = Vec::with_capacity(amt);\n        let mut passwd: libc::passwd = mem::zeroed();\n        let mut result = ptr::null_mut();\n        match libc::getpwuid_r(libc::getuid(), &mut passwd, buf.as_mut_ptr(),\n                               buf.capacity(), &mut result) {\n            0 if !result.is_null() => {\n                let ptr = passwd.pw_dir as *const _;\n                let bytes = CStr::from_ptr(ptr).to_bytes().to_vec();\n                Some(OsStringExt::from_vec(bytes))\n            },\n            _ => None,\n        }\n    }\n}\n\npub fn exit(code: i32) -> ! {\n    unsafe { libc::exit(code as c_int) }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse cell::UnsafeCell;\nuse libc;\nuse mem;\n\npub struct Mutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n\n#[inline]\npub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t {\n    m.inner.get()\n}\n\nunsafe impl Send for Mutex {}\nunsafe impl Sync for Mutex {}\n\n#[allow(dead_code)] // sys isn't exported yet\nimpl Mutex {\n    pub const fn new() -> Mutex {\n        // Might be moved and address is changing it is better to avoid\n        // initialization of potentially opaque OS data before it landed\n        Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n    }\n    #[inline]\n    pub unsafe fn init(&mut self) {\n        // Issue #33770\n        //\n        // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have\n        // a type of PTHREAD_MUTEX_DEFAULT, which has undefined behavior if you\n        // try to re-lock it from the same thread when you already hold a lock.\n        //\n        // In practice, glibc takes advantage of this undefined behavior to\n        // implement hardware lock elision, which uses hardware transactional\n        // memory to avoid acquiring the lock. While a transaction is in\n        // progress, the lock appears to be unlocked. This isn't a problem for\n        // other threads since the transactional memory will abort if a conflict\n        // is detected, however no abort is generated if re-locking from the\n        // same thread.\n        //\n        // Since locking the same mutex twice will result in two aliasing &mut\n        // references, we instead create the mutex with type\n        // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n        // re-lock it from the same thread, thus avoiding undefined behavior.\n        //\n        // We can't do anything for StaticMutex, but that type is deprecated\n        // anyways.\n        let mut attr: libc::pthread_mutexattr_t = mem::uninitialized();\n        let r = libc::pthread_mutexattr_init(&mut attr);\n        debug_assert_eq!(r, 0);\n        let r = libc::pthread_mutexattr_settype(&mut attr, libc::PTHREAD_MUTEX_NORMAL);\n        debug_assert_eq!(r, 0);\n        let r = libc::pthread_mutex_init(self.inner.get(), &attr);\n        debug_assert_eq!(r, 0);\n        let r = libc::pthread_mutexattr_destroy(&mut attr);\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    pub unsafe fn lock(&self) {\n        let r = libc::pthread_mutex_lock(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        let r = libc::pthread_mutex_unlock(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        libc::pthread_mutex_trylock(self.inner.get()) == 0\n    }\n    #[inline]\n    #[cfg(not(target_os = \"dragonfly\"))]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_mutex_destroy(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    #[cfg(target_os = \"dragonfly\")]\n    pub unsafe fn destroy(&self) {\n        use libc;\n        let r = libc::pthread_mutex_destroy(self.inner.get());\n        // On DragonFly pthread_mutex_destroy() returns EINVAL if called on a\n        // mutex that was just initialized with libc::PTHREAD_MUTEX_INITIALIZER.\n        // Once it is used (locked/unlocked) or pthread_mutex_init() is called,\n        // this behaviour no longer occurs.\n        debug_assert!(r == 0 || r == libc::EINVAL);\n    }\n}\n\npub struct ReentrantMutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n\nunsafe impl Send for ReentrantMutex {}\nunsafe impl Sync for ReentrantMutex {}\n\nimpl ReentrantMutex {\n    pub unsafe fn uninitialized() -> ReentrantMutex {\n        ReentrantMutex { inner: mem::uninitialized() }\n    }\n\n    pub unsafe fn init(&mut self) {\n        let mut attr: libc::pthread_mutexattr_t = mem::uninitialized();\n        let result = libc::pthread_mutexattr_init(&mut attr as *mut _);\n        debug_assert_eq!(result, 0);\n        let result = libc::pthread_mutexattr_settype(&mut attr as *mut _,\n                                                    libc::PTHREAD_MUTEX_RECURSIVE);\n        debug_assert_eq!(result, 0);\n        let result = libc::pthread_mutex_init(self.inner.get(), &attr as *const _);\n        debug_assert_eq!(result, 0);\n        let result = libc::pthread_mutexattr_destroy(&mut attr as *mut _);\n        debug_assert_eq!(result, 0);\n    }\n\n    pub unsafe fn lock(&self) {\n        let result = libc::pthread_mutex_lock(self.inner.get());\n        debug_assert_eq!(result, 0);\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        libc::pthread_mutex_trylock(self.inner.get()) == 0\n    }\n\n    pub unsafe fn unlock(&self) {\n        let result = libc::pthread_mutex_unlock(self.inner.get());\n        debug_assert_eq!(result, 0);\n    }\n\n    pub unsafe fn destroy(&self) {\n        let result = libc::pthread_mutex_destroy(self.inner.get());\n        debug_assert_eq!(result, 0);\n    }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse borrow::{Borrow, Cow};\nuse fmt;\nuse mem;\nuse ops;\nuse cmp;\nuse hash::{Hash, Hasher};\n\nuse sys::os_str::{Buf, Slice};\nuse sys_common::{AsInner, IntoInner, FromInner};\n\n/// A type that can represent owned, mutable platform-native strings, but is\n/// cheaply inter-convertible with Rust strings.\n///\n/// The need for this type arises from the fact that:\n///\n/// * On Unix systems, strings are often arbitrary sequences of non-zero\n///   bytes, in many cases interpreted as UTF-8.\n///\n/// * On Windows, strings are often arbitrary sequences of non-zero 16-bit\n///   values, interpreted as UTF-16 when it is valid to do so.\n///\n/// * In Rust, strings are always valid UTF-8, which may contain zeros.\n///\n/// `OsString` and [`OsStr`] bridge this gap by simultaneously representing Rust\n/// and platform-native string values, and in particular allowing a Rust string\n/// to be converted into an \"OS\" string with no cost.\n///\n/// [`OsStr`]: struct.OsStr.html\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct OsString {\n    inner: Buf\n}\n\n/// Slices into OS strings (see [`OsString`]).\n///\n/// [`OsString`]: struct.OsString.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct OsStr {\n    inner: Slice\n}\n\nimpl OsString {\n    /// Constructs a new empty `OsString`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let os_string = OsString::new();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> OsString {\n        OsString { inner: Buf::from_string(String::new()) }\n    }\n\n    /// Converts to an [`OsStr`] slice.\n    ///\n    /// [`OsStr`]: struct.OsStr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{OsString, OsStr};\n    ///\n    /// let os_string = OsString::from(\"foo\");\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert_eq!(os_string.as_os_str(), os_str);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_os_str(&self) -> &OsStr {\n        self\n    }\n\n    /// Converts the `OsString` into a [`String`] if it contains valid Unicode data.\n    ///\n    /// On failure, ownership of the original `OsString` is returned.\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let os_string = OsString::from(\"foo\");\n    /// let string = os_string.into_string();\n    /// assert_eq!(string, Ok(String::from(\"foo\")));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_string(self) -> Result<String, OsString> {\n        self.inner.into_string().map_err(|buf| OsString { inner: buf} )\n    }\n\n    /// Extends the string with the given [`&OsStr`] slice.\n    ///\n    /// [`&OsStr`]: struct.OsStr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut os_string = OsString::from(\"foo\");\n    /// os_string.push(\"bar\");\n    /// assert_eq!(&os_string, \"foobar\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push<T: AsRef<OsStr>>(&mut self, s: T) {\n        self.inner.push_slice(&s.as_ref().inner)\n    }\n\n    /// Creates a new `OsString` with the given capacity.\n    ///\n    /// The string will be able to hold exactly `capacity` lenth units of other\n    /// OS strings without reallocating. If `capacity` is 0, the string will not\n    /// allocate.\n    ///\n    /// See main `OsString` documentation information about encoding.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut os_string = OsString::with_capacity(10);\n    /// let capacity = os_string.capacity();\n    ///\n    /// // This push is done without reallocating\n    /// os_string.push(\"foo\");\n    ///\n    /// assert_eq!(capacity, os_string.capacity());\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn with_capacity(capacity: usize) -> OsString {\n        OsString {\n            inner: Buf::with_capacity(capacity)\n        }\n    }\n\n    /// Truncates the `OsString` to zero length.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut os_string = OsString::from(\"foo\");\n    /// assert_eq!(&os_string, \"foo\");\n    ///\n    /// os_string.clear();\n    /// assert_eq!(&os_string, \"\");\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn clear(&mut self) {\n        self.inner.clear()\n    }\n\n    /// Returns the capacity this `OsString` can hold without reallocating.\n    ///\n    /// See `OsString` introduction for information about encoding.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut os_string = OsString::with_capacity(10);\n    /// assert!(os_string.capacity() >= 10);\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn capacity(&self) -> usize {\n        self.inner.capacity()\n    }\n\n    /// Reserves capacity for at least `additional` more capacity to be inserted\n    /// in the given `OsString`.\n    ///\n    /// The collection may reserve more space to avoid frequent reallocations.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::new();\n    /// s.reserve(10);\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n        self.inner.reserve(additional)\n    }\n\n    /// Reserves the minimum capacity for exactly `additional` more capacity to\n    /// be inserted in the given `OsString`. Does nothing if the capacity is\n    /// already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it\n    /// requests. Therefore capacity can not be relied upon to be precisely\n    /// minimal. Prefer reserve if future insertions are expected.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::new();\n    /// s.reserve_exact(10);\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.inner.reserve_exact(additional)\n    }\n\n    /// Shrinks the capacity of the `OsString` to match its length.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::from(\"foo\");\n    ///\n    /// s.reserve(100);\n    /// assert!(s.capacity() >= 100);\n    ///\n    /// s.shrink_to_fit();\n    /// assert_eq!(3, s.capacity());\n    /// ```\n    #[stable(feature = \"osstring_shrink_to_fit\", since = \"1.19.0\")]\n    pub fn shrink_to_fit(&mut self) {\n        self.inner.shrink_to_fit()\n    }\n\n    /// Converts this `OsString` into a boxed [`OsStr`].\n    ///\n    /// [`OsStr`]: struct.OsStr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(into_boxed_os_str)]\n    ///\n    /// use std::ffi::{OsString, OsStr};\n    ///\n    /// let s = OsString::from(\"hello\");\n    ///\n    /// let b: Box<OsStr> = s.into_boxed_os_str();\n    /// ```\n    #[unstable(feature = \"into_boxed_os_str\", issue = \"40380\")]\n    pub fn into_boxed_os_str(self) -> Box<OsStr> {\n        unsafe { mem::transmute(self.inner.into_box()) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<String> for OsString {\n    fn from(s: String) -> OsString {\n        OsString { inner: Buf::from_string(s) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized + AsRef<OsStr>> From<&'a T> for OsString {\n    fn from(s: &'a T) -> OsString {\n        s.as_ref().to_os_string()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::RangeFull> for OsString {\n    type Output = OsStr;\n\n    #[inline]\n    fn index(&self, _index: ops::RangeFull) -> &OsStr {\n        OsStr::from_inner(self.inner.as_slice())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Deref for OsString {\n    type Target = OsStr;\n\n    #[inline]\n    fn deref(&self) -> &OsStr {\n        &self[..]\n    }\n}\n\n#[stable(feature = \"osstring_default\", since = \"1.9.0\")]\nimpl Default for OsString {\n    /// Constructs an empty `OsString`.\n    #[inline]\n    fn default() -> OsString {\n        OsString::new()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for OsString {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&**self, formatter)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for OsString {\n    fn eq(&self, other: &OsString) -> bool {\n        &**self == &**other\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq<str> for OsString {\n    fn eq(&self, other: &str) -> bool {\n        &**self == other\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq<OsString> for str {\n    fn eq(&self, other: &OsString) -> bool {\n        &**other == self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for OsString {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for OsString {\n    #[inline]\n    fn partial_cmp(&self, other: &OsString) -> Option<cmp::Ordering> {\n        (&**self).partial_cmp(&**other)\n    }\n    #[inline]\n    fn lt(&self, other: &OsString) -> bool { &**self < &**other }\n    #[inline]\n    fn le(&self, other: &OsString) -> bool { &**self <= &**other }\n    #[inline]\n    fn gt(&self, other: &OsString) -> bool { &**self > &**other }\n    #[inline]\n    fn ge(&self, other: &OsString) -> bool { &**self >= &**other }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd<str> for OsString {\n    #[inline]\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        (&**self).partial_cmp(other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for OsString {\n    #[inline]\n    fn cmp(&self, other: &OsString) -> cmp::Ordering {\n        (&**self).cmp(&**other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Hash for OsString {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        (&**self).hash(state)\n    }\n}\n\nimpl OsStr {\n    /// Coerces into an `OsStr` slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &OsStr {\n        s.as_ref()\n    }\n\n    fn from_inner(inner: &Slice) -> &OsStr {\n        unsafe { mem::transmute(inner) }\n    }\n\n    /// Yields a [`&str`] slice if the `OsStr` is valid Unicode.\n    ///\n    /// This conversion may entail doing a check for UTF-8 validity.\n    ///\n    /// [`&str`]: ../../std/primitive.str.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert_eq!(os_str.to_str(), Some(\"foo\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_str(&self) -> Option<&str> {\n        self.inner.to_str()\n    }\n\n    /// Converts an `OsStr` to a [`Cow`]`<`[`str`]`>`.\n    ///\n    /// Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n    ///\n    /// [`Cow`]: ../../std/borrow/enum.Cow.html\n    /// [`str`]: ../../std/primitive.str.html\n    ///\n    /// # Examples\n    ///\n    /// Calling `to_string_lossy` on an `OsStr` with valid unicode:\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert_eq!(os_str.to_string_lossy(), \"foo\");\n    /// ```\n    ///\n    /// Had `os_str` contained invalid unicode, the `to_string_lossy` call might\n    /// have returned `\"fo\"`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_string_lossy(&self) -> Cow<str> {\n        self.inner.to_string_lossy()\n    }\n\n    /// Copies the slice into an owned [`OsString`].\n    ///\n    /// [`OsString`]: struct.OsString.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{OsStr, OsString};\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// let os_string = os_str.to_os_string();\n    /// assert_eq!(os_string, OsString::from(\"foo\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_os_string(&self) -> OsString {\n        OsString { inner: self.inner.to_owned() }\n    }\n\n    /// Checks whether the `OsStr` is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"\");\n    /// assert!(os_str.is_empty());\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert!(!os_str.is_empty());\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn is_empty(&self) -> bool {\n        self.inner.inner.is_empty()\n    }\n\n    /// Returns the length of this `OsStr`.\n    ///\n    /// Note that this does **not** return the number of bytes in this string\n    /// as, for example, OS strings on Windows are encoded as a list of [`u16`]\n    /// rather than a list of bytes. This number is simply useful for passing to\n    /// other methods like [`OsString::with_capacity`] to avoid reallocations.\n    ///\n    /// See `OsStr` introduction for more information about encoding.\n    ///\n    /// [`u16`]: ../primitive.u16.html\n    /// [`OsString::with_capacity`]: struct.OsString.html#method.with_capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"\");\n    /// assert_eq!(os_str.len(), 0);\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert_eq!(os_str.len(), 3);\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn len(&self) -> usize {\n        self.inner.inner.len()\n    }\n\n    /// Converts a [`Box`]`<OsStr>` into an [`OsString`] without copying or allocating.\n    ///\n    /// [`Box`]: ../boxed/struct.Box.html\n    /// [`OsString`]: struct.OsString.html\n    #[unstable(feature = \"into_boxed_os_str\", issue = \"40380\")]\n    pub fn into_os_string(self: Box<OsStr>) -> OsString {\n        let inner: Box<Slice> = unsafe { mem::transmute(self) };\n        OsString { inner: Buf::from_box(inner) }\n    }\n\n    /// Gets the underlying byte representation.\n    ///\n    /// Note: it is *crucial* that this API is private, to avoid\n    /// revealing the internal, platform-specific encodings.\n    fn bytes(&self) -> &[u8] {\n        unsafe { mem::transmute(&self.inner) }\n    }\n}\n\n#[stable(feature = \"box_from_os_str\", since = \"1.17.0\")]\nimpl<'a> From<&'a OsStr> for Box<OsStr> {\n    fn from(s: &'a OsStr) -> Box<OsStr> {\n        unsafe { mem::transmute(s.inner.into_box()) }\n    }\n}\n\n#[stable(feature = \"os_string_from_box\", since = \"1.18.0\")]\nimpl From<Box<OsStr>> for OsString {\n    fn from(boxed: Box<OsStr>) -> OsString {\n        boxed.into_os_string()\n    }\n}\n\n#[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\nimpl From<OsString> for Box<OsStr> {\n    fn from(s: OsString) -> Box<OsStr> {\n        s.into_boxed_os_str()\n    }\n}\n\n#[stable(feature = \"box_default_extra\", since = \"1.17.0\")]\nimpl Default for Box<OsStr> {\n    fn default() -> Box<OsStr> {\n        unsafe { mem::transmute(Slice::empty_box()) }\n    }\n}\n\n#[stable(feature = \"osstring_default\", since = \"1.9.0\")]\nimpl<'a> Default for &'a OsStr {\n    /// Creates an empty `OsStr`.\n    #[inline]\n    fn default() -> &'a OsStr {\n        OsStr::new(\"\")\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for OsStr {\n    fn eq(&self, other: &OsStr) -> bool {\n        self.bytes().eq(other.bytes())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq<str> for OsStr {\n    fn eq(&self, other: &str) -> bool {\n        *self == *OsStr::new(other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq<OsStr> for str {\n    fn eq(&self, other: &OsStr) -> bool {\n        *other == *OsStr::new(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for OsStr {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for OsStr {\n    #[inline]\n    fn partial_cmp(&self, other: &OsStr) -> Option<cmp::Ordering> {\n        self.bytes().partial_cmp(other.bytes())\n    }\n    #[inline]\n    fn lt(&self, other: &OsStr) -> bool { self.bytes().lt(other.bytes()) }\n    #[inline]\n    fn le(&self, other: &OsStr) -> bool { self.bytes().le(other.bytes()) }\n    #[inline]\n    fn gt(&self, other: &OsStr) -> bool { self.bytes().gt(other.bytes()) }\n    #[inline]\n    fn ge(&self, other: &OsStr) -> bool { self.bytes().ge(other.bytes()) }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd<str> for OsStr {\n    #[inline]\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        self.partial_cmp(OsStr::new(other))\n    }\n}\n\n// FIXME (#19470): cannot provide PartialOrd<OsStr> for str until we\n// have more flexible coherence rules.\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for OsStr {\n    #[inline]\n    fn cmp(&self, other: &OsStr) -> cmp::Ordering { self.bytes().cmp(other.bytes()) }\n}\n\nmacro_rules! impl_cmp {\n    ($lhs:ty, $rhs: ty) => {\n        #[stable(feature = \"cmp_os_str\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialEq<$rhs> for $lhs {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool { <OsStr as PartialEq>::eq(self, other) }\n        }\n\n        #[stable(feature = \"cmp_os_str\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool { <OsStr as PartialEq>::eq(self, other) }\n        }\n\n        #[stable(feature = \"cmp_os_str\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$rhs> for $lhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$rhs) -> Option<cmp::Ordering> {\n                <OsStr as PartialOrd>::partial_cmp(self, other)\n            }\n        }\n\n        #[stable(feature = \"cmp_os_str\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$lhs> for $rhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$lhs) -> Option<cmp::Ordering> {\n                <OsStr as PartialOrd>::partial_cmp(self, other)\n            }\n        }\n    }\n}\n\nimpl_cmp!(OsString, OsStr);\nimpl_cmp!(OsString, &'a OsStr);\nimpl_cmp!(Cow<'a, OsStr>, OsStr);\nimpl_cmp!(Cow<'a, OsStr>, &'b OsStr);\nimpl_cmp!(Cow<'a, OsStr>, OsString);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Hash for OsStr {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.bytes().hash(state)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for OsStr {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&self.inner, formatter)\n    }\n}\n\nimpl OsStr {\n    pub(crate) fn display(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&self.inner, formatter)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Borrow<OsStr> for OsString {\n    fn borrow(&self) -> &OsStr { &self[..] }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToOwned for OsStr {\n    type Owned = OsString;\n    fn to_owned(&self) -> OsString {\n        self.to_os_string()\n    }\n    fn clone_into(&self, target: &mut OsString) {\n        target.clear();\n        target.push(self);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for OsStr {\n    fn as_ref(&self) -> &OsStr {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for OsString {\n    fn as_ref(&self) -> &OsStr {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for str {\n    fn as_ref(&self) -> &OsStr {\n        OsStr::from_inner(Slice::from_str(self))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for String {\n    fn as_ref(&self) -> &OsStr {\n        (&**self).as_ref()\n    }\n}\n\nimpl FromInner<Buf> for OsString {\n    fn from_inner(buf: Buf) -> OsString {\n        OsString { inner: buf }\n    }\n}\n\nimpl IntoInner<Buf> for OsString {\n    fn into_inner(self) -> Buf {\n        self.inner\n    }\n}\n\nimpl AsInner<Slice> for OsStr {\n    fn as_inner(&self) -> &Slice {\n        &self.inner\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use sys_common::{AsInner, IntoInner};\n\n    #[test]\n    fn test_os_string_with_capacity() {\n        let os_string = OsString::with_capacity(0);\n        assert_eq!(0, os_string.inner.into_inner().capacity());\n\n        let os_string = OsString::with_capacity(10);\n        assert_eq!(10, os_string.inner.into_inner().capacity());\n\n        let mut os_string = OsString::with_capacity(0);\n        os_string.push(\"abc\");\n        assert!(os_string.inner.into_inner().capacity() >= 3);\n    }\n\n    #[test]\n    fn test_os_string_clear() {\n        let mut os_string = OsString::from(\"abc\");\n        assert_eq!(3, os_string.inner.as_inner().len());\n\n        os_string.clear();\n        assert_eq!(&os_string, \"\");\n        assert_eq!(0, os_string.inner.as_inner().len());\n    }\n\n    #[test]\n    fn test_os_string_capacity() {\n        let os_string = OsString::with_capacity(0);\n        assert_eq!(0, os_string.capacity());\n\n        let os_string = OsString::with_capacity(10);\n        assert_eq!(10, os_string.capacity());\n\n        let mut os_string = OsString::with_capacity(0);\n        os_string.push(\"abc\");\n        assert!(os_string.capacity() >= 3);\n    }\n\n    #[test]\n    fn test_os_string_reserve() {\n        let mut os_string = OsString::new();\n        assert_eq!(os_string.capacity(), 0);\n\n        os_string.reserve(2);\n        assert!(os_string.capacity() >= 2);\n\n        for _ in 0..16 {\n            os_string.push(\"a\");\n        }\n\n        assert!(os_string.capacity() >= 16);\n        os_string.reserve(16);\n        assert!(os_string.capacity() >= 32);\n\n        os_string.push(\"a\");\n\n        os_string.reserve(16);\n        assert!(os_string.capacity() >= 33)\n    }\n\n    #[test]\n    fn test_os_string_reserve_exact() {\n        let mut os_string = OsString::new();\n        assert_eq!(os_string.capacity(), 0);\n\n        os_string.reserve_exact(2);\n        assert!(os_string.capacity() >= 2);\n\n        for _ in 0..16 {\n            os_string.push(\"a\");\n        }\n\n        assert!(os_string.capacity() >= 16);\n        os_string.reserve_exact(16);\n        assert!(os_string.capacity() >= 32);\n\n        os_string.push(\"a\");\n\n        os_string.reserve_exact(16);\n        assert!(os_string.capacity() >= 33)\n    }\n\n    #[test]\n    fn test_os_string_default() {\n        let os_string: OsString = Default::default();\n        assert_eq!(\"\", &os_string);\n    }\n\n    #[test]\n    fn test_os_str_is_empty() {\n        let mut os_string = OsString::new();\n        assert!(os_string.is_empty());\n\n        os_string.push(\"abc\");\n        assert!(!os_string.is_empty());\n\n        os_string.clear();\n        assert!(os_string.is_empty());\n    }\n\n    #[test]\n    fn test_os_str_len() {\n        let mut os_string = OsString::new();\n        assert_eq!(0, os_string.len());\n\n        os_string.push(\"abc\");\n        assert_eq!(3, os_string.len());\n\n        os_string.clear();\n        assert_eq!(0, os_string.len());\n    }\n\n    #[test]\n    fn test_os_str_default() {\n        let os_str: &OsStr = Default::default();\n        assert_eq!(\"\", os_str);\n    }\n\n    #[test]\n    fn into_boxed() {\n        let orig = \"Hello, world!\";\n        let os_str = OsStr::new(orig);\n        let boxed: Box<OsStr> = Box::from(os_str);\n        let os_string = os_str.to_owned().into_boxed_os_str().into_os_string();\n        assert_eq!(os_str, &*boxed);\n        assert_eq!(&*boxed, &*os_string);\n        assert_eq!(&*os_string, os_str);\n    }\n\n    #[test]\n    fn boxed_default() {\n        let boxed = <Box<OsStr>>::default();\n        assert!(boxed.is_empty());\n    }\n\n    #[test]\n    fn test_os_str_clone_into() {\n        let mut os_string = OsString::with_capacity(123);\n        os_string.push(\"hello\");\n        let os_str = OsStr::new(\"bonjour\");\n        os_str.clone_into(&mut os_string);\n        assert_eq!(os_str, os_string);\n        assert!(os_string.capacity() >= 123);\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Numeric traits and functions for the built-in numeric types.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse convert::TryFrom;\nuse fmt;\nuse intrinsics;\nuse str::FromStr;\n\n/// Provides intentionally-wrapped arithmetic on `T`.\n///\n/// Operations like `+` on `u32` values is intended to never overflow,\n/// and in some debug configurations overflow is detected and results\n/// in a panic. While most arithmetic falls into this category, some\n/// code explicitly expects and relies upon modular arithmetic (e.g.,\n/// hashing).\n///\n/// Wrapping arithmetic can be achieved either through methods like\n/// `wrapping_add`, or through the `Wrapping<T>` type, which says that\n/// all standard arithmetic operations on the underlying value are\n/// intended to have wrapping semantics.\n///\n/// # Examples\n///\n/// ```\n/// use std::num::Wrapping;\n///\n/// let zero = Wrapping(0u32);\n/// let one = Wrapping(1u32);\n///\n/// assert_eq!(std::u32::MAX, (zero - one).0);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\npub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n                       pub T);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_display\", since = \"1.10.0\")]\nimpl<T: fmt::Display> fmt::Display for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::Binary> fmt::Binary for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::Octal> fmt::Octal for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::LowerHex> fmt::LowerHex for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::UpperHex> fmt::UpperHex for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\nmod wrapping;\n\n// All these modules are technically private and only exposed for coretests:\npub mod flt2dec;\npub mod dec2flt;\npub mod bignum;\npub mod diy_float;\n\n// `Int` + `SignedInt` implemented for signed integers\nmacro_rules! int_impl {\n    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr,\n     $add_with_overflow:path,\n     $sub_with_overflow:path,\n     $mul_with_overflow:path) => {\n        /// Returns the smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// assert_eq!(i8::min_value(), -128);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub const fn min_value() -> Self {\n            !0 ^ ((!0 as $UnsignedT) >> 1) as Self\n        }\n\n        /// Returns the largest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// assert_eq!(i8::max_value(), 127);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub const fn max_value() -> Self {\n            !Self::min_value()\n        }\n\n        /// Converts a string slice in a given base to an integer.\n        ///\n        /// Leading and trailing whitespace represent an error.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(i32::from_str_radix(\"A\", 16), Ok(10));\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n            from_str_radix(src, radix)\n        }\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = -0b1000_0000i8;\n        ///\n        /// assert_eq!(n.count_ones(), 1);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = -0b1000_0000i8;\n        ///\n        /// assert_eq!(n.count_zeros(), 7);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = -1i16;\n        ///\n        /// assert_eq!(n.leading_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn leading_zeros(self) -> u32 {\n            (self as $UnsignedT).leading_zeros()\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = -4i8;\n        ///\n        /// assert_eq!(n.trailing_zeros(), 2);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn trailing_zeros(self) -> u32 {\n            (self as $UnsignedT).trailing_zeros()\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as `<<`!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFi64;\n        /// let m = -0x76543210FEDCBA99i64;\n        ///\n        /// assert_eq!(n.rotate_left(32), m);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn rotate_left(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_left(n) as Self\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as `>>`!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFi64;\n        /// let m = -0xFEDCBA987654322i64;\n        ///\n        /// assert_eq!(n.rotate_right(4), m);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn rotate_right(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_right(n) as Self\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n =  0x0123456789ABCDEFi64;\n        /// let m = -0x1032547698BADCFFi64;\n        ///\n        /// assert_eq!(n.swap_bytes(), m);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn swap_bytes(self) -> Self {\n            (self as $UnsignedT).swap_bytes() as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFi64;\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(i64::from_be(n), n)\n        /// } else {\n        ///     assert_eq!(i64::from_be(n), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn from_be(x: Self) -> Self {\n            if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFi64;\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(i64::from_le(n), n)\n        /// } else {\n        ///     assert_eq!(i64::from_le(n), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn from_le(x: Self) -> Self {\n            if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFi64;\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn to_be(self) -> Self { // or not to be?\n            if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFi64;\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn to_le(self) -> Self {\n            if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n        }\n\n        /// Checked integer addition. Computes `self + other`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(7i16.checked_add(32760), Some(32767));\n        /// assert_eq!(8i16.checked_add(32760), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_add(self, other: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_add(other);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked integer subtraction. Computes `self - other`, returning\n        /// `None` if underflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n        /// assert_eq!((-128i8).checked_sub(1), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_sub(self, other: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_sub(other);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked integer multiplication. Computes `self * other`, returning\n        /// `None` if underflow or overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(6i8.checked_mul(21), Some(126));\n        /// assert_eq!(6i8.checked_mul(22), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_mul(self, other: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(other);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked integer division. Computes `self / other`, returning `None`\n        /// if `other == 0` or the operation results in underflow or overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!((-127i8).checked_div(-1), Some(127));\n        /// assert_eq!((-128i8).checked_div(-1), None);\n        /// assert_eq!((1i8).checked_div(0), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_div(self, other: Self) -> Option<Self> {\n            if other == 0 || (self == Self::min_value() && other == -1) {\n                None\n            } else {\n                Some(unsafe { intrinsics::unchecked_div(self, other) })\n            }\n        }\n\n        /// Checked integer remainder. Computes `self % other`, returning `None`\n        /// if `other == 0` or the operation results in underflow or overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(5i32.checked_rem(2), Some(1));\n        /// assert_eq!(5i32.checked_rem(0), None);\n        /// assert_eq!(i32::MIN.checked_rem(-1), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_rem(self, other: Self) -> Option<Self> {\n            if other == 0 || (self == Self::min_value() && other == -1) {\n                None\n            } else {\n                Some(unsafe { intrinsics::unchecked_rem(self, other) })\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` if `self ==\n        /// MIN`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(5i32.checked_neg(), Some(-5));\n        /// assert_eq!(i32::MIN.checked_neg(), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(0x10i32.checked_shl(4), Some(0x100));\n        /// assert_eq!(0x10i32.checked_shl(33), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(0x10i32.checked_shr(4), Some(0x1));\n        /// assert_eq!(0x10i32.checked_shr(33), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked absolute value. Computes `self.abs()`, returning `None` if\n        /// `self == MIN`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!((-5i32).checked_abs(), Some(5));\n        /// assert_eq!(i32::MIN.checked_abs(), None);\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[inline]\n        pub fn checked_abs(self) -> Option<Self> {\n            if self.is_negative() {\n                self.checked_neg()\n            } else {\n                Some(self)\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + other`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100i8.saturating_add(1), 101);\n        /// assert_eq!(100i8.saturating_add(127), 127);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn saturating_add(self, other: Self) -> Self {\n            match self.checked_add(other) {\n                Some(x) => x,\n                None if other >= 0 => Self::max_value(),\n                None => Self::min_value(),\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - other`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100i8.saturating_sub(127), -27);\n        /// assert_eq!((-100i8).saturating_sub(127), -128);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn saturating_sub(self, other: Self) -> Self {\n            match self.checked_sub(other) {\n                Some(x) => x,\n                None if other >= 0 => Self::min_value(),\n                None => Self::max_value(),\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * other`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(100i32.saturating_mul(127), 12700);\n        /// assert_eq!((1i32 << 23).saturating_mul(1 << 23), i32::MAX);\n        /// assert_eq!((-1i32 << 23).saturating_mul(1 << 23), i32::MIN);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn saturating_mul(self, other: Self) -> Self {\n            self.checked_mul(other).unwrap_or_else(|| {\n                if (self < 0 && other < 0) || (self > 0 && other > 0) {\n                    Self::max_value()\n                } else {\n                    Self::min_value()\n                }\n            })\n        }\n\n        /// Wrapping (modular) addition. Computes `self + other`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100i8.wrapping_add(27), 127);\n        /// assert_eq!(100i8.wrapping_add(127), -29);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn wrapping_add(self, rhs: Self) -> Self {\n            unsafe {\n                intrinsics::overflowing_add(self, rhs)\n            }\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - other`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(0i8.wrapping_sub(127), -127);\n        /// assert_eq!((-2i8).wrapping_sub(127), 127);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn wrapping_sub(self, rhs: Self) -> Self {\n            unsafe {\n                intrinsics::overflowing_sub(self, rhs)\n            }\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// other`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(10i8.wrapping_mul(12), 120);\n        /// assert_eq!(11i8.wrapping_mul(12), -124);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn wrapping_mul(self, rhs: Self) -> Self {\n            unsafe {\n                intrinsics::overflowing_mul(self, rhs)\n            }\n        }\n\n        /// Wrapping (modular) division. Computes `self / other`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one\n        /// divides `MIN / -1` on a signed type (where `MIN` is the\n        /// negative minimal value for the type); this is equivalent\n        /// to `-MIN`, a positive value that is too large to represent\n        /// in the type. In such a case, this function returns `MIN`\n        /// itself.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.wrapping_div(10), 10);\n        /// assert_eq!((-128i8).wrapping_div(-1), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline(always)]\n        pub fn wrapping_div(self, rhs: Self) -> Self {\n            self.overflowing_div(rhs).0\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % other`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Such wrap-around never actually occurs mathematically;\n        /// implementation artifacts make `x % y` invalid for `MIN /\n        /// -1` on a signed type (where `MIN` is the negative\n        /// minimal value). In such a case, this function returns `0`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100i8.wrapping_rem(10), 0);\n        /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline(always)]\n        pub fn wrapping_rem(self, rhs: Self) -> Self {\n            self.overflowing_rem(rhs).0\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one\n        /// negates `MIN` on a signed type (where `MIN` is the\n        /// negative minimal value for the type); this is a positive\n        /// value that is too large to represent in the type. In such\n        /// a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100i8.wrapping_neg(), -100);\n        /// assert_eq!((-128i8).wrapping_neg(), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline(always)]\n        pub fn wrapping_neg(self) -> Self {\n            self.overflowing_neg().0\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a `rotate_left` function, which may\n        /// be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!((-1i8).wrapping_shl(7), -128);\n        /// assert_eq!((-1i8).wrapping_shl(8), -1);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline(always)]\n        pub fn wrapping_shl(self, rhs: u32) -> Self {\n            unsafe {\n                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a `rotate_right` function, which may\n        /// be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!((-128i8).wrapping_shr(7), -1);\n        /// assert_eq!((-128i8).wrapping_shr(8), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline(always)]\n        pub fn wrapping_shr(self, rhs: u32) -> Self {\n            unsafe {\n                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n            }\n        }\n\n        /// Wrapping (modular) absolute value. Computes `self.abs()`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one takes\n        /// the absolute value of the negative minimal value for the type\n        /// this is a positive value that is too large to represent in the\n        /// type. In such a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100i8.wrapping_abs(), 100);\n        /// assert_eq!((-100i8).wrapping_abs(), 100);\n        /// assert_eq!((-128i8).wrapping_abs(), -128);\n        /// assert_eq!((-128i8).wrapping_abs() as u8, 128);\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[inline(always)]\n        pub fn wrapping_abs(self) -> Self {\n            if self.is_negative() {\n                self.wrapping_neg()\n            } else {\n                self\n            }\n        }\n\n        /// Calculates `self` + `rhs`\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(5i32.overflowing_add(2), (7, false));\n        /// assert_eq!(i32::MAX.overflowing_add(1), (i32::MIN, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            unsafe {\n                let (a, b) = $add_with_overflow(self as $ActualT,\n                                                rhs as $ActualT);\n                (a as Self, b)\n            }\n        }\n\n        /// Calculates `self` - `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(5i32.overflowing_sub(2), (3, false));\n        /// assert_eq!(i32::MIN.overflowing_sub(1), (i32::MAX, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            unsafe {\n                let (a, b) = $sub_with_overflow(self as $ActualT,\n                                                rhs as $ActualT);\n                (a as Self, b)\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(5i32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            unsafe {\n                let (a, b) = $mul_with_overflow(self as $ActualT,\n                                                rhs as $ActualT);\n                (a as Self, b)\n            }\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// occur then self is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(5i32.overflowing_div(2), (2, false));\n        /// assert_eq!(i32::MIN.overflowing_div(-1), (i32::MIN, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            if self == Self::min_value() && rhs == -1 {\n                (self, true)\n            } else {\n                (self / rhs, false)\n            }\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would occur then 0 is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(5i32.overflowing_rem(2), (1, false));\n        /// assert_eq!(i32::MIN.overflowing_rem(-1), (0, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            if self == Self::min_value() && rhs == -1 {\n                (0, true)\n            } else {\n                (self % rhs, false)\n            }\n        }\n\n        /// Negates self, overflowing if this is equal to the minimum value.\n        ///\n        /// Returns a tuple of the negated version of self along with a boolean\n        /// indicating whether an overflow happened. If `self` is the minimum\n        /// value (e.g. `i32::MIN` for values of type `i32`), then the minimum\n        /// value will be returned again and `true` will be returned for an\n        /// overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(2i32.overflowing_neg(), (-2, false));\n        /// assert_eq!(i32::MIN.overflowing_neg(), (i32::MIN, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_neg(self) -> (Self, bool) {\n            if self == Self::min_value() {\n                (Self::min_value(), true)\n            } else {\n                (-self, false)\n            }\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(0x10i32.overflowing_shl(4), (0x100, false));\n        /// assert_eq!(0x10i32.overflowing_shl(36), (0x100, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(0x10i32.overflowing_shr(4), (0x1, false));\n        /// assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// Returns a tuple of the absolute version of self along with a\n        /// boolean indicating whether an overflow happened. If self is the\n        /// minimum value (e.g. i32::MIN for values of type i32), then the\n        /// minimum value will be returned again and true will be returned for\n        /// an overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(10i8.overflowing_abs(), (10,false));\n        /// assert_eq!((-10i8).overflowing_abs(), (10,false));\n        /// assert_eq!((-128i8).overflowing_abs(), (-128,true));\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[inline]\n        pub fn overflowing_abs(self) -> (Self, bool) {\n            if self.is_negative() {\n                self.overflowing_neg()\n            } else {\n                (self, false)\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let x: i32 = 2; // or any other integer type\n        ///\n        /// assert_eq!(x.pow(4), 16);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub fn pow(self, mut exp: u32) -> Self {\n            let mut base = self;\n            let mut acc = 1;\n\n            while exp > 1 {\n                if (exp & 1) == 1 {\n                    acc = acc * base;\n                }\n                exp /= 2;\n                base = base * base;\n            }\n\n            // Deal with the final bit of the exponent separately, since\n            // squaring the base afterwards is not necessary and may cause a\n            // needless overflow.\n            if exp == 1 {\n                acc = acc * base;\n            }\n\n            acc\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// # Overflow behavior\n        ///\n        /// The absolute value of `i32::min_value()` cannot be represented as an\n        /// `i32`, and attempting to calculate it will cause an overflow. This\n        /// means that code in debug mode will trigger a panic on this case and\n        /// optimized code will return `i32::min_value()` without a panic.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(10i8.abs(), 10);\n        /// assert_eq!((-10i8).abs(), 10);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub fn abs(self) -> Self {\n            if self.is_negative() {\n                // Note that the #[inline] above means that the overflow\n                // semantics of this negation depend on the crate we're being\n                // inlined into.\n                -self\n            } else {\n                self\n            }\n        }\n\n        /// Returns a number representing sign of `self`.\n        ///\n        /// - `0` if the number is zero\n        /// - `1` if the number is positive\n        /// - `-1` if the number is negative\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(10i8.signum(), 1);\n        /// assert_eq!(0i8.signum(), 0);\n        /// assert_eq!((-10i8).signum(), -1);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn signum(self) -> Self {\n            match self {\n                n if n > 0 =>  1,\n                0          =>  0,\n                _          => -1,\n            }\n        }\n\n        /// Returns `true` if `self` is positive and `false` if the number\n        /// is zero or negative.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert!(10i8.is_positive());\n        /// assert!(!(-10i8).is_positive());\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn is_positive(self) -> bool { self > 0 }\n\n        /// Returns `true` if `self` is negative and `false` if the number\n        /// is zero or positive.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert!((-10i8).is_negative());\n        /// assert!(!10i8.is_negative());\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn is_negative(self) -> bool { self < 0 }\n    }\n}\n\n#[lang = \"i8\"]\nimpl i8 {\n    int_impl! { i8, i8, u8, 8,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[lang = \"i16\"]\nimpl i16 {\n    int_impl! { i16, i16, u16, 16,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[lang = \"i32\"]\nimpl i32 {\n    int_impl! { i32, i32, u32, 32,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[lang = \"i64\"]\nimpl i64 {\n    int_impl! { i64, i64, u64, 64,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[lang = \"i128\"]\nimpl i128 {\n    int_impl! { i128, i128, u128, 128,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[cfg(target_pointer_width = \"16\")]\n#[lang = \"isize\"]\nimpl isize {\n    int_impl! { isize, i16, u16, 16,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[cfg(target_pointer_width = \"32\")]\n#[lang = \"isize\"]\nimpl isize {\n    int_impl! { isize, i32, u32, 32,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[cfg(target_pointer_width = \"64\")]\n#[lang = \"isize\"]\nimpl isize {\n    int_impl! { isize, i64, u64, 64,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n// `Int` + `UnsignedInt` implemented for unsigned integers\nmacro_rules! uint_impl {\n    ($SelfT:ty, $ActualT:ty, $BITS:expr,\n     $ctpop:path,\n     $ctlz:path,\n     $ctlz_nonzero:path,\n     $cttz:path,\n     $bswap:path,\n     $add_with_overflow:path,\n     $sub_with_overflow:path,\n     $mul_with_overflow:path) => {\n        /// Returns the smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// assert_eq!(u8::min_value(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub const fn min_value() -> Self { 0 }\n\n        /// Returns the largest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// assert_eq!(u8::max_value(), 255);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub const fn max_value() -> Self { !0 }\n\n        /// Converts a string slice in a given base to an integer.\n        ///\n        /// Leading and trailing whitespace represent an error.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(u32::from_str_radix(\"A\", 16), Ok(10));\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n            from_str_radix(src, radix)\n        }\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0b01001100u8;\n        ///\n        /// assert_eq!(n.count_ones(), 3);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn count_ones(self) -> u32 {\n            unsafe { $ctpop(self as $ActualT) as u32 }\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0b01001100u8;\n        ///\n        /// assert_eq!(n.count_zeros(), 5);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0b0101000u16;\n        ///\n        /// assert_eq!(n.leading_zeros(), 10);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn leading_zeros(self) -> u32 {\n            unsafe { $ctlz(self as $ActualT) as u32 }\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0b0101000u16;\n        ///\n        /// assert_eq!(n.trailing_zeros(), 3);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn trailing_zeros(self) -> u32 {\n            // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n            // emits two conditional moves on x86_64. By promoting the value to\n            // u16 and setting bit 8, we get better code without any conditional\n            // operations.\n            // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n            // pending, remove this workaround once LLVM generates better code\n            // for cttz8.\n            unsafe {\n                if $BITS == 8 {\n                    intrinsics::cttz(self as u16 | 0x100) as u32\n                } else {\n                    intrinsics::cttz(self) as u32\n                }\n            }\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as `<<`!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        /// let m = 0x3456789ABCDEF012u64;\n        ///\n        /// assert_eq!(n.rotate_left(12), m);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn rotate_left(self, n: u32) -> Self {\n            // Protect against undefined behaviour for over-long bit shifts\n            let n = n % $BITS;\n            (self << n) | (self >> (($BITS - n) % $BITS))\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as `>>`!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        /// let m = 0xDEF0123456789ABCu64;\n        ///\n        /// assert_eq!(n.rotate_right(12), m);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn rotate_right(self, n: u32) -> Self {\n            // Protect against undefined behaviour for over-long bit shifts\n            let n = n % $BITS;\n            (self >> n) | (self << (($BITS - n) % $BITS))\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        /// let m = 0xEFCDAB8967452301u64;\n        ///\n        /// assert_eq!(n.swap_bytes(), m);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn swap_bytes(self) -> Self {\n            unsafe { $bswap(self as $ActualT) as Self }\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(u64::from_be(n), n)\n        /// } else {\n        ///     assert_eq!(u64::from_be(n), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn from_be(x: Self) -> Self {\n            if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(u64::from_le(n), n)\n        /// } else {\n        ///     assert_eq!(u64::from_le(n), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn from_le(x: Self) -> Self {\n            if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn to_be(self) -> Self { // or not to be?\n            if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn to_le(self) -> Self {\n            if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n        }\n\n        /// Checked integer addition. Computes `self + other`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(5u16.checked_add(65530), Some(65535));\n        /// assert_eq!(6u16.checked_add(65530), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_add(self, other: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_add(other);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked integer subtraction. Computes `self - other`, returning\n        /// `None` if underflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(1u8.checked_sub(1), Some(0));\n        /// assert_eq!(0u8.checked_sub(1), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_sub(self, other: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_sub(other);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked integer multiplication. Computes `self * other`, returning\n        /// `None` if underflow or overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(5u8.checked_mul(51), Some(255));\n        /// assert_eq!(5u8.checked_mul(52), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_mul(self, other: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(other);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked integer division. Computes `self / other`, returning `None`\n        /// if `other == 0` or the operation results in underflow or overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(128u8.checked_div(2), Some(64));\n        /// assert_eq!(1u8.checked_div(0), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_div(self, other: Self) -> Option<Self> {\n            match other {\n                0 => None,\n                other => Some(unsafe { intrinsics::unchecked_div(self, other) }),\n            }\n        }\n\n        /// Checked integer remainder. Computes `self % other`, returning `None`\n        /// if `other == 0` or the operation results in underflow or overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(5u32.checked_rem(2), Some(1));\n        /// assert_eq!(5u32.checked_rem(0), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_rem(self, other: Self) -> Option<Self> {\n            if other == 0 {\n                None\n            } else {\n                Some(unsafe { intrinsics::unchecked_rem(self, other) })\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(0u32.checked_neg(), Some(0));\n        /// assert_eq!(1u32.checked_neg(), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(0x10u32.checked_shl(4), Some(0x100));\n        /// assert_eq!(0x10u32.checked_shl(33), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(0x10u32.checked_shr(4), Some(0x1));\n        /// assert_eq!(0x10u32.checked_shr(33), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Saturating integer addition. Computes `self + other`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.saturating_add(1), 101);\n        /// assert_eq!(200u8.saturating_add(127), 255);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn saturating_add(self, other: Self) -> Self {\n            match self.checked_add(other) {\n                Some(x) => x,\n                None => Self::max_value(),\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - other`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.saturating_sub(27), 73);\n        /// assert_eq!(13u8.saturating_sub(127), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn saturating_sub(self, other: Self) -> Self {\n            match self.checked_sub(other) {\n                Some(x) => x,\n                None => Self::min_value(),\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * other`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// use std::u32;\n        ///\n        /// assert_eq!(100u32.saturating_mul(127), 12700);\n        /// assert_eq!((1u32 << 23).saturating_mul(1 << 23), u32::MAX);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn saturating_mul(self, other: Self) -> Self {\n            self.checked_mul(other).unwrap_or(Self::max_value())\n        }\n\n        /// Wrapping (modular) addition. Computes `self + other`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(200u8.wrapping_add(55), 255);\n        /// assert_eq!(200u8.wrapping_add(155), 99);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn wrapping_add(self, rhs: Self) -> Self {\n            unsafe {\n                intrinsics::overflowing_add(self, rhs)\n            }\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - other`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.wrapping_sub(100), 0);\n        /// assert_eq!(100u8.wrapping_sub(155), 201);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn wrapping_sub(self, rhs: Self) -> Self {\n            unsafe {\n                intrinsics::overflowing_sub(self, rhs)\n            }\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// other`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn wrapping_mul(self, rhs: Self) -> Self {\n            unsafe {\n                intrinsics::overflowing_mul(self, rhs)\n            }\n        }\n\n        /// Wrapping (modular) division. Computes `self / other`.\n        /// Wrapped division on unsigned types is just normal division.\n        /// There's no way wrapping could ever happen.\n        /// This function exists, so that all operations\n        /// are accounted for in the wrapping operations.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.wrapping_div(10), 10);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline(always)]\n        pub fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % other`.\n        /// Wrapped remainder calculation on unsigned types is\n        /// just the regular remainder calculation.\n        /// There's no way wrapping could ever happen.\n        /// This function exists, so that all operations\n        /// are accounted for in the wrapping operations.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.wrapping_rem(10), 0);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline(always)]\n        pub fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.wrapping_neg(), 156);\n        /// assert_eq!(0u8.wrapping_neg(), 0);\n        /// assert_eq!(180u8.wrapping_neg(), 76);\n        /// assert_eq!(180u8.wrapping_neg(), (127 + 1) - (180u8 - (127 + 1)));\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline(always)]\n        pub fn wrapping_neg(self) -> Self {\n            self.overflowing_neg().0\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a `rotate_left` function, which may\n        /// be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(1u8.wrapping_shl(7), 128);\n        /// assert_eq!(1u8.wrapping_shl(8), 1);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline(always)]\n        pub fn wrapping_shl(self, rhs: u32) -> Self {\n            unsafe {\n                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a `rotate_right` function, which may\n        /// be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(128u8.wrapping_shr(7), 1);\n        /// assert_eq!(128u8.wrapping_shr(8), 128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline(always)]\n        pub fn wrapping_shr(self, rhs: u32) -> Self {\n            unsafe {\n                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n            }\n        }\n\n        /// Calculates `self` + `rhs`\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::u32;\n        ///\n        /// assert_eq!(5u32.overflowing_add(2), (7, false));\n        /// assert_eq!(u32::MAX.overflowing_add(1), (0, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            unsafe {\n                let (a, b) = $add_with_overflow(self as $ActualT,\n                                                rhs as $ActualT);\n                (a as Self, b)\n            }\n        }\n\n        /// Calculates `self` - `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::u32;\n        ///\n        /// assert_eq!(5u32.overflowing_sub(2), (3, false));\n        /// assert_eq!(0u32.overflowing_sub(1), (u32::MAX, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            unsafe {\n                let (a, b) = $sub_with_overflow(self as $ActualT,\n                                                rhs as $ActualT);\n                (a as Self, b)\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            unsafe {\n                let (a, b) = $mul_with_overflow(self as $ActualT,\n                                                rhs as $ActualT);\n                (a as Self, b)\n            }\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_div(2), (2, false));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_rem(2), (1, false));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(0u32.overflowing_neg(), (0, false));\n        /// assert_eq!(2u32.overflowing_neg(), (-2i32 as u32, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(0x10u32.overflowing_shl(4), (0x100, false));\n        /// assert_eq!(0x10u32.overflowing_shl(36), (0x100, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(0x10u32.overflowing_shr(4), (0x1, false));\n        /// assert_eq!(0x10u32.overflowing_shr(36), (0x1, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(2u32.pow(4), 16);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub fn pow(self, mut exp: u32) -> Self {\n            let mut base = self;\n            let mut acc = 1;\n\n            while exp > 1 {\n                if (exp & 1) == 1 {\n                    acc = acc * base;\n                }\n                exp /= 2;\n                base = base * base;\n            }\n\n            // Deal with the final bit of the exponent separately, since\n            // squaring the base afterwards is not necessary and may cause a\n            // needless overflow.\n            if exp == 1 {\n                acc = acc * base;\n            }\n\n            acc\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert!(16u8.is_power_of_two());\n        /// assert!(!10u8.is_power_of_two());\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn is_power_of_two(self) -> bool {\n            (self.wrapping_sub(1)) & self == 0 && !(self == 0)\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            // Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let p = self - 1;\n            let z = unsafe { $ctlz_nonzero(p) };\n            <$SelfT>::max_value() >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e. `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and return value is wrapped to 0 in\n        /// release mode (the only situation in which method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(2u8.next_power_of_two(), 2);\n        /// assert_eq!(3u8.next_power_of_two(), 4);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(2u8.checked_next_power_of_two(), Some(2));\n        /// assert_eq!(3u8.checked_next_power_of_two(), Some(4));\n        /// assert_eq!(200u8.checked_next_power_of_two(), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n    }\n}\n\n#[cfg(stage0)]\nunsafe fn ctlz_nonzero<T>(x: T) -> T { intrinsics::ctlz(x) }\n#[cfg(not(stage0))]\nunsafe fn ctlz_nonzero<T>(x: T) -> T { intrinsics::ctlz_nonzero(x) }\n\n#[lang = \"u8\"]\nimpl u8 {\n    uint_impl! { u8, u8, 8,\n        intrinsics::ctpop,\n        intrinsics::ctlz,\n        ctlz_nonzero,\n        intrinsics::cttz,\n        intrinsics::bswap,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[lang = \"u16\"]\nimpl u16 {\n    uint_impl! { u16, u16, 16,\n        intrinsics::ctpop,\n        intrinsics::ctlz,\n        ctlz_nonzero,\n        intrinsics::cttz,\n        intrinsics::bswap,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[lang = \"u32\"]\nimpl u32 {\n    uint_impl! { u32, u32, 32,\n        intrinsics::ctpop,\n        intrinsics::ctlz,\n        ctlz_nonzero,\n        intrinsics::cttz,\n        intrinsics::bswap,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[lang = \"u64\"]\nimpl u64 {\n    uint_impl! { u64, u64, 64,\n        intrinsics::ctpop,\n        intrinsics::ctlz,\n        ctlz_nonzero,\n        intrinsics::cttz,\n        intrinsics::bswap,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[lang = \"u128\"]\nimpl u128 {\n    uint_impl! { u128, u128, 128,\n        intrinsics::ctpop,\n        intrinsics::ctlz,\n        ctlz_nonzero,\n        intrinsics::cttz,\n        intrinsics::bswap,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[cfg(target_pointer_width = \"16\")]\n#[lang = \"usize\"]\nimpl usize {\n    uint_impl! { usize, u16, 16,\n        intrinsics::ctpop,\n        intrinsics::ctlz,\n        ctlz_nonzero,\n        intrinsics::cttz,\n        intrinsics::bswap,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n#[cfg(target_pointer_width = \"32\")]\n#[lang = \"usize\"]\nimpl usize {\n    uint_impl! { usize, u32, 32,\n        intrinsics::ctpop,\n        intrinsics::ctlz,\n        ctlz_nonzero,\n        intrinsics::cttz,\n        intrinsics::bswap,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n#[cfg(target_pointer_width = \"64\")]\n#[lang = \"usize\"]\nimpl usize {\n    uint_impl! { usize, u64, 64,\n        intrinsics::ctpop,\n        intrinsics::ctlz,\n        ctlz_nonzero,\n        intrinsics::cttz,\n        intrinsics::bswap,\n        intrinsics::add_with_overflow,\n        intrinsics::sub_with_overflow,\n        intrinsics::mul_with_overflow }\n}\n\n/// A classification of floating point numbers.\n///\n/// This `enum` is used as the return type for [`f32::classify`] and [`f64::classify`]. See\n/// their documentation for more.\n///\n/// [`f32::classify`]: ../../std/primitive.f32.html#method.classify\n/// [`f64::classify`]: ../../std/primitive.f64.html#method.classify\n///\n/// # Examples\n///\n/// ```\n/// use std::num::FpCategory;\n/// use std::f32;\n///\n/// let num = 12.4_f32;\n/// let inf = f32::INFINITY;\n/// let zero = 0f32;\n/// let sub: f32 = 1.1754942e-38;\n/// let nan = f32::NAN;\n///\n/// assert_eq!(num.classify(), FpCategory::Normal);\n/// assert_eq!(inf.classify(), FpCategory::Infinite);\n/// assert_eq!(zero.classify(), FpCategory::Zero);\n/// assert_eq!(nan.classify(), FpCategory::Nan);\n/// assert_eq!(sub.classify(), FpCategory::Subnormal);\n/// ```\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum FpCategory {\n    /// \"Not a Number\", often obtained by dividing by zero.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Nan,\n\n    /// Positive or negative infinity.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Infinite,\n\n    /// Positive or negative zero.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Zero,\n\n    /// De-normalized floating point representation (less precise than `Normal`).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Subnormal,\n\n    /// A regular floating point number.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Normal,\n}\n\n/// A built-in floating point number.\n#[doc(hidden)]\n#[unstable(feature = \"core_float\",\n           reason = \"stable interface is via `impl f{32,64}` in later crates\",\n           issue = \"32110\")]\npub trait Float: Sized {\n    /// Returns `true` if this value is NaN and false otherwise.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_nan(self) -> bool;\n    /// Returns `true` if this value is positive infinity or negative infinity and\n    /// false otherwise.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_infinite(self) -> bool;\n    /// Returns `true` if this number is neither infinite nor NaN.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_finite(self) -> bool;\n    /// Returns `true` if this number is neither zero, infinite, denormal, or NaN.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_normal(self) -> bool;\n    /// Returns the category that this number falls into.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn classify(self) -> FpCategory;\n\n    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n    /// number is `Float::nan()`.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn abs(self) -> Self;\n    /// Returns a number that represents the sign of `self`.\n    ///\n    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n    /// - `Float::nan()` if the number is `Float::nan()`\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn signum(self) -> Self;\n\n    /// Returns `true` if `self` is positive, including `+0.0` and\n    /// `Float::infinity()`.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_sign_positive(self) -> bool;\n    /// Returns `true` if `self` is negative, including `-0.0` and\n    /// `Float::neg_infinity()`.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_sign_negative(self) -> bool;\n\n    /// Take the reciprocal (inverse) of a number, `1/x`.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn recip(self) -> Self;\n\n    /// Raise a number to an integer power.\n    ///\n    /// Using this function is generally faster than using `powf`\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn powi(self, n: i32) -> Self;\n\n    /// Convert radians to degrees.\n    #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n    fn to_degrees(self) -> Self;\n    /// Convert degrees to radians.\n    #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n    fn to_radians(self) -> Self;\n\n    /// Returns the maximum of the two numbers.\n    #[stable(feature = \"core_float_min_max\", since=\"1.20.0\")]\n    fn max(self, other: Self) -> Self;\n    /// Returns the minimum of the two numbers.\n    #[stable(feature = \"core_float_min_max\", since=\"1.20.0\")]\n    fn min(self, other: Self) -> Self;\n}\n\nmacro_rules! from_str_radix_int_impl {\n    ($($t:ty)*) => {$(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl FromStr for $t {\n            type Err = ParseIntError;\n            fn from_str(src: &str) -> Result<Self, ParseIntError> {\n                from_str_radix(src, 10)\n            }\n        }\n    )*}\n}\nfrom_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n\n/// The error type returned when a checked integral type conversion fails.\n#[unstable(feature = \"try_from\", issue = \"33417\")]\n#[derive(Debug, Copy, Clone)]\npub struct TryFromIntError(());\n\nimpl TryFromIntError {\n    #[unstable(feature = \"int_error_internals\",\n               reason = \"available through Error trait and this method should \\\n                         not be exposed publicly\",\n               issue = \"0\")]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n        \"out of range integral type conversion attempted\"\n    }\n}\n\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl fmt::Display for TryFromIntError {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        self.__description().fmt(fmt)\n    }\n}\n\nmacro_rules! same_sign_try_from_int_impl {\n    ($storage:ty, $target:ty, $($source:ty),*) => {$(\n        #[unstable(feature = \"try_from\", issue = \"33417\")]\n        impl TryFrom<$source> for $target {\n            type Error = TryFromIntError;\n\n            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n                let min = <$target as FromStrRadixHelper>::min_value() as $storage;\n                let max = <$target as FromStrRadixHelper>::max_value() as $storage;\n                if u as $storage < min || u as $storage > max {\n                    Err(TryFromIntError(()))\n                } else {\n                    Ok(u as $target)\n                }\n            }\n        }\n    )*}\n}\n\nsame_sign_try_from_int_impl!(u128, u8, u8, u16, u32, u64, u128, usize);\nsame_sign_try_from_int_impl!(i128, i8, i8, i16, i32, i64, i128, isize);\nsame_sign_try_from_int_impl!(u128, u16, u8, u16, u32, u64, u128, usize);\nsame_sign_try_from_int_impl!(i128, i16, i8, i16, i32, i64, i128, isize);\nsame_sign_try_from_int_impl!(u128, u32, u8, u16, u32, u64, u128, usize);\nsame_sign_try_from_int_impl!(i128, i32, i8, i16, i32, i64, i128, isize);\nsame_sign_try_from_int_impl!(u128, u64, u8, u16, u32, u64, u128, usize);\nsame_sign_try_from_int_impl!(i128, i64, i8, i16, i32, i64, i128, isize);\nsame_sign_try_from_int_impl!(u128, u128, u8, u16, u32, u64, u128, usize);\nsame_sign_try_from_int_impl!(i128, i128, i8, i16, i32, i64, i128, isize);\nsame_sign_try_from_int_impl!(u128, usize, u8, u16, u32, u64, u128, usize);\nsame_sign_try_from_int_impl!(i128, isize, i8, i16, i32, i64, i128, isize);\n\nmacro_rules! cross_sign_from_int_impl {\n    ($unsigned:ty, $($signed:ty),*) => {$(\n        #[unstable(feature = \"try_from\", issue = \"33417\")]\n        impl TryFrom<$unsigned> for $signed {\n            type Error = TryFromIntError;\n\n            fn try_from(u: $unsigned) -> Result<$signed, TryFromIntError> {\n                let max = <$signed as FromStrRadixHelper>::max_value() as u128;\n                if u as u128 > max {\n                    Err(TryFromIntError(()))\n                } else {\n                    Ok(u as $signed)\n                }\n            }\n        }\n\n        #[unstable(feature = \"try_from\", issue = \"33417\")]\n        impl TryFrom<$signed> for $unsigned {\n            type Error = TryFromIntError;\n\n            fn try_from(u: $signed) -> Result<$unsigned, TryFromIntError> {\n                let max = <$unsigned as FromStrRadixHelper>::max_value() as u128;\n                if u < 0 || u as u128 > max {\n                    Err(TryFromIntError(()))\n                } else {\n                    Ok(u as $unsigned)\n                }\n            }\n        }\n    )*}\n}\n\ncross_sign_from_int_impl!(u8, i8, i16, i32, i64, i128, isize);\ncross_sign_from_int_impl!(u16, i8, i16, i32, i64, i128, isize);\ncross_sign_from_int_impl!(u32, i8, i16, i32, i64, i128, isize);\ncross_sign_from_int_impl!(u64, i8, i16, i32, i64, i128, isize);\ncross_sign_from_int_impl!(u128, i8, i16, i32, i64, i128, isize);\ncross_sign_from_int_impl!(usize, i8, i16, i32, i64, i128, isize);\n\n#[doc(hidden)]\ntrait FromStrRadixHelper: PartialOrd + Copy {\n    fn min_value() -> Self;\n    fn max_value() -> Self;\n    fn from_u32(u: u32) -> Self;\n    fn checked_mul(&self, other: u32) -> Option<Self>;\n    fn checked_sub(&self, other: u32) -> Option<Self>;\n    fn checked_add(&self, other: u32) -> Option<Self>;\n}\n\nmacro_rules! doit {\n    ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n        fn min_value() -> Self { Self::min_value() }\n        fn max_value() -> Self { Self::max_value() }\n        fn from_u32(u: u32) -> Self { u as Self }\n        fn checked_mul(&self, other: u32) -> Option<Self> {\n            Self::checked_mul(*self, other as Self)\n        }\n        fn checked_sub(&self, other: u32) -> Option<Self> {\n            Self::checked_sub(*self, other as Self)\n        }\n        fn checked_add(&self, other: u32) -> Option<Self> {\n            Self::checked_add(*self, other as Self)\n        }\n    })*)\n}\ndoit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n\nfn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {\n    use self::IntErrorKind::*;\n    use self::ParseIntError as PIE;\n\n    assert!(radix >= 2 && radix <= 36,\n           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n           radix);\n\n    if src.is_empty() {\n        return Err(PIE { kind: Empty });\n    }\n\n    let is_signed_ty = T::from_u32(0) > T::min_value();\n\n    // all valid digits are ascii, so we will just iterate over the utf8 bytes\n    // and cast them to chars. .to_digit() will safely return None for anything\n    // other than a valid ascii digit for the given radix, including the first-byte\n    // of multi-byte sequences\n    let src = src.as_bytes();\n\n    let (is_positive, digits) = match src[0] {\n        b'+' => (true, &src[1..]),\n        b'-' if is_signed_ty => (false, &src[1..]),\n        _ => (true, src),\n    };\n\n    if digits.is_empty() {\n        return Err(PIE { kind: Empty });\n    }\n\n    let mut result = T::from_u32(0);\n    if is_positive {\n        // The number is positive\n        for &c in digits {\n            let x = match (c as char).to_digit(radix) {\n                Some(x) => x,\n                None => return Err(PIE { kind: InvalidDigit }),\n            };\n            result = match result.checked_mul(radix) {\n                Some(result) => result,\n                None => return Err(PIE { kind: Overflow }),\n            };\n            result = match result.checked_add(x) {\n                Some(result) => result,\n                None => return Err(PIE { kind: Overflow }),\n            };\n        }\n    } else {\n        // The number is negative\n        for &c in digits {\n            let x = match (c as char).to_digit(radix) {\n                Some(x) => x,\n                None => return Err(PIE { kind: InvalidDigit }),\n            };\n            result = match result.checked_mul(radix) {\n                Some(result) => result,\n                None => return Err(PIE { kind: Underflow }),\n            };\n            result = match result.checked_sub(x) {\n                Some(result) => result,\n                None => return Err(PIE { kind: Underflow }),\n            };\n        }\n    }\n    Ok(result)\n}\n\n/// An error which can be returned when parsing an integer.\n///\n/// This error is used as the error type for the `from_str_radix()` functions\n/// on the primitive integer types, such as [`i8::from_str_radix`].\n///\n/// [`i8::from_str_radix`]: ../../std/primitive.i8.html#method.from_str_radix\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ParseIntError {\n    kind: IntErrorKind,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nenum IntErrorKind {\n    Empty,\n    InvalidDigit,\n    Overflow,\n    Underflow,\n}\n\nimpl ParseIntError {\n    #[unstable(feature = \"int_error_internals\",\n               reason = \"available through Error trait and this method should \\\n                         not be exposed publicly\",\n               issue = \"0\")]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n        match self.kind {\n            IntErrorKind::Empty => \"cannot parse integer from empty string\",\n            IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n            IntErrorKind::Overflow => \"number too large to fit in target type\",\n            IntErrorKind::Underflow => \"number too small to fit in target type\",\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for ParseIntError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.__description().fmt(f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use num::dec2flt::ParseFloatError;\n\n// Conversion traits for primitive integer and float types\n// Conversions T -> T are covered by a blanket impl and therefore excluded\n// Some conversions from and to usize/isize are not implemented due to portability concerns\nmacro_rules! impl_from {\n    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n        #[$attr]\n        impl From<$Small> for $Large {\n            #[inline]\n            fn from(small: $Small) -> $Large {\n                small as $Large\n            }\n        }\n    }\n}\n\n// Unsigned -> Unsigned\nimpl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u32, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { u64, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n\n// Signed -> Signed\nimpl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i8, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i16, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i32, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { i64, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n\n// Unsigned -> Signed\nimpl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u32, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { u64, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n\n// Note: integers can only be represented with full precision in a float if\n// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n// Lossy float conversions are not implemented at this time.\n\n// Signed -> Float\nimpl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n\n// Unsigned -> Float\nimpl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n\n// Float -> Float\nimpl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n","// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Composable external iteration.\n//!\n//! If you've found yourself with a collection of some kind, and needed to\n//! perform an operation on the elements of said collection, you'll quickly run\n//! into 'iterators'. Iterators are heavily used in idiomatic Rust code, so\n//! it's worth becoming familiar with them.\n//!\n//! Before explaining more, let's talk about how this module is structured:\n//!\n//! # Organization\n//!\n//! This module is largely organized by type:\n//!\n//! * [Traits] are the core portion: these traits define what kind of iterators\n//!   exist and what you can do with them. The methods of these traits are worth\n//!   putting some extra study time into.\n//! * [Functions] provide some helpful ways to create some basic iterators.\n//! * [Structs] are often the return types of the various methods on this\n//!   module's traits. You'll usually want to look at the method that creates\n//!   the `struct`, rather than the `struct` itself. For more detail about why,\n//!   see '[Implementing Iterator](#implementing-iterator)'.\n//!\n//! [Traits]: #traits\n//! [Functions]: #functions\n//! [Structs]: #structs\n//!\n//! That's it! Let's dig into iterators.\n//!\n//! # Iterator\n//!\n//! The heart and soul of this module is the [`Iterator`] trait. The core of\n//! [`Iterator`] looks like this:\n//!\n//! ```\n//! trait Iterator {\n//!     type Item;\n//!     fn next(&mut self) -> Option<Self::Item>;\n//! }\n//! ```\n//!\n//! An iterator has a method, [`next`], which when called, returns an\n//! [`Option`]`<Item>`. [`next`] will return `Some(Item)` as long as there\n//! are elements, and once they've all been exhausted, will return `None` to\n//! indicate that iteration is finished. Individual iterators may choose to\n//! resume iteration, and so calling [`next`] again may or may not eventually\n//! start returning `Some(Item)` again at some point.\n//!\n//! [`Iterator`]'s full definition includes a number of other methods as well,\n//! but they are default methods, built on top of [`next`], and so you get\n//! them for free.\n//!\n//! Iterators are also composable, and it's common to chain them together to do\n//! more complex forms of processing. See the [Adapters](#adapters) section\n//! below for more details.\n//!\n//! [`Iterator`]: trait.Iterator.html\n//! [`next`]: trait.Iterator.html#tymethod.next\n//! [`Option`]: ../../std/option/enum.Option.html\n//!\n//! # The three forms of iteration\n//!\n//! There are three common methods which can create iterators from a collection:\n//!\n//! * `iter()`, which iterates over `&T`.\n//! * `iter_mut()`, which iterates over `&mut T`.\n//! * `into_iter()`, which iterates over `T`.\n//!\n//! Various things in the standard library may implement one or more of the\n//! three, where appropriate.\n//!\n//! # Implementing Iterator\n//!\n//! Creating an iterator of your own involves two steps: creating a `struct` to\n//! hold the iterator's state, and then `impl`ementing [`Iterator`] for that\n//! `struct`. This is why there are so many `struct`s in this module: there is\n//! one for each iterator and iterator adapter.\n//!\n//! Let's make an iterator named `Counter` which counts from `1` to `5`:\n//!\n//! ```\n//! // First, the struct:\n//!\n//! /// An iterator which counts from one to five\n//! struct Counter {\n//!     count: usize,\n//! }\n//!\n//! // we want our count to start at one, so let's add a new() method to help.\n//! // This isn't strictly necessary, but is convenient. Note that we start\n//! // `count` at zero, we'll see why in `next()`'s implementation below.\n//! impl Counter {\n//!     fn new() -> Counter {\n//!         Counter { count: 0 }\n//!     }\n//! }\n//!\n//! // Then, we implement `Iterator` for our `Counter`:\n//!\n//! impl Iterator for Counter {\n//!     // we will be counting with usize\n//!     type Item = usize;\n//!\n//!     // next() is the only required method\n//!     fn next(&mut self) -> Option<usize> {\n//!         // increment our count. This is why we started at zero.\n//!         self.count += 1;\n//!\n//!         // check to see if we've finished counting or not.\n//!         if self.count < 6 {\n//!             Some(self.count)\n//!         } else {\n//!             None\n//!         }\n//!     }\n//! }\n//!\n//! // And now we can use it!\n//!\n//! let mut counter = Counter::new();\n//!\n//! let x = counter.next().unwrap();\n//! println!(\"{}\", x);\n//!\n//! let x = counter.next().unwrap();\n//! println!(\"{}\", x);\n//!\n//! let x = counter.next().unwrap();\n//! println!(\"{}\", x);\n//!\n//! let x = counter.next().unwrap();\n//! println!(\"{}\", x);\n//!\n//! let x = counter.next().unwrap();\n//! println!(\"{}\", x);\n//! ```\n//!\n//! This will print `1` through `5`, each on their own line.\n//!\n//! Calling `next()` this way gets repetitive. Rust has a construct which can\n//! call `next()` on your iterator, until it reaches `None`. Let's go over that\n//! next.\n//!\n//! # for Loops and IntoIterator\n//!\n//! Rust's `for` loop syntax is actually sugar for iterators. Here's a basic\n//! example of `for`:\n//!\n//! ```\n//! let values = vec![1, 2, 3, 4, 5];\n//!\n//! for x in values {\n//!     println!(\"{}\", x);\n//! }\n//! ```\n//!\n//! This will print the numbers one through five, each on their own line. But\n//! you'll notice something here: we never called anything on our vector to\n//! produce an iterator. What gives?\n//!\n//! There's a trait in the standard library for converting something into an\n//! iterator: [`IntoIterator`]. This trait has one method, [`into_iter`],\n//! which converts the thing implementing [`IntoIterator`] into an iterator.\n//! Let's take a look at that `for` loop again, and what the compiler converts\n//! it into:\n//!\n//! [`IntoIterator`]: trait.IntoIterator.html\n//! [`into_iter`]: trait.IntoIterator.html#tymethod.into_iter\n//!\n//! ```\n//! let values = vec![1, 2, 3, 4, 5];\n//!\n//! for x in values {\n//!     println!(\"{}\", x);\n//! }\n//! ```\n//!\n//! Rust de-sugars this into:\n//!\n//! ```\n//! let values = vec![1, 2, 3, 4, 5];\n//! {\n//!     let result = match IntoIterator::into_iter(values) {\n//!         mut iter => loop {\n//!             let next;\n//!             match iter.next() {\n//!                 Some(val) => next = val,\n//!                 None => break,\n//!             };\n//!             let x = next;\n//!             let () = { println!(\"{}\", x); };\n//!         },\n//!     };\n//!     result\n//! }\n//! ```\n//!\n//! First, we call `into_iter()` on the value. Then, we match on the iterator\n//! that returns, calling [`next`] over and over until we see a `None`. At\n//! that point, we `break` out of the loop, and we're done iterating.\n//!\n//! There's one more subtle bit here: the standard library contains an\n//! interesting implementation of [`IntoIterator`]:\n//!\n//! ```ignore (only-for-syntax-highlight)\n//! impl<I: Iterator> IntoIterator for I\n//! ```\n//!\n//! In other words, all [`Iterator`]s implement [`IntoIterator`], by just\n//! returning themselves. This means two things:\n//!\n//! 1. If you're writing an [`Iterator`], you can use it with a `for` loop.\n//! 2. If you're creating a collection, implementing [`IntoIterator`] for it\n//!    will allow your collection to be used with the `for` loop.\n//!\n//! # Adapters\n//!\n//! Functions which take an [`Iterator`] and return another [`Iterator`] are\n//! often called 'iterator adapters', as they're a form of the 'adapter\n//! pattern'.\n//!\n//! Common iterator adapters include [`map`], [`take`], and [`filter`].\n//! For more, see their documentation.\n//!\n//! [`map`]: trait.Iterator.html#method.map\n//! [`take`]: trait.Iterator.html#method.take\n//! [`filter`]: trait.Iterator.html#method.filter\n//!\n//! # Laziness\n//!\n//! Iterators (and iterator [adapters](#adapters)) are *lazy*. This means that\n//! just creating an iterator doesn't _do_ a whole lot. Nothing really happens\n//! until you call [`next`]. This is sometimes a source of confusion when\n//! creating an iterator solely for its side effects. For example, the [`map`]\n//! method calls a closure on each element it iterates over:\n//!\n//! ```\n//! # #![allow(unused_must_use)]\n//! let v = vec![1, 2, 3, 4, 5];\n//! v.iter().map(|x| println!(\"{}\", x));\n//! ```\n//!\n//! This will not print any values, as we only created an iterator, rather than\n//! using it. The compiler will warn us about this kind of behavior:\n//!\n//! ```text\n//! warning: unused result which must be used: iterator adaptors are lazy and\n//! do nothing unless consumed\n//! ```\n//!\n//! The idiomatic way to write a [`map`] for its side effects is to use a\n//! `for` loop instead:\n//!\n//! ```\n//! let v = vec![1, 2, 3, 4, 5];\n//!\n//! for x in &v {\n//!     println!(\"{}\", x);\n//! }\n//! ```\n//!\n//! [`map`]: trait.Iterator.html#method.map\n//!\n//! The two most common ways to evaluate an iterator are to use a `for` loop\n//! like this, or using the [`collect`] method to produce a new collection.\n//!\n//! [`collect`]: trait.Iterator.html#method.collect\n//!\n//! # Infinity\n//!\n//! Iterators do not have to be finite. As an example, an open-ended range is\n//! an infinite iterator:\n//!\n//! ```\n//! let numbers = 0..;\n//! ```\n//!\n//! It is common to use the [`take`] iterator adapter to turn an infinite\n//! iterator into a finite one:\n//!\n//! ```\n//! let numbers = 0..;\n//! let five_numbers = numbers.take(5);\n//!\n//! for number in five_numbers {\n//!     println!(\"{}\", number);\n//! }\n//! ```\n//!\n//! This will print the numbers `0` through `4`, each on their own line.\n//!\n//! [`take`]: trait.Iterator.html#method.take\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse cmp;\nuse fmt;\nuse iter_private::TrustedRandomAccess;\nuse usize;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::iterator::Iterator;\n\n#[unstable(feature = \"step_trait\",\n           reason = \"likely to be replaced by finer-grained traits\",\n           issue = \"42168\")]\npub use self::range::Step;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::sources::{Repeat, repeat};\n#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\npub use self::sources::{Empty, empty};\n#[stable(feature = \"iter_once\", since = \"1.2.0\")]\npub use self::sources::{Once, once};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::traits::{ExactSizeIterator, Sum, Product};\n#[unstable(feature = \"fused\", issue = \"35602\")]\npub use self::traits::FusedIterator;\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\npub use self::traits::TrustedLen;\n\nmod iterator;\nmod range;\nmod sources;\nmod traits;\n\n/// A double-ended iterator with the direction inverted.\n///\n/// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`rev`]: trait.Iterator.html#method.rev\n/// [`Iterator`]: trait.Iterator.html\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Rev<T> {\n    iter: T\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n    type Item = <I as Iterator>::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n\n    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n        where P: FnMut(&Self::Item) -> bool\n    {\n        self.iter.rfind(predicate)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n    #[inline]\n    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n\n    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n        where P: FnMut(&Self::Item) -> bool\n    {\n        self.iter.find(predicate)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> ExactSizeIterator for Rev<I>\n    where I: ExactSizeIterator + DoubleEndedIterator\n{\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I> FusedIterator for Rev<I>\n    where I: FusedIterator + DoubleEndedIterator {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<I> TrustedLen for Rev<I>\n    where I: TrustedLen + DoubleEndedIterator {}\n\n/// An iterator that clones the elements of an underlying iterator.\n///\n/// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`cloned`]: trait.Iterator.html#method.cloned\n/// [`Iterator`]: trait.Iterator.html\n#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[derive(Clone, Debug)]\npub struct Cloned<I> {\n    it: I,\n}\n\n#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\nimpl<'a, I, T: 'a> Iterator for Cloned<I>\n    where I: Iterator<Item=&'a T>, T: Clone\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        self.it.next().cloned()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n\n    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n        where F: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.it.fold(init, move |acc, elt| f(acc, elt.clone()))\n    }\n}\n\n#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\nimpl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n    where I: DoubleEndedIterator<Item=&'a T>, T: Clone\n{\n    fn next_back(&mut self) -> Option<T> {\n        self.it.next_back().cloned()\n    }\n}\n\n#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\nimpl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n    where I: ExactSizeIterator<Item=&'a T>, T: Clone\n{\n    fn len(&self) -> usize {\n        self.it.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.it.is_empty()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, I, T: 'a> FusedIterator for Cloned<I>\n    where I: FusedIterator<Item=&'a T>, T: Clone\n{}\n\n#[doc(hidden)]\nunsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n    where I: TrustedRandomAccess<Item=&'a T>, T: Clone\n{\n    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n        self.it.get_unchecked(i).clone()\n    }\n\n    #[inline]\n    fn may_have_side_effect() -> bool { true }\n}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n    where I: TrustedLen<Item=&'a T>,\n          T: Clone\n{}\n\n/// An iterator that repeats endlessly.\n///\n/// This `struct` is created by the [`cycle`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`cycle`]: trait.Iterator.html#method.cycle\n/// [`Iterator`]: trait.Iterator.html\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Cycle<I> {\n    orig: I,\n    iter: I,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n    type Item = <I as Iterator>::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n        match self.iter.next() {\n            None => { self.iter = self.orig.clone(); self.iter.next() }\n            y => y\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // the cycle iterator is either empty or infinite\n        match self.orig.size_hint() {\n            sz @ (0, Some(0)) => sz,\n            (0, _) => (0, None),\n            _ => (usize::MAX, None)\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n\n/// An adapter for stepping iterators by a custom amount.\n///\n/// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n/// its documentation for more.\n///\n/// [`step_by`]: trait.Iterator.html#method.step_by\n/// [`Iterator`]: trait.Iterator.html\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[unstable(feature = \"iterator_step_by\",\n           reason = \"unstable replacement of Range::step_by\",\n           issue = \"27741\")]\n#[derive(Clone, Debug)]\npub struct StepBy<I> {\n    iter: I,\n    step: usize,\n    first_take: bool,\n}\n\n#[unstable(feature = \"iterator_step_by\",\n           reason = \"unstable replacement of Range::step_by\",\n           issue = \"27741\")]\nimpl<I> Iterator for StepBy<I> where I: Iterator {\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first_take {\n            self.first_take = false;\n            self.iter.next()\n        } else {\n            self.iter.nth(self.step)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let inner_hint = self.iter.size_hint();\n\n        if self.first_take {\n            let f = |n| if n == 0 { 0 } else { 1 + (n-1)/(self.step+1) };\n            (f(inner_hint.0), inner_hint.1.map(f))\n        } else {\n            let f = |n| n / (self.step+1);\n            (f(inner_hint.0), inner_hint.1.map(f))\n        }\n    }\n}\n\n// StepBy can only make the iterator shorter, so the len will still fit.\n#[unstable(feature = \"iterator_step_by\",\n           reason = \"unstable replacement of Range::step_by\",\n           issue = \"27741\")]\nimpl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n\n/// An iterator that strings two iterators together.\n///\n/// This `struct` is created by the [`chain`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`chain`]: trait.Iterator.html#method.chain\n/// [`Iterator`]: trait.Iterator.html\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Chain<A, B> {\n    a: A,\n    b: B,\n    state: ChainState,\n}\n\n// The iterator protocol specifies that iteration ends with the return value\n// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n// further calls return. The chain adaptor must account for this since it uses\n// two subiterators.\n//\n//  It uses three states:\n//\n//  - Both: `a` and `b` are remaining\n//  - Front: `a` remaining\n//  - Back: `b` remaining\n//\n//  The fourth state (neither iterator is remaining) only occurs after Chain has\n//  returned None once, so we don't need to store this state.\n#[derive(Clone, Debug)]\nenum ChainState {\n    // both front and back iterator are remaining\n    Both,\n    // only front is remaining\n    Front,\n    // only back is remaining\n    Back,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> Iterator for Chain<A, B> where\n    A: Iterator,\n    B: Iterator<Item = A::Item>\n{\n    type Item = A::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<A::Item> {\n        match self.state {\n            ChainState::Both => match self.a.next() {\n                elt @ Some(..) => elt,\n                None => {\n                    self.state = ChainState::Back;\n                    self.b.next()\n                }\n            },\n            ChainState::Front => self.a.next(),\n            ChainState::Back => self.b.next(),\n        }\n    }\n\n    #[inline]\n    #[rustc_inherit_overflow_checks]\n    fn count(self) -> usize {\n        match self.state {\n            ChainState::Both => self.a.count() + self.b.count(),\n            ChainState::Front => self.a.count(),\n            ChainState::Back => self.b.count(),\n        }\n    }\n\n    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n        where F: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut accum = init;\n        match self.state {\n            ChainState::Both | ChainState::Front => {\n                accum = self.a.fold(accum, &mut f);\n            }\n            _ => { }\n        }\n        match self.state {\n            ChainState::Both | ChainState::Back => {\n                accum = self.b.fold(accum, &mut f);\n            }\n            _ => { }\n        }\n        accum\n    }\n\n    #[inline]\n    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n        match self.state {\n            ChainState::Both | ChainState::Front => {\n                for x in self.a.by_ref() {\n                    if n == 0 {\n                        return Some(x)\n                    }\n                    n -= 1;\n                }\n                if let ChainState::Both = self.state {\n                    self.state = ChainState::Back;\n                }\n            }\n            ChainState::Back => {}\n        }\n        if let ChainState::Back = self.state {\n            self.b.nth(n)\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n        P: FnMut(&Self::Item) -> bool,\n    {\n        match self.state {\n            ChainState::Both => match self.a.find(&mut predicate) {\n                None => {\n                    self.state = ChainState::Back;\n                    self.b.find(predicate)\n                }\n                v => v\n            },\n            ChainState::Front => self.a.find(predicate),\n            ChainState::Back => self.b.find(predicate),\n        }\n    }\n\n    #[inline]\n    fn last(self) -> Option<A::Item> {\n        match self.state {\n            ChainState::Both => {\n                // Must exhaust a before b.\n                let a_last = self.a.last();\n                let b_last = self.b.last();\n                b_last.or(a_last)\n            },\n            ChainState::Front => self.a.last(),\n            ChainState::Back => self.b.last()\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (a_lower, a_upper) = self.a.size_hint();\n        let (b_lower, b_upper) = self.b.size_hint();\n\n        let lower = a_lower.saturating_add(b_lower);\n\n        let upper = match (a_upper, b_upper) {\n            (Some(x), Some(y)) => x.checked_add(y),\n            _ => None\n        };\n\n        (lower, upper)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> DoubleEndedIterator for Chain<A, B> where\n    A: DoubleEndedIterator,\n    B: DoubleEndedIterator<Item=A::Item>,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<A::Item> {\n        match self.state {\n            ChainState::Both => match self.b.next_back() {\n                elt @ Some(..) => elt,\n                None => {\n                    self.state = ChainState::Front;\n                    self.a.next_back()\n                }\n            },\n            ChainState::Front => self.a.next_back(),\n            ChainState::Back => self.b.next_back(),\n        }\n    }\n}\n\n// Note: *both* must be fused to handle double-ended iterators.\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<A, B> FusedIterator for Chain<A, B>\n    where A: FusedIterator,\n          B: FusedIterator<Item=A::Item>,\n{}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A, B> TrustedLen for Chain<A, B>\n    where A: TrustedLen, B: TrustedLen<Item=A::Item>,\n{}\n\n/// An iterator that iterates two other iterators simultaneously.\n///\n/// This `struct` is created by the [`zip`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`zip`]: trait.Iterator.html#method.zip\n/// [`Iterator`]: trait.Iterator.html\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Zip<A, B> {\n    a: A,\n    b: B,\n    // index and len are only used by the specialized version of zip\n    index: usize,\n    len: usize,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n{\n    type Item = (A::Item, B::Item);\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        ZipImpl::next(self)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        ZipImpl::size_hint(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> DoubleEndedIterator for Zip<A, B> where\n    A: DoubleEndedIterator + ExactSizeIterator,\n    B: DoubleEndedIterator + ExactSizeIterator,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<(A::Item, B::Item)> {\n        ZipImpl::next_back(self)\n    }\n}\n\n// Zip specialization trait\n#[doc(hidden)]\ntrait ZipImpl<A, B> {\n    type Item;\n    fn new(a: A, b: B) -> Self;\n    fn next(&mut self) -> Option<Self::Item>;\n    fn size_hint(&self) -> (usize, Option<usize>);\n    fn next_back(&mut self) -> Option<Self::Item>\n        where A: DoubleEndedIterator + ExactSizeIterator,\n              B: DoubleEndedIterator + ExactSizeIterator;\n}\n\n// General Zip impl\n#[doc(hidden)]\nimpl<A, B> ZipImpl<A, B> for Zip<A, B>\n    where A: Iterator, B: Iterator\n{\n    type Item = (A::Item, B::Item);\n    default fn new(a: A, b: B) -> Self {\n        Zip {\n            a: a,\n            b: b,\n            index: 0, // unused\n            len: 0, // unused\n        }\n    }\n\n    #[inline]\n    default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n        self.a.next().and_then(|x| {\n            self.b.next().and_then(|y| {\n                Some((x, y))\n            })\n        })\n    }\n\n    #[inline]\n    default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n        where A: DoubleEndedIterator + ExactSizeIterator,\n              B: DoubleEndedIterator + ExactSizeIterator\n    {\n        let a_sz = self.a.len();\n        let b_sz = self.b.len();\n        if a_sz != b_sz {\n            // Adjust a, b to equal length\n            if a_sz > b_sz {\n                for _ in 0..a_sz - b_sz { self.a.next_back(); }\n            } else {\n                for _ in 0..b_sz - a_sz { self.b.next_back(); }\n            }\n        }\n        match (self.a.next_back(), self.b.next_back()) {\n            (Some(x), Some(y)) => Some((x, y)),\n            (None, None) => None,\n            _ => unreachable!(),\n        }\n    }\n\n    #[inline]\n    default fn size_hint(&self) -> (usize, Option<usize>) {\n        let (a_lower, a_upper) = self.a.size_hint();\n        let (b_lower, b_upper) = self.b.size_hint();\n\n        let lower = cmp::min(a_lower, b_lower);\n\n        let upper = match (a_upper, b_upper) {\n            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n            (Some(x), None) => Some(x),\n            (None, Some(y)) => Some(y),\n            (None, None) => None\n        };\n\n        (lower, upper)\n    }\n}\n\n#[doc(hidden)]\nimpl<A, B> ZipImpl<A, B> for Zip<A, B>\n    where A: TrustedRandomAccess, B: TrustedRandomAccess\n{\n    fn new(a: A, b: B) -> Self {\n        let len = cmp::min(a.len(), b.len());\n        Zip {\n            a: a,\n            b: b,\n            index: 0,\n            len: len,\n        }\n    }\n\n    #[inline]\n    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n        if self.index < self.len {\n            let i = self.index;\n            self.index += 1;\n            unsafe {\n                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n            }\n        } else if A::may_have_side_effect() && self.index < self.a.len() {\n            // match the base implementation's potential side effects\n            unsafe {\n                self.a.get_unchecked(self.index);\n            }\n            self.index += 1;\n            None\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.len - self.index;\n        (len, Some(len))\n    }\n\n    #[inline]\n    fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n        where A: DoubleEndedIterator + ExactSizeIterator,\n              B: DoubleEndedIterator + ExactSizeIterator\n    {\n        // Adjust a, b to equal length\n        if A::may_have_side_effect() {\n            let sz = self.a.len();\n            if sz > self.len {\n                for _ in 0..sz - cmp::max(self.len, self.index) {\n                    self.a.next_back();\n                }\n            }\n        }\n        if B::may_have_side_effect() {\n            let sz = self.b.len();\n            if sz > self.len {\n                for _ in 0..sz - self.len {\n                    self.b.next_back();\n                }\n            }\n        }\n        if self.index < self.len {\n            self.len -= 1;\n            let i = self.len;\n            unsafe {\n                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n            }\n        } else {\n            None\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> ExactSizeIterator for Zip<A, B>\n    where A: ExactSizeIterator, B: ExactSizeIterator {}\n\n#[doc(hidden)]\nunsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n    where A: TrustedRandomAccess,\n          B: TrustedRandomAccess,\n{\n    unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n        (self.a.get_unchecked(i), self.b.get_unchecked(i))\n    }\n\n    fn may_have_side_effect() -> bool {\n        A::may_have_side_effect() || B::may_have_side_effect()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<A, B> FusedIterator for Zip<A, B>\n    where A: FusedIterator, B: FusedIterator, {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A, B> TrustedLen for Zip<A, B>\n    where A: TrustedLen, B: TrustedLen,\n{}\n\n/// An iterator that maps the values of `iter` with `f`.\n///\n/// This `struct` is created by the [`map`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`map`]: trait.Iterator.html#method.map\n/// [`Iterator`]: trait.Iterator.html\n///\n/// # Notes about side effects\n///\n/// The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n/// you can also [`map`] backwards:\n///\n/// ```rust\n/// let v: Vec<i32> = vec![1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n///\n/// assert_eq!(v, [4, 3, 2]);\n/// ```\n///\n/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n///\n/// But if your closure has state, iterating backwards may act in a way you do\n/// not expect. Let's go through an example. First, in the forward direction:\n///\n/// ```rust\n/// let mut c = 0;\n///\n/// for pair in vec!['a', 'b', 'c'].into_iter()\n///                                .map(|letter| { c += 1; (letter, c) }) {\n///     println!(\"{:?}\", pair);\n/// }\n/// ```\n///\n/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n///\n/// Now consider this twist where we add a call to `rev`. This version will\n/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n/// but the values of the counter still go in order. This is because `map()` is\n/// still being called lazilly on each item, but we are popping items off the\n/// back of the vector now, instead of shifting them from the front.\n///\n/// ```rust\n/// let mut c = 0;\n///\n/// for pair in vec!['a', 'b', 'c'].into_iter()\n///                                .map(|letter| { c += 1; (letter, c) })\n///                                .rev() {\n///     println!(\"{:?}\", pair);\n/// }\n/// ```\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct Map<I, F> {\n    iter: I,\n    f: F,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Map\")\n            .field(\"iter\", &self.iter)\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n    type Item = B;\n\n    #[inline]\n    fn next(&mut self) -> Option<B> {\n        self.iter.next().map(&mut self.f)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n        where G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut f = self.f;\n        self.iter.fold(init, move |acc, elt| g(acc, f(elt)))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n    F: FnMut(I::Item) -> B,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<B> {\n        self.iter.next_back().map(&mut self.f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n    where F: FnMut(I::Item) -> B\n{\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n    where F: FnMut(I::Item) -> B {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<B, I, F> TrustedLen for Map<I, F>\n    where I: TrustedLen,\n          F: FnMut(I::Item) -> B {}\n\n#[doc(hidden)]\nunsafe impl<B, I, F> TrustedRandomAccess for Map<I, F>\n    where I: TrustedRandomAccess,\n          F: FnMut(I::Item) -> B,\n{\n    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n        (self.f)(self.iter.get_unchecked(i))\n    }\n    #[inline]\n    fn may_have_side_effect() -> bool { true }\n}\n\n/// An iterator that filters the elements of `iter` with `predicate`.\n///\n/// This `struct` is created by the [`filter`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`filter`]: trait.Iterator.html#method.filter\n/// [`Iterator`]: trait.Iterator.html\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct Filter<I, P> {\n    iter: I,\n    predicate: P,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Filter\")\n            .field(\"iter\", &self.iter)\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        for x in &mut self.iter {\n            if (self.predicate)(&x) {\n                return Some(x);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper) // can't know a lower bound, due to the predicate\n    }\n\n    // this special case allows the compiler to make `.filter(_).count()`\n    // branchless. Barring perfect branch prediction (which is unattainable in\n    // the general case), this will be much faster in >90% of cases (containing\n    // virtually all real workloads) and only a tiny bit slower in the rest.\n    //\n    // Having this specialization thus allows us to write `.filter(p).count()`\n    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n    // less readable and also less backwards-compatible to Rust before 1.10.\n    //\n    // Using the branchless version will also simplify the LLVM byte code, thus\n    // leaving more budget for LLVM optimizations.\n    #[inline]\n    fn count(mut self) -> usize {\n        let mut count = 0;\n        for x in &mut self.iter {\n            count += (self.predicate)(&x) as usize;\n        }\n        count\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n    where P: FnMut(&I::Item) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<I::Item> {\n        for x in self.iter.by_ref().rev() {\n            if (self.predicate)(&x) {\n                return Some(x);\n            }\n        }\n        None\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I: FusedIterator, P> FusedIterator for Filter<I, P>\n    where P: FnMut(&I::Item) -> bool {}\n\n/// An iterator that uses `f` to both filter and map elements from `iter`.\n///\n/// This `struct` is created by the [`filter_map`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`filter_map`]: trait.Iterator.html#method.filter_map\n/// [`Iterator`]: trait.Iterator.html\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct FilterMap<I, F> {\n    iter: I,\n    f: F,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"FilterMap\")\n            .field(\"iter\", &self.iter)\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n    where F: FnMut(I::Item) -> Option<B>,\n{\n    type Item = B;\n\n    #[inline]\n    fn next(&mut self) -> Option<B> {\n        for x in self.iter.by_ref() {\n            if let Some(y) = (self.f)(x) {\n                return Some(y);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper) // can't know a lower bound, due to the predicate\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n    where F: FnMut(I::Item) -> Option<B>,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<B> {\n        for x in self.iter.by_ref().rev() {\n            if let Some(y) = (self.f)(x) {\n                return Some(y);\n            }\n        }\n        None\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F>\n    where F: FnMut(I::Item) -> Option<B> {}\n\n/// An iterator that yields the current count and the element during iteration.\n///\n/// This `struct` is created by the [`enumerate`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`enumerate`]: trait.Iterator.html#method.enumerate\n/// [`Iterator`]: trait.Iterator.html\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Enumerate<I> {\n    iter: I,\n    count: usize,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> Iterator for Enumerate<I> where I: Iterator {\n    type Item = (usize, <I as Iterator>::Item);\n\n    /// # Overflow Behavior\n    ///\n    /// The method does no guarding against overflows, so enumerating more than\n    /// `usize::MAX` elements either produces the wrong result or panics. If\n    /// debug assertions are enabled, a panic is guaranteed.\n    ///\n    /// # Panics\n    ///\n    /// Might panic if the index of the element overflows a `usize`.\n    #[inline]\n    #[rustc_inherit_overflow_checks]\n    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n        self.iter.next().map(|a| {\n            let ret = (self.count, a);\n            // Possible undefined overflow.\n            self.count += 1;\n            ret\n        })\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    #[inline]\n    #[rustc_inherit_overflow_checks]\n    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n        self.iter.nth(n).map(|a| {\n            let i = self.count + n;\n            self.count = i + 1;\n            (i, a)\n        })\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.iter.count()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> DoubleEndedIterator for Enumerate<I> where\n    I: ExactSizeIterator + DoubleEndedIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n        self.iter.next_back().map(|a| {\n            let len = self.iter.len();\n            // Can safely add, `ExactSizeIterator` promises that the number of\n            // elements fits into a `usize`.\n            (self.count + len, a)\n        })\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\n#[doc(hidden)]\nunsafe impl<I> TrustedRandomAccess for Enumerate<I>\n    where I: TrustedRandomAccess\n{\n    unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n        (self.count + i, self.iter.get_unchecked(i))\n    }\n\n    fn may_have_side_effect() -> bool {\n        I::may_have_side_effect()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<I> TrustedLen for Enumerate<I>\n    where I: TrustedLen,\n{}\n\n\n/// An iterator with a `peek()` that returns an optional reference to the next\n/// element.\n///\n/// This `struct` is created by the [`peekable`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`peekable`]: trait.Iterator.html#method.peekable\n/// [`Iterator`]: trait.Iterator.html\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Peekable<I: Iterator> {\n    iter: I,\n    /// Remember a peeked value, even if it was None.\n    peeked: Option<Option<I::Item>>,\n}\n\n// Peekable must remember if a None has been seen in the `.peek()` method.\n// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n// underlying iterator at most once. This does not by itself make the iterator\n// fused.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator> Iterator for Peekable<I> {\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        match self.peeked.take() {\n            Some(v) => v,\n            None => self.iter.next(),\n        }\n    }\n\n    #[inline]\n    #[rustc_inherit_overflow_checks]\n    fn count(mut self) -> usize {\n        match self.peeked.take() {\n            Some(None) => 0,\n            Some(Some(_)) => 1 + self.iter.count(),\n            None => self.iter.count(),\n        }\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<I::Item> {\n        match self.peeked.take() {\n            // the .take() below is just to avoid \"move into pattern guard\"\n            Some(ref mut v) if n == 0 => v.take(),\n            Some(None) => None,\n            Some(Some(_)) => self.iter.nth(n - 1),\n            None => self.iter.nth(n),\n        }\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<I::Item> {\n        let peek_opt = match self.peeked.take() {\n            Some(None) => return None,\n            Some(v) => v,\n            None => None,\n        };\n        self.iter.last().or(peek_opt)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let peek_len = match self.peeked {\n            Some(None) => return (0, Some(0)),\n            Some(Some(_)) => 1,\n            None => 0,\n        };\n        let (lo, hi) = self.iter.size_hint();\n        let lo = lo.saturating_add(peek_len);\n        let hi = hi.and_then(|x| x.checked_add(peek_len));\n        (lo, hi)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I: FusedIterator> FusedIterator for Peekable<I> {}\n\nimpl<I: Iterator> Peekable<I> {\n    /// Returns a reference to the next() value without advancing the iterator.\n    ///\n    /// Like [`next`], if there is a value, it is wrapped in a `Some(T)`.\n    /// But if the iteration is over, `None` is returned.\n    ///\n    /// [`next`]: trait.Iterator.html#tymethod.next\n    ///\n    /// Because `peek()` returns a reference, and many iterators iterate over\n    /// references, there can be a possibly confusing situation where the\n    /// return value is a double reference. You can see this effect in the\n    /// examples below.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let xs = [1, 2, 3];\n    ///\n    /// let mut iter = xs.iter().peekable();\n    ///\n    /// // peek() lets us see into the future\n    /// assert_eq!(iter.peek(), Some(&&1));\n    /// assert_eq!(iter.next(), Some(&1));\n    ///\n    /// assert_eq!(iter.next(), Some(&2));\n    ///\n    /// // The iterator does not advance even if we `peek` multiple times\n    /// assert_eq!(iter.peek(), Some(&&3));\n    /// assert_eq!(iter.peek(), Some(&&3));\n    ///\n    /// assert_eq!(iter.next(), Some(&3));\n    ///\n    /// // After the iterator is finished, so is `peek()`\n    /// assert_eq!(iter.peek(), None);\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn peek(&mut self) -> Option<&I::Item> {\n        if self.peeked.is_none() {\n            self.peeked = Some(self.iter.next());\n        }\n        match self.peeked {\n            Some(Some(ref value)) => Some(value),\n            Some(None) => None,\n            _ => unreachable!(),\n        }\n    }\n}\n\n/// An iterator that rejects elements while `predicate` is true.\n///\n/// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`skip_while`]: trait.Iterator.html#method.skip_while\n/// [`Iterator`]: trait.Iterator.html\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct SkipWhile<I, P> {\n    iter: I,\n    flag: bool,\n    predicate: P,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"SkipWhile\")\n            .field(\"iter\", &self.iter)\n            .field(\"flag\", &self.flag)\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator, P> Iterator for SkipWhile<I, P>\n    where P: FnMut(&I::Item) -> bool\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        for x in self.iter.by_ref() {\n            if self.flag || !(self.predicate)(&x) {\n                self.flag = true;\n                return Some(x);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper) // can't know a lower bound, due to the predicate\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I, P> FusedIterator for SkipWhile<I, P>\n    where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n\n/// An iterator that only accepts elements while `predicate` is true.\n///\n/// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`take_while`]: trait.Iterator.html#method.take_while\n/// [`Iterator`]: trait.Iterator.html\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct TakeWhile<I, P> {\n    iter: I,\n    flag: bool,\n    predicate: P,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"TakeWhile\")\n            .field(\"iter\", &self.iter)\n            .field(\"flag\", &self.flag)\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator, P> Iterator for TakeWhile<I, P>\n    where P: FnMut(&I::Item) -> bool\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        if self.flag {\n            None\n        } else {\n            self.iter.next().and_then(|x| {\n                if (self.predicate)(&x) {\n                    Some(x)\n                } else {\n                    self.flag = true;\n                    None\n                }\n            })\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper) // can't know a lower bound, due to the predicate\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I, P> FusedIterator for TakeWhile<I, P>\n    where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n\n/// An iterator that skips over `n` elements of `iter`.\n///\n/// This `struct` is created by the [`skip`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`skip`]: trait.Iterator.html#method.skip\n/// [`Iterator`]: trait.Iterator.html\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Skip<I> {\n    iter: I,\n    n: usize\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> Iterator for Skip<I> where I: Iterator {\n    type Item = <I as Iterator>::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        if self.n == 0 {\n            self.iter.next()\n        } else {\n            let old_n = self.n;\n            self.n = 0;\n            self.iter.nth(old_n)\n        }\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<I::Item> {\n        // Can't just add n + self.n due to overflow.\n        if self.n == 0 {\n            self.iter.nth(n)\n        } else {\n            let to_skip = self.n;\n            self.n = 0;\n            // nth(n) skips n+1\n            if self.iter.nth(to_skip-1).is_none() {\n                return None;\n            }\n            self.iter.nth(n)\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.iter.count().saturating_sub(self.n)\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<I::Item> {\n        if self.n == 0 {\n            self.iter.last()\n        } else {\n            let next = self.next();\n            if next.is_some() {\n                // recurse. n should be 0.\n                self.last().or(next)\n            } else {\n                None\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (lower, upper) = self.iter.size_hint();\n\n        let lower = lower.saturating_sub(self.n);\n        let upper = upper.map(|x| x.saturating_sub(self.n));\n\n        (lower, upper)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n\n#[stable(feature = \"double_ended_skip_iterator\", since = \"1.9.0\")]\nimpl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSizeIterator {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.len() > 0 {\n            self.iter.next_back()\n        } else {\n            None\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n\n/// An iterator that only iterates over the first `n` iterations of `iter`.\n///\n/// This `struct` is created by the [`take`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`take`]: trait.Iterator.html#method.take\n/// [`Iterator`]: trait.Iterator.html\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Take<I> {\n    iter: I,\n    n: usize\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> Iterator for Take<I> where I: Iterator{\n    type Item = <I as Iterator>::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n        if self.n != 0 {\n            self.n -= 1;\n            self.iter.next()\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<I::Item> {\n        if self.n > n {\n            self.n -= n + 1;\n            self.iter.nth(n)\n        } else {\n            if self.n > 0 {\n                self.iter.nth(self.n - 1);\n                self.n = 0;\n            }\n            None\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (lower, upper) = self.iter.size_hint();\n\n        let lower = cmp::min(lower, self.n);\n\n        let upper = match upper {\n            Some(x) if x < self.n => Some(x),\n            _ => Some(self.n)\n        };\n\n        (lower, upper)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I> FusedIterator for Take<I> where I: FusedIterator {}\n\n/// An iterator to maintain state while iterating another iterator.\n///\n/// This `struct` is created by the [`scan`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`scan`]: trait.Iterator.html#method.scan\n/// [`Iterator`]: trait.Iterator.html\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct Scan<I, St, F> {\n    iter: I,\n    f: F,\n    state: St,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Scan\")\n            .field(\"iter\", &self.iter)\n            .field(\"state\", &self.state)\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B, I, St, F> Iterator for Scan<I, St, F> where\n    I: Iterator,\n    F: FnMut(&mut St, I::Item) -> Option<B>,\n{\n    type Item = B;\n\n    #[inline]\n    fn next(&mut self) -> Option<B> {\n        self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper) // can't know a lower bound, due to the scan function\n    }\n}\n\n/// An iterator that maps each element to an iterator, and yields the elements\n/// of the produced iterators.\n///\n/// This `struct` is created by the [`flat_map`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`flat_map`]: trait.Iterator.html#method.flat_map\n/// [`Iterator`]: trait.Iterator.html\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct FlatMap<I, U: IntoIterator, F> {\n    iter: I,\n    f: F,\n    frontiter: Option<U::IntoIter>,\n    backiter: Option<U::IntoIter>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n    where U::IntoIter: fmt::Debug\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"FlatMap\")\n            .field(\"iter\", &self.iter)\n            .field(\"frontiter\", &self.frontiter)\n            .field(\"backiter\", &self.backiter)\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n    where F: FnMut(I::Item) -> U,\n{\n    type Item = U::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<U::Item> {\n        loop {\n            if let Some(ref mut inner) = self.frontiter {\n                if let Some(x) = inner.by_ref().next() {\n                    return Some(x)\n                }\n            }\n            match self.iter.next().map(&mut self.f) {\n                None => return self.backiter.as_mut().and_then(|it| it.next()),\n                next => self.frontiter = next.map(IntoIterator::into_iter),\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n        let lo = flo.saturating_add(blo);\n        match (self.iter.size_hint(), fhi, bhi) {\n            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n            _ => (lo, None)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> where\n    F: FnMut(I::Item) -> U,\n    U: IntoIterator,\n    U::IntoIter: DoubleEndedIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<U::Item> {\n        loop {\n            if let Some(ref mut inner) = self.backiter {\n                if let Some(y) = inner.next_back() {\n                    return Some(y)\n                }\n            }\n            match self.iter.next_back().map(&mut self.f) {\n                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n                next => self.backiter = next.map(IntoIterator::into_iter),\n            }\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I, U, F> FusedIterator for FlatMap<I, U, F>\n    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n\n/// An iterator that yields `None` forever after the underlying iterator\n/// yields `None` once.\n///\n/// This `struct` is created by the [`fuse`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`fuse`]: trait.Iterator.html#method.fuse\n/// [`Iterator`]: trait.Iterator.html\n#[derive(Clone, Debug)]\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Fuse<I> {\n    iter: I,\n    done: bool\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I> FusedIterator for Fuse<I> where I: Iterator {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> Iterator for Fuse<I> where I: Iterator {\n    type Item = <I as Iterator>::Item;\n\n    #[inline]\n    default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n        if self.done {\n            None\n        } else {\n            let next = self.iter.next();\n            self.done = next.is_none();\n            next\n        }\n    }\n\n    #[inline]\n    default fn nth(&mut self, n: usize) -> Option<I::Item> {\n        if self.done {\n            None\n        } else {\n            let nth = self.iter.nth(n);\n            self.done = nth.is_none();\n            nth\n        }\n    }\n\n    #[inline]\n    default fn last(self) -> Option<I::Item> {\n        if self.done {\n            None\n        } else {\n            self.iter.last()\n        }\n    }\n\n    #[inline]\n    default fn count(self) -> usize {\n        if self.done {\n            0\n        } else {\n            self.iter.count()\n        }\n    }\n\n    #[inline]\n    default fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.done {\n            (0, Some(0))\n        } else {\n            self.iter.size_hint()\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n    #[inline]\n    default fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n        if self.done {\n            None\n        } else {\n            let next = self.iter.next_back();\n            self.done = next.is_none();\n            next\n        }\n    }\n}\n\nunsafe impl<I> TrustedRandomAccess for Fuse<I>\n    where I: TrustedRandomAccess,\n{\n    unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n        self.iter.get_unchecked(i)\n    }\n\n    fn may_have_side_effect() -> bool {\n        I::may_have_side_effect()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I> Iterator for Fuse<I> where I: FusedIterator {\n    #[inline]\n    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n        self.iter.next()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<I::Item> {\n        self.iter.nth(n)\n    }\n\n    #[inline]\n    fn last(self) -> Option<I::Item> {\n        self.iter.last()\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.iter.count()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[unstable(feature = \"fused\", reason = \"recently added\", issue = \"35602\")]\nimpl<I> DoubleEndedIterator for Fuse<I>\n    where I: DoubleEndedIterator + FusedIterator\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n        self.iter.next_back()\n    }\n}\n\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\n/// An iterator that calls a function with a reference to each element before\n/// yielding it.\n///\n/// This `struct` is created by the [`inspect`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`inspect`]: trait.Iterator.html#method.inspect\n/// [`Iterator`]: trait.Iterator.html\n#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct Inspect<I, F> {\n    iter: I,\n    f: F,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Inspect\")\n            .field(\"iter\", &self.iter)\n            .finish()\n    }\n}\n\nimpl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n    #[inline]\n    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n        if let Some(ref a) = elt {\n            (self.f)(a);\n        }\n\n        elt\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        let next = self.iter.next();\n        self.do_inspect(next)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n    where F: FnMut(&I::Item),\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<I::Item> {\n        let next = self.iter.next_back();\n        self.do_inspect(next)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n    where F: FnMut(&I::Item)\n{\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n    where F: FnMut(&I::Item) {}\n","// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse io;\nuse intrinsics;\nuse ffi::CStr;\nuse libc;\nuse sys::backtrace::BacktraceContext;\nuse sys_common::backtrace::Frame;\n\npub fn resolve_symname<F>(frame: Frame,\n                          callback: F,\n                          _: &BacktraceContext) -> io::Result<()>\n    where F: FnOnce(Option<&str>) -> io::Result<()>\n{\n    unsafe {\n        let mut info: Dl_info = intrinsics::init();\n        let symname = if dladdr(frame.exact_position, &mut info) == 0 {\n            None\n        } else {\n            CStr::from_ptr(info.dli_sname).to_str().ok()\n        };\n        callback(symname)\n    }\n}\n\npub fn foreach_symbol_fileline<F>(_symbol_addr: Frame,\n                                  _f: F,\n                                  _: &BacktraceContext) -> io::Result<bool>\n    where F: FnMut(&[u8], libc::c_int) -> io::Result<()>\n{\n    Ok(false)\n}\n\n#[repr(C)]\nstruct Dl_info {\n    dli_fname: *const libc::c_char,\n    dli_fbase: *mut libc::c_void,\n    dli_sname: *const libc::c_char,\n    dli_saddr: *mut libc::c_void,\n}\n\nextern {\n    fn dladdr(addr: *const libc::c_void,\n              info: *mut Dl_info) -> libc::c_int;\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! String manipulation\n//!\n//! For more details, see std::str\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse self::pattern::Pattern;\nuse self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n\nuse char;\nuse convert::TryFrom;\nuse fmt;\nuse iter::{Map, Cloned, FusedIterator};\nuse slice::{self, SliceIndex};\nuse mem;\n\npub mod pattern;\n\n/// A trait to abstract the idea of creating a new instance of a type from a\n/// string.\n///\n/// `FromStr`'s [`from_str`] method is often used implicitly, through\n/// [`str`]'s [`parse`] method. See [`parse`]'s documentation for examples.\n///\n/// [`from_str`]: #tymethod.from_str\n/// [`str`]: ../../std/primitive.str.html\n/// [`parse`]: ../../std/primitive.str.html#method.parse\n///\n/// # Examples\n///\n/// Basic implementation of `FromStr` on an example `Point` type:\n///\n/// ```\n/// use std::str::FromStr;\n/// use std::num::ParseIntError;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Point {\n///     x: i32,\n///     y: i32\n/// }\n///\n/// impl FromStr for Point {\n///     type Err = ParseIntError;\n///\n///     fn from_str(s: &str) -> Result<Self, Self::Err> {\n///         let coords: Vec<&str> = s.trim_matches(|p| p == '(' || p == ')' )\n///                                  .split(\",\")\n///                                  .collect();\n///\n///         let x_fromstr = coords[0].parse::<i32>()?;\n///         let y_fromstr = coords[1].parse::<i32>()?;\n///\n///         Ok(Point { x: x_fromstr, y: y_fromstr })\n///     }\n/// }\n///\n/// let p = Point::from_str(\"(1,2)\");\n/// assert_eq!(p.unwrap(), Point{ x: 1, y: 2} )\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait FromStr: Sized {\n    /// The associated error which can be returned from parsing.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Err;\n\n    /// Parses a string `s` to return a value of this type.\n    ///\n    /// If parsing succeeds, return the value inside `Ok`, otherwise\n    /// when the string is ill-formatted return an error specific to the\n    /// inside `Err`. The error type is specific to implementation of the trait.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage with [`i32`][ithirtytwo], a type that implements `FromStr`:\n    ///\n    /// [ithirtytwo]: ../../std/primitive.i32.html\n    ///\n    /// ```\n    /// use std::str::FromStr;\n    ///\n    /// let s = \"5\";\n    /// let x = i32::from_str(s).unwrap();\n    ///\n    /// assert_eq!(5, x);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn from_str(s: &str) -> Result<Self, Self::Err>;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromStr for bool {\n    type Err = ParseBoolError;\n\n    /// Parse a `bool` from a string.\n    ///\n    /// Yields a `Result<bool, ParseBoolError>`, because `s` may or may not\n    /// actually be parseable.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::str::FromStr;\n    ///\n    /// assert_eq!(FromStr::from_str(\"true\"), Ok(true));\n    /// assert_eq!(FromStr::from_str(\"false\"), Ok(false));\n    /// assert!(<bool as FromStr>::from_str(\"not even a boolean\").is_err());\n    /// ```\n    ///\n    /// Note, in many cases, the `.parse()` method on `str` is more proper.\n    ///\n    /// ```\n    /// assert_eq!(\"true\".parse(), Ok(true));\n    /// assert_eq!(\"false\".parse(), Ok(false));\n    /// assert!(\"not even a boolean\".parse::<bool>().is_err());\n    /// ```\n    #[inline]\n    fn from_str(s: &str) -> Result<bool, ParseBoolError> {\n        match s {\n            \"true\"  => Ok(true),\n            \"false\" => Ok(false),\n            _       => Err(ParseBoolError { _priv: () }),\n        }\n    }\n}\n\n/// An error returned when parsing a `bool` using [`from_str`] fails\n///\n/// [`from_str`]: ../../std/primitive.bool.html#method.from_str\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ParseBoolError { _priv: () }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for ParseBoolError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        \"provided string was not `true` or `false`\".fmt(f)\n    }\n}\n\n/*\nSection: Creating a string\n*/\n\n/// Errors which can occur when attempting to interpret a sequence of [`u8`]\n/// as a string.\n///\n/// [`u8`]: ../../std/primitive.u8.html\n///\n/// As such, the `from_utf8` family of functions and methods for both [`String`]s\n/// and [`&str`]s make use of this error, for example.\n///\n/// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n/// [`&str`]: ../../std/str/fn.from_utf8.html\n#[derive(Copy, Eq, PartialEq, Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Utf8Error {\n    valid_up_to: usize,\n    error_len: Option<u8>,\n}\n\nimpl Utf8Error {\n    /// Returns the index in the given string up to which valid UTF-8 was\n    /// verified.\n    ///\n    /// It is the maximum index such that `from_utf8(&input[..index])`\n    /// would return `Ok(_)`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::str;\n    ///\n    /// // some invalid bytes, in a vector\n    /// let sparkle_heart = vec![0, 159, 146, 150];\n    ///\n    /// // std::str::from_utf8 returns a Utf8Error\n    /// let error = str::from_utf8(&sparkle_heart).unwrap_err();\n    ///\n    /// // the second byte is invalid here\n    /// assert_eq!(1, error.valid_up_to());\n    /// ```\n    #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n    pub fn valid_up_to(&self) -> usize { self.valid_up_to }\n\n    /// Provide more information about the failure:\n    ///\n    /// * `None`: the end of the input was reached unexpectedly.\n    ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n    ///   If a byte stream (such as a file or a network socket) is being decoded incrementally,\n    ///   this could be a valid `char` whose UTF-8 byte sequence is spanning multiple chunks.\n    ///\n    /// * `Some(len)`: an unexpected byte was encountered.\n    ///   The length provided is that of the invalid byte sequence\n    ///   that starts at the index given by `valid_up_to()`.\n    ///   Decoding should resume after that sequence\n    ///   (after inserting a U+FFFD REPLACEMENT CHARACTER) in case of lossy decoding.\n    #[unstable(feature = \"utf8_error_error_len\", reason =\"new\", issue = \"40494\")]\n    pub fn error_len(&self) -> Option<usize> {\n        self.error_len.map(|len| len as usize)\n    }\n}\n\n/// Converts a slice of bytes to a string slice.\n///\n/// A string slice ([`&str`]) is made of bytes ([`u8`]), and a byte slice\n/// ([`&[u8]`][byteslice]) is made of bytes, so this function converts between\n/// the two. Not all byte slices are valid string slices, however: [`&str`] requires\n/// that it is valid UTF-8. `from_utf8()` checks to ensure that the bytes are valid\n/// UTF-8, and then does the conversion.\n///\n/// [`&str`]: ../../std/primitive.str.html\n/// [`u8`]: ../../std/primitive.u8.html\n/// [byteslice]: ../../std/primitive.slice.html\n///\n/// If you are sure that the byte slice is valid UTF-8, and you don't want to\n/// incur the overhead of the validity check, there is an unsafe version of\n/// this function, [`from_utf8_unchecked`][fromutf8u], which has the same\n/// behavior but skips the check.\n///\n/// [fromutf8u]: fn.from_utf8_unchecked.html\n///\n/// If you need a `String` instead of a `&str`, consider\n/// [`String::from_utf8`][string].\n///\n/// [string]: ../../std/string/struct.String.html#method.from_utf8\n///\n/// Because you can stack-allocate a `[u8; N]`, and you can take a\n/// [`&[u8]`][byteslice] of it, this function is one way to have a\n/// stack-allocated string. There is an example of this in the\n/// examples section below.\n///\n/// [byteslice]: ../../std/primitive.slice.html\n///\n/// # Errors\n///\n/// Returns `Err` if the slice is not UTF-8 with a description as to why the\n/// provided slice is not UTF-8.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::str;\n///\n/// // some bytes, in a vector\n/// let sparkle_heart = vec![240, 159, 146, 150];\n///\n/// // We know these bytes are valid, so just use `unwrap()`.\n/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n///\n/// assert_eq!(\"\", sparkle_heart);\n/// ```\n///\n/// Incorrect bytes:\n///\n/// ```\n/// use std::str;\n///\n/// // some invalid bytes, in a vector\n/// let sparkle_heart = vec![0, 159, 146, 150];\n///\n/// assert!(str::from_utf8(&sparkle_heart).is_err());\n/// ```\n///\n/// See the docs for [`Utf8Error`][error] for more details on the kinds of\n/// errors that can be returned.\n///\n/// [error]: struct.Utf8Error.html\n///\n/// A \"stack allocated string\":\n///\n/// ```\n/// use std::str;\n///\n/// // some bytes, in a stack-allocated array\n/// let sparkle_heart = [240, 159, 146, 150];\n///\n/// // We know these bytes are valid, so just use `unwrap()`.\n/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n///\n/// assert_eq!(\"\", sparkle_heart);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n    run_utf8_validation(v)?;\n    Ok(unsafe { from_utf8_unchecked(v) })\n}\n\n/// Converts a mutable slice of bytes to a mutable string slice.\n#[unstable(feature = \"str_mut_extras\", issue = \"41119\")]\npub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n    run_utf8_validation(v)?;\n    Ok(unsafe { from_utf8_unchecked_mut(v) })\n}\n\n/// Forms a str from a pointer and a length.\n///\n/// The `len` argument is the number of bytes in the string.\n///\n/// # Safety\n///\n/// This function is unsafe as there is no guarantee that the given pointer is\n/// valid for `len` bytes, nor whether the lifetime inferred is a suitable\n/// lifetime for the returned str.\n///\n/// The data must be valid UTF-8\n///\n/// `p` must be non-null, even for zero-length strs, because non-zero bits\n/// are required to distinguish between a zero-length str within `Some()`\n/// from `None`. `p` can be a bogus non-dereferencable pointer, such as `0x1`,\n/// for zero-length strs, though.\n///\n/// # Caveat\n///\n/// The lifetime for the returned str is inferred from its usage. To\n/// prevent accidental misuse, it's suggested to tie the lifetime to whichever\n/// source lifetime is safe in the context, such as by providing a helper\n/// function taking the lifetime of a host value for the str, or by explicit\n/// annotation.\n/// Performs the same functionality as `from_raw_parts`, except that a mutable\n/// str is returned.\n///\nunsafe fn from_raw_parts_mut<'a>(p: *mut u8, len: usize) -> &'a mut str {\n    from_utf8_unchecked_mut(slice::from_raw_parts_mut(p, len))\n}\n\n/// Converts a slice of bytes to a string slice without checking\n/// that the string contains valid UTF-8.\n///\n/// See the safe version, [`from_utf8`][fromutf8], for more information.\n///\n/// [fromutf8]: fn.from_utf8.html\n///\n/// # Safety\n///\n/// This function is unsafe because it does not check that the bytes passed to\n/// it are valid UTF-8. If this constraint is violated, undefined behavior\n/// results, as the rest of Rust assumes that [`&str`]s are valid UTF-8.\n///\n/// [`&str`]: ../../std/primitive.str.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::str;\n///\n/// // some bytes, in a vector\n/// let sparkle_heart = vec![240, 159, 146, 150];\n///\n/// let sparkle_heart = unsafe {\n///     str::from_utf8_unchecked(&sparkle_heart)\n/// };\n///\n/// assert_eq!(\"\", sparkle_heart);\n/// ```\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n    mem::transmute(v)\n}\n\n/// Converts a slice of bytes to a string slice without checking\n/// that the string contains valid UTF-8; mutable version.\n///\n/// See the immutable version, [`from_utf8_unchecked()`][fromutf8], for more information.\n///\n/// [fromutf8]: fn.from_utf8_unchecked.html\n#[inline(always)]\n#[unstable(feature = \"str_mut_extras\", issue = \"41119\")]\npub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n    mem::transmute(v)\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Utf8Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if let Some(error_len) = self.error_len {\n            write!(f, \"invalid utf-8 sequence of {} bytes from index {}\",\n                   error_len, self.valid_up_to)\n        } else {\n            write!(f, \"incomplete utf-8 byte sequence from index {}\", self.valid_up_to)\n        }\n    }\n}\n\n/*\nSection: Iterators\n*/\n\n/// An iterator over the [`char`]s of a string slice.\n///\n/// [`char`]: ../../std/primitive.char.html\n///\n/// This struct is created by the [`chars`] method on [`str`].\n/// See its documentation for more.\n///\n/// [`chars`]: ../../std/primitive.str.html#method.chars\n/// [`str`]: ../../std/primitive.str.html\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Chars<'a> {\n    iter: slice::Iter<'a, u8>\n}\n\n/// Returns the initial codepoint accumulator for the first byte.\n/// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n/// for width 3, and 3 bits for width 4.\n#[inline]\nfn utf8_first_byte(byte: u8, width: u32) -> u32 { (byte & (0x7F >> width)) as u32 }\n\n/// Returns the value of `ch` updated with continuation byte `byte`.\n#[inline]\nfn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 { (ch << 6) | (byte & CONT_MASK) as u32 }\n\n/// Checks whether the byte is a UTF-8 continuation byte (i.e. starts with the\n/// bits `10`).\n#[inline]\nfn utf8_is_cont_byte(byte: u8) -> bool { (byte & !CONT_MASK) == TAG_CONT_U8 }\n\n#[inline]\nfn unwrap_or_0(opt: Option<&u8>) -> u8 {\n    match opt {\n        Some(&byte) => byte,\n        None => 0,\n    }\n}\n\n/// Reads the next code point out of a byte iterator (assuming a\n/// UTF-8-like encoding).\n#[unstable(feature = \"str_internals\", issue = \"0\")]\n#[inline]\npub fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n    // Decode UTF-8\n    let x = match bytes.next() {\n        None => return None,\n        Some(&next_byte) if next_byte < 128 => return Some(next_byte as u32),\n        Some(&next_byte) => next_byte,\n    };\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [[[x y] z] w]\n    // NOTE: Performance is sensitive to the exact formulation here\n    let init = utf8_first_byte(x, 2);\n    let y = unwrap_or_0(bytes.next());\n    let mut ch = utf8_acc_cont_byte(init, y);\n    if x >= 0xE0 {\n        // [[x y z] w] case\n        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n        let z = unwrap_or_0(bytes.next());\n        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n        ch = init << 12 | y_z;\n        if x >= 0xF0 {\n            // [x y z w] case\n            // use only the lower 3 bits of `init`\n            let w = unwrap_or_0(bytes.next());\n            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n        }\n    }\n\n    Some(ch)\n}\n\n/// Reads the last code point out of a byte iterator (assuming a\n/// UTF-8-like encoding).\n#[inline]\nfn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>\n    where I: DoubleEndedIterator<Item = &'a u8>,\n{\n    // Decode UTF-8\n    let w = match bytes.next_back() {\n        None => return None,\n        Some(&next_byte) if next_byte < 128 => return Some(next_byte as u32),\n        Some(&back_byte) => back_byte,\n    };\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [x [y [z w]]]\n    let mut ch;\n    let z = unwrap_or_0(bytes.next_back());\n    ch = utf8_first_byte(z, 2);\n    if utf8_is_cont_byte(z) {\n        let y = unwrap_or_0(bytes.next_back());\n        ch = utf8_first_byte(y, 3);\n        if utf8_is_cont_byte(y) {\n            let x = unwrap_or_0(bytes.next_back());\n            ch = utf8_first_byte(x, 4);\n            ch = utf8_acc_cont_byte(ch, y);\n        }\n        ch = utf8_acc_cont_byte(ch, z);\n    }\n    ch = utf8_acc_cont_byte(ch, w);\n\n    Some(ch)\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for Chars<'a> {\n    type Item = char;\n\n    #[inline]\n    fn next(&mut self) -> Option<char> {\n        next_code_point(&mut self.iter).map(|ch| {\n            // str invariant says `ch` is a valid Unicode Scalar Value\n            unsafe {\n                char::from_u32_unchecked(ch)\n            }\n        })\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        // length in `char` is equal to the number of non-continuation bytes\n        let bytes_len = self.iter.len();\n        let mut cont_bytes = 0;\n        for &byte in self.iter {\n            cont_bytes += utf8_is_cont_byte(byte) as usize;\n        }\n        bytes_len - cont_bytes\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.iter.len();\n        // `(len + 3)` can't overflow, because we know that the `slice::Iter`\n        // belongs to a slice in memory which has a maximum length of\n        // `isize::MAX` (that's well below `usize::MAX`).\n        ((len + 3) / 4, Some(len))\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<char> {\n        // No need to go through the entire string.\n        self.next_back()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> DoubleEndedIterator for Chars<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<char> {\n        next_code_point_reverse(&mut self.iter).map(|ch| {\n            // str invariant says `ch` is a valid Unicode Scalar Value\n            unsafe {\n                char::from_u32_unchecked(ch)\n            }\n        })\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a> FusedIterator for Chars<'a> {}\n\nimpl<'a> Chars<'a> {\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// This has the same lifetime as the original slice, and so the\n    /// iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut chars = \"abc\".chars();\n    ///\n    /// assert_eq!(chars.as_str(), \"abc\");\n    /// chars.next();\n    /// assert_eq!(chars.as_str(), \"bc\");\n    /// chars.next();\n    /// chars.next();\n    /// assert_eq!(chars.as_str(), \"\");\n    /// ```\n    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n    #[inline]\n    pub fn as_str(&self) -> &'a str {\n        unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n    }\n}\n\n/// An iterator over the [`char`]s of a string slice, and their positions.\n///\n/// [`char`]: ../../std/primitive.char.html\n///\n/// This struct is created by the [`char_indices`] method on [`str`].\n/// See its documentation for more.\n///\n/// [`char_indices`]: ../../std/primitive.str.html#method.char_indices\n/// [`str`]: ../../std/primitive.str.html\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct CharIndices<'a> {\n    front_offset: usize,\n    iter: Chars<'a>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for CharIndices<'a> {\n    type Item = (usize, char);\n\n    #[inline]\n    fn next(&mut self) -> Option<(usize, char)> {\n        let pre_len = self.iter.iter.len();\n        match self.iter.next() {\n            None => None,\n            Some(ch) => {\n                let index = self.front_offset;\n                let len = self.iter.iter.len();\n                self.front_offset += pre_len - len;\n                Some((index, ch))\n            }\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.iter.count()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<(usize, char)> {\n        // No need to go through the entire string.\n        self.next_back()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> DoubleEndedIterator for CharIndices<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<(usize, char)> {\n        match self.iter.next_back() {\n            None => None,\n            Some(ch) => {\n                let index = self.front_offset + self.iter.iter.len();\n                Some((index, ch))\n            }\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a> FusedIterator for CharIndices<'a> {}\n\nimpl<'a> CharIndices<'a> {\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// This has the same lifetime as the original slice, and so the\n    /// iterator can continue to be used while this exists.\n    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n    #[inline]\n    pub fn as_str(&self) -> &'a str {\n        self.iter.as_str()\n    }\n}\n\n/// An iterator over the bytes of a string slice.\n///\n/// This struct is created by the [`bytes`] method on [`str`].\n/// See its documentation for more.\n///\n/// [`bytes`]: ../../std/primitive.str.html#method.bytes\n/// [`str`]: ../../std/primitive.str.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone, Debug)]\npub struct Bytes<'a>(Cloned<slice::Iter<'a, u8>>);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for Bytes<'a> {\n    type Item = u8;\n\n    #[inline]\n    fn next(&mut self) -> Option<u8> {\n        self.0.next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.0.count()\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        self.0.last()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        self.0.nth(n)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> DoubleEndedIterator for Bytes<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<u8> {\n        self.0.next_back()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> ExactSizeIterator for Bytes<'a> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    #[inline]\n    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a> FusedIterator for Bytes<'a> {}\n\n/// This macro generates a Clone impl for string pattern API\n/// wrapper types of the form X<'a, P>\nmacro_rules! derive_pattern_clone {\n    (clone $t:ident with |$s:ident| $e:expr) => {\n        impl<'a, P: Pattern<'a>> Clone for $t<'a, P>\n            where P::Searcher: Clone\n        {\n            fn clone(&self) -> Self {\n                let $s = self;\n                $e\n            }\n        }\n    }\n}\n\n/// This macro generates two public iterator structs\n/// wrapping a private internal one that makes use of the `Pattern` API.\n///\n/// For all patterns `P: Pattern<'a>` the following items will be\n/// generated (generics omitted):\n///\n/// struct $forward_iterator($internal_iterator);\n/// struct $reverse_iterator($internal_iterator);\n///\n/// impl Iterator for $forward_iterator\n/// { /* internal ends up calling Searcher::next_match() */ }\n///\n/// impl DoubleEndedIterator for $forward_iterator\n///       where P::Searcher: DoubleEndedSearcher\n/// { /* internal ends up calling Searcher::next_match_back() */ }\n///\n/// impl Iterator for $reverse_iterator\n///       where P::Searcher: ReverseSearcher\n/// { /* internal ends up calling Searcher::next_match_back() */ }\n///\n/// impl DoubleEndedIterator for $reverse_iterator\n///       where P::Searcher: DoubleEndedSearcher\n/// { /* internal ends up calling Searcher::next_match() */ }\n///\n/// The internal one is defined outside the macro, and has almost the same\n/// semantic as a DoubleEndedIterator by delegating to `pattern::Searcher` and\n/// `pattern::ReverseSearcher` for both forward and reverse iteration.\n///\n/// \"Almost\", because a `Searcher` and a `ReverseSearcher` for a given\n/// `Pattern` might not return the same elements, so actually implementing\n/// `DoubleEndedIterator` for it would be incorrect.\n/// (See the docs in `str::pattern` for more details)\n///\n/// However, the internal struct still represents a single ended iterator from\n/// either end, and depending on pattern is also a valid double ended iterator,\n/// so the two wrapper structs implement `Iterator`\n/// and `DoubleEndedIterator` depending on the concrete pattern type, leading\n/// to the complex impls seen above.\nmacro_rules! generate_pattern_iterators {\n    {\n        // Forward iterator\n        forward:\n            $(#[$forward_iterator_attribute:meta])*\n            struct $forward_iterator:ident;\n\n        // Reverse iterator\n        reverse:\n            $(#[$reverse_iterator_attribute:meta])*\n            struct $reverse_iterator:ident;\n\n        // Stability of all generated items\n        stability:\n            $(#[$common_stability_attribute:meta])*\n\n        // Internal almost-iterator that is being delegated to\n        internal:\n            $internal_iterator:ident yielding ($iterty:ty);\n\n        // Kind of delgation - either single ended or double ended\n        delegate $($t:tt)*\n    } => {\n        $(#[$forward_iterator_attribute])*\n        $(#[$common_stability_attribute])*\n        pub struct $forward_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n\n        $(#[$common_stability_attribute])*\n        impl<'a, P: Pattern<'a>> fmt::Debug for $forward_iterator<'a, P>\n            where P::Searcher: fmt::Debug\n        {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                f.debug_tuple(stringify!($forward_iterator))\n                    .field(&self.0)\n                    .finish()\n            }\n        }\n\n        $(#[$common_stability_attribute])*\n        impl<'a, P: Pattern<'a>> Iterator for $forward_iterator<'a, P> {\n            type Item = $iterty;\n\n            #[inline]\n            fn next(&mut self) -> Option<$iterty> {\n                self.0.next()\n            }\n        }\n\n        $(#[$common_stability_attribute])*\n        impl<'a, P: Pattern<'a>> Clone for $forward_iterator<'a, P>\n            where P::Searcher: Clone\n        {\n            fn clone(&self) -> Self {\n                $forward_iterator(self.0.clone())\n            }\n        }\n\n        $(#[$reverse_iterator_attribute])*\n        $(#[$common_stability_attribute])*\n        pub struct $reverse_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n\n        $(#[$common_stability_attribute])*\n        impl<'a, P: Pattern<'a>> fmt::Debug for $reverse_iterator<'a, P>\n            where P::Searcher: fmt::Debug\n        {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                f.debug_tuple(stringify!($reverse_iterator))\n                    .field(&self.0)\n                    .finish()\n            }\n        }\n\n        $(#[$common_stability_attribute])*\n        impl<'a, P: Pattern<'a>> Iterator for $reverse_iterator<'a, P>\n            where P::Searcher: ReverseSearcher<'a>\n        {\n            type Item = $iterty;\n\n            #[inline]\n            fn next(&mut self) -> Option<$iterty> {\n                self.0.next_back()\n            }\n        }\n\n        $(#[$common_stability_attribute])*\n        impl<'a, P: Pattern<'a>> Clone for $reverse_iterator<'a, P>\n            where P::Searcher: Clone\n        {\n            fn clone(&self) -> Self {\n                $reverse_iterator(self.0.clone())\n            }\n        }\n\n        #[unstable(feature = \"fused\", issue = \"35602\")]\n        impl<'a, P: Pattern<'a>> FusedIterator for $forward_iterator<'a, P> {}\n\n        #[unstable(feature = \"fused\", issue = \"35602\")]\n        impl<'a, P: Pattern<'a>> FusedIterator for $reverse_iterator<'a, P>\n            where P::Searcher: ReverseSearcher<'a> {}\n\n        generate_pattern_iterators!($($t)* with $(#[$common_stability_attribute])*,\n                                                $forward_iterator,\n                                                $reverse_iterator, $iterty);\n    };\n    {\n        double ended; with $(#[$common_stability_attribute:meta])*,\n                           $forward_iterator:ident,\n                           $reverse_iterator:ident, $iterty:ty\n    } => {\n        $(#[$common_stability_attribute])*\n        impl<'a, P: Pattern<'a>> DoubleEndedIterator for $forward_iterator<'a, P>\n            where P::Searcher: DoubleEndedSearcher<'a>\n        {\n            #[inline]\n            fn next_back(&mut self) -> Option<$iterty> {\n                self.0.next_back()\n            }\n        }\n\n        $(#[$common_stability_attribute])*\n        impl<'a, P: Pattern<'a>> DoubleEndedIterator for $reverse_iterator<'a, P>\n            where P::Searcher: DoubleEndedSearcher<'a>\n        {\n            #[inline]\n            fn next_back(&mut self) -> Option<$iterty> {\n                self.0.next()\n            }\n        }\n    };\n    {\n        single ended; with $(#[$common_stability_attribute:meta])*,\n                           $forward_iterator:ident,\n                           $reverse_iterator:ident, $iterty:ty\n    } => {}\n}\n\nderive_pattern_clone!{\n    clone SplitInternal\n    with |s| SplitInternal { matcher: s.matcher.clone(), ..*s }\n}\n\nstruct SplitInternal<'a, P: Pattern<'a>> {\n    start: usize,\n    end: usize,\n    matcher: P::Searcher,\n    allow_trailing_empty: bool,\n    finished: bool,\n}\n\nimpl<'a, P: Pattern<'a>> fmt::Debug for SplitInternal<'a, P> where P::Searcher: fmt::Debug {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"SplitInternal\")\n            .field(\"start\", &self.start)\n            .field(\"end\", &self.end)\n            .field(\"matcher\", &self.matcher)\n            .field(\"allow_trailing_empty\", &self.allow_trailing_empty)\n            .field(\"finished\", &self.finished)\n            .finish()\n    }\n}\n\nimpl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n    #[inline]\n    fn get_end(&mut self) -> Option<&'a str> {\n        if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n            self.finished = true;\n            unsafe {\n                let string = self.matcher.haystack().slice_unchecked(self.start, self.end);\n                Some(string)\n            }\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a str> {\n        if self.finished { return None }\n\n        let haystack = self.matcher.haystack();\n        match self.matcher.next_match() {\n            Some((a, b)) => unsafe {\n                let elt = haystack.slice_unchecked(self.start, a);\n                self.start = b;\n                Some(elt)\n            },\n            None => self.get_end(),\n        }\n    }\n\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a str>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        if self.finished { return None }\n\n        if !self.allow_trailing_empty {\n            self.allow_trailing_empty = true;\n            match self.next_back() {\n                Some(elt) if !elt.is_empty() => return Some(elt),\n                _ => if self.finished { return None }\n            }\n        }\n\n        let haystack = self.matcher.haystack();\n        match self.matcher.next_match_back() {\n            Some((a, b)) => unsafe {\n                let elt = haystack.slice_unchecked(b, self.end);\n                self.end = a;\n                Some(elt)\n            },\n            None => unsafe {\n                self.finished = true;\n                Some(haystack.slice_unchecked(self.start, self.end))\n            },\n        }\n    }\n}\n\ngenerate_pattern_iterators! {\n    forward:\n        /// Created with the method [`split`].\n        ///\n        /// [`split`]: ../../std/primitive.str.html#method.split\n        struct Split;\n    reverse:\n        /// Created with the method [`rsplit`].\n        ///\n        /// [`rsplit`]: ../../std/primitive.str.html#method.rsplit\n        struct RSplit;\n    stability:\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    internal:\n        SplitInternal yielding (&'a str);\n    delegate double ended;\n}\n\ngenerate_pattern_iterators! {\n    forward:\n        /// Created with the method [`split_terminator`].\n        ///\n        /// [`split_terminator`]: ../../std/primitive.str.html#method.split_terminator\n        struct SplitTerminator;\n    reverse:\n        /// Created with the method [`rsplit_terminator`].\n        ///\n        /// [`rsplit_terminator`]: ../../std/primitive.str.html#method.rsplit_terminator\n        struct RSplitTerminator;\n    stability:\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    internal:\n        SplitInternal yielding (&'a str);\n    delegate double ended;\n}\n\nderive_pattern_clone!{\n    clone SplitNInternal\n    with |s| SplitNInternal { iter: s.iter.clone(), ..*s }\n}\n\nstruct SplitNInternal<'a, P: Pattern<'a>> {\n    iter: SplitInternal<'a, P>,\n    /// The number of splits remaining\n    count: usize,\n}\n\nimpl<'a, P: Pattern<'a>> fmt::Debug for SplitNInternal<'a, P> where P::Searcher: fmt::Debug {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"SplitNInternal\")\n            .field(\"iter\", &self.iter)\n            .field(\"count\", &self.count)\n            .finish()\n    }\n}\n\nimpl<'a, P: Pattern<'a>> SplitNInternal<'a, P> {\n    #[inline]\n    fn next(&mut self) -> Option<&'a str> {\n        match self.count {\n            0 => None,\n            1 => { self.count = 0; self.iter.get_end() }\n            _ => { self.count -= 1; self.iter.next() }\n        }\n    }\n\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a str>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        match self.count {\n            0 => None,\n            1 => { self.count = 0; self.iter.get_end() }\n            _ => { self.count -= 1; self.iter.next_back() }\n        }\n    }\n}\n\ngenerate_pattern_iterators! {\n    forward:\n        /// Created with the method [`splitn`].\n        ///\n        /// [`splitn`]: ../../std/primitive.str.html#method.splitn\n        struct SplitN;\n    reverse:\n        /// Created with the method [`rsplitn`].\n        ///\n        /// [`rsplitn`]: ../../std/primitive.str.html#method.rsplitn\n        struct RSplitN;\n    stability:\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    internal:\n        SplitNInternal yielding (&'a str);\n    delegate single ended;\n}\n\nderive_pattern_clone!{\n    clone MatchIndicesInternal\n    with |s| MatchIndicesInternal(s.0.clone())\n}\n\nstruct MatchIndicesInternal<'a, P: Pattern<'a>>(P::Searcher);\n\nimpl<'a, P: Pattern<'a>> fmt::Debug for MatchIndicesInternal<'a, P> where P::Searcher: fmt::Debug {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"MatchIndicesInternal\")\n            .field(&self.0)\n            .finish()\n    }\n}\n\nimpl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n    #[inline]\n    fn next(&mut self) -> Option<(usize, &'a str)> {\n        self.0.next_match().map(|(start, end)| unsafe {\n            (start, self.0.haystack().slice_unchecked(start, end))\n        })\n    }\n\n    #[inline]\n    fn next_back(&mut self) -> Option<(usize, &'a str)>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        self.0.next_match_back().map(|(start, end)| unsafe {\n            (start, self.0.haystack().slice_unchecked(start, end))\n        })\n    }\n}\n\ngenerate_pattern_iterators! {\n    forward:\n        /// Created with the method [`match_indices`].\n        ///\n        /// [`match_indices`]: ../../std/primitive.str.html#method.match_indices\n        struct MatchIndices;\n    reverse:\n        /// Created with the method [`rmatch_indices`].\n        ///\n        /// [`rmatch_indices`]: ../../std/primitive.str.html#method.rmatch_indices\n        struct RMatchIndices;\n    stability:\n        #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n    internal:\n        MatchIndicesInternal yielding ((usize, &'a str));\n    delegate double ended;\n}\n\nderive_pattern_clone!{\n    clone MatchesInternal\n    with |s| MatchesInternal(s.0.clone())\n}\n\nstruct MatchesInternal<'a, P: Pattern<'a>>(P::Searcher);\n\nimpl<'a, P: Pattern<'a>> fmt::Debug for MatchesInternal<'a, P> where P::Searcher: fmt::Debug {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"MatchesInternal\")\n            .field(&self.0)\n            .finish()\n    }\n}\n\nimpl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n    #[inline]\n    fn next(&mut self) -> Option<&'a str> {\n        self.0.next_match().map(|(a, b)| unsafe {\n            // Indices are known to be on utf8 boundaries\n            self.0.haystack().slice_unchecked(a, b)\n        })\n    }\n\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a str>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        self.0.next_match_back().map(|(a, b)| unsafe {\n            // Indices are known to be on utf8 boundaries\n            self.0.haystack().slice_unchecked(a, b)\n        })\n    }\n}\n\ngenerate_pattern_iterators! {\n    forward:\n        /// Created with the method [`matches`].\n        ///\n        /// [`matches`]: ../../std/primitive.str.html#method.matches\n        struct Matches;\n    reverse:\n        /// Created with the method [`rmatches`].\n        ///\n        /// [`rmatches`]: ../../std/primitive.str.html#method.rmatches\n        struct RMatches;\n    stability:\n        #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n    internal:\n        MatchesInternal yielding (&'a str);\n    delegate double ended;\n}\n\n/// An iterator over the lines of a string, as string slices.\n///\n/// This struct is created with the [`lines`] method on [`str`].\n/// See its documentation for more.\n///\n/// [`lines`]: ../../std/primitive.str.html#method.lines\n/// [`str`]: ../../std/primitive.str.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone, Debug)]\npub struct Lines<'a>(Map<SplitTerminator<'a, char>, LinesAnyMap>);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for Lines<'a> {\n    type Item = &'a str;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a str> {\n        self.0.next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> DoubleEndedIterator for Lines<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a str> {\n        self.0.next_back()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a> FusedIterator for Lines<'a> {}\n\n/// Created with the method [`lines_any`].\n///\n/// [`lines_any`]: ../../std/primitive.str.html#method.lines_any\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.4.0\", reason = \"use lines()/Lines instead now\")]\n#[derive(Clone, Debug)]\n#[allow(deprecated)]\npub struct LinesAny<'a>(Lines<'a>);\n\n/// A nameable, cloneable fn type\n#[derive(Clone)]\nstruct LinesAnyMap;\n\nimpl<'a> Fn<(&'a str,)> for LinesAnyMap {\n    #[inline]\n    extern \"rust-call\" fn call(&self, (line,): (&'a str,)) -> &'a str {\n        let l = line.len();\n        if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n        else { line }\n    }\n}\n\nimpl<'a> FnMut<(&'a str,)> for LinesAnyMap {\n    #[inline]\n    extern \"rust-call\" fn call_mut(&mut self, (line,): (&'a str,)) -> &'a str {\n        Fn::call(&*self, (line,))\n    }\n}\n\nimpl<'a> FnOnce<(&'a str,)> for LinesAnyMap {\n    type Output = &'a str;\n\n    #[inline]\n    extern \"rust-call\" fn call_once(self, (line,): (&'a str,)) -> &'a str {\n        Fn::call(&self, (line,))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\nimpl<'a> Iterator for LinesAny<'a> {\n    type Item = &'a str;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a str> {\n        self.0.next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\nimpl<'a> DoubleEndedIterator for LinesAny<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a str> {\n        self.0.next_back()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\n#[allow(deprecated)]\nimpl<'a> FusedIterator for LinesAny<'a> {}\n\n/*\nSection: Comparing strings\n*/\n\n/// Bytewise slice equality\n/// NOTE: This function is (ab)used in rustc::middle::trans::_match\n/// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n#[lang = \"str_eq\"]\n#[inline]\nfn eq_slice(a: &str, b: &str) -> bool {\n    a.as_bytes() == b.as_bytes()\n}\n\n/*\nSection: UTF-8 validation\n*/\n\n// use truncation to fit u64 into usize\nconst NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n\n/// Returns `true` if any byte in the word `x` is nonascii (>= 128).\n#[inline]\nfn contains_nonascii(x: usize) -> bool {\n    (x & NONASCII_MASK) != 0\n}\n\n/// Walks through `iter` checking that it's a valid UTF-8 sequence,\n/// returning `true` in that case, or, if it is invalid, `false` with\n/// `iter` reset such that it is pointing at the first byte in the\n/// invalid sequence.\n#[inline(always)]\nfn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n    let mut index = 0;\n    let len = v.len();\n\n    let usize_bytes = mem::size_of::<usize>();\n    let ascii_block_size = 2 * usize_bytes;\n    let blocks_end = if len >= ascii_block_size { len - ascii_block_size + 1 } else { 0 };\n\n    while index < len {\n        let old_offset = index;\n        macro_rules! err {\n            ($error_len: expr) => {\n                return Err(Utf8Error {\n                    valid_up_to: old_offset,\n                    error_len: $error_len,\n                })\n            }\n        }\n\n        macro_rules! next { () => {{\n            index += 1;\n            // we needed data, but there was none: error!\n            if index >= len {\n                err!(None)\n            }\n            v[index]\n        }}}\n\n        let first = v[index];\n        if first >= 128 {\n            let w = UTF8_CHAR_WIDTH[first as usize];\n            // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n            //        first  C2 80        last DF BF\n            // 3-byte encoding is for codepoints  \\u{0800} to  \\u{ffff}\n            //        first  E0 A0 80     last EF BF BF\n            //   excluding surrogates codepoints  \\u{d800} to  \\u{dfff}\n            //               ED A0 80 to       ED BF BF\n            // 4-byte encoding is for codepoints \\u{1000}0 to \\u{10ff}ff\n            //        first  F0 90 80 80  last F4 8F BF BF\n            //\n            // Use the UTF-8 syntax from the RFC\n            //\n            // https://tools.ietf.org/html/rfc3629\n            // UTF8-1      = %x00-7F\n            // UTF8-2      = %xC2-DF UTF8-tail\n            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n            //               %xF4 %x80-8F 2( UTF8-tail )\n            match w {\n                2 => if next!() & !CONT_MASK != TAG_CONT_U8 {\n                    err!(Some(1))\n                },\n                3 => {\n                    match (first, next!()) {\n                        (0xE0         , 0xA0 ... 0xBF) |\n                        (0xE1 ... 0xEC, 0x80 ... 0xBF) |\n                        (0xED         , 0x80 ... 0x9F) |\n                        (0xEE ... 0xEF, 0x80 ... 0xBF) => {}\n                        _ => err!(Some(1))\n                    }\n                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n                        err!(Some(2))\n                    }\n                }\n                4 => {\n                    match (first, next!()) {\n                        (0xF0         , 0x90 ... 0xBF) |\n                        (0xF1 ... 0xF3, 0x80 ... 0xBF) |\n                        (0xF4         , 0x80 ... 0x8F) => {}\n                        _ => err!(Some(1))\n                    }\n                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n                        err!(Some(2))\n                    }\n                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n                        err!(Some(3))\n                    }\n                }\n                _ => err!(Some(1))\n            }\n            index += 1;\n        } else {\n            // Ascii case, try to skip forward quickly.\n            // When the pointer is aligned, read 2 words of data per iteration\n            // until we find a word containing a non-ascii byte.\n            let ptr = v.as_ptr();\n            let align = (ptr as usize + index) & (usize_bytes - 1);\n            if align == 0 {\n                while index < blocks_end {\n                    unsafe {\n                        let block = ptr.offset(index as isize) as *const usize;\n                        // break if there is a nonascii byte\n                        let zu = contains_nonascii(*block);\n                        let zv = contains_nonascii(*block.offset(1));\n                        if zu | zv {\n                            break;\n                        }\n                    }\n                    index += ascii_block_size;\n                }\n                // step from the point where the wordwise loop stopped\n                while index < len && v[index] < 128 {\n                    index += 1;\n                }\n            } else {\n                index += 1;\n            }\n        }\n    }\n\n    Ok(())\n}\n\n// https://tools.ietf.org/html/rfc3629\nstatic UTF8_CHAR_WIDTH: [u8; 256] = [\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x1F\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x3F\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x5F\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x7F\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0x9F\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0xBF\n0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0xDF\n3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, // 0xEF\n4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0, // 0xFF\n];\n\n/// Given a first byte, determines how many bytes are in this UTF-8 character.\n#[unstable(feature = \"str_internals\", issue = \"0\")]\n#[inline]\npub fn utf8_char_width(b: u8) -> usize {\n    return UTF8_CHAR_WIDTH[b as usize] as usize;\n}\n\n/// Mask of the value bits of a continuation byte.\nconst CONT_MASK: u8 = 0b0011_1111;\n/// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte.\nconst TAG_CONT_U8: u8 = 0b1000_0000;\n\n/*\nSection: Trait implementations\n*/\n\nmod traits {\n    use cmp::Ordering;\n    use ops;\n    use slice::{self, SliceIndex};\n    use str::eq_slice;\n\n    /// Implements ordering of strings.\n    ///\n    /// Strings are ordered  lexicographically by their byte values.  This orders Unicode code\n    /// points based on their positions in the code charts.  This is not necessarily the same as\n    /// \"alphabetical\" order, which varies by language and locale.  Sorting strings according to\n    /// culturally-accepted standards requires locale-specific data that is outside the scope of\n    /// the `str` type.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Ord for str {\n        #[inline]\n        fn cmp(&self, other: &str) -> Ordering {\n            self.as_bytes().cmp(other.as_bytes())\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialEq for str {\n        #[inline]\n        fn eq(&self, other: &str) -> bool {\n            eq_slice(self, other)\n        }\n        #[inline]\n        fn ne(&self, other: &str) -> bool { !(*self).eq(other) }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Eq for str {}\n\n    /// Implements comparison operations on strings.\n    ///\n    /// Strings are compared lexicographically by their byte values.  This compares Unicode code\n    /// points based on their positions in the code charts.  This is not necessarily the same as\n    /// \"alphabetical\" order, which varies by language and locale.  Comparing strings according to\n    /// culturally-accepted standards requires locale-specific data that is outside the scope of\n    /// the `str` type.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialOrd for str {\n        #[inline]\n        fn partial_cmp(&self, other: &str) -> Option<Ordering> {\n            Some(self.cmp(other))\n        }\n    }\n\n    /// Implements substring slicing with syntax `&self[begin .. end]`.\n    ///\n    /// Returns a slice of the given string from the byte range\n    /// [`begin`..`end`).\n    ///\n    /// This operation is `O(1)`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `begin` or `end` does not point to the starting\n    /// byte offset of a character (as defined by `is_char_boundary`).\n    /// Requires that `begin <= end` and `end <= len` where `len` is the\n    /// length of the string.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s = \"Lwe  Lopard\";\n    /// assert_eq!(&s[0 .. 1], \"L\");\n    ///\n    /// assert_eq!(&s[1 .. 9], \"we \");\n    ///\n    /// // these will panic:\n    /// // byte 2 lies within ``:\n    /// // &s[2 ..3];\n    ///\n    /// // byte 8 lies within ``\n    /// // &s[1 .. 8];\n    ///\n    /// // byte 100 is outside the string\n    /// // &s[3 .. 100];\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl ops::Index<ops::Range<usize>> for str {\n        type Output = str;\n        #[inline]\n        fn index(&self, index: ops::Range<usize>) -> &str {\n            index.index(self)\n        }\n    }\n\n    /// Implements mutable substring slicing with syntax\n    /// `&mut self[begin .. end]`.\n    ///\n    /// Returns a mutable slice of the given string from the byte range\n    /// [`begin`..`end`).\n    ///\n    /// This operation is `O(1)`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `begin` or `end` does not point to the starting\n    /// byte offset of a character (as defined by `is_char_boundary`).\n    /// Requires that `begin <= end` and `end <= len` where `len` is the\n    /// length of the string.\n    #[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\n    impl ops::IndexMut<ops::Range<usize>> for str {\n        #[inline]\n        fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str {\n            index.index_mut(self)\n        }\n    }\n\n    /// Implements substring slicing with syntax `&self[.. end]`.\n    ///\n    /// Returns a slice of the string from the beginning to byte offset\n    /// `end`.\n    ///\n    /// Equivalent to `&self[0 .. end]`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl ops::Index<ops::RangeTo<usize>> for str {\n        type Output = str;\n\n        #[inline]\n        fn index(&self, index: ops::RangeTo<usize>) -> &str {\n            index.index(self)\n        }\n    }\n\n    /// Implements mutable substring slicing with syntax `&mut self[.. end]`.\n    ///\n    /// Returns a mutable slice of the string from the beginning to byte offset\n    /// `end`.\n    ///\n    /// Equivalent to `&mut self[0 .. end]`.\n    #[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\n    impl ops::IndexMut<ops::RangeTo<usize>> for str {\n        #[inline]\n        fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str {\n            index.index_mut(self)\n        }\n    }\n\n    /// Implements substring slicing with syntax `&self[begin ..]`.\n    ///\n    /// Returns a slice of the string from byte offset `begin`\n    /// to the end of the string.\n    ///\n    /// Equivalent to `&self[begin .. len]`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl ops::Index<ops::RangeFrom<usize>> for str {\n        type Output = str;\n\n        #[inline]\n        fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n            index.index(self)\n        }\n    }\n\n    /// Implements mutable substring slicing with syntax `&mut self[begin ..]`.\n    ///\n    /// Returns a mutable slice of the string from byte offset `begin`\n    /// to the end of the string.\n    ///\n    /// Equivalent to `&mut self[begin .. len]`.\n    #[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\n    impl ops::IndexMut<ops::RangeFrom<usize>> for str {\n        #[inline]\n        fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str {\n            index.index_mut(self)\n        }\n    }\n\n    /// Implements substring slicing with syntax `&self[..]`.\n    ///\n    /// Returns a slice of the whole string. This operation can\n    /// never panic.\n    ///\n    /// Equivalent to `&self[0 .. len]`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl ops::Index<ops::RangeFull> for str {\n        type Output = str;\n\n        #[inline]\n        fn index(&self, _index: ops::RangeFull) -> &str {\n            self\n        }\n    }\n\n    /// Implements mutable substring slicing with syntax `&mut self[..]`.\n    ///\n    /// Returns a mutable slice of the whole string. This operation can\n    /// never panic.\n    ///\n    /// Equivalent to `&mut self[0 .. len]`.\n    #[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\n    impl ops::IndexMut<ops::RangeFull> for str {\n        #[inline]\n        fn index_mut(&mut self, _index: ops::RangeFull) -> &mut str {\n            self\n        }\n    }\n\n    #[unstable(feature = \"inclusive_range\",\n               reason = \"recently added, follows RFC\",\n               issue = \"28237\")]\n    impl ops::Index<ops::RangeInclusive<usize>> for str {\n        type Output = str;\n\n        #[inline]\n        fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n            index.index(self)\n        }\n    }\n\n    #[unstable(feature = \"inclusive_range\",\n               reason = \"recently added, follows RFC\",\n               issue = \"28237\")]\n    impl ops::Index<ops::RangeToInclusive<usize>> for str {\n        type Output = str;\n\n        #[inline]\n        fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n            index.index(self)\n        }\n    }\n\n    #[unstable(feature = \"inclusive_range\",\n               reason = \"recently added, follows RFC\",\n               issue = \"28237\")]\n    impl ops::IndexMut<ops::RangeInclusive<usize>> for str {\n        #[inline]\n        fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n            index.index_mut(self)\n        }\n    }\n    #[unstable(feature = \"inclusive_range\",\n               reason = \"recently added, follows RFC\",\n               issue = \"28237\")]\n    impl ops::IndexMut<ops::RangeToInclusive<usize>> for str {\n        #[inline]\n        fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n            index.index_mut(self)\n        }\n    }\n\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    impl SliceIndex<str> for ops::RangeFull {\n        type Output = str;\n        #[inline]\n        fn get(self, slice: &str) -> Option<&Self::Output> {\n            Some(slice)\n        }\n        #[inline]\n        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n            Some(slice)\n        }\n        #[inline]\n        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n            slice\n        }\n        #[inline]\n        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n            slice\n        }\n        #[inline]\n        fn index(self, slice: &str) -> &Self::Output {\n            slice\n        }\n        #[inline]\n        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n            slice\n        }\n    }\n\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    impl SliceIndex<str> for ops::Range<usize> {\n        type Output = str;\n        #[inline]\n        fn get(self, slice: &str) -> Option<&Self::Output> {\n            if self.start <= self.end &&\n               slice.is_char_boundary(self.start) &&\n               slice.is_char_boundary(self.end) {\n                Some(unsafe { self.get_unchecked(slice) })\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n            if self.start <= self.end &&\n               slice.is_char_boundary(self.start) &&\n               slice.is_char_boundary(self.end) {\n                Some(unsafe { self.get_unchecked_mut(slice) })\n            } else {\n                None\n            }\n        }\n        #[inline]\n        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n            let ptr = slice.as_ptr().offset(self.start as isize);\n            let len = self.end - self.start;\n            super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n        }\n        #[inline]\n        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n            let ptr = slice.as_ptr().offset(self.start as isize);\n            let len = self.end - self.start;\n            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr as *mut u8, len))\n        }\n        #[inline]\n        fn index(self, slice: &str) -> &Self::Output {\n            let (start, end) = (self.start, self.end);\n            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, start, end))\n        }\n        #[inline]\n        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n            // is_char_boundary checks that the index is in [0, .len()]\n            // canot reuse `get` as above, because of NLL trouble\n            if self.start <= self.end &&\n               slice.is_char_boundary(self.start) &&\n               slice.is_char_boundary(self.end) {\n                unsafe { self.get_unchecked_mut(slice) }\n            } else {\n                super::slice_error_fail(slice, self.start, self.end)\n            }\n        }\n    }\n\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    impl SliceIndex<str> for ops::RangeTo<usize> {\n        type Output = str;\n        #[inline]\n        fn get(self, slice: &str) -> Option<&Self::Output> {\n            if slice.is_char_boundary(self.end) {\n                Some(unsafe { self.get_unchecked(slice) })\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n            if slice.is_char_boundary(self.end) {\n                Some(unsafe { self.get_unchecked_mut(slice) })\n            } else {\n                None\n            }\n        }\n        #[inline]\n        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n            let ptr = slice.as_ptr();\n            super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end))\n        }\n        #[inline]\n        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n            let ptr = slice.as_ptr();\n            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr as *mut u8, self.end))\n        }\n        #[inline]\n        fn index(self, slice: &str) -> &Self::Output {\n            let end = self.end;\n            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, 0, end))\n        }\n        #[inline]\n        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n            // is_char_boundary checks that the index is in [0, .len()]\n            if slice.is_char_boundary(self.end) {\n                unsafe { self.get_unchecked_mut(slice) }\n            } else {\n                super::slice_error_fail(slice, 0, self.end)\n            }\n        }\n    }\n\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    impl SliceIndex<str> for ops::RangeFrom<usize> {\n        type Output = str;\n        #[inline]\n        fn get(self, slice: &str) -> Option<&Self::Output> {\n            if slice.is_char_boundary(self.start) {\n                Some(unsafe { self.get_unchecked(slice) })\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n            if slice.is_char_boundary(self.start) {\n                Some(unsafe { self.get_unchecked_mut(slice) })\n            } else {\n                None\n            }\n        }\n        #[inline]\n        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n            let ptr = slice.as_ptr().offset(self.start as isize);\n            let len = slice.len() - self.start;\n            super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n        }\n        #[inline]\n        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n            let ptr = slice.as_ptr().offset(self.start as isize);\n            let len = slice.len() - self.start;\n            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr as *mut u8, len))\n        }\n        #[inline]\n        fn index(self, slice: &str) -> &Self::Output {\n            let (start, end) = (self.start, slice.len());\n            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, start, end))\n        }\n        #[inline]\n        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n            // is_char_boundary checks that the index is in [0, .len()]\n            if slice.is_char_boundary(self.start) {\n                unsafe { self.get_unchecked_mut(slice) }\n            } else {\n                super::slice_error_fail(slice, self.start, slice.len())\n            }\n        }\n    }\n\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    impl SliceIndex<str> for ops::RangeInclusive<usize> {\n        type Output = str;\n        #[inline]\n        fn get(self, slice: &str) -> Option<&Self::Output> {\n            if let Some(end) = self.end.checked_add(1) {\n                (self.start..end).get(slice)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n            if let Some(end) = self.end.checked_add(1) {\n                (self.start..end).get_mut(slice)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n            (self.start..self.end+1).get_unchecked(slice)\n        }\n        #[inline]\n        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n            (self.start..self.end+1).get_unchecked_mut(slice)\n        }\n        #[inline]\n        fn index(self, slice: &str) -> &Self::Output {\n            assert!(self.end != usize::max_value(),\n                \"attempted to index str up to maximum usize\");\n            (self.start..self.end+1).index(slice)\n        }\n        #[inline]\n        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n            assert!(self.end != usize::max_value(),\n                \"attempted to index str up to maximum usize\");\n            (self.start..self.end+1).index_mut(slice)\n        }\n    }\n\n\n\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n        type Output = str;\n        #[inline]\n        fn get(self, slice: &str) -> Option<&Self::Output> {\n            if self.end < usize::max_value() && slice.is_char_boundary(self.end + 1) {\n                Some(unsafe { self.get_unchecked(slice) })\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n            if self.end < usize::max_value() && slice.is_char_boundary(self.end + 1) {\n                Some(unsafe { self.get_unchecked_mut(slice) })\n            } else {\n                None\n            }\n        }\n        #[inline]\n        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n            let ptr = slice.as_ptr();\n            super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end + 1))\n        }\n        #[inline]\n        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n            let ptr = slice.as_ptr();\n            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr as *mut u8, self.end + 1))\n        }\n        #[inline]\n        fn index(self, slice: &str) -> &Self::Output {\n            assert!(self.end != usize::max_value(),\n                \"attempted to index str up to maximum usize\");\n            let end = self.end + 1;\n            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, 0, end))\n        }\n        #[inline]\n        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n            assert!(self.end != usize::max_value(),\n                \"attempted to index str up to maximum usize\");\n            if slice.is_char_boundary(self.end) {\n                unsafe { self.get_unchecked_mut(slice) }\n            } else {\n                super::slice_error_fail(slice, 0, self.end + 1)\n            }\n        }\n    }\n\n}\n\n\n/// Methods for string slices\n#[allow(missing_docs)]\n#[doc(hidden)]\n#[unstable(feature = \"core_str_ext\",\n           reason = \"stable interface provided by `impl str` in later crates\",\n           issue = \"32110\")]\npub trait StrExt {\n    // NB there are no docs here are they're all located on the StrExt trait in\n    // liballoc, not here.\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn chars(&self) -> Chars;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn bytes(&self) -> Bytes;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn char_indices(&self) -> CharIndices;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n        where P::Searcher: ReverseSearcher<'a>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n        where P::Searcher: ReverseSearcher<'a>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n        where P::Searcher: ReverseSearcher<'a>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n        where P::Searcher: ReverseSearcher<'a>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n        where P::Searcher: ReverseSearcher<'a>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn lines(&self) -> Lines;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    #[rustc_deprecated(since = \"1.6.0\", reason = \"use lines() instead now\")]\n    #[allow(deprecated)]\n    fn lines_any(&self) -> LinesAny;\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output>;\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output>;\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output;\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n        where P::Searcher: ReverseSearcher<'a>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n        where P::Searcher: DoubleEndedSearcher<'a>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n        where P::Searcher: ReverseSearcher<'a>;\n    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n    fn is_char_boundary(&self, index: usize) -> bool;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn as_bytes(&self) -> &[u8];\n    #[unstable(feature = \"str_mut_extras\", issue = \"41119\")]\n    unsafe fn as_bytes_mut(&mut self) -> &mut [u8];\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n        where P::Searcher: ReverseSearcher<'a>;\n    fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_at(&self, mid: usize) -> (&str, &str);\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str);\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn as_ptr(&self) -> *const u8;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn len(&self) -> usize;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_empty(&self) -> bool;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn parse<'a, T: TryFrom<&'a str>>(&'a self) -> Result<T, T::Error>;\n}\n\n// truncate `&str` to length at most equal to `max`\n// return `true` if it were truncated, and the new str.\nfn truncate_to_char_boundary(s: &str, mut max: usize) -> (bool, &str) {\n    if max >= s.len() {\n        (false, s)\n    } else {\n        while !s.is_char_boundary(max) {\n            max -= 1;\n        }\n        (true, &s[..max])\n    }\n}\n\n#[inline(never)]\n#[cold]\nfn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n    const MAX_DISPLAY_LENGTH: usize = 256;\n    let (truncated, s_trunc) = truncate_to_char_boundary(s, MAX_DISPLAY_LENGTH);\n    let ellipsis = if truncated { \"[...]\" } else { \"\" };\n\n    // 1. out of bounds\n    if begin > s.len() || end > s.len() {\n        let oob_index = if begin > s.len() { begin } else { end };\n        panic!(\"byte index {} is out of bounds of `{}`{}\", oob_index, s_trunc, ellipsis);\n    }\n\n    // 2. begin <= end\n    assert!(begin <= end, \"begin <= end ({} <= {}) when slicing `{}`{}\",\n            begin, end, s_trunc, ellipsis);\n\n    // 3. character boundary\n    let index = if !s.is_char_boundary(begin) { begin } else { end };\n    // find the character\n    let mut char_start = index;\n    while !s.is_char_boundary(char_start) {\n        char_start -= 1;\n    }\n    // `char_start` must be less than len and a char boundary\n    let ch = s[char_start..].chars().next().unwrap();\n    let char_range = char_start .. char_start + ch.len_utf8();\n    panic!(\"byte index {} is not a char boundary; it is inside {:?} (bytes {:?}) of `{}`{}\",\n           index, ch, char_range, s_trunc, ellipsis);\n}\n\n#[stable(feature = \"core\", since = \"1.6.0\")]\nimpl StrExt for str {\n    #[inline]\n    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n        pat.is_contained_in(self)\n    }\n\n    #[inline]\n    fn chars(&self) -> Chars {\n        Chars{iter: self.as_bytes().iter()}\n    }\n\n    #[inline]\n    fn bytes(&self) -> Bytes {\n        Bytes(self.as_bytes().iter().cloned())\n    }\n\n    #[inline]\n    fn char_indices(&self) -> CharIndices {\n        CharIndices { front_offset: 0, iter: self.chars() }\n    }\n\n    #[inline]\n    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n        Split(SplitInternal {\n            start: 0,\n            end: self.len(),\n            matcher: pat.into_searcher(self),\n            allow_trailing_empty: true,\n            finished: false,\n        })\n    }\n\n    #[inline]\n    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        RSplit(self.split(pat).0)\n    }\n\n    #[inline]\n    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n        SplitN(SplitNInternal {\n            iter: self.split(pat).0,\n            count: count,\n        })\n    }\n\n    #[inline]\n    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        RSplitN(self.splitn(count, pat).0)\n    }\n\n    #[inline]\n    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n        SplitTerminator(SplitInternal {\n            allow_trailing_empty: false,\n            ..self.split(pat).0\n        })\n    }\n\n    #[inline]\n    fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        RSplitTerminator(self.split_terminator(pat).0)\n    }\n\n    #[inline]\n    fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n        Matches(MatchesInternal(pat.into_searcher(self)))\n    }\n\n    #[inline]\n    fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        RMatches(self.matches(pat).0)\n    }\n\n    #[inline]\n    fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n        MatchIndices(MatchIndicesInternal(pat.into_searcher(self)))\n    }\n\n    #[inline]\n    fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        RMatchIndices(self.match_indices(pat).0)\n    }\n    #[inline]\n    fn lines(&self) -> Lines {\n        Lines(self.split_terminator('\\n').map(LinesAnyMap))\n    }\n\n    #[inline]\n    #[allow(deprecated)]\n    fn lines_any(&self) -> LinesAny {\n        LinesAny(self.lines())\n    }\n\n    #[inline]\n    fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n        i.get(self)\n    }\n\n    #[inline]\n    fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n        i.get_mut(self)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n        i.get_unchecked(self)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n        i.get_unchecked_mut(self)\n    }\n\n    #[inline]\n    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n        (begin..end).get_unchecked(self)\n    }\n\n    #[inline]\n    unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n        (begin..end).get_unchecked_mut(self)\n    }\n\n    #[inline]\n    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n        pat.is_prefix_of(self)\n    }\n\n    #[inline]\n    fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        pat.is_suffix_of(self)\n    }\n\n    #[inline]\n    fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n        where P::Searcher: DoubleEndedSearcher<'a>\n    {\n        let mut i = 0;\n        let mut j = 0;\n        let mut matcher = pat.into_searcher(self);\n        if let Some((a, b)) = matcher.next_reject() {\n            i = a;\n            j = b; // Remember earliest known match, correct it below if\n                   // last match is different\n        }\n        if let Some((_, b)) = matcher.next_reject_back() {\n            j = b;\n        }\n        unsafe {\n            // Searcher is known to return valid indices\n            self.slice_unchecked(i, j)\n        }\n    }\n\n    #[inline]\n    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n        let mut i = self.len();\n        let mut matcher = pat.into_searcher(self);\n        if let Some((a, _)) = matcher.next_reject() {\n            i = a;\n        }\n        unsafe {\n            // Searcher is known to return valid indices\n            self.slice_unchecked(i, self.len())\n        }\n    }\n\n    #[inline]\n    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        let mut j = 0;\n        let mut matcher = pat.into_searcher(self);\n        if let Some((_, b)) = matcher.next_reject_back() {\n            j = b;\n        }\n        unsafe {\n            // Searcher is known to return valid indices\n            self.slice_unchecked(0, j)\n        }\n    }\n\n    #[inline]\n    fn is_char_boundary(&self, index: usize) -> bool {\n        // 0 and len are always ok.\n        // Test for 0 explicitly so that it can optimize out the check\n        // easily and skip reading string data for that case.\n        if index == 0 || index == self.len() { return true; }\n        match self.as_bytes().get(index) {\n            None => false,\n            // This is bit magic equivalent to: b < 128 || b >= 192\n            Some(&b) => (b as i8) >= -0x40,\n        }\n    }\n\n    #[inline]\n    fn as_bytes(&self) -> &[u8] {\n        unsafe { mem::transmute(self) }\n    }\n\n    #[inline]\n    unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n        mem::transmute(self)\n    }\n\n    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n        pat.into_searcher(self).next_match().map(|(i, _)| i)\n    }\n\n    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        pat.into_searcher(self).next_match_back().map(|(i, _)| i)\n    }\n\n    fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n        self.find(pat)\n    }\n\n    #[inline]\n    fn split_at(&self, mid: usize) -> (&str, &str) {\n        // is_char_boundary checks that the index is in [0, .len()]\n        if self.is_char_boundary(mid) {\n            unsafe {\n                (self.slice_unchecked(0, mid),\n                 self.slice_unchecked(mid, self.len()))\n            }\n        } else {\n            slice_error_fail(self, 0, mid)\n        }\n    }\n\n    fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n        // is_char_boundary checks that the index is in [0, .len()]\n        if self.is_char_boundary(mid) {\n            let len = self.len();\n            let ptr = self.as_ptr() as *mut u8;\n            unsafe {\n                (from_raw_parts_mut(ptr, mid),\n                 from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n            }\n        } else {\n            slice_error_fail(self, 0, mid)\n        }\n    }\n\n    #[inline]\n    fn as_ptr(&self) -> *const u8 {\n        self as *const str as *const u8\n    }\n\n    #[inline]\n    fn len(&self) -> usize {\n        self.as_bytes().len()\n    }\n\n    #[inline]\n    fn is_empty(&self) -> bool { self.len() == 0 }\n\n    #[inline]\n    fn parse<'a, T>(&'a self) -> Result<T, T::Error> where T: TryFrom<&'a str> {\n        T::try_from(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<[u8]> for str {\n    #[inline]\n    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Default for &'a str {\n    /// Creates an empty str\n    fn default() -> &'a str { \"\" }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! The string Pattern API.\n//!\n//! For more details, see the traits `Pattern`, `Searcher`,\n//! `ReverseSearcher` and `DoubleEndedSearcher`.\n\n#![unstable(feature = \"pattern\",\n            reason = \"API not fully fleshed out and ready to be stabilized\",\n            issue = \"27721\")]\n\nuse cmp;\nuse fmt;\nuse usize;\n\n// Pattern\n\n/// A string pattern.\n///\n/// A `Pattern<'a>` expresses that the implementing type\n/// can be used as a string pattern for searching in a `&'a str`.\n///\n/// For example, both `'a'` and `\"aa\"` are patterns that\n/// would match at index `1` in the string `\"baaaab\"`.\n///\n/// The trait itself acts as a builder for an associated\n/// `Searcher` type, which does the actual work of finding\n/// occurrences of the pattern in a string.\npub trait Pattern<'a>: Sized {\n    /// Associated searcher for this pattern\n    type Searcher: Searcher<'a>;\n\n    /// Constructs the associated searcher from\n    /// `self` and the `haystack` to search in.\n    fn into_searcher(self, haystack: &'a str) -> Self::Searcher;\n\n    /// Checks whether the pattern matches anywhere in the haystack\n    #[inline]\n    fn is_contained_in(self, haystack: &'a str) -> bool {\n        self.into_searcher(haystack).next_match().is_some()\n    }\n\n    /// Checks whether the pattern matches at the front of the haystack\n    #[inline]\n    fn is_prefix_of(self, haystack: &'a str) -> bool {\n        match self.into_searcher(haystack).next() {\n            SearchStep::Match(0, _) => true,\n            _ => false,\n        }\n    }\n\n    /// Checks whether the pattern matches at the back of the haystack\n    #[inline]\n    fn is_suffix_of(self, haystack: &'a str) -> bool\n        where Self::Searcher: ReverseSearcher<'a>\n    {\n        match self.into_searcher(haystack).next_back() {\n            SearchStep::Match(_, j) if haystack.len() == j => true,\n            _ => false,\n        }\n    }\n}\n\n// Searcher\n\n/// Result of calling `Searcher::next()` or `ReverseSearcher::next_back()`.\n#[derive(Copy, Clone, Eq, PartialEq, Debug)]\npub enum SearchStep {\n    /// Expresses that a match of the pattern has been found at\n    /// `haystack[a..b]`.\n    Match(usize, usize),\n    /// Expresses that `haystack[a..b]` has been rejected as a possible match\n    /// of the pattern.\n    ///\n    /// Note that there might be more than one `Reject` between two `Match`es,\n    /// there is no requirement for them to be combined into one.\n    Reject(usize, usize),\n    /// Expresses that every byte of the haystack has been visted, ending\n    /// the iteration.\n    Done\n}\n\n/// A searcher for a string pattern.\n///\n/// This trait provides methods for searching for non-overlapping\n/// matches of a pattern starting from the front (left) of a string.\n///\n/// It will be implemented by associated `Searcher`\n/// types of the `Pattern` trait.\n///\n/// The trait is marked unsafe because the indices returned by the\n/// `next()` methods are required to lie on valid utf8 boundaries in\n/// the haystack. This enables consumers of this trait to\n/// slice the haystack without additional runtime checks.\npub unsafe trait Searcher<'a> {\n    /// Getter for the underlaying string to be searched in\n    ///\n    /// Will always return the same `&str`\n    fn haystack(&self) -> &'a str;\n\n    /// Performs the next search step starting from the front.\n    ///\n    /// - Returns `Match(a, b)` if `haystack[a..b]` matches the pattern.\n    /// - Returns `Reject(a, b)` if `haystack[a..b]` can not match the\n    ///   pattern, even partially.\n    /// - Returns `Done` if every byte of the haystack has been visited\n    ///\n    /// The stream of `Match` and `Reject` values up to a `Done`\n    /// will contain index ranges that are adjacent, non-overlapping,\n    /// covering the whole haystack, and laying on utf8 boundaries.\n    ///\n    /// A `Match` result needs to contain the whole matched pattern,\n    /// however `Reject` results may be split up into arbitrary\n    /// many adjacent fragments. Both ranges may have zero length.\n    ///\n    /// As an example, the pattern `\"aaa\"` and the haystack `\"cbaaaaab\"`\n    /// might produce the stream\n    /// `[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]`\n    fn next(&mut self) -> SearchStep;\n\n    /// Find the next `Match` result. See `next()`\n    #[inline]\n    fn next_match(&mut self) -> Option<(usize, usize)> {\n        loop {\n            match self.next() {\n                SearchStep::Match(a, b) => return Some((a, b)),\n                SearchStep::Done => return None,\n                _ => continue,\n            }\n        }\n    }\n\n    /// Find the next `Reject` result. See `next()`\n    #[inline]\n    fn next_reject(&mut self) -> Option<(usize, usize)> {\n        loop {\n            match self.next() {\n                SearchStep::Reject(a, b) => return Some((a, b)),\n                SearchStep::Done => return None,\n                _ => continue,\n            }\n        }\n    }\n}\n\n/// A reverse searcher for a string pattern.\n///\n/// This trait provides methods for searching for non-overlapping\n/// matches of a pattern starting from the back (right) of a string.\n///\n/// It will be implemented by associated `Searcher`\n/// types of the `Pattern` trait if the pattern supports searching\n/// for it from the back.\n///\n/// The index ranges returned by this trait are not required\n/// to exactly match those of the forward search in reverse.\n///\n/// For the reason why this trait is marked unsafe, see them\n/// parent trait `Searcher`.\npub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n    /// Performs the next search step starting from the back.\n    ///\n    /// - Returns `Match(a, b)` if `haystack[a..b]` matches the pattern.\n    /// - Returns `Reject(a, b)` if `haystack[a..b]` can not match the\n    ///   pattern, even partially.\n    /// - Returns `Done` if every byte of the haystack has been visited\n    ///\n    /// The stream of `Match` and `Reject` values up to a `Done`\n    /// will contain index ranges that are adjacent, non-overlapping,\n    /// covering the whole haystack, and laying on utf8 boundaries.\n    ///\n    /// A `Match` result needs to contain the whole matched pattern,\n    /// however `Reject` results may be split up into arbitrary\n    /// many adjacent fragments. Both ranges may have zero length.\n    ///\n    /// As an example, the pattern `\"aaa\"` and the haystack `\"cbaaaaab\"`\n    /// might produce the stream\n    /// `[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]`\n    fn next_back(&mut self) -> SearchStep;\n\n    /// Find the next `Match` result. See `next_back()`\n    #[inline]\n    fn next_match_back(&mut self) -> Option<(usize, usize)>{\n        loop {\n            match self.next_back() {\n                SearchStep::Match(a, b) => return Some((a, b)),\n                SearchStep::Done => return None,\n                _ => continue,\n            }\n        }\n    }\n\n    /// Find the next `Reject` result. See `next_back()`\n    #[inline]\n    fn next_reject_back(&mut self) -> Option<(usize, usize)>{\n        loop {\n            match self.next_back() {\n                SearchStep::Reject(a, b) => return Some((a, b)),\n                SearchStep::Done => return None,\n                _ => continue,\n            }\n        }\n    }\n}\n\n/// A marker trait to express that a `ReverseSearcher`\n/// can be used for a `DoubleEndedIterator` implementation.\n///\n/// For this, the impl of `Searcher` and `ReverseSearcher` need\n/// to follow these conditions:\n///\n/// - All results of `next()` need to be identical\n///   to the results of `next_back()` in reverse order.\n/// - `next()` and `next_back()` need to behave as\n///   the two ends of a range of values, that is they\n///   can not \"walk past each other\".\n///\n/// # Examples\n///\n/// `char::Searcher` is a `DoubleEndedSearcher` because searching for a\n/// `char` only requires looking at one at a time, which behaves the same\n/// from both ends.\n///\n/// `(&str)::Searcher` is not a `DoubleEndedSearcher` because\n/// the pattern `\"aa\"` in the haystack `\"aaa\"` matches as either\n/// `\"[aa]a\"` or `\"a[aa]\"`, depending from which side it is searched.\npub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}\n\n/////////////////////////////////////////////////////////////////////////////\n// Impl for a CharEq wrapper\n/////////////////////////////////////////////////////////////////////////////\n\n#[doc(hidden)]\ntrait CharEq {\n    fn matches(&mut self, c: char) -> bool;\n    fn only_ascii(&self) -> bool;\n}\n\nimpl CharEq for char {\n    #[inline]\n    fn matches(&mut self, c: char) -> bool { *self == c }\n\n    #[inline]\n    fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n}\n\nimpl<F> CharEq for F where F: FnMut(char) -> bool {\n    #[inline]\n    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n\n    #[inline]\n    fn only_ascii(&self) -> bool { false }\n}\n\nimpl<'a> CharEq for &'a [char] {\n    #[inline]\n    fn matches(&mut self, c: char) -> bool {\n        self.iter().any(|&m| { let mut m = m; m.matches(c) })\n    }\n\n    #[inline]\n    fn only_ascii(&self) -> bool {\n        self.iter().all(|m| m.only_ascii())\n    }\n}\n\nstruct CharEqPattern<C: CharEq>(C);\n\n#[derive(Clone, Debug)]\nstruct CharEqSearcher<'a, C: CharEq> {\n    char_eq: C,\n    haystack: &'a str,\n    char_indices: super::CharIndices<'a>,\n    #[allow(dead_code)]\n    ascii_only: bool,\n}\n\nimpl<'a, C: CharEq> Pattern<'a> for CharEqPattern<C> {\n    type Searcher = CharEqSearcher<'a, C>;\n\n    #[inline]\n    fn into_searcher(self, haystack: &'a str) -> CharEqSearcher<'a, C> {\n        CharEqSearcher {\n            ascii_only: self.0.only_ascii(),\n            haystack: haystack,\n            char_eq: self.0,\n            char_indices: haystack.char_indices(),\n        }\n    }\n}\n\nunsafe impl<'a, C: CharEq> Searcher<'a> for CharEqSearcher<'a, C> {\n    #[inline]\n    fn haystack(&self) -> &'a str {\n        self.haystack\n    }\n\n    #[inline]\n    fn next(&mut self) -> SearchStep {\n        let s = &mut self.char_indices;\n        // Compare lengths of the internal byte slice iterator\n        // to find length of current char\n        let pre_len = s.iter.iter.len();\n        if let Some((i, c)) = s.next() {\n            let len = s.iter.iter.len();\n            let char_len = pre_len - len;\n            if self.char_eq.matches(c) {\n                return SearchStep::Match(i, i + char_len);\n            } else {\n                return SearchStep::Reject(i, i + char_len);\n            }\n        }\n        SearchStep::Done\n    }\n}\n\nunsafe impl<'a, C: CharEq> ReverseSearcher<'a> for CharEqSearcher<'a, C> {\n    #[inline]\n    fn next_back(&mut self) -> SearchStep {\n        let s = &mut self.char_indices;\n        // Compare lengths of the internal byte slice iterator\n        // to find length of current char\n        let pre_len = s.iter.iter.len();\n        if let Some((i, c)) = s.next_back() {\n            let len = s.iter.iter.len();\n            let char_len = pre_len - len;\n            if self.char_eq.matches(c) {\n                return SearchStep::Match(i, i + char_len);\n            } else {\n                return SearchStep::Reject(i, i + char_len);\n            }\n        }\n        SearchStep::Done\n    }\n}\n\nimpl<'a, C: CharEq> DoubleEndedSearcher<'a> for CharEqSearcher<'a, C> {}\n\n/////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! pattern_methods {\n    ($t:ty, $pmap:expr, $smap:expr) => {\n        type Searcher = $t;\n\n        #[inline]\n        fn into_searcher(self, haystack: &'a str) -> $t {\n            ($smap)(($pmap)(self).into_searcher(haystack))\n        }\n\n        #[inline]\n        fn is_contained_in(self, haystack: &'a str) -> bool {\n            ($pmap)(self).is_contained_in(haystack)\n        }\n\n        #[inline]\n        fn is_prefix_of(self, haystack: &'a str) -> bool {\n            ($pmap)(self).is_prefix_of(haystack)\n        }\n\n        #[inline]\n        fn is_suffix_of(self, haystack: &'a str) -> bool\n            where $t: ReverseSearcher<'a>\n        {\n            ($pmap)(self).is_suffix_of(haystack)\n        }\n    }\n}\n\nmacro_rules! searcher_methods {\n    (forward) => {\n        #[inline]\n        fn haystack(&self) -> &'a str {\n            self.0.haystack()\n        }\n        #[inline]\n        fn next(&mut self) -> SearchStep {\n            self.0.next()\n        }\n        #[inline]\n        fn next_match(&mut self) -> Option<(usize, usize)> {\n            self.0.next_match()\n        }\n        #[inline]\n        fn next_reject(&mut self) -> Option<(usize, usize)> {\n            self.0.next_reject()\n        }\n    };\n    (reverse) => {\n        #[inline]\n        fn next_back(&mut self) -> SearchStep {\n            self.0.next_back()\n        }\n        #[inline]\n        fn next_match_back(&mut self) -> Option<(usize, usize)> {\n            self.0.next_match_back()\n        }\n        #[inline]\n        fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n            self.0.next_reject_back()\n        }\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Impl for char\n/////////////////////////////////////////////////////////////////////////////\n\n/// Associated type for `<char as Pattern<'a>>::Searcher`.\n#[derive(Clone, Debug)]\npub struct CharSearcher<'a>(<CharEqPattern<char> as Pattern<'a>>::Searcher);\n\nunsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n    searcher_methods!(forward);\n}\n\nunsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n    searcher_methods!(reverse);\n}\n\nimpl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n\n/// Searches for chars that are equal to a given char\nimpl<'a> Pattern<'a> for char {\n    type Searcher = CharSearcher<'a>;\n\n    #[inline]\n    fn into_searcher(self, haystack: &'a str) -> Self::Searcher {\n        CharSearcher(CharEqPattern(self).into_searcher(haystack))\n    }\n\n    #[inline]\n    fn is_contained_in(self, haystack: &'a str) -> bool {\n        if (self as u32) < 128 {\n            haystack.as_bytes().contains(&(self as u8))\n        } else {\n            let mut buffer = [0u8; 4];\n            self.encode_utf8(&mut buffer).is_contained_in(haystack)\n        }\n    }\n\n    #[inline]\n    fn is_prefix_of(self, haystack: &'a str) -> bool {\n        CharEqPattern(self).is_prefix_of(haystack)\n    }\n\n    #[inline]\n    fn is_suffix_of(self, haystack: &'a str) -> bool where Self::Searcher: ReverseSearcher<'a>\n    {\n        CharEqPattern(self).is_suffix_of(haystack)\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Impl for &[char]\n/////////////////////////////////////////////////////////////////////////////\n\n// Todo: Change / Remove due to ambiguity in meaning.\n\n/// Associated type for `<&[char] as Pattern<'a>>::Searcher`.\n#[derive(Clone, Debug)]\npub struct CharSliceSearcher<'a, 'b>(<CharEqPattern<&'b [char]> as Pattern<'a>>::Searcher);\n\nunsafe impl<'a, 'b> Searcher<'a> for CharSliceSearcher<'a, 'b> {\n    searcher_methods!(forward);\n}\n\nunsafe impl<'a, 'b> ReverseSearcher<'a> for CharSliceSearcher<'a, 'b> {\n    searcher_methods!(reverse);\n}\n\nimpl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}\n\n/// Searches for chars that are equal to any of the chars in the array\nimpl<'a, 'b> Pattern<'a> for &'b [char] {\n    pattern_methods!(CharSliceSearcher<'a, 'b>, CharEqPattern, CharSliceSearcher);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Impl for F: FnMut(char) -> bool\n/////////////////////////////////////////////////////////////////////////////\n\n/// Associated type for `<F as Pattern<'a>>::Searcher`.\n#[derive(Clone)]\npub struct CharPredicateSearcher<'a, F>(<CharEqPattern<F> as Pattern<'a>>::Searcher)\n    where F: FnMut(char) -> bool;\n\nimpl<'a, F> fmt::Debug for CharPredicateSearcher<'a, F>\n    where F: FnMut(char) -> bool\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"CharPredicateSearcher\")\n            .field(\"haystack\", &self.0.haystack)\n            .field(\"char_indices\", &self.0.char_indices)\n            .field(\"ascii_only\", &self.0.ascii_only)\n            .finish()\n    }\n}\nunsafe impl<'a, F> Searcher<'a> for CharPredicateSearcher<'a, F>\n    where F: FnMut(char) -> bool\n{\n    searcher_methods!(forward);\n}\n\nunsafe impl<'a, F> ReverseSearcher<'a> for CharPredicateSearcher<'a, F>\n    where F: FnMut(char) -> bool\n{\n    searcher_methods!(reverse);\n}\n\nimpl<'a, F> DoubleEndedSearcher<'a> for CharPredicateSearcher<'a, F>\n    where F: FnMut(char) -> bool {}\n\n/// Searches for chars that match the given predicate\nimpl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n    pattern_methods!(CharPredicateSearcher<'a, F>, CharEqPattern, CharPredicateSearcher);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Impl for &&str\n/////////////////////////////////////////////////////////////////////////////\n\n/// Delegates to the `&str` impl.\nimpl<'a, 'b, 'c> Pattern<'a> for &'c &'b str {\n    pattern_methods!(StrSearcher<'a, 'b>, |&s| s, |s| s);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Impl for &str\n/////////////////////////////////////////////////////////////////////////////\n\n/// Non-allocating substring search.\n///\n/// Will handle the pattern `\"\"` as returning empty matches at each character\n/// boundary.\nimpl<'a, 'b> Pattern<'a> for &'b str {\n    type Searcher = StrSearcher<'a, 'b>;\n\n    #[inline]\n    fn into_searcher(self, haystack: &'a str) -> StrSearcher<'a, 'b> {\n        StrSearcher::new(haystack, self)\n    }\n\n    /// Checks whether the pattern matches at the front of the haystack\n    #[inline]\n    fn is_prefix_of(self, haystack: &'a str) -> bool {\n        haystack.is_char_boundary(self.len()) &&\n            self == &haystack[..self.len()]\n    }\n\n    /// Checks whether the pattern matches at the back of the haystack\n    #[inline]\n    fn is_suffix_of(self, haystack: &'a str) -> bool {\n        self.len() <= haystack.len() &&\n            haystack.is_char_boundary(haystack.len() - self.len()) &&\n            self == &haystack[haystack.len() - self.len()..]\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Two Way substring searcher\n/////////////////////////////////////////////////////////////////////////////\n\n#[derive(Clone, Debug)]\n/// Associated type for `<&str as Pattern<'a>>::Searcher`.\npub struct StrSearcher<'a, 'b> {\n    haystack: &'a str,\n    needle: &'b str,\n\n    searcher: StrSearcherImpl,\n}\n\n#[derive(Clone, Debug)]\nenum StrSearcherImpl {\n    Empty(EmptyNeedle),\n    TwoWay(TwoWaySearcher),\n}\n\n#[derive(Clone, Debug)]\nstruct EmptyNeedle {\n    position: usize,\n    end: usize,\n    is_match_fw: bool,\n    is_match_bw: bool,\n}\n\nimpl<'a, 'b> StrSearcher<'a, 'b> {\n    fn new(haystack: &'a str, needle: &'b str) -> StrSearcher<'a, 'b> {\n        if needle.is_empty() {\n            StrSearcher {\n                haystack: haystack,\n                needle: needle,\n                searcher: StrSearcherImpl::Empty(EmptyNeedle {\n                    position: 0,\n                    end: haystack.len(),\n                    is_match_fw: true,\n                    is_match_bw: true,\n                }),\n            }\n        } else {\n            StrSearcher {\n                haystack: haystack,\n                needle: needle,\n                searcher: StrSearcherImpl::TwoWay(\n                    TwoWaySearcher::new(needle.as_bytes(), haystack.len())\n                ),\n            }\n        }\n    }\n}\n\nunsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {\n    #[inline]\n    fn haystack(&self) -> &'a str {\n        self.haystack\n    }\n\n    #[inline]\n    fn next(&mut self) -> SearchStep {\n        match self.searcher {\n            StrSearcherImpl::Empty(ref mut searcher) => {\n                // empty needle rejects every char and matches every empty string between them\n                let is_match = searcher.is_match_fw;\n                searcher.is_match_fw = !searcher.is_match_fw;\n                let pos = searcher.position;\n                match self.haystack[pos..].chars().next() {\n                    _ if is_match => SearchStep::Match(pos, pos),\n                    None => SearchStep::Done,\n                    Some(ch) => {\n                        searcher.position += ch.len_utf8();\n                        SearchStep::Reject(pos, searcher.position)\n                    }\n                }\n            }\n            StrSearcherImpl::TwoWay(ref mut searcher) => {\n                // TwoWaySearcher produces valid *Match* indices that split at char boundaries\n                // as long as it does correct matching and that haystack and needle are\n                // valid UTF-8\n                // *Rejects* from the algorithm can fall on any indices, but we will walk them\n                // manually to the next character boundary, so that they are utf-8 safe.\n                if searcher.position == self.haystack.len() {\n                    return SearchStep::Done;\n                }\n                let is_long = searcher.memory == usize::MAX;\n                match searcher.next::<RejectAndMatch>(self.haystack.as_bytes(),\n                                                      self.needle.as_bytes(),\n                                                      is_long)\n                {\n                    SearchStep::Reject(a, mut b) => {\n                        // skip to next char boundary\n                        while !self.haystack.is_char_boundary(b) {\n                            b += 1;\n                        }\n                        searcher.position = cmp::max(b, searcher.position);\n                        SearchStep::Reject(a, b)\n                    }\n                    otherwise => otherwise,\n                }\n            }\n        }\n    }\n\n    #[inline(always)]\n    fn next_match(&mut self) -> Option<(usize, usize)> {\n        match self.searcher {\n            StrSearcherImpl::Empty(..) => {\n                loop {\n                    match self.next() {\n                        SearchStep::Match(a, b) => return Some((a, b)),\n                        SearchStep::Done => return None,\n                        SearchStep::Reject(..) => { }\n                    }\n                }\n            }\n            StrSearcherImpl::TwoWay(ref mut searcher) => {\n                let is_long = searcher.memory == usize::MAX;\n                // write out `true` and `false` cases to encourage the compiler\n                // to specialize the two cases separately.\n                if is_long {\n                    searcher.next::<MatchOnly>(self.haystack.as_bytes(),\n                                               self.needle.as_bytes(),\n                                               true)\n                } else {\n                    searcher.next::<MatchOnly>(self.haystack.as_bytes(),\n                                               self.needle.as_bytes(),\n                                               false)\n                }\n            }\n        }\n    }\n}\n\nunsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n    #[inline]\n    fn next_back(&mut self) -> SearchStep {\n        match self.searcher {\n            StrSearcherImpl::Empty(ref mut searcher) => {\n                let is_match = searcher.is_match_bw;\n                searcher.is_match_bw = !searcher.is_match_bw;\n                let end = searcher.end;\n                match self.haystack[..end].chars().next_back() {\n                    _ if is_match => SearchStep::Match(end, end),\n                    None => SearchStep::Done,\n                    Some(ch) => {\n                        searcher.end -= ch.len_utf8();\n                        SearchStep::Reject(searcher.end, end)\n                    }\n                }\n            }\n            StrSearcherImpl::TwoWay(ref mut searcher) => {\n                if searcher.end == 0 {\n                    return SearchStep::Done;\n                }\n                let is_long = searcher.memory == usize::MAX;\n                match searcher.next_back::<RejectAndMatch>(self.haystack.as_bytes(),\n                                                           self.needle.as_bytes(),\n                                                           is_long)\n                {\n                    SearchStep::Reject(mut a, b) => {\n                        // skip to next char boundary\n                        while !self.haystack.is_char_boundary(a) {\n                            a -= 1;\n                        }\n                        searcher.end = cmp::min(a, searcher.end);\n                        SearchStep::Reject(a, b)\n                    }\n                    otherwise => otherwise,\n                }\n            }\n        }\n    }\n\n    #[inline]\n    fn next_match_back(&mut self) -> Option<(usize, usize)> {\n        match self.searcher {\n            StrSearcherImpl::Empty(..) => {\n                loop {\n                    match self.next_back() {\n                        SearchStep::Match(a, b) => return Some((a, b)),\n                        SearchStep::Done => return None,\n                        SearchStep::Reject(..) => { }\n                    }\n                }\n            }\n            StrSearcherImpl::TwoWay(ref mut searcher) => {\n                let is_long = searcher.memory == usize::MAX;\n                // write out `true` and `false`, like `next_match`\n                if is_long {\n                    searcher.next_back::<MatchOnly>(self.haystack.as_bytes(),\n                                                    self.needle.as_bytes(),\n                                                    true)\n                } else {\n                    searcher.next_back::<MatchOnly>(self.haystack.as_bytes(),\n                                                    self.needle.as_bytes(),\n                                                    false)\n                }\n            }\n        }\n    }\n}\n\n/// The internal state of the two-way substring search algorithm.\n#[derive(Clone, Debug)]\nstruct TwoWaySearcher {\n    // constants\n    /// critical factorization index\n    crit_pos: usize,\n    /// critical factorization index for reversed needle\n    crit_pos_back: usize,\n    period: usize,\n    /// `byteset` is an extension (not part of the two way algorithm);\n    /// it's a 64-bit \"fingerprint\" where each set bit `j` corresponds\n    /// to a (byte & 63) == j present in the needle.\n    byteset: u64,\n\n    // variables\n    position: usize,\n    end: usize,\n    /// index into needle before which we have already matched\n    memory: usize,\n    /// index into needle after which we have already matched\n    memory_back: usize,\n}\n\n/*\n    This is the Two-Way search algorithm, which was introduced in the paper:\n    Crochemore, M., Perrin, D., 1991, Two-way string-matching, Journal of the ACM 38(3):651-675.\n\n    Here's some background information.\n\n    A *word* is a string of symbols. The *length* of a word should be a familiar\n    notion, and here we denote it for any word x by |x|.\n    (We also allow for the possibility of the *empty word*, a word of length zero).\n\n    If x is any non-empty word, then an integer p with 0 < p <= |x| is said to be a\n    *period* for x iff for all i with 0 <= i <= |x| - p - 1, we have x[i] == x[i+p].\n    For example, both 1 and 2 are periods for the string \"aa\". As another example,\n    the only period of the string \"abcd\" is 4.\n\n    We denote by period(x) the *smallest* period of x (provided that x is non-empty).\n    This is always well-defined since every non-empty word x has at least one period,\n    |x|. We sometimes call this *the period* of x.\n\n    If u, v and x are words such that x = uv, where uv is the concatenation of u and\n    v, then we say that (u, v) is a *factorization* of x.\n\n    Let (u, v) be a factorization for a word x. Then if w is a non-empty word such\n    that both of the following hold\n\n      - either w is a suffix of u or u is a suffix of w\n      - either w is a prefix of v or v is a prefix of w\n\n    then w is said to be a *repetition* for the factorization (u, v).\n\n    Just to unpack this, there are four possibilities here. Let w = \"abc\". Then we\n    might have:\n\n      - w is a suffix of u and w is a prefix of v. ex: (\"lolabc\", \"abcde\")\n      - w is a suffix of u and v is a prefix of w. ex: (\"lolabc\", \"ab\")\n      - u is a suffix of w and w is a prefix of v. ex: (\"bc\", \"abchi\")\n      - u is a suffix of w and v is a prefix of w. ex: (\"bc\", \"a\")\n\n    Note that the word vu is a repetition for any factorization (u,v) of x = uv,\n    so every factorization has at least one repetition.\n\n    If x is a string and (u, v) is a factorization for x, then a *local period* for\n    (u, v) is an integer r such that there is some word w such that |w| = r and w is\n    a repetition for (u, v).\n\n    We denote by local_period(u, v) the smallest local period of (u, v). We sometimes\n    call this *the local period* of (u, v). Provided that x = uv is non-empty, this\n    is well-defined (because each non-empty word has at least one factorization, as\n    noted above).\n\n    It can be proven that the following is an equivalent definition of a local period\n    for a factorization (u, v): any positive integer r such that x[i] == x[i+r] for\n    all i such that |u| - r <= i <= |u| - 1 and such that both x[i] and x[i+r] are\n    defined. (i.e. i > 0 and i + r < |x|).\n\n    Using the above reformulation, it is easy to prove that\n\n        1 <= local_period(u, v) <= period(uv)\n\n    A factorization (u, v) of x such that local_period(u,v) = period(x) is called a\n    *critical factorization*.\n\n    The algorithm hinges on the following theorem, which is stated without proof:\n\n    **Critical Factorization Theorem** Any word x has at least one critical\n    factorization (u, v) such that |u| < period(x).\n\n    The purpose of maximal_suffix is to find such a critical factorization.\n\n    If the period is short, compute another factorization x = u' v' to use\n    for reverse search, chosen instead so that |v'| < period(x).\n\n*/\nimpl TwoWaySearcher {\n    fn new(needle: &[u8], end: usize) -> TwoWaySearcher {\n        let (crit_pos_false, period_false) = TwoWaySearcher::maximal_suffix(needle, false);\n        let (crit_pos_true, period_true) = TwoWaySearcher::maximal_suffix(needle, true);\n\n        let (crit_pos, period) =\n            if crit_pos_false > crit_pos_true {\n                (crit_pos_false, period_false)\n            } else {\n                (crit_pos_true, period_true)\n            };\n\n        // A particularly readable explanation of what's going on here can be found\n        // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n        // see the code for \"Algorithm CP\" on p. 323.\n        //\n        // What's going on is we have some critical factorization (u, v) of the\n        // needle, and we want to determine whether u is a suffix of\n        // &v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n        // \"Algorithm CP2\", which is optimized for when the period of the needle\n        // is large.\n        if &needle[..crit_pos] == &needle[period.. period + crit_pos] {\n            // short period case -- the period is exact\n            // compute a separate critical factorization for the reversed needle\n            // x = u' v' where |v'| < period(x).\n            //\n            // This is sped up by the period being known already.\n            // Note that a case like x = \"acba\" may be factored exactly forwards\n            // (crit_pos = 1, period = 3) while being factored with approximate\n            // period in reverse (crit_pos = 2, period = 2). We use the given\n            // reverse factorization but keep the exact period.\n            let crit_pos_back = needle.len() - cmp::max(\n                TwoWaySearcher::reverse_maximal_suffix(needle, period, false),\n                TwoWaySearcher::reverse_maximal_suffix(needle, period, true));\n\n            TwoWaySearcher {\n                crit_pos: crit_pos,\n                crit_pos_back: crit_pos_back,\n                period: period,\n                byteset: Self::byteset_create(&needle[..period]),\n\n                position: 0,\n                end: end,\n                memory: 0,\n                memory_back: needle.len(),\n            }\n        } else {\n            // long period case -- we have an approximation to the actual period,\n            // and don't use memorization.\n            //\n            // Approximate the period by lower bound max(|u|, |v|) + 1.\n            // The critical factorization is efficient to use for both forward and\n            // reverse search.\n\n            TwoWaySearcher {\n                crit_pos: crit_pos,\n                crit_pos_back: crit_pos,\n                period: cmp::max(crit_pos, needle.len() - crit_pos) + 1,\n                byteset: Self::byteset_create(needle),\n\n                position: 0,\n                end: end,\n                memory: usize::MAX, // Dummy value to signify that the period is long\n                memory_back: usize::MAX,\n            }\n        }\n    }\n\n    #[inline]\n    fn byteset_create(bytes: &[u8]) -> u64 {\n        bytes.iter().fold(0, |a, &b| (1 << (b & 0x3f)) | a)\n    }\n\n    #[inline(always)]\n    fn byteset_contains(&self, byte: u8) -> bool {\n        (self.byteset >> ((byte & 0x3f) as usize)) & 1 != 0\n    }\n\n    // One of the main ideas of Two-Way is that we factorize the needle into\n    // two halves, (u, v), and begin trying to find v in the haystack by scanning\n    // left to right. If v matches, we try to match u by scanning right to left.\n    // How far we can jump when we encounter a mismatch is all based on the fact\n    // that (u, v) is a critical factorization for the needle.\n    #[inline(always)]\n    fn next<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n        -> S::Output\n        where S: TwoWayStrategy\n    {\n        // `next()` uses `self.position` as its cursor\n        let old_pos = self.position;\n        let needle_last = needle.len() - 1;\n        'search: loop {\n            // Check that we have room to search in\n            // position + needle_last can not overflow if we assume slices\n            // are bounded by isize's range.\n            let tail_byte = match haystack.get(self.position + needle_last) {\n                Some(&b) => b,\n                None => {\n                    self.position = haystack.len();\n                    return S::rejecting(old_pos, self.position);\n                }\n            };\n\n            if S::use_early_reject() && old_pos != self.position {\n                return S::rejecting(old_pos, self.position);\n            }\n\n            // Quickly skip by large portions unrelated to our substring\n            if !self.byteset_contains(tail_byte) {\n                self.position += needle.len();\n                if !long_period {\n                    self.memory = 0;\n                }\n                continue 'search;\n            }\n\n            // See if the right part of the needle matches\n            let start = if long_period { self.crit_pos }\n                        else { cmp::max(self.crit_pos, self.memory) };\n            for i in start..needle.len() {\n                if needle[i] != haystack[self.position + i] {\n                    self.position += i - self.crit_pos + 1;\n                    if !long_period {\n                        self.memory = 0;\n                    }\n                    continue 'search;\n                }\n            }\n\n            // See if the left part of the needle matches\n            let start = if long_period { 0 } else { self.memory };\n            for i in (start..self.crit_pos).rev() {\n                if needle[i] != haystack[self.position + i] {\n                    self.position += self.period;\n                    if !long_period {\n                        self.memory = needle.len() - self.period;\n                    }\n                    continue 'search;\n                }\n            }\n\n            // We have found a match!\n            let match_pos = self.position;\n\n            // Note: add self.period instead of needle.len() to have overlapping matches\n            self.position += needle.len();\n            if !long_period {\n                self.memory = 0; // set to needle.len() - self.period for overlapping matches\n            }\n\n            return S::matching(match_pos, match_pos + needle.len());\n        }\n    }\n\n    // Follows the ideas in `next()`.\n    //\n    // The definitions are symmetrical, with period(x) = period(reverse(x))\n    // and local_period(u, v) = local_period(reverse(v), reverse(u)), so if (u, v)\n    // is a critical factorization, so is (reverse(v), reverse(u)).\n    //\n    // For the reverse case we have computed a critical factorization x = u' v'\n    // (field `crit_pos_back`). We need |u| < period(x) for the forward case and\n    // thus |v'| < period(x) for the reverse.\n    //\n    // To search in reverse through the haystack, we search forward through\n    // a reversed haystack with a reversed needle, matching first u' and then v'.\n    #[inline]\n    fn next_back<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n        -> S::Output\n        where S: TwoWayStrategy\n    {\n        // `next_back()` uses `self.end` as its cursor -- so that `next()` and `next_back()`\n        // are independent.\n        let old_end = self.end;\n        'search: loop {\n            // Check that we have room to search in\n            // end - needle.len() will wrap around when there is no more room,\n            // but due to slice length limits it can never wrap all the way back\n            // into the length of haystack.\n            let front_byte = match haystack.get(self.end.wrapping_sub(needle.len())) {\n                Some(&b) => b,\n                None => {\n                    self.end = 0;\n                    return S::rejecting(0, old_end);\n                }\n            };\n\n            if S::use_early_reject() && old_end != self.end {\n                return S::rejecting(self.end, old_end);\n            }\n\n            // Quickly skip by large portions unrelated to our substring\n            if !self.byteset_contains(front_byte) {\n                self.end -= needle.len();\n                if !long_period {\n                    self.memory_back = needle.len();\n                }\n                continue 'search;\n            }\n\n            // See if the left part of the needle matches\n            let crit = if long_period { self.crit_pos_back }\n                       else { cmp::min(self.crit_pos_back, self.memory_back) };\n            for i in (0..crit).rev() {\n                if needle[i] != haystack[self.end - needle.len() + i] {\n                    self.end -= self.crit_pos_back - i;\n                    if !long_period {\n                        self.memory_back = needle.len();\n                    }\n                    continue 'search;\n                }\n            }\n\n            // See if the right part of the needle matches\n            let needle_end = if long_period { needle.len() }\n                             else { self.memory_back };\n            for i in self.crit_pos_back..needle_end {\n                if needle[i] != haystack[self.end - needle.len() + i] {\n                    self.end -= self.period;\n                    if !long_period {\n                        self.memory_back = self.period;\n                    }\n                    continue 'search;\n                }\n            }\n\n            // We have found a match!\n            let match_pos = self.end - needle.len();\n            // Note: sub self.period instead of needle.len() to have overlapping matches\n            self.end -= needle.len();\n            if !long_period {\n                self.memory_back = needle.len();\n            }\n\n            return S::matching(match_pos, match_pos + needle.len());\n        }\n    }\n\n    // Compute the maximal suffix of `arr`.\n    //\n    // The maximal suffix is a possible critical factorization (u, v) of `arr`.\n    //\n    // Returns (`i`, `p`) where `i` is the starting index of v and `p` is the\n    // period of v.\n    //\n    // `order_greater` determines if lexical order is `<` or `>`. Both\n    // orders must be computed -- the ordering with the largest `i` gives\n    // a critical factorization.\n    //\n    // For long period cases, the resulting period is not exact (it is too short).\n    #[inline]\n    fn maximal_suffix(arr: &[u8], order_greater: bool) -> (usize, usize) {\n        let mut left = 0; // Corresponds to i in the paper\n        let mut right = 1; // Corresponds to j in the paper\n        let mut offset = 0; // Corresponds to k in the paper, but starting at 0\n                            // to match 0-based indexing.\n        let mut period = 1; // Corresponds to p in the paper\n\n        while let Some(&a) = arr.get(right + offset) {\n            // `left` will be inbounds when `right` is.\n            let b = arr[left + offset];\n            if (a < b && !order_greater) || (a > b && order_greater) {\n                // Suffix is smaller, period is entire prefix so far.\n                right += offset + 1;\n                offset = 0;\n                period = right - left;\n            } else if a == b {\n                // Advance through repetition of the current period.\n                if offset + 1 == period {\n                    right += offset + 1;\n                    offset = 0;\n                } else {\n                    offset += 1;\n                }\n            } else {\n                // Suffix is larger, start over from current location.\n                left = right;\n                right += 1;\n                offset = 0;\n                period = 1;\n            }\n        }\n        (left, period)\n    }\n\n    // Compute the maximal suffix of the reverse of `arr`.\n    //\n    // The maximal suffix is a possible critical factorization (u', v') of `arr`.\n    //\n    // Returns `i` where `i` is the starting index of v', from the back;\n    // returns immedately when a period of `known_period` is reached.\n    //\n    // `order_greater` determines if lexical order is `<` or `>`. Both\n    // orders must be computed -- the ordering with the largest `i` gives\n    // a critical factorization.\n    //\n    // For long period cases, the resulting period is not exact (it is too short).\n    fn reverse_maximal_suffix(arr: &[u8], known_period: usize,\n                              order_greater: bool) -> usize\n    {\n        let mut left = 0; // Corresponds to i in the paper\n        let mut right = 1; // Corresponds to j in the paper\n        let mut offset = 0; // Corresponds to k in the paper, but starting at 0\n                            // to match 0-based indexing.\n        let mut period = 1; // Corresponds to p in the paper\n        let n = arr.len();\n\n        while right + offset < n {\n            let a = arr[n - (1 + right + offset)];\n            let b = arr[n - (1 + left + offset)];\n            if (a < b && !order_greater) || (a > b && order_greater) {\n                // Suffix is smaller, period is entire prefix so far.\n                right += offset + 1;\n                offset = 0;\n                period = right - left;\n            } else if a == b {\n                // Advance through repetition of the current period.\n                if offset + 1 == period {\n                    right += offset + 1;\n                    offset = 0;\n                } else {\n                    offset += 1;\n                }\n            } else {\n                // Suffix is larger, start over from current location.\n                left = right;\n                right += 1;\n                offset = 0;\n                period = 1;\n            }\n            if period == known_period {\n                break;\n            }\n        }\n        debug_assert!(period <= known_period);\n        left\n    }\n}\n\n// TwoWayStrategy allows the algorithm to either skip non-matches as quickly\n// as possible, or to work in a mode where it emits Rejects relatively quickly.\ntrait TwoWayStrategy {\n    type Output;\n    fn use_early_reject() -> bool;\n    fn rejecting(a: usize, b: usize) -> Self::Output;\n    fn matching(a: usize, b: usize) -> Self::Output;\n}\n\n/// Skip to match intervals as quickly as possible\nenum MatchOnly { }\n\nimpl TwoWayStrategy for MatchOnly {\n    type Output = Option<(usize, usize)>;\n\n    #[inline]\n    fn use_early_reject() -> bool { false }\n    #[inline]\n    fn rejecting(_a: usize, _b: usize) -> Self::Output { None }\n    #[inline]\n    fn matching(a: usize, b: usize) -> Self::Output { Some((a, b)) }\n}\n\n/// Emit Rejects regularly\nenum RejectAndMatch { }\n\nimpl TwoWayStrategy for RejectAndMatch {\n    type Output = SearchStep;\n\n    #[inline]\n    fn use_early_reject() -> bool { true }\n    #[inline]\n    fn rejecting(a: usize, b: usize) -> Self::Output { SearchStep::Reject(a, b) }\n    #[inline]\n    fn matching(a: usize, b: usize) -> Self::Output { SearchStep::Match(a, b) }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A character type.\n//!\n//! The `char` type represents a single character. More specifically, since\n//! 'character' isn't a well-defined concept in Unicode, `char` is a '[Unicode\n//! scalar value]', which is similar to, but not the same as, a '[Unicode code\n//! point]'.\n//!\n//! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n//! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n//!\n//! This module exists for technical reasons, the primary documentation for\n//! `char` is directly on [the `char` primitive type](../../std/primitive.char.html)\n//! itself.\n//!\n//! This module is the home of the iterator implementations for the iterators\n//! implemented on `char`, as well as some useful constants and conversion\n//! functions that convert various types to `char`.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::char::CharExt as C;\nuse core::iter::FusedIterator;\nuse core::fmt::{self, Write};\nuse tables::{conversions, derived_property, general_category, property};\n\n// stable reexports\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::char::{MAX, from_digit, from_u32, from_u32_unchecked};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::char::{EscapeDebug, EscapeDefault, EscapeUnicode};\n#[stable(feature = \"char_from_str\", since = \"1.19.0\")]\npub use core::char::ParseCharError;\n\n// unstable reexports\n#[unstable(feature = \"try_from\", issue = \"33417\")]\npub use core::char::CharTryFromError;\n#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\npub use core::char::{DecodeUtf8, decode_utf8};\n#[unstable(feature = \"unicode\", issue = \"27783\")]\npub use tables::UNICODE_VERSION;\n\n/// Returns an iterator that yields the lowercase equivalent of a `char`.\n///\n/// This `struct` is created by the [`to_lowercase`] method on [`char`]. See\n/// its documentation for more.\n///\n/// [`to_lowercase`]: ../../std/primitive.char.html#method.to_lowercase\n/// [`char`]: ../../std/primitive.char.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ToLowercase(CaseMappingIter);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for ToLowercase {\n    type Item = char;\n    fn next(&mut self) -> Option<char> {\n        self.0.next()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl FusedIterator for ToLowercase {}\n\n/// Returns an iterator that yields the uppercase equivalent of a `char`.\n///\n/// This `struct` is created by the [`to_uppercase`] method on [`char`]. See\n/// its documentation for more.\n///\n/// [`to_uppercase`]: ../../std/primitive.char.html#method.to_uppercase\n/// [`char`]: ../../std/primitive.char.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ToUppercase(CaseMappingIter);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for ToUppercase {\n    type Item = char;\n    fn next(&mut self) -> Option<char> {\n        self.0.next()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl FusedIterator for ToUppercase {}\n\nenum CaseMappingIter {\n    Three(char, char, char),\n    Two(char, char),\n    One(char),\n    Zero,\n}\n\nimpl CaseMappingIter {\n    fn new(chars: [char; 3]) -> CaseMappingIter {\n        if chars[2] == '\\0' {\n            if chars[1] == '\\0' {\n                CaseMappingIter::One(chars[0])  // Including if chars[0] == '\\0'\n            } else {\n                CaseMappingIter::Two(chars[0], chars[1])\n            }\n        } else {\n            CaseMappingIter::Three(chars[0], chars[1], chars[2])\n        }\n    }\n}\n\nimpl Iterator for CaseMappingIter {\n    type Item = char;\n    fn next(&mut self) -> Option<char> {\n        match *self {\n            CaseMappingIter::Three(a, b, c) => {\n                *self = CaseMappingIter::Two(b, c);\n                Some(a)\n            }\n            CaseMappingIter::Two(b, c) => {\n                *self = CaseMappingIter::One(c);\n                Some(b)\n            }\n            CaseMappingIter::One(c) => {\n                *self = CaseMappingIter::Zero;\n                Some(c)\n            }\n            CaseMappingIter::Zero => None,\n        }\n    }\n}\n\nimpl fmt::Display for CaseMappingIter {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            CaseMappingIter::Three(a, b, c) => {\n                f.write_char(a)?;\n                f.write_char(b)?;\n                f.write_char(c)\n            }\n            CaseMappingIter::Two(b, c) => {\n                f.write_char(b)?;\n                f.write_char(c)\n            }\n            CaseMappingIter::One(c) => {\n                f.write_char(c)\n            }\n            CaseMappingIter::Zero => Ok(()),\n        }\n    }\n}\n\n#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\nimpl fmt::Display for ToLowercase {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&self.0, f)\n    }\n}\n\n#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\nimpl fmt::Display for ToUppercase {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&self.0, f)\n    }\n}\n\n#[lang = \"char\"]\nimpl char {\n    /// Checks if a `char` is a digit in the given radix.\n    ///\n    /// A 'radix' here is sometimes also called a 'base'. A radix of two\n    /// indicates a binary number, a radix of ten, decimal, and a radix of\n    /// sixteen, hexadecimal, to give some common values. Arbitrary\n    /// radices are supported.\n    ///\n    /// Compared to `is_numeric()`, this function only recognizes the characters\n    /// `0-9`, `a-z` and `A-Z`.\n    ///\n    /// 'Digit' is defined to be only the following characters:\n    ///\n    /// * `0-9`\n    /// * `a-z`\n    /// * `A-Z`\n    ///\n    /// For a more comprehensive understanding of 'digit', see [`is_numeric`][is_numeric].\n    ///\n    /// [is_numeric]: #method.is_numeric\n    ///\n    /// # Panics\n    ///\n    /// Panics if given a radix larger than 36.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!('1'.is_digit(10));\n    /// assert!('f'.is_digit(16));\n    /// assert!(!'f'.is_digit(10));\n    /// ```\n    ///\n    /// Passing a large radix, causing a panic:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let result = thread::spawn(|| {\n    ///     // this panics\n    ///     '1'.is_digit(37);\n    /// }).join();\n    ///\n    /// assert!(result.is_err());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_digit(self, radix: u32) -> bool {\n        C::is_digit(self, radix)\n    }\n\n    /// Converts a `char` to a digit in the given radix.\n    ///\n    /// A 'radix' here is sometimes also called a 'base'. A radix of two\n    /// indicates a binary number, a radix of ten, decimal, and a radix of\n    /// sixteen, hexadecimal, to give some common values. Arbitrary\n    /// radices are supported.\n    ///\n    /// 'Digit' is defined to be only the following characters:\n    ///\n    /// * `0-9`\n    /// * `a-z`\n    /// * `A-Z`\n    ///\n    /// # Errors\n    ///\n    /// Returns `None` if the `char` does not refer to a digit in the given radix.\n    ///\n    /// # Panics\n    ///\n    /// Panics if given a radix larger than 36.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert_eq!('1'.to_digit(10), Some(1));\n    /// assert_eq!('f'.to_digit(16), Some(15));\n    /// ```\n    ///\n    /// Passing a non-digit results in failure:\n    ///\n    /// ```\n    /// assert_eq!('f'.to_digit(10), None);\n    /// assert_eq!('z'.to_digit(16), None);\n    /// ```\n    ///\n    /// Passing a large radix, causing a panic:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let result = thread::spawn(|| {\n    ///     '1'.to_digit(37);\n    /// }).join();\n    ///\n    /// assert!(result.is_err());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_digit(self, radix: u32) -> Option<u32> {\n        C::to_digit(self, radix)\n    }\n\n    /// Returns an iterator that yields the hexadecimal Unicode escape of a\n    /// character as `char`s.\n    ///\n    /// This will escape characters with the Rust syntax of the form\n    /// `\\u{NNNNNN}` where `NNNNNN` is a hexadecimal representation.\n    ///\n    /// # Examples\n    ///\n    /// As an iterator:\n    ///\n    /// ```\n    /// for c in ''.escape_unicode() {\n    ///     print!(\"{}\", c);\n    /// }\n    /// println!();\n    /// ```\n    ///\n    /// Using `println!` directly:\n    ///\n    /// ```\n    /// println!(\"{}\", ''.escape_unicode());\n    /// ```\n    ///\n    /// Both are equivalent to:\n    ///\n    /// ```\n    /// println!(\"\\\\u{{2764}}\");\n    /// ```\n    ///\n    /// Using `to_string`:\n    ///\n    /// ```\n    /// assert_eq!(''.escape_unicode().to_string(), \"\\\\u{2764}\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn escape_unicode(self) -> EscapeUnicode {\n        C::escape_unicode(self)\n    }\n\n    /// Returns an iterator that yields the literal escape code of a character\n    /// as `char`s.\n    ///\n    /// This will escape the characters similar to the `Debug` implementations\n    /// of `str` or `char`.\n    ///\n    /// # Examples\n    ///\n    /// As an iterator:\n    ///\n    /// ```\n    /// # #![feature(char_escape_debug)]\n    /// for c in '\\n'.escape_debug() {\n    ///     print!(\"{}\", c);\n    /// }\n    /// println!();\n    /// ```\n    ///\n    /// Using `println!` directly:\n    ///\n    /// ```\n    /// # #![feature(char_escape_debug)]\n    /// println!(\"{}\", '\\n'.escape_debug());\n    /// ```\n    ///\n    /// Both are equivalent to:\n    ///\n    /// ```\n    /// println!(\"\\\\n\");\n    /// ```\n    ///\n    /// Using `to_string`:\n    ///\n    /// ```\n    /// # #![feature(char_escape_debug)]\n    /// assert_eq!('\\n'.escape_debug().to_string(), \"\\\\n\");\n    /// ```\n    #[unstable(feature = \"char_escape_debug\", issue = \"35068\")]\n    #[inline]\n    pub fn escape_debug(self) -> EscapeDebug {\n        C::escape_debug(self)\n    }\n\n    /// Returns an iterator that yields the literal escape code of a character\n    /// as `char`s.\n    ///\n    /// The default is chosen with a bias toward producing literals that are\n    /// legal in a variety of languages, including C++11 and similar C-family\n    /// languages. The exact rules are:\n    ///\n    /// * Tab is escaped as `\\t`.\n    /// * Carriage return is escaped as `\\r`.\n    /// * Line feed is escaped as `\\n`.\n    /// * Single quote is escaped as `\\'`.\n    /// * Double quote is escaped as `\\\"`.\n    /// * Backslash is escaped as `\\\\`.\n    /// * Any character in the 'printable ASCII' range `0x20` .. `0x7e`\n    ///   inclusive is not escaped.\n    /// * All other characters are given hexadecimal Unicode escapes; see\n    ///   [`escape_unicode`][escape_unicode].\n    ///\n    /// [escape_unicode]: #method.escape_unicode\n    ///\n    /// # Examples\n    ///\n    /// As an iterator:\n    ///\n    /// ```\n    /// for c in '\"'.escape_default() {\n    ///     print!(\"{}\", c);\n    /// }\n    /// println!();\n    /// ```\n    ///\n    /// Using `println!` directly:\n    ///\n    /// ```\n    /// println!(\"{}\", '\"'.escape_default());\n    /// ```\n    ///\n    ///\n    /// Both are equivalent to:\n    ///\n    /// ```\n    /// println!(\"\\\\\\\"\");\n    /// ```\n    ///\n    /// Using `to_string`:\n    ///\n    /// ```\n    /// assert_eq!('\"'.escape_default().to_string(), \"\\\\\\\"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn escape_default(self) -> EscapeDefault {\n        C::escape_default(self)\n    }\n\n    /// Returns the number of bytes this `char` would need if encoded in UTF-8.\n    ///\n    /// That number of bytes is always between 1 and 4, inclusive.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let len = 'A'.len_utf8();\n    /// assert_eq!(len, 1);\n    ///\n    /// let len = ''.len_utf8();\n    /// assert_eq!(len, 2);\n    ///\n    /// let len = ''.len_utf8();\n    /// assert_eq!(len, 3);\n    ///\n    /// let len = ''.len_utf8();\n    /// assert_eq!(len, 4);\n    /// ```\n    ///\n    /// The `&str` type guarantees that its contents are UTF-8, and so we can compare the length it\n    /// would take if each code point was represented as a `char` vs in the `&str` itself:\n    ///\n    /// ```\n    /// // as chars\n    /// let eastern = '';\n    /// let capitol = '';\n    ///\n    /// // both can be represented as three bytes\n    /// assert_eq!(3, eastern.len_utf8());\n    /// assert_eq!(3, capitol.len_utf8());\n    ///\n    /// // as a &str, these two are encoded in UTF-8\n    /// let tokyo = \"\";\n    ///\n    /// let len = eastern.len_utf8() + capitol.len_utf8();\n    ///\n    /// // we can see that they take six bytes total...\n    /// assert_eq!(6, tokyo.len());\n    ///\n    /// // ... just like the &str\n    /// assert_eq!(len, tokyo.len());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn len_utf8(self) -> usize {\n        C::len_utf8(self)\n    }\n\n    /// Returns the number of 16-bit code units this `char` would need if\n    /// encoded in UTF-16.\n    ///\n    /// See the documentation for [`len_utf8`] for more explanation of this\n    /// concept. This function is a mirror, but for UTF-16 instead of UTF-8.\n    ///\n    /// [`len_utf8`]: #method.len_utf8\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let n = ''.len_utf16();\n    /// assert_eq!(n, 1);\n    ///\n    /// let len = ''.len_utf16();\n    /// assert_eq!(len, 2);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn len_utf16(self) -> usize {\n        C::len_utf16(self)\n    }\n\n    /// Encodes this character as UTF-8 into the provided byte buffer,\n    /// and then returns the subslice of the buffer that contains the encoded character.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the buffer is not large enough.\n    /// A buffer of length four is large enough to encode any `char`.\n    ///\n    /// # Examples\n    ///\n    /// In both of these examples, '' takes two bytes to encode.\n    ///\n    /// ```\n    /// let mut b = [0; 2];\n    ///\n    /// let result = ''.encode_utf8(&mut b);\n    ///\n    /// assert_eq!(result, \"\");\n    ///\n    /// assert_eq!(result.len(), 2);\n    /// ```\n    ///\n    /// A buffer that's too small:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let result = thread::spawn(|| {\n    ///     let mut b = [0; 1];\n    ///\n    ///     // this panics\n    ///    ''.encode_utf8(&mut b);\n    /// }).join();\n    ///\n    /// assert!(result.is_err());\n    /// ```\n    #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n    #[inline]\n    pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n        C::encode_utf8(self, dst)\n    }\n\n    /// Encodes this character as UTF-16 into the provided `u16` buffer,\n    /// and then returns the subslice of the buffer that contains the encoded character.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the buffer is not large enough.\n    /// A buffer of length 2 is large enough to encode any `char`.\n    ///\n    /// # Examples\n    ///\n    /// In both of these examples, '' takes two `u16`s to encode.\n    ///\n    /// ```\n    /// let mut b = [0; 2];\n    ///\n    /// let result = ''.encode_utf16(&mut b);\n    ///\n    /// assert_eq!(result.len(), 2);\n    /// ```\n    ///\n    /// A buffer that's too small:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let result = thread::spawn(|| {\n    ///     let mut b = [0; 1];\n    ///\n    ///     // this panics\n    ///     ''.encode_utf16(&mut b);\n    /// }).join();\n    ///\n    /// assert!(result.is_err());\n    /// ```\n    #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n    #[inline]\n    pub fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n        C::encode_utf16(self, dst)\n    }\n\n    /// Returns true if this `char` is an alphabetic code point, and false if not.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!('a'.is_alphabetic());\n    /// assert!(''.is_alphabetic());\n    ///\n    /// let c = '';\n    /// // love is many things, but it is not alphabetic\n    /// assert!(!c.is_alphabetic());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_alphabetic(self) -> bool {\n        match self {\n            'a'...'z' | 'A'...'Z' => true,\n            c if c > '\\x7f' => derived_property::Alphabetic(c),\n            _ => false,\n        }\n    }\n\n    /// Returns true if this `char` satisfies the 'XID_Start' Unicode property, and false\n    /// otherwise.\n    ///\n    /// 'XID_Start' is a Unicode Derived Property specified in\n    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n    /// mostly similar to `ID_Start` but modified for closure under `NFKx`.\n    #[unstable(feature = \"rustc_private\",\n               reason = \"mainly needed for compiler internals\",\n               issue = \"27812\")]\n    #[inline]\n    pub fn is_xid_start(self) -> bool {\n        derived_property::XID_Start(self)\n    }\n\n    /// Returns true if this `char` satisfies the 'XID_Continue' Unicode property, and false\n    /// otherwise.\n    ///\n    /// 'XID_Continue' is a Unicode Derived Property specified in\n    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n    /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n    #[unstable(feature = \"rustc_private\",\n               reason = \"mainly needed for compiler internals\",\n               issue = \"27812\")]\n    #[inline]\n    pub fn is_xid_continue(self) -> bool {\n        derived_property::XID_Continue(self)\n    }\n\n    /// Returns true if this `char` is lowercase, and false otherwise.\n    ///\n    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core\n    /// Property `Lowercase`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!('a'.is_lowercase());\n    /// assert!(''.is_lowercase());\n    /// assert!(!'A'.is_lowercase());\n    /// assert!(!''.is_lowercase());\n    ///\n    /// // The various Chinese scripts do not have case, and so:\n    /// assert!(!''.is_lowercase());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_lowercase(self) -> bool {\n        match self {\n            'a'...'z' => true,\n            c if c > '\\x7f' => derived_property::Lowercase(c),\n            _ => false,\n        }\n    }\n\n    /// Returns true if this `char` is uppercase, and false otherwise.\n    ///\n    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core\n    /// Property `Uppercase`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!(!'a'.is_uppercase());\n    /// assert!(!''.is_uppercase());\n    /// assert!('A'.is_uppercase());\n    /// assert!(''.is_uppercase());\n    ///\n    /// // The various Chinese scripts do not have case, and so:\n    /// assert!(!''.is_uppercase());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_uppercase(self) -> bool {\n        match self {\n            'A'...'Z' => true,\n            c if c > '\\x7f' => derived_property::Uppercase(c),\n            _ => false,\n        }\n    }\n\n    /// Returns true if this `char` is whitespace, and false otherwise.\n    ///\n    /// 'Whitespace' is defined according to the terms of the Unicode Derived Core\n    /// Property `White_Space`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!(' '.is_whitespace());\n    ///\n    /// // a non-breaking space\n    /// assert!('\\u{A0}'.is_whitespace());\n    ///\n    /// assert!(!''.is_whitespace());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_whitespace(self) -> bool {\n        match self {\n            ' ' | '\\x09'...'\\x0d' => true,\n            c if c > '\\x7f' => property::White_Space(c),\n            _ => false,\n        }\n    }\n\n    /// Returns true if this `char` is alphanumeric, and false otherwise.\n    ///\n    /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n    /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!(''.is_alphanumeric());\n    /// assert!('7'.is_alphanumeric());\n    /// assert!(''.is_alphanumeric());\n    /// assert!('K'.is_alphanumeric());\n    /// assert!(''.is_alphanumeric());\n    /// assert!(''.is_alphanumeric());\n    /// assert!(!''.is_alphanumeric());\n    /// assert!(!''.is_alphanumeric());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_alphanumeric(self) -> bool {\n        self.is_alphabetic() || self.is_numeric()\n    }\n\n    /// Returns true if this `char` is a control code point, and false otherwise.\n    ///\n    /// 'Control code point' is defined in terms of the Unicode General\n    /// Category `Cc`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // U+009C, STRING TERMINATOR\n    /// assert!(''.is_control());\n    /// assert!(!'q'.is_control());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_control(self) -> bool {\n        general_category::Cc(self)\n    }\n\n    /// Returns true if this `char` is numeric, and false otherwise.\n    ///\n    /// 'Numeric'-ness is defined in terms of the Unicode General Categories\n    /// 'Nd', 'Nl', 'No'.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!(''.is_numeric());\n    /// assert!('7'.is_numeric());\n    /// assert!(''.is_numeric());\n    /// assert!(!'K'.is_numeric());\n    /// assert!(!''.is_numeric());\n    /// assert!(!''.is_numeric());\n    /// assert!(!''.is_numeric());\n    /// assert!(!''.is_numeric());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_numeric(self) -> bool {\n        match self {\n            '0'...'9' => true,\n            c if c > '\\x7f' => general_category::N(c),\n            _ => false,\n        }\n    }\n\n    /// Returns an iterator that yields the lowercase equivalent of a `char`\n    /// as one or more `char`s.\n    ///\n    /// If a character does not have a lowercase equivalent, the same character\n    /// will be returned back by the iterator.\n    ///\n    /// This performs complex unconditional mappings with no tailoring: it maps\n    /// one Unicode character to its lowercase equivalent according to the\n    /// [Unicode database] and the additional complex mappings\n    /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n    /// language) are not considered here.\n    ///\n    /// For a full reference, see [here][reference].\n    ///\n    /// [Unicode database]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n    ///\n    /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n    ///\n    /// [reference]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n    ///\n    /// # Examples\n    ///\n    /// As an iterator:\n    ///\n    /// ```\n    /// for c in ''.to_lowercase() {\n    ///     print!(\"{}\", c);\n    /// }\n    /// println!();\n    /// ```\n    ///\n    /// Using `println!` directly:\n    ///\n    /// ```\n    /// println!(\"{}\", ''.to_lowercase());\n    /// ```\n    ///\n    /// Both are equivalent to:\n    ///\n    /// ```\n    /// println!(\"i\\u{307}\");\n    /// ```\n    ///\n    /// Using `to_string`:\n    ///\n    /// ```\n    /// assert_eq!('C'.to_lowercase().to_string(), \"c\");\n    ///\n    /// // Sometimes the result is more than one character:\n    /// assert_eq!(''.to_lowercase().to_string(), \"i\\u{307}\");\n    ///\n    /// // Characters that do not have both uppercase and lowercase\n    /// // convert into themselves.\n    /// assert_eq!(''.to_lowercase().to_string(), \"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_lowercase(self) -> ToLowercase {\n        ToLowercase(CaseMappingIter::new(conversions::to_lower(self)))\n    }\n\n    /// Returns an iterator that yields the uppercase equivalent of a `char`\n    /// as one or more `char`s.\n    ///\n    /// If a character does not have an uppercase equivalent, the same character\n    /// will be returned back by the iterator.\n    ///\n    /// This performs complex unconditional mappings with no tailoring: it maps\n    /// one Unicode character to its uppercase equivalent according to the\n    /// [Unicode database] and the additional complex mappings\n    /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n    /// language) are not considered here.\n    ///\n    /// For a full reference, see [here][reference].\n    ///\n    /// [Unicode database]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n    ///\n    /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n    ///\n    /// [reference]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n    ///\n    /// # Examples\n    ///\n    /// As an iterator:\n    ///\n    /// ```\n    /// for c in ''.to_uppercase() {\n    ///     print!(\"{}\", c);\n    /// }\n    /// println!();\n    /// ```\n    ///\n    /// Using `println!` directly:\n    ///\n    /// ```\n    /// println!(\"{}\", ''.to_uppercase());\n    /// ```\n    ///\n    /// Both are equivalent to:\n    ///\n    /// ```\n    /// println!(\"SS\");\n    /// ```\n    ///\n    /// Using `to_string`:\n    ///\n    /// ```\n    /// assert_eq!('c'.to_uppercase().to_string(), \"C\");\n    ///\n    /// // Sometimes the result is more than one character:\n    /// assert_eq!(''.to_uppercase().to_string(), \"SS\");\n    ///\n    /// // Characters that do not have both uppercase and lowercase\n    /// // convert into themselves.\n    /// assert_eq!(''.to_uppercase().to_string(), \"\");\n    /// ```\n    ///\n    /// # Note on locale\n    ///\n    /// In Turkish, the equivalent of 'i' in Latin has five forms instead of two:\n    ///\n    /// * 'Dotless': I / , sometimes written \n    /// * 'Dotted':  / i\n    ///\n    /// Note that the lowercase dotted 'i' is the same as the Latin. Therefore:\n    ///\n    /// ```\n    /// let upper_i = 'i'.to_uppercase().to_string();\n    /// ```\n    ///\n    /// The value of `upper_i` here relies on the language of the text: if we're\n    /// in `en-US`, it should be `\"I\"`, but if we're in `tr_TR`, it should\n    /// be `\"\"`. `to_uppercase()` does not take this into account, and so:\n    ///\n    /// ```\n    /// let upper_i = 'i'.to_uppercase().to_string();\n    ///\n    /// assert_eq!(upper_i, \"I\");\n    /// ```\n    ///\n    /// holds across languages.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_uppercase(self) -> ToUppercase {\n        ToUppercase(CaseMappingIter::new(conversions::to_upper(self)))\n    }\n}\n\n/// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n#[derive(Clone)]\npub struct DecodeUtf16<I>\n    where I: Iterator<Item = u16>\n{\n    iter: I,\n    buf: Option<u16>,\n}\n\n/// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n#[derive(Debug, Clone, Eq, PartialEq)]\npub struct DecodeUtf16Error {\n    code: u16,\n}\n\n/// Create an iterator over the UTF-16 encoded code points in `iter`,\n/// returning unpaired surrogates as `Err`s.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::char::decode_utf16;\n///\n/// fn main() {\n///     // mus<invalid>ic<invalid>\n///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n///              0x0073, 0xDD1E, 0x0069, 0x0063,\n///              0xD834];\n///\n///     assert_eq!(decode_utf16(v.iter().cloned())\n///                            .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n///                            .collect::<Vec<_>>(),\n///                vec![Ok(''),\n///                     Ok('m'), Ok('u'), Ok('s'),\n///                     Err(0xDD1E),\n///                     Ok('i'), Ok('c'),\n///                     Err(0xD834)]);\n/// }\n/// ```\n///\n/// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n///\n/// ```\n/// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n///\n/// fn main() {\n///     // mus<invalid>ic<invalid>\n///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n///              0x0073, 0xDD1E, 0x0069, 0x0063,\n///              0xD834];\n///\n///     assert_eq!(decode_utf16(v.iter().cloned())\n///                    .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n///                    .collect::<String>(),\n///                \"music\");\n/// }\n/// ```\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n#[inline]\npub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n    DecodeUtf16 {\n        iter: iter.into_iter(),\n        buf: None,\n    }\n}\n\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\nimpl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n    type Item = Result<char, DecodeUtf16Error>;\n\n    fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n        let u = match self.buf.take() {\n            Some(buf) => buf,\n            None => {\n                match self.iter.next() {\n                    Some(u) => u,\n                    None => return None,\n                }\n            }\n        };\n\n        if u < 0xD800 || 0xDFFF < u {\n            // not a surrogate\n            Some(Ok(unsafe { from_u32_unchecked(u as u32) }))\n        } else if u >= 0xDC00 {\n            // a trailing surrogate\n            Some(Err(DecodeUtf16Error { code: u }))\n        } else {\n            let u2 = match self.iter.next() {\n                Some(u2) => u2,\n                // eof\n                None => return Some(Err(DecodeUtf16Error { code: u })),\n            };\n            if u2 < 0xDC00 || u2 > 0xDFFF {\n                // not a trailing surrogate so we're not a valid\n                // surrogate pair, so rewind to redecode u2 next time.\n                self.buf = Some(u2);\n                return Some(Err(DecodeUtf16Error { code: u }));\n            }\n\n            // all ok, so lets decode it.\n            let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n            Some(Ok(unsafe { from_u32_unchecked(c) }))\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, high) = self.iter.size_hint();\n        // we could be entirely valid surrogates (2 elements per\n        // char), or entirely non-surrogates (1 element per char)\n        (low / 2, high)\n    }\n}\n\nimpl DecodeUtf16Error {\n    /// Returns the unpaired surrogate which caused this error.\n    #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n    pub fn unpaired_surrogate(&self) -> u16 {\n        self.code\n    }\n}\n\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\nimpl fmt::Display for DecodeUtf16Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"unpaired surrogate found: {:x}\", self.code)\n    }\n}\n\n/// `U+FFFD REPLACEMENT CHARACTER` () is used in Unicode to represent a\n/// decoding error.\n///\n/// It can occur, for example, when giving ill-formed UTF-8 bytes to\n/// [`String::from_utf8_lossy`](../../std/string/struct.String.html#method.from_utf8_lossy).\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\npub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';\n","// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse cmp::Ordering;\n\nuse super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse};\nuse super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\nuse super::{Zip, Sum, Product};\nuse super::{ChainState, FromIterator, ZipImpl};\n\nfn _assert_is_object_safe(_: &Iterator<Item=()>) {}\n\n/// An interface for dealing with iterators.\n///\n/// This is the main iterator trait. For more about the concept of iterators\n/// generally, please see the [module-level documentation]. In particular, you\n/// may want to know how to [implement `Iterator`][impl].\n///\n/// [module-level documentation]: index.html\n/// [impl]: index.html#implementing-iterator\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling \\\n                            `.iter()` or a similar method\"]\npub trait Iterator {\n    /// The type of the elements being iterated over.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Item;\n\n    /// Advances the iterator and returns the next value.\n    ///\n    /// Returns [`None`] when iteration is finished. Individual iterator\n    /// implementations may choose to resume iteration, and so calling `next()`\n    /// again may or may not eventually start returning [`Some(Item)`] again at some\n    /// point.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`Some(Item)`]: ../../std/option/enum.Option.html#variant.Some\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter();\n    ///\n    /// // A call to next() returns the next value...\n    /// assert_eq!(Some(&1), iter.next());\n    /// assert_eq!(Some(&2), iter.next());\n    /// assert_eq!(Some(&3), iter.next());\n    ///\n    /// // ... and then None once it's over.\n    /// assert_eq!(None, iter.next());\n    ///\n    /// // More calls may or may not return None. Here, they always will.\n    /// assert_eq!(None, iter.next());\n    /// assert_eq!(None, iter.next());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn next(&mut self) -> Option<Self::Item>;\n\n    /// Returns the bounds on the remaining length of the iterator.\n    ///\n    /// Specifically, `size_hint()` returns a tuple where the first element\n    /// is the lower bound, and the second element is the upper bound.\n    ///\n    /// The second half of the tuple that is returned is an [`Option`]`<`[`usize`]`>`.\n    /// A [`None`] here means that either there is no known upper bound, or the\n    /// upper bound is larger than [`usize`].\n    ///\n    /// # Implementation notes\n    ///\n    /// It is not enforced that an iterator implementation yields the declared\n    /// number of elements. A buggy iterator may yield less than the lower bound\n    /// or more than the upper bound of elements.\n    ///\n    /// `size_hint()` is primarily intended to be used for optimizations such as\n    /// reserving space for the elements of the iterator, but must not be\n    /// trusted to e.g. omit bounds checks in unsafe code. An incorrect\n    /// implementation of `size_hint()` should not lead to memory safety\n    /// violations.\n    ///\n    /// That said, the implementation should provide a correct estimation,\n    /// because otherwise it would be a violation of the trait's protocol.\n    ///\n    /// The default implementation returns `(0, None)` which is correct for any\n    /// iterator.\n    ///\n    /// [`usize`]: ../../std/primitive.usize.html\n    /// [`Option`]: ../../std/option/enum.Option.html\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// let iter = a.iter();\n    ///\n    /// assert_eq!((3, Some(3)), iter.size_hint());\n    /// ```\n    ///\n    /// A more complex example:\n    ///\n    /// ```\n    /// // The even numbers from zero to ten.\n    /// let iter = (0..10).filter(|x| x % 2 == 0);\n    ///\n    /// // We might iterate from zero to ten times. Knowing that it's five\n    /// // exactly wouldn't be possible without executing filter().\n    /// assert_eq!((0, Some(10)), iter.size_hint());\n    ///\n    /// // Let's add five more numbers with chain()\n    /// let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n    ///\n    /// // now both bounds are increased by five\n    /// assert_eq!((5, Some(15)), iter.size_hint());\n    /// ```\n    ///\n    /// Returning `None` for an upper bound:\n    ///\n    /// ```\n    /// // an infinite iterator has no upper bound\n    /// // and the maximum possible lower bound\n    /// let iter = 0..;\n    ///\n    /// assert_eq!((usize::max_value(), None), iter.size_hint());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }\n\n    /// Consumes the iterator, counting the number of iterations and returning it.\n    ///\n    /// This method will evaluate the iterator until its [`next`] returns\n    /// [`None`]. Once [`None`] is encountered, `count()` returns the number of\n    /// times it called [`next`].\n    ///\n    /// [`next`]: #tymethod.next\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Overflow Behavior\n    ///\n    /// The method does no guarding against overflows, so counting elements of\n    /// an iterator with more than [`usize::MAX`] elements either produces the\n    /// wrong result or panics. If debug assertions are enabled, a panic is\n    /// guaranteed.\n    ///\n    /// # Panics\n    ///\n    /// This function might panic if the iterator has more than [`usize::MAX`]\n    /// elements.\n    ///\n    /// [`usize::MAX`]: ../../std/isize/constant.MAX.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert_eq!(a.iter().count(), 3);\n    ///\n    /// let a = [1, 2, 3, 4, 5];\n    /// assert_eq!(a.iter().count(), 5);\n    /// ```\n    #[inline]\n    #[rustc_inherit_overflow_checks]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn count(self) -> usize where Self: Sized {\n        // Might overflow.\n        self.fold(0, |cnt, _| cnt + 1)\n    }\n\n    /// Consumes the iterator, returning the last element.\n    ///\n    /// This method will evaluate the iterator until it returns [`None`]. While\n    /// doing so, it keeps track of the current element. After [`None`] is\n    /// returned, `last()` will then return the last element it saw.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert_eq!(a.iter().last(), Some(&3));\n    ///\n    /// let a = [1, 2, 3, 4, 5];\n    /// assert_eq!(a.iter().last(), Some(&5));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn last(self) -> Option<Self::Item> where Self: Sized {\n        let mut last = None;\n        for x in self { last = Some(x); }\n        last\n    }\n\n    /// Returns the `n`th element of the iterator.\n    ///\n    /// Like most indexing operations, the count starts from zero, so `nth(0)`\n    /// returns the first value, `nth(1)` the second, and so on.\n    ///\n    /// Note that all preceding elements, as well as the returned element, will be\n    /// consumed from the iterator. That means that the preceding elements will be\n    /// discarded, and also that calling `nth(0)` multiple times on the same iterator\n    /// will return different elements.\n    ///\n    /// `nth()` will return [`None`] if `n` is greater than or equal to the length of the\n    /// iterator.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert_eq!(a.iter().nth(1), Some(&2));\n    /// ```\n    ///\n    /// Calling `nth()` multiple times doesn't rewind the iterator:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter();\n    ///\n    /// assert_eq!(iter.nth(1), Some(&2));\n    /// assert_eq!(iter.nth(1), None);\n    /// ```\n    ///\n    /// Returning `None` if there are less than `n + 1` elements:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert_eq!(a.iter().nth(10), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n        for x in self {\n            if n == 0 { return Some(x) }\n            n -= 1;\n        }\n        None\n    }\n\n    /// Creates an iterator starting at the same point, but stepping by\n    /// the given amount at each iteration.\n    ///\n    /// Note that it will always return the first element of the iterator,\n    /// regardless of the step given.\n    ///\n    /// # Panics\n    ///\n    /// The method will panic if the given step is `0`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(iterator_step_by)]\n    /// let a = [0, 1, 2, 3, 4, 5];\n    /// let mut iter = a.into_iter().step_by(2);\n    ///\n    /// assert_eq!(iter.next(), Some(&0));\n    /// assert_eq!(iter.next(), Some(&2));\n    /// assert_eq!(iter.next(), Some(&4));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"iterator_step_by\",\n               reason = \"unstable replacement of Range::step_by\",\n               issue = \"27741\")]\n    fn step_by(self, step: usize) -> StepBy<Self> where Self: Sized {\n        assert!(step != 0);\n        StepBy{iter: self, step: step - 1, first_take: true}\n    }\n\n    /// Takes two iterators and creates a new iterator over both in sequence.\n    ///\n    /// `chain()` will return a new iterator which will first iterate over\n    /// values from the first iterator and then over values from the second\n    /// iterator.\n    ///\n    /// In other words, it links two iterators together, in a chain. \n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a1 = [1, 2, 3];\n    /// let a2 = [4, 5, 6];\n    ///\n    /// let mut iter = a1.iter().chain(a2.iter());\n    ///\n    /// assert_eq!(iter.next(), Some(&1));\n    /// assert_eq!(iter.next(), Some(&2));\n    /// assert_eq!(iter.next(), Some(&3));\n    /// assert_eq!(iter.next(), Some(&4));\n    /// assert_eq!(iter.next(), Some(&5));\n    /// assert_eq!(iter.next(), Some(&6));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// Since the argument to `chain()` uses [`IntoIterator`], we can pass\n    /// anything that can be converted into an [`Iterator`], not just an\n    /// [`Iterator`] itself. For example, slices (`&[T]`) implement\n    /// [`IntoIterator`], and so can be passed to `chain()` directly:\n    ///\n    /// [`IntoIterator`]: trait.IntoIterator.html\n    /// [`Iterator`]: trait.Iterator.html\n    ///\n    /// ```\n    /// let s1 = &[1, 2, 3];\n    /// let s2 = &[4, 5, 6];\n    ///\n    /// let mut iter = s1.iter().chain(s2);\n    ///\n    /// assert_eq!(iter.next(), Some(&1));\n    /// assert_eq!(iter.next(), Some(&2));\n    /// assert_eq!(iter.next(), Some(&3));\n    /// assert_eq!(iter.next(), Some(&4));\n    /// assert_eq!(iter.next(), Some(&5));\n    /// assert_eq!(iter.next(), Some(&6));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn chain<U>(self, other: U) -> Chain<Self, U::IntoIter> where\n        Self: Sized, U: IntoIterator<Item=Self::Item>,\n    {\n        Chain{a: self, b: other.into_iter(), state: ChainState::Both}\n    }\n\n    /// 'Zips up' two iterators into a single iterator of pairs.\n    ///\n    /// `zip()` returns a new iterator that will iterate over two other\n    /// iterators, returning a tuple where the first element comes from the\n    /// first iterator, and the second element comes from the second iterator.\n    ///\n    /// In other words, it zips two iterators together, into a single one.\n    ///\n    /// When either iterator returns [`None`], all further calls to [`next`]\n    /// will return [`None`].\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a1 = [1, 2, 3];\n    /// let a2 = [4, 5, 6];\n    ///\n    /// let mut iter = a1.iter().zip(a2.iter());\n    ///\n    /// assert_eq!(iter.next(), Some((&1, &4)));\n    /// assert_eq!(iter.next(), Some((&2, &5)));\n    /// assert_eq!(iter.next(), Some((&3, &6)));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// Since the argument to `zip()` uses [`IntoIterator`], we can pass\n    /// anything that can be converted into an [`Iterator`], not just an\n    /// [`Iterator`] itself. For example, slices (`&[T]`) implement\n    /// [`IntoIterator`], and so can be passed to `zip()` directly:\n    ///\n    /// [`IntoIterator`]: trait.IntoIterator.html\n    /// [`Iterator`]: trait.Iterator.html\n    ///\n    /// ```\n    /// let s1 = &[1, 2, 3];\n    /// let s2 = &[4, 5, 6];\n    ///\n    /// let mut iter = s1.iter().zip(s2);\n    ///\n    /// assert_eq!(iter.next(), Some((&1, &4)));\n    /// assert_eq!(iter.next(), Some((&2, &5)));\n    /// assert_eq!(iter.next(), Some((&3, &6)));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// `zip()` is often used to zip an infinite iterator to a finite one.\n    /// This works because the finite iterator will eventually return [`None`],\n    /// ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate`]:\n    ///\n    /// ```\n    /// let enumerate: Vec<_> = \"foo\".chars().enumerate().collect();\n    ///\n    /// let zipper: Vec<_> = (0..).zip(\"foo\".chars()).collect();\n    ///\n    /// assert_eq!((0, 'f'), enumerate[0]);\n    /// assert_eq!((0, 'f'), zipper[0]);\n    ///\n    /// assert_eq!((1, 'o'), enumerate[1]);\n    /// assert_eq!((1, 'o'), zipper[1]);\n    ///\n    /// assert_eq!((2, 'o'), enumerate[2]);\n    /// assert_eq!((2, 'o'), zipper[2]);\n    /// ```\n    ///\n    /// [`enumerate`]: trait.Iterator.html#method.enumerate\n    /// [`next`]: ../../std/iter/trait.Iterator.html#tymethod.next\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter> where\n        Self: Sized, U: IntoIterator\n    {\n        Zip::new(self, other.into_iter())\n    }\n\n    /// Takes a closure and creates an iterator which calls that closure on each\n    /// element.\n    ///\n    /// `map()` transforms one iterator into another, by means of its argument:\n    /// something that implements `FnMut`. It produces a new iterator which\n    /// calls this closure on each element of the original iterator.\n    ///\n    /// If you are good at thinking in types, you can think of `map()` like this:\n    /// If you have an iterator that gives you elements of some type `A`, and\n    /// you want an iterator of some other type `B`, you can use `map()`,\n    /// passing a closure that takes an `A` and returns a `B`.\n    ///\n    /// `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n    /// lazy, it is best used when you're already working with other iterators.\n    /// If you're doing some sort of looping for a side effect, it's considered\n    /// more idiomatic to use [`for`] than `map()`.\n    ///\n    /// [`for`]: ../../book/first-edition/loops.html#for\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.into_iter().map(|x| 2 * x);\n    ///\n    /// assert_eq!(iter.next(), Some(2));\n    /// assert_eq!(iter.next(), Some(4));\n    /// assert_eq!(iter.next(), Some(6));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// If you're doing some sort of side effect, prefer [`for`] to `map()`:\n    ///\n    /// ```\n    /// # #![allow(unused_must_use)]\n    /// // don't do this:\n    /// (0..5).map(|x| println!(\"{}\", x));\n    ///\n    /// // it won't even execute, as it is lazy. Rust will warn you about this.\n    ///\n    /// // Instead, use for:\n    /// for x in 0..5 {\n    ///     println!(\"{}\", x);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn map<B, F>(self, f: F) -> Map<Self, F> where\n        Self: Sized, F: FnMut(Self::Item) -> B,\n    {\n        Map{iter: self, f: f}\n    }\n\n    /// Calls a closure on each element of an iterator.\n    ///\n    /// This is equivalent to using a [`for`] loop on the iterator, although\n    /// `break` and `continue` are not possible from a closure.  It's generally\n    /// more idiomatic to use a `for` loop, but `for_each` may be more legible\n    /// when processing items at the end of longer iterator chains.  In some\n    /// cases `for_each` may also be faster than a loop, because it will use\n    /// internal iteration on adaptors like `Chain`.\n    ///\n    /// [`for`]: ../../book/first-edition/loops.html#for\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(iterator_for_each)]\n    ///\n    /// use std::sync::mpsc::channel;\n    ///\n    /// let (tx, rx) = channel();\n    /// (0..5).map(|x| x * 2 + 1)\n    ///       .for_each(move |x| tx.send(x).unwrap());\n    ///\n    /// let v: Vec<_> =  rx.iter().collect();\n    /// assert_eq!(v, vec![1, 3, 5, 7, 9]);\n    /// ```\n    ///\n    /// For such a small example, a `for` loop may be cleaner, but `for_each`\n    /// might be preferable to keep a functional style with longer iterators:\n    ///\n    /// ```\n    /// #![feature(iterator_for_each)]\n    ///\n    /// (0..5).flat_map(|x| x * 100 .. x * 110)\n    ///       .enumerate()\n    ///       .filter(|&(i, x)| (i + x) % 3 == 0)\n    ///       .for_each(|(i, x)| println!(\"{}:{}\", i, x));\n    /// ```\n    #[inline]\n    #[unstable(feature = \"iterator_for_each\", issue = \"42986\")]\n    fn for_each<F>(self, mut f: F) where\n        Self: Sized, F: FnMut(Self::Item),\n    {\n        self.fold((), move |(), item| f(item));\n    }\n\n    /// Creates an iterator which uses a closure to determine if an element\n    /// should be yielded.\n    ///\n    /// The closure must return `true` or `false`. `filter()` creates an\n    /// iterator which calls this closure on each element. If the closure\n    /// returns `true`, then the element is returned. If the closure returns\n    /// `false`, it will try again, and call the closure on the next element,\n    /// seeing if it passes the test.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [0i32, 1, 2];\n    ///\n    /// let mut iter = a.into_iter().filter(|x| x.is_positive());\n    ///\n    /// assert_eq!(iter.next(), Some(&1));\n    /// assert_eq!(iter.next(), Some(&2));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// Because the closure passed to `filter()` takes a reference, and many\n    /// iterators iterate over references, this leads to a possibly confusing\n    /// situation, where the type of the closure is a double reference:\n    ///\n    /// ```\n    /// let a = [0, 1, 2];\n    ///\n    /// let mut iter = a.into_iter().filter(|x| **x > 1); // need two *s!\n    ///\n    /// assert_eq!(iter.next(), Some(&2));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// It's common to instead use destructuring on the argument to strip away\n    /// one:\n    ///\n    /// ```\n    /// let a = [0, 1, 2];\n    ///\n    /// let mut iter = a.into_iter().filter(|&x| *x > 1); // both & and *\n    ///\n    /// assert_eq!(iter.next(), Some(&2));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// or both:\n    ///\n    /// ```\n    /// let a = [0, 1, 2];\n    ///\n    /// let mut iter = a.into_iter().filter(|&&x| x > 1); // two &s\n    ///\n    /// assert_eq!(iter.next(), Some(&2));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// of these layers.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn filter<P>(self, predicate: P) -> Filter<Self, P> where\n        Self: Sized, P: FnMut(&Self::Item) -> bool,\n    {\n        Filter{iter: self, predicate: predicate}\n    }\n\n    /// Creates an iterator that both filters and maps.\n    ///\n    /// The closure must return an [`Option<T>`]. `filter_map` creates an\n    /// iterator which calls this closure on each element. If the closure\n    /// returns [`Some(element)`][`Some`], then that element is returned. If the\n    /// closure returns [`None`], it will try again, and call the closure on the\n    /// next element, seeing if it will return [`Some`].\n    ///\n    /// Why `filter_map` and not just [`filter`].[`map`]? The key is in this\n    /// part:\n    ///\n    /// [`filter`]: #method.filter\n    /// [`map`]: #method.map\n    ///\n    /// > If the closure returns [`Some(element)`][`Some`], then that element is returned.\n    ///\n    /// In other words, it removes the [`Option<T>`] layer automatically. If your\n    /// mapping is already returning an [`Option<T>`] and you want to skip over\n    /// [`None`]s, then `filter_map` is much, much nicer to use.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [\"1\", \"2\", \"lol\"];\n    ///\n    /// let mut iter = a.iter().filter_map(|s| s.parse().ok());\n    ///\n    /// assert_eq!(iter.next(), Some(1));\n    /// assert_eq!(iter.next(), Some(2));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// Here's the same example, but with [`filter`] and [`map`]:\n    ///\n    /// ```\n    /// let a = [\"1\", \"2\", \"lol\"];\n    ///\n    /// let mut iter = a.iter()\n    ///                 .map(|s| s.parse().ok())\n    ///                 .filter(|s| s.is_some());\n    ///\n    /// assert_eq!(iter.next(), Some(Some(1)));\n    /// assert_eq!(iter.next(), Some(Some(2)));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// There's an extra layer of [`Some`] in there.\n    ///\n    /// [`Option<T>`]: ../../std/option/enum.Option.html\n    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n        Self: Sized, F: FnMut(Self::Item) -> Option<B>,\n    {\n        FilterMap { iter: self, f: f }\n    }\n\n    /// Creates an iterator which gives the current iteration count as well as\n    /// the next value.\n    ///\n    /// The iterator returned yields pairs `(i, val)`, where `i` is the\n    /// current index of iteration and `val` is the value returned by the\n    /// iterator.\n    ///\n    /// `enumerate()` keeps its count as a [`usize`]. If you want to count by a\n    /// different sized integer, the [`zip`] function provides similar\n    /// functionality.\n    ///\n    /// # Overflow Behavior\n    ///\n    /// The method does no guarding against overflows, so enumerating more than\n    /// [`usize::MAX`] elements either produces the wrong result or panics. If\n    /// debug assertions are enabled, a panic is guaranteed.\n    ///\n    /// # Panics\n    ///\n    /// The returned iterator might panic if the to-be-returned index would\n    /// overflow a [`usize`].\n    ///\n    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n    /// [`usize`]: ../../std/primitive.usize.html\n    /// [`zip`]: #method.zip\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = ['a', 'b', 'c'];\n    ///\n    /// let mut iter = a.iter().enumerate();\n    ///\n    /// assert_eq!(iter.next(), Some((0, &'a')));\n    /// assert_eq!(iter.next(), Some((1, &'b')));\n    /// assert_eq!(iter.next(), Some((2, &'c')));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn enumerate(self) -> Enumerate<Self> where Self: Sized {\n        Enumerate { iter: self, count: 0 }\n    }\n\n    /// Creates an iterator which can use `peek` to look at the next element of\n    /// the iterator without consuming it.\n    ///\n    /// Adds a [`peek`] method to an iterator. See its documentation for\n    /// more information.\n    ///\n    /// Note that the underlying iterator is still advanced when [`peek`] is\n    /// called for the first time: In order to retrieve the next element,\n    /// [`next`] is called on the underlying iterator, hence any side effects (i.e.\n    /// anything other than fetching the next value) of the [`next`] method\n    /// will occur.\n    ///\n    /// [`peek`]: struct.Peekable.html#method.peek\n    /// [`next`]: ../../std/iter/trait.Iterator.html#tymethod.next\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let xs = [1, 2, 3];\n    ///\n    /// let mut iter = xs.iter().peekable();\n    ///\n    /// // peek() lets us see into the future\n    /// assert_eq!(iter.peek(), Some(&&1));\n    /// assert_eq!(iter.next(), Some(&1));\n    ///\n    /// assert_eq!(iter.next(), Some(&2));\n    ///\n    /// // we can peek() multiple times, the iterator won't advance\n    /// assert_eq!(iter.peek(), Some(&&3));\n    /// assert_eq!(iter.peek(), Some(&&3));\n    ///\n    /// assert_eq!(iter.next(), Some(&3));\n    ///\n    /// // after the iterator is finished, so is peek()\n    /// assert_eq!(iter.peek(), None);\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn peekable(self) -> Peekable<Self> where Self: Sized {\n        Peekable{iter: self, peeked: None}\n    }\n\n    /// Creates an iterator that [`skip`]s elements based on a predicate.\n    ///\n    /// [`skip`]: #method.skip\n    ///\n    /// `skip_while()` takes a closure as an argument. It will call this\n    /// closure on each element of the iterator, and ignore elements\n    /// until it returns `false`.\n    ///\n    /// After `false` is returned, `skip_while()`'s job is over, and the\n    /// rest of the elements are yielded.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [-1i32, 0, 1];\n    ///\n    /// let mut iter = a.into_iter().skip_while(|x| x.is_negative());\n    ///\n    /// assert_eq!(iter.next(), Some(&0));\n    /// assert_eq!(iter.next(), Some(&1));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// Because the closure passed to `skip_while()` takes a reference, and many\n    /// iterators iterate over references, this leads to a possibly confusing\n    /// situation, where the type of the closure is a double reference:\n    ///\n    /// ```\n    /// let a = [-1, 0, 1];\n    ///\n    /// let mut iter = a.into_iter().skip_while(|x| **x < 0); // need two *s!\n    ///\n    /// assert_eq!(iter.next(), Some(&0));\n    /// assert_eq!(iter.next(), Some(&1));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// Stopping after an initial `false`:\n    ///\n    /// ```\n    /// let a = [-1, 0, 1, -2];\n    ///\n    /// let mut iter = a.into_iter().skip_while(|x| **x < 0);\n    ///\n    /// assert_eq!(iter.next(), Some(&0));\n    /// assert_eq!(iter.next(), Some(&1));\n    ///\n    /// // while this would have been false, since we already got a false,\n    /// // skip_while() isn't used any more\n    /// assert_eq!(iter.next(), Some(&-2));\n    ///\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where\n        Self: Sized, P: FnMut(&Self::Item) -> bool,\n    {\n        SkipWhile{iter: self, flag: false, predicate: predicate}\n    }\n\n    /// Creates an iterator that yields elements based on a predicate.\n    ///\n    /// `take_while()` takes a closure as an argument. It will call this\n    /// closure on each element of the iterator, and yield elements\n    /// while it returns `true`.\n    ///\n    /// After `false` is returned, `take_while()`'s job is over, and the\n    /// rest of the elements are ignored.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [-1i32, 0, 1];\n    ///\n    /// let mut iter = a.into_iter().take_while(|x| x.is_negative());\n    ///\n    /// assert_eq!(iter.next(), Some(&-1));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// Because the closure passed to `take_while()` takes a reference, and many\n    /// iterators iterate over references, this leads to a possibly confusing\n    /// situation, where the type of the closure is a double reference:\n    ///\n    /// ```\n    /// let a = [-1, 0, 1];\n    ///\n    /// let mut iter = a.into_iter().take_while(|x| **x < 0); // need two *s!\n    ///\n    /// assert_eq!(iter.next(), Some(&-1));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// Stopping after an initial `false`:\n    ///\n    /// ```\n    /// let a = [-1, 0, 1, -2];\n    ///\n    /// let mut iter = a.into_iter().take_while(|x| **x < 0);\n    ///\n    /// assert_eq!(iter.next(), Some(&-1));\n    ///\n    /// // We have more elements that are less than zero, but since we already\n    /// // got a false, take_while() isn't used any more\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// Because `take_while()` needs to look at the value in order to see if it\n    /// should be included or not, consuming iterators will see that it is\n    /// removed:\n    ///\n    /// ```\n    /// let a = [1, 2, 3, 4];\n    /// let mut iter = a.into_iter();\n    ///\n    /// let result: Vec<i32> = iter.by_ref()\n    ///                            .take_while(|n| **n != 3)\n    ///                            .cloned()\n    ///                            .collect();\n    ///\n    /// assert_eq!(result, &[1, 2]);\n    ///\n    /// let result: Vec<i32> = iter.cloned().collect();\n    ///\n    /// assert_eq!(result, &[4]);\n    /// ```\n    ///\n    /// The `3` is no longer there, because it was consumed in order to see if\n    /// the iteration should stop, but wasn't placed back into the iterator or\n    /// some similar thing.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where\n        Self: Sized, P: FnMut(&Self::Item) -> bool,\n    {\n        TakeWhile{iter: self, flag: false, predicate: predicate}\n    }\n\n    /// Creates an iterator that skips the first `n` elements.\n    ///\n    /// After they have been consumed, the rest of the elements are yielded.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter().skip(2);\n    ///\n    /// assert_eq!(iter.next(), Some(&3));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn skip(self, n: usize) -> Skip<Self> where Self: Sized {\n        Skip{iter: self, n: n}\n    }\n\n    /// Creates an iterator that yields its first `n` elements.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter().take(2);\n    ///\n    /// assert_eq!(iter.next(), Some(&1));\n    /// assert_eq!(iter.next(), Some(&2));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// `take()` is often used with an infinite iterator, to make it finite:\n    ///\n    /// ```\n    /// let mut iter = (0..).take(3);\n    ///\n    /// assert_eq!(iter.next(), Some(0));\n    /// assert_eq!(iter.next(), Some(1));\n    /// assert_eq!(iter.next(), Some(2));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn take(self, n: usize) -> Take<Self> where Self: Sized, {\n        Take{iter: self, n: n}\n    }\n\n    /// An iterator adaptor similar to [`fold`] that holds internal state and\n    /// produces a new iterator.\n    ///\n    /// [`fold`]: #method.fold\n    ///\n    /// `scan()` takes two arguments: an initial value which seeds the internal\n    /// state, and a closure with two arguments, the first being a mutable\n    /// reference to the internal state and the second an iterator element.\n    /// The closure can assign to the internal state to share state between\n    /// iterations.\n    ///\n    /// On iteration, the closure will be applied to each element of the\n    /// iterator and the return value from the closure, an [`Option`], is\n    /// yielded by the iterator.\n    ///\n    /// [`Option`]: ../../std/option/enum.Option.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter().scan(1, |state, &x| {\n    ///     // each iteration, we'll multiply the state by the element\n    ///     *state = *state * x;\n    ///\n    ///     // the value passed on to the next iteration\n    ///     Some(*state)\n    /// });\n    ///\n    /// assert_eq!(iter.next(), Some(1));\n    /// assert_eq!(iter.next(), Some(2));\n    /// assert_eq!(iter.next(), Some(6));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>\n        where Self: Sized, F: FnMut(&mut St, Self::Item) -> Option<B>,\n    {\n        Scan{iter: self, f: f, state: initial_state}\n    }\n\n    /// Creates an iterator that works like map, but flattens nested structure.\n    ///\n    /// The [`map`] adapter is very useful, but only when the closure\n    /// argument produces values. If it produces an iterator instead, there's\n    /// an extra layer of indirection. `flat_map()` will remove this extra layer\n    /// on its own.\n    ///\n    /// Another way of thinking about `flat_map()`: [`map`]'s closure returns\n    /// one item for each element, and `flat_map()`'s closure returns an\n    /// iterator for each element.\n    ///\n    /// [`map`]: #method.map\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let words = [\"alpha\", \"beta\", \"gamma\"];\n    ///\n    /// // chars() returns an iterator\n    /// let merged: String = words.iter()\n    ///                           .flat_map(|s| s.chars())\n    ///                           .collect();\n    /// assert_eq!(merged, \"alphabetagamma\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>\n        where Self: Sized, U: IntoIterator, F: FnMut(Self::Item) -> U,\n    {\n        FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n    }\n\n    /// Creates an iterator which ends after the first [`None`].\n    ///\n    /// After an iterator returns [`None`], future calls may or may not yield\n    /// [`Some(T)`] again. `fuse()` adapts an iterator, ensuring that after a\n    /// [`None`] is given, it will always return [`None`] forever.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`Some(T)`]: ../../std/option/enum.Option.html#variant.Some\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // an iterator which alternates between Some and None\n    /// struct Alternate {\n    ///     state: i32,\n    /// }\n    ///\n    /// impl Iterator for Alternate {\n    ///     type Item = i32;\n    ///\n    ///     fn next(&mut self) -> Option<i32> {\n    ///         let val = self.state;\n    ///         self.state = self.state + 1;\n    ///\n    ///         // if it's even, Some(i32), else None\n    ///         if val % 2 == 0 {\n    ///             Some(val)\n    ///         } else {\n    ///             None\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// let mut iter = Alternate { state: 0 };\n    ///\n    /// // we can see our iterator going back and forth\n    /// assert_eq!(iter.next(), Some(0));\n    /// assert_eq!(iter.next(), None);\n    /// assert_eq!(iter.next(), Some(2));\n    /// assert_eq!(iter.next(), None);\n    ///\n    /// // however, once we fuse it...\n    /// let mut iter = iter.fuse();\n    ///\n    /// assert_eq!(iter.next(), Some(4));\n    /// assert_eq!(iter.next(), None);\n    ///\n    /// // it will always return None after the first time.\n    /// assert_eq!(iter.next(), None);\n    /// assert_eq!(iter.next(), None);\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fuse(self) -> Fuse<Self> where Self: Sized {\n        Fuse{iter: self, done: false}\n    }\n\n    /// Do something with each element of an iterator, passing the value on.\n    ///\n    /// When using iterators, you'll often chain several of them together.\n    /// While working on such code, you might want to check out what's\n    /// happening at various parts in the pipeline. To do that, insert\n    /// a call to `inspect()`.\n    ///\n    /// It's much more common for `inspect()` to be used as a debugging tool\n    /// than to exist in your final code, but never say never.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 4, 2, 3];\n    ///\n    /// // this iterator sequence is complex.\n    /// let sum = a.iter()\n    ///             .cloned()\n    ///             .filter(|&x| x % 2 == 0)\n    ///             .fold(0, |sum, i| sum + i);\n    ///\n    /// println!(\"{}\", sum);\n    ///\n    /// // let's add some inspect() calls to investigate what's happening\n    /// let sum = a.iter()\n    ///             .cloned()\n    ///             .inspect(|x| println!(\"about to filter: {}\", x))\n    ///             .filter(|&x| x % 2 == 0)\n    ///             .inspect(|x| println!(\"made it through filter: {}\", x))\n    ///             .fold(0, |sum, i| sum + i);\n    ///\n    /// println!(\"{}\", sum);\n    /// ```\n    ///\n    /// This will print:\n    ///\n    /// ```text\n    /// about to filter: 1\n    /// about to filter: 4\n    /// made it through filter: 4\n    /// about to filter: 2\n    /// made it through filter: 2\n    /// about to filter: 3\n    /// 6\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn inspect<F>(self, f: F) -> Inspect<Self, F> where\n        Self: Sized, F: FnMut(&Self::Item),\n    {\n        Inspect{iter: self, f: f}\n    }\n\n    /// Borrows an iterator, rather than consuming it.\n    ///\n    /// This is useful to allow applying iterator adaptors while still\n    /// retaining ownership of the original iterator.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let iter = a.into_iter();\n    ///\n    /// let sum: i32 = iter.take(5)\n    ///                    .fold(0, |acc, &i| acc + i );\n    ///\n    /// assert_eq!(sum, 6);\n    ///\n    /// // if we try to use iter again, it won't work. The following line\n    /// // gives \"error: use of moved value: `iter`\n    /// // assert_eq!(iter.next(), None);\n    ///\n    /// // let's try that again\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.into_iter();\n    ///\n    /// // instead, we add in a .by_ref()\n    /// let sum: i32 = iter.by_ref()\n    ///                    .take(2)\n    ///                    .fold(0, |acc, &i| acc + i );\n    ///\n    /// assert_eq!(sum, 3);\n    ///\n    /// // now this is just fine:\n    /// assert_eq!(iter.next(), Some(&3));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n\n    /// Transforms an iterator into a collection.\n    ///\n    /// `collect()` can take anything iterable, and turn it into a relevant\n    /// collection. This is one of the more powerful methods in the standard\n    /// library, used in a variety of contexts.\n    ///\n    /// The most basic pattern in which `collect()` is used is to turn one\n    /// collection into another. You take a collection, call [`iter`] on it,\n    /// do a bunch of transformations, and then `collect()` at the end.\n    ///\n    /// One of the keys to `collect()`'s power is that many things you might\n    /// not think of as 'collections' actually are. For example, a [`String`]\n    /// is a collection of [`char`]s. And a collection of\n    /// [`Result<T, E>`][`Result`] can be thought of as single\n    /// [`Result`]`<Collection<T>, E>`. See the examples below for more.\n    ///\n    /// Because `collect()` is so general, it can cause problems with type\n    /// inference. As such, `collect()` is one of the few times you'll see\n    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n    /// helps the inference algorithm understand specifically which collection\n    /// you're trying to collect into.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let doubled: Vec<i32> = a.iter()\n    ///                          .map(|&x| x * 2)\n    ///                          .collect();\n    ///\n    /// assert_eq!(vec![2, 4, 6], doubled);\n    /// ```\n    ///\n    /// Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n    /// we could collect into, for example, a [`VecDeque<T>`] instead:\n    ///\n    /// [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let a = [1, 2, 3];\n    ///\n    /// let doubled: VecDeque<i32> = a.iter()\n    ///                               .map(|&x| x * 2)\n    ///                               .collect();\n    ///\n    /// assert_eq!(2, doubled[0]);\n    /// assert_eq!(4, doubled[1]);\n    /// assert_eq!(6, doubled[2]);\n    /// ```\n    ///\n    /// Using the 'turbofish' instead of annotating `doubled`:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let doubled = a.iter()\n    ///                .map(|&x| x * 2)\n    ///                .collect::<Vec<i32>>();\n    ///\n    /// assert_eq!(vec![2, 4, 6], doubled);\n    /// ```\n    ///\n    /// Because `collect()` cares about what you're collecting into, you can\n    /// still use a partial type hint, `_`, with the turbofish:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let doubled = a.iter()\n    ///                .map(|&x| x * 2)\n    ///                .collect::<Vec<_>>();\n    ///\n    /// assert_eq!(vec![2, 4, 6], doubled);\n    /// ```\n    ///\n    /// Using `collect()` to make a [`String`]:\n    ///\n    /// ```\n    /// let chars = ['g', 'd', 'k', 'k', 'n'];\n    ///\n    /// let hello: String = chars.iter()\n    ///                          .map(|&x| x as u8)\n    ///                          .map(|x| (x + 1) as char)\n    ///                          .collect();\n    ///\n    /// assert_eq!(\"hello\", hello);\n    /// ```\n    ///\n    /// If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n    /// see if any of them failed:\n    ///\n    /// ```\n    /// let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n    ///\n    /// let result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n    ///\n    /// // gives us the first error\n    /// assert_eq!(Err(\"nope\"), result);\n    ///\n    /// let results = [Ok(1), Ok(3)];\n    ///\n    /// let result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n    ///\n    /// // gives us the list of answers\n    /// assert_eq!(Ok(vec![1, 3]), result);\n    /// ```\n    ///\n    /// [`iter`]: ../../std/iter/trait.Iterator.html#tymethod.next\n    /// [`String`]: ../../std/string/struct.String.html\n    /// [`char`]: ../../std/primitive.char.html\n    /// [`Result`]: ../../std/result/enum.Result.html\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn collect<B: FromIterator<Self::Item>>(self) -> B where Self: Sized {\n        FromIterator::from_iter(self)\n    }\n\n    /// Consumes an iterator, creating two collections from it.\n    ///\n    /// The predicate passed to `partition()` can return `true`, or `false`.\n    /// `partition()` returns a pair, all of the elements for which it returned\n    /// `true`, and all of the elements for which it returned `false`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let (even, odd): (Vec<i32>, Vec<i32>) = a.into_iter()\n    ///                                          .partition(|&n| n % 2 == 0);\n    ///\n    /// assert_eq!(even, vec![2]);\n    /// assert_eq!(odd, vec![1, 3]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn partition<B, F>(self, mut f: F) -> (B, B) where\n        Self: Sized,\n        B: Default + Extend<Self::Item>,\n        F: FnMut(&Self::Item) -> bool\n    {\n        let mut left: B = Default::default();\n        let mut right: B = Default::default();\n\n        for x in self {\n            if f(&x) {\n                left.extend(Some(x))\n            } else {\n                right.extend(Some(x))\n            }\n        }\n\n        (left, right)\n    }\n\n    /// An iterator adaptor that applies a function, producing a single, final value.\n    ///\n    /// `fold()` takes two arguments: an initial value, and a closure with two\n    /// arguments: an 'accumulator', and an element. The closure returns the value that\n    /// the accumulator should have for the next iteration.\n    ///\n    /// The initial value is the value the accumulator will have on the first\n    /// call.\n    ///\n    /// After applying this closure to every element of the iterator, `fold()`\n    /// returns the accumulator.\n    ///\n    /// This operation is sometimes called 'reduce' or 'inject'.\n    ///\n    /// Folding is useful whenever you have a collection of something, and want\n    /// to produce a single value from it.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// // the sum of all of the elements of a\n    /// let sum = a.iter()\n    ///            .fold(0, |acc, &x| acc + x);\n    ///\n    /// assert_eq!(sum, 6);\n    /// ```\n    ///\n    /// Let's walk through each step of the iteration here:\n    ///\n    /// | element | acc | x | result |\n    /// |---------|-----|---|--------|\n    /// |         | 0   |   |        |\n    /// | 1       | 0   | 1 | 1      |\n    /// | 2       | 1   | 2 | 3      |\n    /// | 3       | 3   | 3 | 6      |\n    ///\n    /// And so, our final result, `6`.\n    ///\n    /// It's common for people who haven't used iterators a lot to\n    /// use a `for` loop with a list of things to build up a result. Those\n    /// can be turned into `fold()`s:\n    ///\n    /// [`for`]: ../../book/first-edition/loops.html#for\n    ///\n    /// ```\n    /// let numbers = [1, 2, 3, 4, 5];\n    ///\n    /// let mut result = 0;\n    ///\n    /// // for loop:\n    /// for i in &numbers {\n    ///     result = result + i;\n    /// }\n    ///\n    /// // fold:\n    /// let result2 = numbers.iter().fold(0, |acc, &x| acc + x);\n    ///\n    /// // they're the same\n    /// assert_eq!(result, result2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fold<B, F>(self, init: B, mut f: F) -> B where\n        Self: Sized, F: FnMut(B, Self::Item) -> B,\n    {\n        let mut accum = init;\n        for x in self {\n            accum = f(accum, x);\n        }\n        accum\n    }\n\n    /// Tests if every element of the iterator matches a predicate.\n    ///\n    /// `all()` takes a closure that returns `true` or `false`. It applies\n    /// this closure to each element of the iterator, and if they all return\n    /// `true`, then so does `all()`. If any of them return `false`, it\n    /// returns `false`.\n    ///\n    /// `all()` is short-circuiting; in other words, it will stop processing\n    /// as soon as it finds a `false`, given that no matter what else happens,\n    /// the result will also be `false`.\n    ///\n    /// An empty iterator returns `true`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// assert!(a.iter().all(|&x| x > 0));\n    ///\n    /// assert!(!a.iter().all(|&x| x > 2));\n    /// ```\n    ///\n    /// Stopping at the first `false`:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter();\n    ///\n    /// assert!(!iter.all(|&x| x != 2));\n    ///\n    /// // we can still use `iter`, as there are more elements.\n    /// assert_eq!(iter.next(), Some(&3));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn all<F>(&mut self, mut f: F) -> bool where\n        Self: Sized, F: FnMut(Self::Item) -> bool\n    {\n        for x in self {\n            if !f(x) {\n                return false;\n            }\n        }\n        true\n    }\n\n    /// Tests if any element of the iterator matches a predicate.\n    ///\n    /// `any()` takes a closure that returns `true` or `false`. It applies\n    /// this closure to each element of the iterator, and if any of them return\n    /// `true`, then so does `any()`. If they all return `false`, it\n    /// returns `false`.\n    ///\n    /// `any()` is short-circuiting; in other words, it will stop processing\n    /// as soon as it finds a `true`, given that no matter what else happens,\n    /// the result will also be `true`.\n    ///\n    /// An empty iterator returns `false`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// assert!(a.iter().any(|&x| x > 0));\n    ///\n    /// assert!(!a.iter().any(|&x| x > 5));\n    /// ```\n    ///\n    /// Stopping at the first `true`:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter();\n    ///\n    /// assert!(iter.any(|&x| x != 2));\n    ///\n    /// // we can still use `iter`, as there are more elements.\n    /// assert_eq!(iter.next(), Some(&2));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn any<F>(&mut self, mut f: F) -> bool where\n        Self: Sized,\n        F: FnMut(Self::Item) -> bool\n    {\n        for x in self {\n            if f(x) {\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Searches for an element of an iterator that satisfies a predicate.\n    ///\n    /// `find()` takes a closure that returns `true` or `false`. It applies\n    /// this closure to each element of the iterator, and if any of them return\n    /// `true`, then `find()` returns [`Some(element)`]. If they all return\n    /// `false`, it returns [`None`].\n    ///\n    /// `find()` is short-circuiting; in other words, it will stop processing\n    /// as soon as the closure returns `true`.\n    ///\n    /// Because `find()` takes a reference, and many iterators iterate over\n    /// references, this leads to a possibly confusing situation where the\n    /// argument is a double reference. You can see this effect in the\n    /// examples below, with `&&x`.\n    ///\n    /// [`Some(element)`]: ../../std/option/enum.Option.html#variant.Some\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// assert_eq!(a.iter().find(|&&x| x == 2), Some(&2));\n    ///\n    /// assert_eq!(a.iter().find(|&&x| x == 5), None);\n    /// ```\n    ///\n    /// Stopping at the first `true`:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter();\n    ///\n    /// assert_eq!(iter.find(|&&x| x == 2), Some(&2));\n    ///\n    /// // we can still use `iter`, as there are more elements.\n    /// assert_eq!(iter.next(), Some(&3));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n        Self: Sized,\n        P: FnMut(&Self::Item) -> bool,\n    {\n        for x in self {\n            if predicate(&x) { return Some(x) }\n        }\n        None\n    }\n\n    /// Searches for an element in an iterator, returning its index.\n    ///\n    /// `position()` takes a closure that returns `true` or `false`. It applies\n    /// this closure to each element of the iterator, and if one of them\n    /// returns `true`, then `position()` returns [`Some(index)`]. If all of\n    /// them return `false`, it returns [`None`].\n    ///\n    /// `position()` is short-circuiting; in other words, it will stop\n    /// processing as soon as it finds a `true`.\n    ///\n    /// # Overflow Behavior\n    ///\n    /// The method does no guarding against overflows, so if there are more\n    /// than [`usize::MAX`] non-matching elements, it either produces the wrong\n    /// result or panics. If debug assertions are enabled, a panic is\n    /// guaranteed.\n    ///\n    /// # Panics\n    ///\n    /// This function might panic if the iterator has more than `usize::MAX`\n    /// non-matching elements.\n    ///\n    /// [`Some(index)`]: ../../std/option/enum.Option.html#variant.Some\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// assert_eq!(a.iter().position(|&x| x == 2), Some(1));\n    ///\n    /// assert_eq!(a.iter().position(|&x| x == 5), None);\n    /// ```\n    ///\n    /// Stopping at the first `true`:\n    ///\n    /// ```\n    /// let a = [1, 2, 3, 4];\n    ///\n    /// let mut iter = a.iter();\n    ///\n    /// assert_eq!(iter.position(|&x| x >= 2), Some(1));\n    ///\n    /// // we can still use `iter`, as there are more elements.\n    /// assert_eq!(iter.next(), Some(&3));\n    ///\n    /// // The returned index depends on iterator state\n    /// assert_eq!(iter.position(|&x| x == 4), Some(0));\n    ///\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n        Self: Sized,\n        P: FnMut(Self::Item) -> bool,\n    {\n        // `enumerate` might overflow.\n        for (i, x) in self.enumerate() {\n            if predicate(x) {\n                return Some(i);\n            }\n        }\n        None\n    }\n\n    /// Searches for an element in an iterator from the right, returning its\n    /// index.\n    ///\n    /// `rposition()` takes a closure that returns `true` or `false`. It applies\n    /// this closure to each element of the iterator, starting from the end,\n    /// and if one of them returns `true`, then `rposition()` returns\n    /// [`Some(index)`]. If all of them return `false`, it returns [`None`].\n    ///\n    /// `rposition()` is short-circuiting; in other words, it will stop\n    /// processing as soon as it finds a `true`.\n    ///\n    /// [`Some(index)`]: ../../std/option/enum.Option.html#variant.Some\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// assert_eq!(a.iter().rposition(|&x| x == 3), Some(2));\n    ///\n    /// assert_eq!(a.iter().rposition(|&x| x == 5), None);\n    /// ```\n    ///\n    /// Stopping at the first `true`:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter();\n    ///\n    /// assert_eq!(iter.rposition(|&x| x == 2), Some(1));\n    ///\n    /// // we can still use `iter`, as there are more elements.\n    /// assert_eq!(iter.next(), Some(&1));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n        P: FnMut(Self::Item) -> bool,\n        Self: Sized + ExactSizeIterator + DoubleEndedIterator\n    {\n        let mut i = self.len();\n\n        while let Some(v) = self.next_back() {\n            // No need for an overflow check here, because `ExactSizeIterator`\n            // implies that the number of elements fits into a `usize`.\n            i -= 1;\n            if predicate(v) {\n                return Some(i);\n            }\n        }\n        None\n    }\n\n    /// Returns the maximum element of an iterator.\n    ///\n    /// If several elements are equally maximum, the last element is\n    /// returned. If the iterator is empty, [`None`] is returned.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// let b: Vec<u32> = Vec::new();\n    ///\n    /// assert_eq!(a.iter().max(), Some(&3));\n    /// assert_eq!(b.iter().max(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n    {\n        select_fold1(self,\n                     |_| (),\n                     // switch to y even if it is only equal, to preserve\n                     // stability.\n                     |_, x, _, y| *x <= *y)\n            .map(|(_, x)| x)\n    }\n\n    /// Returns the minimum element of an iterator.\n    ///\n    /// If several elements are equally minimum, the first element is\n    /// returned. If the iterator is empty, [`None`] is returned.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// let b: Vec<u32> = Vec::new();\n    ///\n    /// assert_eq!(a.iter().min(), Some(&1));\n    /// assert_eq!(b.iter().min(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n    {\n        select_fold1(self,\n                     |_| (),\n                     // only switch to y if it is strictly smaller, to\n                     // preserve stability.\n                     |_, x, _, y| *x > *y)\n            .map(|(_, x)| x)\n    }\n\n    /// Returns the element that gives the maximum value from the\n    /// specified function.\n    ///\n    /// If several elements are equally maximum, the last element is\n    /// returned. If the iterator is empty, [`None`] is returned.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(*a.iter().max_by_key(|x| x.abs()).unwrap(), -10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n        where Self: Sized, F: FnMut(&Self::Item) -> B,\n    {\n        select_fold1(self,\n                     f,\n                     // switch to y even if it is only equal, to preserve\n                     // stability.\n                     |x_p, _, y_p, _| x_p <= y_p)\n            .map(|(_, x)| x)\n    }\n\n    /// Returns the element that gives the maximum value with respect to the\n    /// specified comparison function.\n    ///\n    /// If several elements are equally maximum, the last element is\n    /// returned. If the iterator is empty, [`None`] is returned.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(*a.iter().max_by(|x, y| x.cmp(y)).unwrap(), 5);\n    /// ```\n    #[inline]\n    #[stable(feature = \"iter_max_by\", since = \"1.15.0\")]\n    fn max_by<F>(self, mut compare: F) -> Option<Self::Item>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n    {\n        select_fold1(self,\n                     |_| (),\n                     // switch to y even if it is only equal, to preserve\n                     // stability.\n                     |_, x, _, y| Ordering::Greater != compare(x, y))\n            .map(|(_, x)| x)\n    }\n\n    /// Returns the element that gives the minimum value from the\n    /// specified function.\n    ///\n    /// If several elements are equally minimum, the first element is\n    /// returned. If the iterator is empty, [`None`] is returned.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n    /// ```\n    #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n        where Self: Sized, F: FnMut(&Self::Item) -> B,\n    {\n        select_fold1(self,\n                     f,\n                     // only switch to y if it is strictly smaller, to\n                     // preserve stability.\n                     |x_p, _, y_p, _| x_p > y_p)\n            .map(|(_, x)| x)\n    }\n\n    /// Returns the element that gives the minimum value with respect to the\n    /// specified comparison function.\n    ///\n    /// If several elements are equally minimum, the first element is\n    /// returned. If the iterator is empty, [`None`] is returned.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = [-3_i32, 0, 1, 5, -10];\n    /// assert_eq!(*a.iter().min_by(|x, y| x.cmp(y)).unwrap(), -10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"iter_min_by\", since = \"1.15.0\")]\n    fn min_by<F>(self, mut compare: F) -> Option<Self::Item>\n        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n    {\n        select_fold1(self,\n                     |_| (),\n                     // switch to y even if it is strictly smaller, to\n                     // preserve stability.\n                     |_, x, _, y| Ordering::Greater == compare(x, y))\n            .map(|(_, x)| x)\n    }\n\n\n    /// Reverses an iterator's direction.\n    ///\n    /// Usually, iterators iterate from left to right. After using `rev()`,\n    /// an iterator will instead iterate from right to left.\n    ///\n    /// This is only possible if the iterator has an end, so `rev()` only\n    /// works on [`DoubleEndedIterator`]s.\n    ///\n    /// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter().rev();\n    ///\n    /// assert_eq!(iter.next(), Some(&3));\n    /// assert_eq!(iter.next(), Some(&2));\n    /// assert_eq!(iter.next(), Some(&1));\n    ///\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn rev(self) -> Rev<Self> where Self: Sized + DoubleEndedIterator {\n        Rev{iter: self}\n    }\n\n    /// Converts an iterator of pairs into a pair of containers.\n    ///\n    /// `unzip()` consumes an entire iterator of pairs, producing two\n    /// collections: one from the left elements of the pairs, and one\n    /// from the right elements.\n    ///\n    /// This function is, in some sense, the opposite of [`zip`].\n    ///\n    /// [`zip`]: #method.zip\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [(1, 2), (3, 4)];\n    ///\n    /// let (left, right): (Vec<_>, Vec<_>) = a.iter().cloned().unzip();\n    ///\n    /// assert_eq!(left, [1, 3]);\n    /// assert_eq!(right, [2, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where\n        FromA: Default + Extend<A>,\n        FromB: Default + Extend<B>,\n        Self: Sized + Iterator<Item=(A, B)>,\n    {\n        let mut ts: FromA = Default::default();\n        let mut us: FromB = Default::default();\n\n        for (t, u) in self {\n            ts.extend(Some(t));\n            us.extend(Some(u));\n        }\n\n        (ts, us)\n    }\n\n    /// Creates an iterator which [`clone`]s all of its elements.\n    ///\n    /// This is useful when you have an iterator over `&T`, but you need an\n    /// iterator over `T`.\n    ///\n    /// [`clone`]: ../../std/clone/trait.Clone.html#tymethod.clone\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let v_cloned: Vec<_> = a.iter().cloned().collect();\n    ///\n    /// // cloned is the same as .map(|&x| x), for integers\n    /// let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n    ///\n    /// assert_eq!(v_cloned, vec![1, 2, 3]);\n    /// assert_eq!(v_map, vec![1, 2, 3]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn cloned<'a, T: 'a>(self) -> Cloned<Self>\n        where Self: Sized + Iterator<Item=&'a T>, T: Clone\n    {\n        Cloned { it: self }\n    }\n\n    /// Repeats an iterator endlessly.\n    ///\n    /// Instead of stopping at [`None`], the iterator will instead start again,\n    /// from the beginning. After iterating again, it will start at the\n    /// beginning again. And again. And again. Forever.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut it = a.iter().cycle();\n    ///\n    /// assert_eq!(it.next(), Some(&1));\n    /// assert_eq!(it.next(), Some(&2));\n    /// assert_eq!(it.next(), Some(&3));\n    /// assert_eq!(it.next(), Some(&1));\n    /// assert_eq!(it.next(), Some(&2));\n    /// assert_eq!(it.next(), Some(&3));\n    /// assert_eq!(it.next(), Some(&1));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    fn cycle(self) -> Cycle<Self> where Self: Sized + Clone {\n        Cycle{orig: self.clone(), iter: self}\n    }\n\n    /// Sums the elements of an iterator.\n    ///\n    /// Takes each element, adds them together, and returns the result.\n    ///\n    /// An empty iterator returns the zero value of the type.\n    ///\n    /// # Panics\n    ///\n    /// When calling `sum()` and a primitive integer type is being returned, this\n    /// method will panic if the computation overflows and debug assertions are\n    /// enabled.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// let sum: i32 = a.iter().sum();\n    ///\n    /// assert_eq!(sum, 6);\n    /// ```\n    #[stable(feature = \"iter_arith\", since = \"1.11.0\")]\n    fn sum<S>(self) -> S\n        where Self: Sized,\n              S: Sum<Self::Item>,\n    {\n        Sum::sum(self)\n    }\n\n    /// Iterates over the entire iterator, multiplying all the elements\n    ///\n    /// An empty iterator returns the one value of the type.\n    ///\n    /// # Panics\n    ///\n    /// When calling `product()` and a primitive integer type is being returned,\n    /// method will panic if the computation overflows and debug assertions are\n    /// enabled.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// fn factorial(n: u32) -> u32 {\n    ///     (1..).take_while(|&i| i <= n).product()\n    /// }\n    /// assert_eq!(factorial(0), 1);\n    /// assert_eq!(factorial(1), 1);\n    /// assert_eq!(factorial(5), 120);\n    /// ```\n    #[stable(feature = \"iter_arith\", since = \"1.11.0\")]\n    fn product<P>(self) -> P\n        where Self: Sized,\n              P: Product<Self::Item>,\n    {\n        Product::product(self)\n    }\n\n    /// Lexicographically compares the elements of this `Iterator` with those\n    /// of another.\n    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n    fn cmp<I>(mut self, other: I) -> Ordering where\n        I: IntoIterator<Item = Self::Item>,\n        Self::Item: Ord,\n        Self: Sized,\n    {\n        let mut other = other.into_iter();\n\n        loop {\n            match (self.next(), other.next()) {\n                (None, None) => return Ordering::Equal,\n                (None, _   ) => return Ordering::Less,\n                (_   , None) => return Ordering::Greater,\n                (Some(x), Some(y)) => match x.cmp(&y) {\n                    Ordering::Equal => (),\n                    non_eq => return non_eq,\n                },\n            }\n        }\n    }\n\n    /// Lexicographically compares the elements of this `Iterator` with those\n    /// of another.\n    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n    fn partial_cmp<I>(mut self, other: I) -> Option<Ordering> where\n        I: IntoIterator,\n        Self::Item: PartialOrd<I::Item>,\n        Self: Sized,\n    {\n        let mut other = other.into_iter();\n\n        loop {\n            match (self.next(), other.next()) {\n                (None, None) => return Some(Ordering::Equal),\n                (None, _   ) => return Some(Ordering::Less),\n                (_   , None) => return Some(Ordering::Greater),\n                (Some(x), Some(y)) => match x.partial_cmp(&y) {\n                    Some(Ordering::Equal) => (),\n                    non_eq => return non_eq,\n                },\n            }\n        }\n    }\n\n    /// Determines if the elements of this `Iterator` are equal to those of\n    /// another.\n    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n    fn eq<I>(mut self, other: I) -> bool where\n        I: IntoIterator,\n        Self::Item: PartialEq<I::Item>,\n        Self: Sized,\n    {\n        let mut other = other.into_iter();\n\n        loop {\n            match (self.next(), other.next()) {\n                (None, None) => return true,\n                (None, _) | (_, None) => return false,\n                (Some(x), Some(y)) => if x != y { return false },\n            }\n        }\n    }\n\n    /// Determines if the elements of this `Iterator` are unequal to those of\n    /// another.\n    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n    fn ne<I>(mut self, other: I) -> bool where\n        I: IntoIterator,\n        Self::Item: PartialEq<I::Item>,\n        Self: Sized,\n    {\n        let mut other = other.into_iter();\n\n        loop {\n            match (self.next(), other.next()) {\n                (None, None) => return false,\n                (None, _) | (_, None) => return true,\n                (Some(x), Some(y)) => if x.ne(&y) { return true },\n            }\n        }\n    }\n\n    /// Determines if the elements of this `Iterator` are lexicographically\n    /// less than those of another.\n    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n    fn lt<I>(mut self, other: I) -> bool where\n        I: IntoIterator,\n        Self::Item: PartialOrd<I::Item>,\n        Self: Sized,\n    {\n        let mut other = other.into_iter();\n\n        loop {\n            match (self.next(), other.next()) {\n                (None, None) => return false,\n                (None, _   ) => return true,\n                (_   , None) => return false,\n                (Some(x), Some(y)) => {\n                    match x.partial_cmp(&y) {\n                        Some(Ordering::Less) => return true,\n                        Some(Ordering::Equal) => {}\n                        Some(Ordering::Greater) => return false,\n                        None => return false,\n                    }\n                },\n            }\n        }\n    }\n\n    /// Determines if the elements of this `Iterator` are lexicographically\n    /// less or equal to those of another.\n    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n    fn le<I>(mut self, other: I) -> bool where\n        I: IntoIterator,\n        Self::Item: PartialOrd<I::Item>,\n        Self: Sized,\n    {\n        let mut other = other.into_iter();\n\n        loop {\n            match (self.next(), other.next()) {\n                (None, None) => return true,\n                (None, _   ) => return true,\n                (_   , None) => return false,\n                (Some(x), Some(y)) => {\n                    match x.partial_cmp(&y) {\n                        Some(Ordering::Less) => return true,\n                        Some(Ordering::Equal) => {}\n                        Some(Ordering::Greater) => return false,\n                        None => return false,\n                    }\n                },\n            }\n        }\n    }\n\n    /// Determines if the elements of this `Iterator` are lexicographically\n    /// greater than those of another.\n    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n    fn gt<I>(mut self, other: I) -> bool where\n        I: IntoIterator,\n        Self::Item: PartialOrd<I::Item>,\n        Self: Sized,\n    {\n        let mut other = other.into_iter();\n\n        loop {\n            match (self.next(), other.next()) {\n                (None, None) => return false,\n                (None, _   ) => return false,\n                (_   , None) => return true,\n                (Some(x), Some(y)) => {\n                    match x.partial_cmp(&y) {\n                        Some(Ordering::Less) => return false,\n                        Some(Ordering::Equal) => {}\n                        Some(Ordering::Greater) => return true,\n                        None => return false,\n                    }\n                }\n            }\n        }\n    }\n\n    /// Determines if the elements of this `Iterator` are lexicographically\n    /// greater than or equal to those of another.\n    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n    fn ge<I>(mut self, other: I) -> bool where\n        I: IntoIterator,\n        Self::Item: PartialOrd<I::Item>,\n        Self: Sized,\n    {\n        let mut other = other.into_iter();\n\n        loop {\n            match (self.next(), other.next()) {\n                (None, None) => return true,\n                (None, _   ) => return false,\n                (_   , None) => return true,\n                (Some(x), Some(y)) => {\n                    match x.partial_cmp(&y) {\n                        Some(Ordering::Less) => return false,\n                        Some(Ordering::Equal) => {}\n                        Some(Ordering::Greater) => return true,\n                        None => return false,\n                    }\n                },\n            }\n        }\n    }\n}\n\n/// Select an element from an iterator based on the given \"projection\"\n/// and \"comparison\" function.\n///\n/// This is an idiosyncratic helper to try to factor out the\n/// commonalities of {max,min}{,_by}. In particular, this avoids\n/// having to implement optimizations several times.\n#[inline]\nfn select_fold1<I, B, FProj, FCmp>(mut it: I,\n                                   mut f_proj: FProj,\n                                   mut f_cmp: FCmp) -> Option<(B, I::Item)>\n    where I: Iterator,\n          FProj: FnMut(&I::Item) -> B,\n          FCmp: FnMut(&B, &I::Item, &B, &I::Item) -> bool\n{\n    // start with the first element as our selection. This avoids\n    // having to use `Option`s inside the loop, translating to a\n    // sizeable performance gain (6x in one case).\n    it.next().map(|mut sel| {\n        let mut sel_p = f_proj(&sel);\n\n        for x in it {\n            let x_p = f_proj(&x);\n            if f_cmp(&sel_p, &sel, &x_p, &x) {\n                sel = x;\n                sel_p = x_p;\n            }\n        }\n        (sel_p, sel)\n    })\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {\n    type Item = I::Item;\n    fn next(&mut self) -> Option<I::Item> { (**self).next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        (**self).nth(n)\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Character manipulation.\n//!\n//! For more details, see ::std_unicode::char (a.k.a. std::char)\n\n#![allow(non_snake_case)]\n#![stable(feature = \"core_char\", since = \"1.2.0\")]\n\nuse char_private::is_printable;\nuse convert::TryFrom;\nuse fmt::{self, Write};\nuse slice;\nuse str::{from_utf8_unchecked_mut, FromStr};\nuse iter::FusedIterator;\nuse mem::transmute;\n\n// UTF-8 ranges and tags for encoding characters\nconst TAG_CONT: u8    = 0b1000_0000;\nconst TAG_TWO_B: u8   = 0b1100_0000;\nconst TAG_THREE_B: u8 = 0b1110_0000;\nconst TAG_FOUR_B: u8  = 0b1111_0000;\nconst MAX_ONE_B: u32   =     0x80;\nconst MAX_TWO_B: u32   =    0x800;\nconst MAX_THREE_B: u32 =  0x10000;\n\n/*\n    Lu  Uppercase_Letter        an uppercase letter\n    Ll  Lowercase_Letter        a lowercase letter\n    Lt  Titlecase_Letter        a digraphic character, with first part uppercase\n    Lm  Modifier_Letter         a modifier letter\n    Lo  Other_Letter            other letters, including syllables and ideographs\n    Mn  Nonspacing_Mark         a nonspacing combining mark (zero advance width)\n    Mc  Spacing_Mark            a spacing combining mark (positive advance width)\n    Me  Enclosing_Mark          an enclosing combining mark\n    Nd  Decimal_Number          a decimal digit\n    Nl  Letter_Number           a letterlike numeric character\n    No  Other_Number            a numeric character of other type\n    Pc  Connector_Punctuation   a connecting punctuation mark, like a tie\n    Pd  Dash_Punctuation        a dash or hyphen punctuation mark\n    Ps  Open_Punctuation        an opening punctuation mark (of a pair)\n    Pe  Close_Punctuation       a closing punctuation mark (of a pair)\n    Pi  Initial_Punctuation     an initial quotation mark\n    Pf  Final_Punctuation       a final quotation mark\n    Po  Other_Punctuation       a punctuation mark of other type\n    Sm  Math_Symbol             a symbol of primarily mathematical use\n    Sc  Currency_Symbol         a currency sign\n    Sk  Modifier_Symbol         a non-letterlike modifier symbol\n    So  Other_Symbol            a symbol of other type\n    Zs  Space_Separator         a space character (of various non-zero widths)\n    Zl  Line_Separator          U+2028 LINE SEPARATOR only\n    Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only\n    Cc  Control                 a C0 or C1 control code\n    Cf  Format                  a format control character\n    Cs  Surrogate               a surrogate code point\n    Co  Private_Use             a private-use character\n    Cn  Unassigned              a reserved unassigned code point or a noncharacter\n*/\n\n/// The highest valid code point a `char` can have.\n///\n/// A [`char`] is a [Unicode Scalar Value], which means that it is a [Code\n/// Point], but only ones within a certain range. `MAX` is the highest valid\n/// code point that's a valid [Unicode Scalar Value].\n///\n/// [`char`]: ../../std/primitive.char.html\n/// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n/// [Code Point]: http://www.unicode.org/glossary/#code_point\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MAX: char = '\\u{10ffff}';\n\n/// Converts a `u32` to a `char`.\n///\n/// Note that all [`char`]s are valid [`u32`]s, and can be casted to one with\n/// [`as`]:\n///\n/// ```\n/// let c = '';\n/// let i = c as u32;\n///\n/// assert_eq!(128175, i);\n/// ```\n///\n/// However, the reverse is not true: not all valid [`u32`]s are valid\n/// [`char`]s. `from_u32()` will return `None` if the input is not a valid value\n/// for a [`char`].\n///\n/// [`char`]: ../../std/primitive.char.html\n/// [`u32`]: ../../std/primitive.u32.html\n/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n///\n/// For an unsafe version of this function which ignores these checks, see\n/// [`from_u32_unchecked`].\n///\n/// [`from_u32_unchecked`]: fn.from_u32_unchecked.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::char;\n///\n/// let c = char::from_u32(0x2764);\n///\n/// assert_eq!(Some(''), c);\n/// ```\n///\n/// Returning `None` when the input is not a valid [`char`]:\n///\n/// ```\n/// use std::char;\n///\n/// let c = char::from_u32(0x110000);\n///\n/// assert_eq!(None, c);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn from_u32(i: u32) -> Option<char> {\n    char::try_from(i).ok()\n}\n\n/// Converts a `u32` to a `char`, ignoring validity.\n///\n/// Note that all [`char`]s are valid [`u32`]s, and can be casted to one with\n/// [`as`]:\n///\n/// ```\n/// let c = '';\n/// let i = c as u32;\n///\n/// assert_eq!(128175, i);\n/// ```\n///\n/// However, the reverse is not true: not all valid [`u32`]s are valid\n/// [`char`]s. `from_u32_unchecked()` will ignore this, and blindly cast to\n/// [`char`], possibly creating an invalid one.\n///\n/// [`char`]: ../../std/primitive.char.html\n/// [`u32`]: ../../std/primitive.u32.html\n/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n///\n/// # Safety\n///\n/// This function is unsafe, as it may construct invalid `char` values.\n///\n/// For a safe version of this function, see the [`from_u32`] function.\n///\n/// [`from_u32`]: fn.from_u32.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::char;\n///\n/// let c = unsafe { char::from_u32_unchecked(0x2764) };\n///\n/// assert_eq!('', c);\n/// ```\n#[inline]\n#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\npub unsafe fn from_u32_unchecked(i: u32) -> char {\n    transmute(i)\n}\n\n#[stable(feature = \"char_convert\", since = \"1.13.0\")]\nimpl From<char> for u32 {\n    #[inline]\n    fn from(c: char) -> Self {\n        c as u32\n    }\n}\n\n/// Maps a byte in 0x00...0xFF to a `char` whose code point has the same value, in U+0000 to U+00FF.\n///\n/// Unicode is designed such that this effectively decodes bytes\n/// with the character encoding that IANA calls ISO-8859-1.\n/// This encoding is compatible with ASCII.\n///\n/// Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen),\n/// which leaves some \"blanks\", byte values that are not assigned to any character.\n/// ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.\n///\n/// Note that this is *also* different from Windows-1252 a.k.a. code page 1252,\n/// which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks\n/// to punctuation and various Latin characters.\n///\n/// To confuse things further, [on the Web](https://encoding.spec.whatwg.org/)\n/// `ascii`, `iso-8859-1`, and `windows-1252` are all aliases\n/// for a superset of Windows-1252 that fills the remaining blanks with corresponding\n/// C0 and C1 control codes.\n#[stable(feature = \"char_convert\", since = \"1.13.0\")]\nimpl From<u8> for char {\n    #[inline]\n    fn from(i: u8) -> Self {\n        i as char\n    }\n}\n\n\n/// An error which can be returned when parsing a char.\n#[stable(feature = \"char_from_str\", since = \"1.19.0\")]\n#[derive(Clone, Debug)]\npub struct ParseCharError {\n    kind: CharErrorKind,\n}\n\nimpl ParseCharError {\n    #[unstable(feature = \"char_error_internals\",\n               reason = \"this method should not be available publicly\",\n               issue = \"0\")]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n        match self.kind {\n            CharErrorKind::EmptyString => {\n                \"cannot parse char from empty string\"\n            },\n            CharErrorKind::TooManyChars => \"too many characters in string\"\n        }\n    }\n}\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\nenum CharErrorKind {\n    EmptyString,\n    TooManyChars,\n}\n\n#[stable(feature = \"char_from_str\", since = \"1.19.0\")]\nimpl fmt::Display for ParseCharError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.__description().fmt(f)\n    }\n}\n\n\n#[stable(feature = \"char_from_str\", since = \"1.19.0\")]\nimpl FromStr for char {\n    type Err = ParseCharError;\n\n    #[inline]\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let mut chars = s.chars();\n        match (chars.next(), chars.next()) {\n            (None, _) => {\n                Err(ParseCharError { kind: CharErrorKind::EmptyString })\n            },\n            (Some(c), None) => Ok(c),\n            _ => {\n                Err(ParseCharError { kind: CharErrorKind::TooManyChars })\n            }\n        }\n    }\n}\n\n\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl TryFrom<u32> for char {\n    type Error = CharTryFromError;\n\n    #[inline]\n    fn try_from(i: u32) -> Result<Self, Self::Error> {\n        if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n            Err(CharTryFromError(()))\n        } else {\n            Ok(unsafe { from_u32_unchecked(i) })\n        }\n    }\n}\n\n/// The error type returned when a conversion from u32 to char fails.\n#[unstable(feature = \"try_from\", issue = \"33417\")]\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub struct CharTryFromError(());\n\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl fmt::Display for CharTryFromError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        \"converted integer out of range for `char`\".fmt(f)\n    }\n}\n\n/// Converts a digit in the given radix to a `char`.\n///\n/// A 'radix' here is sometimes also called a 'base'. A radix of two\n/// indicates a binary number, a radix of ten, decimal, and a radix of\n/// sixteen, hexadecimal, to give some common values. Arbitrary\n/// radices are supported.\n///\n/// `from_digit()` will return `None` if the input is not a digit in\n/// the given radix.\n///\n/// # Panics\n///\n/// Panics if given a radix larger than 36.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::char;\n///\n/// let c = char::from_digit(4, 10);\n///\n/// assert_eq!(Some('4'), c);\n///\n/// // Decimal 11 is a single digit in base 16\n/// let c = char::from_digit(11, 16);\n///\n/// assert_eq!(Some('b'), c);\n/// ```\n///\n/// Returning `None` when the input is not a digit:\n///\n/// ```\n/// use std::char;\n///\n/// let c = char::from_digit(20, 10);\n///\n/// assert_eq!(None, c);\n/// ```\n///\n/// Passing a large radix, causing a panic:\n///\n/// ```\n/// use std::thread;\n/// use std::char;\n///\n/// let result = thread::spawn(|| {\n///     // this panics\n///     let c = char::from_digit(1, 37);\n/// }).join();\n///\n/// assert!(result.is_err());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn from_digit(num: u32, radix: u32) -> Option<char> {\n    if radix > 36 {\n        panic!(\"from_digit: radix is too high (maximum 36)\");\n    }\n    if num < radix {\n        let num = num as u8;\n        if num < 10 {\n            Some((b'0' + num) as char)\n        } else {\n            Some((b'a' + num - 10) as char)\n        }\n    } else {\n        None\n    }\n}\n\n// NB: the stabilization and documentation for this trait is in\n// unicode/char.rs, not here\n#[allow(missing_docs)] // docs in libunicode/u_char.rs\n#[doc(hidden)]\n#[unstable(feature = \"core_char_ext\",\n           reason = \"the stable interface is `impl char` in later crate\",\n           issue = \"32110\")]\npub trait CharExt {\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_digit(self, radix: u32) -> bool;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn to_digit(self, radix: u32) -> Option<u32>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn escape_unicode(self) -> EscapeUnicode;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn escape_default(self) -> EscapeDefault;\n    #[unstable(feature = \"char_escape_debug\", issue = \"35068\")]\n    fn escape_debug(self) -> EscapeDebug;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn len_utf8(self) -> usize;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn len_utf16(self) -> usize;\n    #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n    fn encode_utf8(self, dst: &mut [u8]) -> &mut str;\n    #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n    fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16];\n}\n\n#[stable(feature = \"core\", since = \"1.6.0\")]\nimpl CharExt for char {\n    #[inline]\n    fn is_digit(self, radix: u32) -> bool {\n        self.to_digit(radix).is_some()\n    }\n\n    #[inline]\n    fn to_digit(self, radix: u32) -> Option<u32> {\n        if radix > 36 {\n            panic!(\"to_digit: radix is too high (maximum 36)\");\n        }\n        let val = match self {\n          '0' ... '9' => self as u32 - '0' as u32,\n          'a' ... 'z' => self as u32 - 'a' as u32 + 10,\n          'A' ... 'Z' => self as u32 - 'A' as u32 + 10,\n          _ => return None,\n        };\n        if val < radix { Some(val) }\n        else { None }\n    }\n\n    #[inline]\n    fn escape_unicode(self) -> EscapeUnicode {\n        let c = self as u32;\n\n        // or-ing 1 ensures that for c==0 the code computes that one\n        // digit should be printed and (which is the same) avoids the\n        // (31 - 32) underflow\n        let msb = 31 - (c | 1).leading_zeros();\n\n        // the index of the most significant hex digit\n        let ms_hex_digit = msb / 4;\n        EscapeUnicode {\n            c: self,\n            state: EscapeUnicodeState::Backslash,\n            hex_digit_idx: ms_hex_digit as usize,\n        }\n    }\n\n    #[inline]\n    fn escape_default(self) -> EscapeDefault {\n        let init_state = match self {\n            '\\t' => EscapeDefaultState::Backslash('t'),\n            '\\r' => EscapeDefaultState::Backslash('r'),\n            '\\n' => EscapeDefaultState::Backslash('n'),\n            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n            '\\x20' ... '\\x7e' => EscapeDefaultState::Char(self),\n            _ => EscapeDefaultState::Unicode(self.escape_unicode())\n        };\n        EscapeDefault { state: init_state }\n    }\n\n    #[inline]\n    fn escape_debug(self) -> EscapeDebug {\n        let init_state = match self {\n            '\\t' => EscapeDefaultState::Backslash('t'),\n            '\\r' => EscapeDefaultState::Backslash('r'),\n            '\\n' => EscapeDefaultState::Backslash('n'),\n            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n            c if is_printable(c) => EscapeDefaultState::Char(c),\n            c => EscapeDefaultState::Unicode(c.escape_unicode()),\n        };\n        EscapeDebug(EscapeDefault { state: init_state })\n    }\n\n    #[inline]\n    fn len_utf8(self) -> usize {\n        let code = self as u32;\n        if code < MAX_ONE_B {\n            1\n        } else if code < MAX_TWO_B {\n            2\n        } else if code < MAX_THREE_B {\n            3\n        } else {\n            4\n        }\n    }\n\n    #[inline]\n    fn len_utf16(self) -> usize {\n        let ch = self as u32;\n        if (ch & 0xFFFF) == ch { 1 } else { 2 }\n    }\n\n    #[inline]\n    fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n        let code = self as u32;\n        unsafe {\n            let len =\n            if code < MAX_ONE_B && !dst.is_empty() {\n                *dst.get_unchecked_mut(0) = code as u8;\n                1\n            } else if code < MAX_TWO_B && dst.len() >= 2 {\n                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;\n                2\n            } else if code < MAX_THREE_B && dst.len() >= 3  {\n                *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n                *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;\n                3\n            } else if dst.len() >= 4 {\n                *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n                *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;\n                4\n            } else {\n                panic!(\"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n                    from_u32_unchecked(code).len_utf8(),\n                    code,\n                    dst.len())\n            };\n            from_utf8_unchecked_mut(dst.get_unchecked_mut(..len))\n        }\n    }\n\n    #[inline]\n    fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n        let mut code = self as u32;\n        unsafe {\n            if (code & 0xFFFF) == code && !dst.is_empty() {\n                // The BMP falls through (assuming non-surrogate, as it should)\n                *dst.get_unchecked_mut(0) = code as u16;\n                slice::from_raw_parts_mut(dst.as_mut_ptr(), 1)\n            } else if dst.len() >= 2 {\n                // Supplementary planes break into surrogates.\n                code -= 0x1_0000;\n                *dst.get_unchecked_mut(0) = 0xD800 | ((code >> 10) as u16);\n                *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n                slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n            } else {\n                panic!(\"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n                    from_u32_unchecked(code).len_utf16(),\n                    code,\n                    dst.len())\n            }\n        }\n    }\n}\n\n/// Returns an iterator that yields the hexadecimal Unicode escape of a\n/// character, as `char`s.\n///\n/// This `struct` is created by the [`escape_unicode`] method on [`char`]. See\n/// its documentation for more.\n///\n/// [`escape_unicode`]: ../../std/primitive.char.html#method.escape_unicode\n/// [`char`]: ../../std/primitive.char.html\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct EscapeUnicode {\n    c: char,\n    state: EscapeUnicodeState,\n\n    // The index of the next hex digit to be printed (0 if none),\n    // i.e. the number of remaining hex digits to be printed;\n    // increasing from the least significant digit: 0x543210\n    hex_digit_idx: usize,\n}\n\n// The enum values are ordered so that their representation is the\n// same as the remaining length (besides the hexadecimal digits). This\n// likely makes `len()` a single load from memory) and inline-worth.\n#[derive(Clone, Debug)]\nenum EscapeUnicodeState {\n    Done,\n    RightBrace,\n    Value,\n    LeftBrace,\n    Type,\n    Backslash,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for EscapeUnicode {\n    type Item = char;\n\n    fn next(&mut self) -> Option<char> {\n        match self.state {\n            EscapeUnicodeState::Backslash => {\n                self.state = EscapeUnicodeState::Type;\n                Some('\\\\')\n            }\n            EscapeUnicodeState::Type => {\n                self.state = EscapeUnicodeState::LeftBrace;\n                Some('u')\n            }\n            EscapeUnicodeState::LeftBrace => {\n                self.state = EscapeUnicodeState::Value;\n                Some('{')\n            }\n            EscapeUnicodeState::Value => {\n                let hex_digit = ((self.c as u32) >> (self.hex_digit_idx * 4)) & 0xf;\n                let c = from_digit(hex_digit, 16).unwrap();\n                if self.hex_digit_idx == 0 {\n                    self.state = EscapeUnicodeState::RightBrace;\n                } else {\n                    self.hex_digit_idx -= 1;\n                }\n                Some(c)\n            }\n            EscapeUnicodeState::RightBrace => {\n                self.state = EscapeUnicodeState::Done;\n                Some('}')\n            }\n            EscapeUnicodeState::Done => None,\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.len();\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    fn last(self) -> Option<char> {\n        match self.state {\n            EscapeUnicodeState::Done => None,\n\n            EscapeUnicodeState::RightBrace |\n            EscapeUnicodeState::Value |\n            EscapeUnicodeState::LeftBrace |\n            EscapeUnicodeState::Type |\n            EscapeUnicodeState::Backslash => Some('}'),\n        }\n    }\n}\n\n#[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\nimpl ExactSizeIterator for EscapeUnicode {\n    #[inline]\n    fn len(&self) -> usize {\n        // The match is a single memory access with no branching\n        self.hex_digit_idx + match self.state {\n            EscapeUnicodeState::Done => 0,\n            EscapeUnicodeState::RightBrace => 1,\n            EscapeUnicodeState::Value => 2,\n            EscapeUnicodeState::LeftBrace => 3,\n            EscapeUnicodeState::Type => 4,\n            EscapeUnicodeState::Backslash => 5,\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl FusedIterator for EscapeUnicode {}\n\n#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\nimpl fmt::Display for EscapeUnicode {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for c in self.clone() {\n            f.write_char(c)?;\n        }\n        Ok(())\n    }\n}\n\n/// An iterator that yields the literal escape code of a `char`.\n///\n/// This `struct` is created by the [`escape_default`] method on [`char`]. See\n/// its documentation for more.\n///\n/// [`escape_default`]: ../../std/primitive.char.html#method.escape_default\n/// [`char`]: ../../std/primitive.char.html\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct EscapeDefault {\n    state: EscapeDefaultState\n}\n\n#[derive(Clone, Debug)]\nenum EscapeDefaultState {\n    Done,\n    Char(char),\n    Backslash(char),\n    Unicode(EscapeUnicode),\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for EscapeDefault {\n    type Item = char;\n\n    fn next(&mut self) -> Option<char> {\n        match self.state {\n            EscapeDefaultState::Backslash(c) => {\n                self.state = EscapeDefaultState::Char(c);\n                Some('\\\\')\n            }\n            EscapeDefaultState::Char(c) => {\n                self.state = EscapeDefaultState::Done;\n                Some(c)\n            }\n            EscapeDefaultState::Done => None,\n            EscapeDefaultState::Unicode(ref mut iter) => iter.next(),\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.len();\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    fn nth(&mut self, n: usize) -> Option<char> {\n        match self.state {\n            EscapeDefaultState::Backslash(c) if n == 0 => {\n                self.state = EscapeDefaultState::Char(c);\n                Some('\\\\')\n            },\n            EscapeDefaultState::Backslash(c) if n == 1 => {\n                self.state = EscapeDefaultState::Done;\n                Some(c)\n            },\n            EscapeDefaultState::Backslash(_) => {\n                self.state = EscapeDefaultState::Done;\n                None\n            },\n            EscapeDefaultState::Char(c) => {\n                self.state = EscapeDefaultState::Done;\n\n                if n == 0 {\n                    Some(c)\n                } else {\n                    None\n                }\n            },\n            EscapeDefaultState::Done => return None,\n            EscapeDefaultState::Unicode(ref mut i) => return i.nth(n),\n        }\n    }\n\n    fn last(self) -> Option<char> {\n        match self.state {\n            EscapeDefaultState::Unicode(iter) => iter.last(),\n            EscapeDefaultState::Done => None,\n            EscapeDefaultState::Backslash(c) | EscapeDefaultState::Char(c) => Some(c),\n        }\n    }\n}\n\n#[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\nimpl ExactSizeIterator for EscapeDefault {\n    fn len(&self) -> usize {\n        match self.state {\n            EscapeDefaultState::Done => 0,\n            EscapeDefaultState::Char(_) => 1,\n            EscapeDefaultState::Backslash(_) => 2,\n            EscapeDefaultState::Unicode(ref iter) => iter.len(),\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl FusedIterator for EscapeDefault {}\n\n#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\nimpl fmt::Display for EscapeDefault {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for c in self.clone() {\n            f.write_char(c)?;\n        }\n        Ok(())\n    }\n}\n\n/// An iterator that yields the literal escape code of a `char`.\n///\n/// This `struct` is created by the [`escape_debug`] method on [`char`]. See its\n/// documentation for more.\n///\n/// [`escape_debug`]: ../../std/primitive.char.html#method.escape_debug\n/// [`char`]: ../../std/primitive.char.html\n#[unstable(feature = \"char_escape_debug\", issue = \"35068\")]\n#[derive(Clone, Debug)]\npub struct EscapeDebug(EscapeDefault);\n\n#[unstable(feature = \"char_escape_debug\", issue = \"35068\")]\nimpl Iterator for EscapeDebug {\n    type Item = char;\n    fn next(&mut self) -> Option<char> { self.0.next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n}\n\n#[unstable(feature = \"char_escape_debug\", issue = \"35068\")]\nimpl ExactSizeIterator for EscapeDebug { }\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl FusedIterator for EscapeDebug {}\n\n#[unstable(feature = \"char_escape_debug\", issue = \"35068\")]\nimpl fmt::Display for EscapeDebug {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&self.0, f)\n    }\n}\n\n\n\n/// An iterator over an iterator of bytes of the characters the bytes represent\n/// as UTF-8\n#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n#[derive(Clone, Debug)]\npub struct DecodeUtf8<I: Iterator<Item = u8>>(::iter::Peekable<I>);\n\n/// Decodes an `Iterator` of bytes as UTF-8.\n#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n#[inline]\npub fn decode_utf8<I: IntoIterator<Item = u8>>(i: I) -> DecodeUtf8<I::IntoIter> {\n    DecodeUtf8(i.into_iter().peekable())\n}\n\n/// `<DecodeUtf8 as Iterator>::next` returns this for an invalid input sequence.\n#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n#[derive(PartialEq, Eq, Debug)]\npub struct InvalidSequence(());\n\n#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\nimpl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n    type Item = Result<char, InvalidSequence>;\n    #[inline]\n\n    fn next(&mut self) -> Option<Result<char, InvalidSequence>> {\n        self.0.next().map(|first_byte| {\n            // Emit InvalidSequence according to\n            // Unicode 5.22 Best Practice for U+FFFD Substitution\n            // http://www.unicode.org/versions/Unicode9.0.0/ch05.pdf#G40630\n\n            // Roughly: consume at least one byte,\n            // then validate one byte at a time and stop before the first unexpected byte\n            // (which might be the valid start of the next byte sequence).\n\n            let mut code_point;\n            macro_rules! first_byte {\n                ($mask: expr) => {\n                    code_point = u32::from(first_byte & $mask)\n                }\n            }\n            macro_rules! continuation_byte {\n                () => { continuation_byte!(0x80...0xBF) };\n                ($range: pat) => {\n                    match self.0.peek() {\n                        Some(&byte @ $range) => {\n                            code_point = (code_point << 6) | u32::from(byte & 0b0011_1111);\n                            self.0.next();\n                        }\n                        _ => return Err(InvalidSequence(()))\n                    }\n                }\n            }\n\n            match first_byte {\n                0x00...0x7F => {\n                    first_byte!(0b1111_1111);\n                }\n                0xC2...0xDF => {\n                    first_byte!(0b0001_1111);\n                    continuation_byte!();\n                }\n                0xE0 => {\n                    first_byte!(0b0000_1111);\n                    continuation_byte!(0xA0...0xBF);  // 0x80...0x9F here are overlong\n                    continuation_byte!();\n                }\n                0xE1...0xEC | 0xEE...0xEF => {\n                    first_byte!(0b0000_1111);\n                    continuation_byte!();\n                    continuation_byte!();\n                }\n                0xED => {\n                    first_byte!(0b0000_1111);\n                    continuation_byte!(0x80...0x9F);  // 0xA0..0xBF here are surrogates\n                    continuation_byte!();\n                }\n                0xF0 => {\n                    first_byte!(0b0000_0111);\n                    continuation_byte!(0x90...0xBF);  // 0x80..0x8F here are overlong\n                    continuation_byte!();\n                    continuation_byte!();\n                }\n                0xF1...0xF3 => {\n                    first_byte!(0b0000_0111);\n                    continuation_byte!();\n                    continuation_byte!();\n                    continuation_byte!();\n                }\n                0xF4 => {\n                    first_byte!(0b0000_0111);\n                    continuation_byte!(0x80...0x8F);  // 0x90..0xBF here are beyond char::MAX\n                    continuation_byte!();\n                    continuation_byte!();\n                }\n                _ => return Err(InvalidSequence(()))  // Illegal first byte, overlong, or beyond MAX\n            }\n            unsafe {\n                Ok(from_u32_unchecked(code_point))\n            }\n        })\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I: FusedIterator<Item = u8>> FusedIterator for DecodeUtf8<I> {}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Traits for conversions between types.\n//!\n//! The traits in this module provide a general way to talk about conversions\n//! from one type to another. They follow the standard Rust conventions of\n//! `as`/`into`/`from`.\n//!\n//! Like many traits, these are often used as bounds for generic functions, to\n//! support arguments of multiple types.\n//!\n//! - Implement the `As*` traits for reference-to-reference conversions\n//! - Implement the [`Into`] trait when you want to consume the value in the conversion\n//! - The [`From`] trait is the most flexible, useful for value _and_ reference conversions\n//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`], but allow for the\n//!   conversion to fail\n//!\n//! As a library author, you should prefer implementing [`From<T>`][`From`] or\n//! [`TryFrom<T>`][`TryFrom`] rather than [`Into<U>`][`Into`] or [`TryInto<U>`][`TryInto`],\n//! as [`From`] and [`TryFrom`] provide greater flexibility and offer\n//! equivalent [`Into`] or [`TryInto`] implementations for free, thanks to a\n//! blanket implementation in the standard library.\n//!\n//! # Generic Implementations\n//!\n//! - [`AsRef`] and [`AsMut`] auto-dereference if the inner type is a reference\n//! - [`From`]`<U> for T` implies [`Into`]`<T> for U`\n//! - [`TryFrom`]`<U> for T` implies [`TryInto`]`<T> for U`\n//! - [`From`] and [`Into`] are reflexive, which means that all types can\n//!   `into` themselves and `from` themselves\n//!\n//! See each trait for usage examples.\n//!\n//! [`Into`]: trait.Into.html\n//! [`From`]: trait.From.html\n//! [`TryFrom`]: trait.TryFrom.html\n//! [`TryInto`]: trait.TryInto.html\n//! [`AsRef`]: trait.AsRef.html\n//! [`AsMut`]: trait.AsMut.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse str::FromStr;\n\n/// A cheap reference-to-reference conversion. Used to convert a value to a\n/// reference value within generic code.\n///\n/// `AsRef` is very similar to, but serves a slightly different purpose than,\n/// [`Borrow`].\n///\n/// `AsRef` is to be used when wishing to convert to a reference of another\n/// type.\n/// `Borrow` is more related to the notion of taking the reference. It is\n/// useful when wishing to abstract over the type of reference\n/// (`&T`, `&mut T`) or allow both the referenced and owned type to be treated\n/// in the same manner.\n///\n/// The key difference between the two traits is the intention:\n///\n/// - Use `AsRef` when goal is to simply convert into a reference\n/// - Use `Borrow` when goal is related to writing code that is agnostic to the\n///   type of borrow and if is reference or value\n///\n/// See [the book][book] for a more detailed comparison.\n///\n/// [book]: ../../book/first-edition/borrow-and-asref.html\n/// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n///\n/// **Note: this trait must not fail**. If the conversion can fail, use a\n/// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n///\n/// [`Option<T>`]: ../../std/option/enum.Option.html\n/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n///\n/// # Generic Implementations\n///\n/// - `AsRef` auto-dereferences if the inner type is a reference or a mutable\n///   reference (e.g.: `foo.as_ref()` will work the same if `foo` has type\n///   `&mut Foo` or `&&mut Foo`)\n///\n/// # Examples\n///\n/// Both [`String`] and `&str` implement `AsRef<str>`:\n///\n/// [`String`]: ../../std/string/struct.String.html\n///\n/// ```\n/// fn is_hello<T: AsRef<str>>(s: T) {\n///    assert_eq!(\"hello\", s.as_ref());\n/// }\n///\n/// let s = \"hello\";\n/// is_hello(s);\n///\n/// let s = \"hello\".to_string();\n/// is_hello(s);\n/// ```\n///\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait AsRef<T: ?Sized> {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn as_ref(&self) -> &T;\n}\n\n/// A cheap, mutable reference-to-mutable reference conversion.\n///\n/// This trait is similar to `AsRef` but used for converting between mutable\n/// references.\n///\n/// **Note: this trait must not fail**. If the conversion can fail, use a\n/// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n///\n/// [`Option<T>`]: ../../std/option/enum.Option.html\n/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n///\n/// # Generic Implementations\n///\n/// - `AsMut` auto-dereferences if the inner type is a reference or a mutable\n///   reference (e.g.: `foo.as_ref()` will work the same if `foo` has type\n///   `&mut Foo` or `&&mut Foo`)\n///\n/// # Examples\n///\n/// [`Box<T>`] implements `AsMut<T>`:\n///\n/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n///\n/// ```\n/// fn add_one<T: AsMut<u64>>(num: &mut T) {\n///     *num.as_mut() += 1;\n/// }\n///\n/// let mut boxed_num = Box::new(0);\n/// add_one(&mut boxed_num);\n/// assert_eq!(*boxed_num, 1);\n/// ```\n///\n///\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait AsMut<T: ?Sized> {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn as_mut(&mut self) -> &mut T;\n}\n\n/// A conversion that consumes `self`, which may or may not be expensive. The\n/// reciprocal of [`From`][From].\n///\n/// **Note: this trait must not fail**. If the conversion can fail, use\n/// [`TryInto`] or a dedicated method which returns an [`Option<T>`] or a\n/// [`Result<T, E>`].\n///\n/// Library authors should not directly implement this trait, but should prefer\n/// implementing the [`From`][From] trait, which offers greater flexibility and\n/// provides an equivalent `Into` implementation for free, thanks to a blanket\n/// implementation in the standard library.\n///\n/// # Generic Implementations\n///\n/// - [`From<T>`][From]` for U` implies `Into<U> for T`\n/// - [`into`] is reflexive, which means that `Into<T> for T` is implemented\n///\n/// # Implementing `Into`\n///\n/// There is one exception to implementing `Into`, and it's kind of esoteric.\n/// If the destination type is not part of the current crate, and it uses a\n/// generic variable, then you can't implement `From` directly.  For example,\n/// take this crate:\n///\n/// ```compile_fail\n/// struct Wrapper<T>(Vec<T>);\n/// impl<T> From<Wrapper<T>> for Vec<T> {\n///     fn from(w: Wrapper<T>) -> Vec<T> {\n///         w.0\n///     }\n/// }\n/// ```\n///\n/// To fix this, you can implement `Into` directly:\n///\n/// ```\n/// struct Wrapper<T>(Vec<T>);\n/// impl<T> Into<Vec<T>> for Wrapper<T> {\n///     fn into(self) -> Vec<T> {\n///         self.0\n///     }\n/// }\n/// ```\n///\n/// This won't always allow the conversion: for example, `try!` and `?`\n/// always use `From`. However, in most cases, people use `Into` to do the\n/// conversions, and this will allow that.\n///\n/// In almost all cases, you should try to implement `From`, then fall back\n/// to `Into` if `From` can't be implemented.\n///\n/// # Examples\n///\n/// [`String`] implements `Into<Vec<u8>>`:\n///\n/// ```\n/// fn is_hello<T: Into<Vec<u8>>>(s: T) {\n///    let bytes = b\"hello\".to_vec();\n///    assert_eq!(bytes, s.into());\n/// }\n///\n/// let s = \"hello\".to_string();\n/// is_hello(s);\n/// ```\n///\n/// [`TryInto`]: trait.TryInto.html\n/// [`Option<T>`]: ../../std/option/enum.Option.html\n/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [From]: trait.From.html\n/// [`into`]: trait.Into.html#tymethod.into\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Into<T>: Sized {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn into(self) -> T;\n}\n\n/// Simple and safe type conversions in to `Self`. It is the reciprocal of\n/// `Into`.\n///\n/// This trait is useful when performing error handling as described by\n/// [the book][book] and is closely related to the `?` operator.\n///\n/// When constructing a function that is capable of failing the return type\n/// will generally be of the form `Result<T, E>`.\n///\n/// The `From` trait allows for simplification of error handling by providing a\n/// means of returning a single error type that encapsulates numerous possible\n/// erroneous situations.\n///\n/// This trait is not limited to error handling, rather the general case for\n/// this trait would be in any type conversions to have an explicit definition\n/// of how they are performed.\n///\n/// **Note: this trait must not fail**. If the conversion can fail, use\n/// [`TryFrom`] or a dedicated method which returns an [`Option<T>`] or a\n/// [`Result<T, E>`].\n///\n/// # Generic Implementations\n///\n/// - `From<T> for U` implies [`Into<U>`]` for T`\n/// - [`from`] is reflexive, which means that `From<T> for T` is implemented\n///\n/// # Examples\n///\n/// [`String`] implements `From<&str>`:\n///\n/// ```\n/// let string = \"hello\".to_string();\n/// let other_string = String::from(\"hello\");\n///\n/// assert_eq!(string, other_string);\n/// ```\n///\n/// An example usage for error handling:\n///\n/// ```\n/// use std::io::{self, Read};\n/// use std::num;\n///\n/// enum CliError {\n///     IoError(io::Error),\n///     ParseError(num::ParseIntError),\n/// }\n///\n/// impl From<io::Error> for CliError {\n///     fn from(error: io::Error) -> Self {\n///         CliError::IoError(error)\n///     }\n/// }\n///\n/// impl From<num::ParseIntError> for CliError {\n///     fn from(error: num::ParseIntError) -> Self {\n///         CliError::ParseError(error)\n///     }\n/// }\n///\n/// fn open_and_parse_file(file_name: &str) -> Result<i32, CliError> {\n///     let mut file = std::fs::File::open(\"test\")?;\n///     let mut contents = String::new();\n///     file.read_to_string(&mut contents)?;\n///     let num: i32 = contents.trim().parse()?;\n///     Ok(num)\n/// }\n/// ```\n///\n/// [`TryFrom`]: trait.TryFrom.html\n/// [`Option<T>`]: ../../std/option/enum.Option.html\n/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [`Into<U>`]: trait.Into.html\n/// [`from`]: trait.From.html#tymethod.from\n/// [book]: ../../book/first-edition/error-handling.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait From<T>: Sized {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn from(_: T) -> Self;\n}\n\n/// An attempted conversion that consumes `self`, which may or may not be\n/// expensive.\n///\n/// Library authors should not directly implement this trait, but should prefer\n/// implementing the [`TryFrom`] trait, which offers greater flexibility and\n/// provides an equivalent `TryInto` implementation for free, thanks to a\n/// blanket implementation in the standard library. For more information on this,\n/// see the documentation for [`Into`].\n///\n/// [`TryFrom`]: trait.TryFrom.html\n/// [`Into`]: trait.Into.html\n#[unstable(feature = \"try_from\", issue = \"33417\")]\npub trait TryInto<T>: Sized {\n    /// The type returned in the event of a conversion error.\n    type Error;\n\n    /// Performs the conversion.\n    fn try_into(self) -> Result<T, Self::Error>;\n}\n\n/// Attempt to construct `Self` via a conversion.\n#[unstable(feature = \"try_from\", issue = \"33417\")]\npub trait TryFrom<T>: Sized {\n    /// The type returned in the event of a conversion error.\n    type Error;\n\n    /// Performs the conversion.\n    fn try_from(value: T) -> Result<Self, Self::Error>;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// GENERIC IMPLS\n////////////////////////////////////////////////////////////////////////////////\n\n// As lifts over &\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a T where T: AsRef<U>\n{\n    fn as_ref(&self) -> &U {\n        <T as AsRef<U>>::as_ref(*self)\n    }\n}\n\n// As lifts over &mut\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U>\n{\n    fn as_ref(&self) -> &U {\n        <T as AsRef<U>>::as_ref(*self)\n    }\n}\n\n// FIXME (#23442): replace the above impls for &/&mut with the following more general one:\n// // As lifts over Deref\n// impl<D: ?Sized + Deref, U: ?Sized> AsRef<U> for D where D::Target: AsRef<U> {\n//     fn as_ref(&self) -> &U {\n//         self.deref().as_ref()\n//     }\n// }\n\n// AsMut lifts over &mut\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U>\n{\n    fn as_mut(&mut self) -> &mut U {\n        (*self).as_mut()\n    }\n}\n\n// FIXME (#23442): replace the above impl for &mut with the following more general one:\n// // AsMut lifts over DerefMut\n// impl<D: ?Sized + Deref, U: ?Sized> AsMut<U> for D where D::Target: AsMut<U> {\n//     fn as_mut(&mut self) -> &mut U {\n//         self.deref_mut().as_mut()\n//     }\n// }\n\n// From implies Into\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, U> Into<U> for T where U: From<T>\n{\n    fn into(self) -> U {\n        U::from(self)\n    }\n}\n\n// From (and thus Into) is reflexive\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> From<T> for T {\n    fn from(t: T) -> T { t }\n}\n\n\n// TryFrom implies TryInto\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl<T, U> TryInto<U> for T where U: TryFrom<T>\n{\n    type Error = U::Error;\n\n    fn try_into(self) -> Result<U, U::Error> {\n        U::try_from(self)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// CONCRETE IMPLS\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsRef<[T]> for [T] {\n    fn as_ref(&self) -> &[T] {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsMut<[T]> for [T] {\n    fn as_mut(&mut self) -> &mut [T] {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<str> for str {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        self\n    }\n}\n\n// FromStr implies TryFrom<&str>\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl<'a, T> TryFrom<&'a str> for T where T: FromStr\n{\n    type Error = <T as FromStr>::Err;\n\n    fn try_from(s: &'a str) -> Result<T, Self::Error> {\n        FromStr::from_str(s)\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse cell::UnsafeCell;\nuse fmt;\nuse mem;\nuse ops::{Deref, DerefMut};\nuse ptr;\nuse sys_common::mutex as sys;\nuse sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n\n/// A mutual exclusion primitive useful for protecting shared data\n///\n/// This mutex will block threads waiting for the lock to become available. The\n/// mutex can also be statically initialized or created via a `new`\n/// constructor. Each mutex has a type parameter which represents the data that\n/// it is protecting. The data can only be accessed through the RAII guards\n/// returned from `lock` and `try_lock`, which guarantees that the data is only\n/// ever accessed when the mutex is locked.\n///\n/// # Poisoning\n///\n/// The mutexes in this module implement a strategy called \"poisoning\" where a\n/// mutex is considered poisoned whenever a thread panics while holding the\n/// mutex. Once a mutex is poisoned, all other threads are unable to access the\n/// data by default as it is likely tainted (some invariant is not being\n/// upheld).\n///\n/// For a mutex, this means that the `lock` and `try_lock` methods return a\n/// `Result` which indicates whether a mutex has been poisoned or not. Most\n/// usage of a mutex will simply `unwrap()` these results, propagating panics\n/// among threads to ensure that a possibly invalid invariant is not witnessed.\n///\n/// A poisoned mutex, however, does not prevent all access to the underlying\n/// data. The `PoisonError` type has an `into_inner` method which will return\n/// the guard that would have otherwise been returned on a successful lock. This\n/// allows access to the data, despite the lock being poisoned.\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::{Arc, Mutex};\n/// use std::thread;\n/// use std::sync::mpsc::channel;\n///\n/// const N: usize = 10;\n///\n/// // Spawn a few threads to increment a shared variable (non-atomically), and\n/// // let the main thread know once all increments are done.\n/// //\n/// // Here we're using an Arc to share memory among threads, and the data inside\n/// // the Arc is protected with a mutex.\n/// let data = Arc::new(Mutex::new(0));\n///\n/// let (tx, rx) = channel();\n/// for _ in 0..N {\n///     let (data, tx) = (data.clone(), tx.clone());\n///     thread::spawn(move || {\n///         // The shared state can only be accessed once the lock is held.\n///         // Our non-atomic increment is safe because we're the only thread\n///         // which can access the shared state when the lock is held.\n///         //\n///         // We unwrap() the return value to assert that we are not expecting\n///         // threads to ever fail while holding the lock.\n///         let mut data = data.lock().unwrap();\n///         *data += 1;\n///         if *data == N {\n///             tx.send(()).unwrap();\n///         }\n///         // the lock is unlocked here when `data` goes out of scope.\n///     });\n/// }\n///\n/// rx.recv().unwrap();\n/// ```\n///\n/// To recover from a poisoned mutex:\n///\n/// ```\n/// use std::sync::{Arc, Mutex};\n/// use std::thread;\n///\n/// let lock = Arc::new(Mutex::new(0_u32));\n/// let lock2 = lock.clone();\n///\n/// let _ = thread::spawn(move || -> () {\n///     // This thread will acquire the mutex first, unwrapping the result of\n///     // `lock` because the lock has not been poisoned.\n///     let _guard = lock2.lock().unwrap();\n///\n///     // This panic while holding the lock (`_guard` is in scope) will poison\n///     // the mutex.\n///     panic!();\n/// }).join();\n///\n/// // The lock is poisoned by this point, but the returned result can be\n/// // pattern matched on to return the underlying guard on both branches.\n/// let mut guard = match lock.lock() {\n///     Ok(guard) => guard,\n///     Err(poisoned) => poisoned.into_inner(),\n/// };\n///\n/// *guard += 1;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Mutex<T: ?Sized> {\n    // Note that this mutex is in a *box*, not inlined into the struct itself.\n    // Once a native mutex has been used once, its address can never change (it\n    // can't be moved). This mutex type can be safely moved at any time, so to\n    // ensure that the native mutex is used correctly we box the inner mutex to\n    // give it a constant address.\n    inner: Box<sys::Mutex>,\n    poison: poison::Flag,\n    data: UnsafeCell<T>,\n}\n\n// these are the only places where `T: Send` matters; all other\n// functionality works fine on a single thread.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: ?Sized + Send> Send for Mutex<T> { }\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: ?Sized + Send> Sync for Mutex<T> { }\n\n/// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n/// dropped (falls out of scope), the lock will be unlocked.\n///\n/// The data protected by the mutex can be accessed through this guard via its\n/// [`Deref`] and [`DerefMut`] implementations.\n///\n/// This structure is created by the [`lock`] and [`try_lock`] methods on\n/// [`Mutex`].\n///\n/// [`Deref`]: ../../std/ops/trait.Deref.html\n/// [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n/// [`lock`]: struct.Mutex.html#method.lock\n/// [`try_lock`]: struct.Mutex.html#method.try_lock\n/// [`Mutex`]: struct.Mutex.html\n#[must_use]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct MutexGuard<'a, T: ?Sized + 'a> {\n    // funny underscores due to how Deref/DerefMut currently work (they\n    // disregard field privacy).\n    __lock: &'a Mutex<T>,\n    __poison: poison::Guard,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized> !Send for MutexGuard<'a, T> { }\n#[stable(feature = \"mutexguard\", since = \"1.19.0\")]\nunsafe impl<'a, T: ?Sized + Sync> Sync for MutexGuard<'a, T> { }\n\nimpl<T> Mutex<T> {\n    /// Creates a new mutex in an unlocked state ready for use.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Mutex;\n    ///\n    /// let mutex = Mutex::new(0);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(t: T) -> Mutex<T> {\n        let mut m = Mutex {\n            inner: box sys::Mutex::new(),\n            poison: poison::Flag::new(),\n            data: UnsafeCell::new(t),\n        };\n        unsafe {\n            m.inner.init();\n        }\n        m\n    }\n}\n\nimpl<T: ?Sized> Mutex<T> {\n    /// Acquires a mutex, blocking the current thread until it is able to do so.\n    ///\n    /// This function will block the local thread until it is available to acquire\n    /// the mutex. Upon returning, the thread is the only thread with the lock\n    /// held. An RAII guard is returned to allow scoped unlock of the lock. When\n    /// the guard goes out of scope, the mutex will be unlocked.\n    ///\n    /// The exact behavior on locking a mutex in the thread which already holds\n    /// the lock is left unspecified. However, this function will not return on\n    /// the second call (it might panic or deadlock, for example).\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return an error once the mutex is acquired.\n    ///\n    /// # Panics\n    ///\n    /// This function might panic when called if the lock is already held by\n    /// the current thread.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex};\n    /// use std::thread;\n    ///\n    /// let mutex = Arc::new(Mutex::new(0));\n    /// let c_mutex = mutex.clone();\n    ///\n    /// thread::spawn(move || {\n    ///     *c_mutex.lock().unwrap() = 10;\n    /// }).join().expect(\"thread::spawn failed\");\n    /// assert_eq!(*mutex.lock().unwrap(), 10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n        unsafe {\n            self.inner.lock();\n            MutexGuard::new(self)\n        }\n    }\n\n    /// Attempts to acquire this lock.\n    ///\n    /// If the lock could not be acquired at this time, then `Err` is returned.\n    /// Otherwise, an RAII guard is returned. The lock will be unlocked when the\n    /// guard is dropped.\n    ///\n    /// This function does not block.\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return failure if the mutex would otherwise be\n    /// acquired.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex};\n    /// use std::thread;\n    ///\n    /// let mutex = Arc::new(Mutex::new(0));\n    /// let c_mutex = mutex.clone();\n    ///\n    /// thread::spawn(move || {\n    ///     let mut lock = c_mutex.try_lock();\n    ///     if let Ok(ref mut mutex) = lock {\n    ///         **mutex = 10;\n    ///     } else {\n    ///         println!(\"try_lock failed\");\n    ///     }\n    /// }).join().expect(\"thread::spawn failed\");\n    /// assert_eq!(*mutex.lock().unwrap(), 10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n        unsafe {\n            if self.inner.try_lock() {\n                Ok(MutexGuard::new(self)?)\n            } else {\n                Err(TryLockError::WouldBlock)\n            }\n        }\n    }\n\n    /// Determines whether the mutex is poisoned.\n    ///\n    /// If another thread is active, the mutex can still become poisoned at any\n    /// time. You should not trust a `false` value for program correctness\n    /// without additional synchronization.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex};\n    /// use std::thread;\n    ///\n    /// let mutex = Arc::new(Mutex::new(0));\n    /// let c_mutex = mutex.clone();\n    ///\n    /// let _ = thread::spawn(move || {\n    ///     let _lock = c_mutex.lock().unwrap();\n    ///     panic!(); // the mutex gets poisoned\n    /// }).join();\n    /// assert_eq!(mutex.is_poisoned(), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n    pub fn is_poisoned(&self) -> bool {\n        self.poison.get()\n    }\n\n    /// Consumes this mutex, returning the underlying data.\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return an error instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Mutex;\n    ///\n    /// let mutex = Mutex::new(0);\n    /// assert_eq!(mutex.into_inner().unwrap(), 0);\n    /// ```\n    #[stable(feature = \"mutex_into_inner\", since = \"1.6.0\")]\n    pub fn into_inner(self) -> LockResult<T> where T: Sized {\n        // We know statically that there are no outstanding references to\n        // `self` so there's no need to lock the inner mutex.\n        //\n        // To get the inner value, we'd like to call `data.into_inner()`,\n        // but because `Mutex` impl-s `Drop`, we can't move out of it, so\n        // we'll have to destructure it manually instead.\n        unsafe {\n            // Like `let Mutex { inner, poison, data } = self`.\n            let (inner, poison, data) = {\n                let Mutex { ref inner, ref poison, ref data } = self;\n                (ptr::read(inner), ptr::read(poison), ptr::read(data))\n            };\n            mem::forget(self);\n            inner.destroy();  // Keep in sync with the `Drop` impl.\n            drop(inner);\n\n            poison::map_result(poison.borrow(), |_| data.into_inner())\n        }\n    }\n\n    /// Returns a mutable reference to the underlying data.\n    ///\n    /// Since this call borrows the `Mutex` mutably, no actual locking needs to\n    /// take place---the mutable borrow statically guarantees no locks exist.\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return an error instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Mutex;\n    ///\n    /// let mut mutex = Mutex::new(0);\n    /// *mutex.get_mut().unwrap() = 10;\n    /// assert_eq!(*mutex.lock().unwrap(), 10);\n    /// ```\n    #[stable(feature = \"mutex_get_mut\", since = \"1.6.0\")]\n    pub fn get_mut(&mut self) -> LockResult<&mut T> {\n        // We know statically that there are no other references to `self`, so\n        // there's no need to lock the inner mutex.\n        let data = unsafe { &mut *self.data.get() };\n        poison::map_result(self.poison.borrow(), |_| data )\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T: ?Sized> Drop for Mutex<T> {\n    fn drop(&mut self) {\n        // This is actually safe b/c we know that there is no further usage of\n        // this mutex (it's up to the user to arrange for a mutex to get\n        // dropped, that's not our job)\n        //\n        // IMPORTANT: This code must be kept in sync with `Mutex::into_inner`.\n        unsafe { self.inner.destroy() }\n    }\n}\n\n#[stable(feature = \"mutex_default\", since = \"1.10.0\")]\nimpl<T: ?Sized + Default> Default for Mutex<T> {\n    /// Creates a `Mutex<T>`, with the `Default` value for T.\n    fn default() -> Mutex<T> {\n        Mutex::new(Default::default())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + fmt::Debug> fmt::Debug for Mutex<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self.try_lock() {\n            Ok(guard) => write!(f, \"Mutex {{ data: {:?} }}\", &*guard),\n            Err(TryLockError::Poisoned(err)) => {\n                write!(f, \"Mutex {{ data: Poisoned({:?}) }}\", &**err.get_ref())\n            },\n            Err(TryLockError::WouldBlock) => write!(f, \"Mutex {{ <locked> }}\")\n        }\n    }\n}\n\nimpl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n    unsafe fn new(lock: &'mutex Mutex<T>) -> LockResult<MutexGuard<'mutex, T>> {\n        poison::map_result(lock.poison.borrow(), |guard| {\n            MutexGuard {\n                __lock: lock,\n                __poison: guard,\n            }\n        })\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'mutex, T: ?Sized> Deref for MutexGuard<'mutex, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        unsafe { &*self.__lock.data.get() }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'mutex, T: ?Sized> DerefMut for MutexGuard<'mutex, T> {\n    fn deref_mut(&mut self) -> &mut T {\n        unsafe { &mut *self.__lock.data.get() }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized> Drop for MutexGuard<'a, T> {\n    #[inline]\n    fn drop(&mut self) {\n        unsafe {\n            self.__lock.poison.done(&self.__poison);\n            self.__lock.inner.unlock();\n        }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<'a, T: ?Sized + fmt::Debug> fmt::Debug for MutexGuard<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"MutexGuard\")\n            .field(\"lock\", &self.__lock)\n            .finish()\n    }\n}\n\n#[stable(feature = \"std_guard_impls\", since = \"1.20\")]\nimpl<'a, T: ?Sized + fmt::Display> fmt::Display for MutexGuard<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        (**self).fmt(f)\n    }\n}\n\npub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n    &guard.__lock.inner\n}\n\npub fn guard_poison<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n    &guard.__lock.poison\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use sync::mpsc::channel;\n    use sync::{Arc, Mutex, Condvar};\n    use sync::atomic::{AtomicUsize, Ordering};\n    use thread;\n\n    struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n\n    #[derive(Eq, PartialEq, Debug)]\n    struct NonCopy(i32);\n\n    #[test]\n    fn smoke() {\n        let m = Mutex::new(());\n        drop(m.lock().unwrap());\n        drop(m.lock().unwrap());\n    }\n\n    #[test]\n    fn lots_and_lots() {\n        const J: u32 = 1000;\n        const K: u32 = 3;\n\n        let m = Arc::new(Mutex::new(0));\n\n        fn inc(m: &Mutex<u32>) {\n            for _ in 0..J {\n                *m.lock().unwrap() += 1;\n            }\n        }\n\n        let (tx, rx) = channel();\n        for _ in 0..K {\n            let tx2 = tx.clone();\n            let m2 = m.clone();\n            thread::spawn(move|| { inc(&m2); tx2.send(()).unwrap(); });\n            let tx2 = tx.clone();\n            let m2 = m.clone();\n            thread::spawn(move|| { inc(&m2); tx2.send(()).unwrap(); });\n        }\n\n        drop(tx);\n        for _ in 0..2 * K {\n            rx.recv().unwrap();\n        }\n        assert_eq!(*m.lock().unwrap(), J * K * 2);\n    }\n\n    #[test]\n    fn try_lock() {\n        let m = Mutex::new(());\n        *m.try_lock().unwrap() = ();\n    }\n\n    #[test]\n    fn test_into_inner() {\n        let m = Mutex::new(NonCopy(10));\n        assert_eq!(m.into_inner().unwrap(), NonCopy(10));\n    }\n\n    #[test]\n    fn test_into_inner_drop() {\n        struct Foo(Arc<AtomicUsize>);\n        impl Drop for Foo {\n            fn drop(&mut self) {\n                self.0.fetch_add(1, Ordering::SeqCst);\n            }\n        }\n        let num_drops = Arc::new(AtomicUsize::new(0));\n        let m = Mutex::new(Foo(num_drops.clone()));\n        assert_eq!(num_drops.load(Ordering::SeqCst), 0);\n        {\n            let _inner = m.into_inner().unwrap();\n            assert_eq!(num_drops.load(Ordering::SeqCst), 0);\n        }\n        assert_eq!(num_drops.load(Ordering::SeqCst), 1);\n    }\n\n    #[test]\n    fn test_into_inner_poison() {\n        let m = Arc::new(Mutex::new(NonCopy(10)));\n        let m2 = m.clone();\n        let _ = thread::spawn(move || {\n            let _lock = m2.lock().unwrap();\n            panic!(\"test panic in inner thread to poison mutex\");\n        }).join();\n\n        assert!(m.is_poisoned());\n        match Arc::try_unwrap(m).unwrap().into_inner() {\n            Err(e) => assert_eq!(e.into_inner(), NonCopy(10)),\n            Ok(x) => panic!(\"into_inner of poisoned Mutex is Ok: {:?}\", x),\n        }\n    }\n\n    #[test]\n    fn test_get_mut() {\n        let mut m = Mutex::new(NonCopy(10));\n        *m.get_mut().unwrap() = NonCopy(20);\n        assert_eq!(m.into_inner().unwrap(), NonCopy(20));\n    }\n\n    #[test]\n    fn test_get_mut_poison() {\n        let m = Arc::new(Mutex::new(NonCopy(10)));\n        let m2 = m.clone();\n        let _ = thread::spawn(move || {\n            let _lock = m2.lock().unwrap();\n            panic!(\"test panic in inner thread to poison mutex\");\n        }).join();\n\n        assert!(m.is_poisoned());\n        match Arc::try_unwrap(m).unwrap().get_mut() {\n            Err(e) => assert_eq!(*e.into_inner(), NonCopy(10)),\n            Ok(x) => panic!(\"get_mut of poisoned Mutex is Ok: {:?}\", x),\n        }\n    }\n\n    #[test]\n    fn test_mutex_arc_condvar() {\n        let packet = Packet(Arc::new((Mutex::new(false), Condvar::new())));\n        let packet2 = Packet(packet.0.clone());\n        let (tx, rx) = channel();\n        let _t = thread::spawn(move|| {\n            // wait until parent gets in\n            rx.recv().unwrap();\n            let &(ref lock, ref cvar) = &*packet2.0;\n            let mut lock = lock.lock().unwrap();\n            *lock = true;\n            cvar.notify_one();\n        });\n\n        let &(ref lock, ref cvar) = &*packet.0;\n        let mut lock = lock.lock().unwrap();\n        tx.send(()).unwrap();\n        assert!(!*lock);\n        while !*lock {\n            lock = cvar.wait(lock).unwrap();\n        }\n    }\n\n    #[test]\n    fn test_arc_condvar_poison() {\n        let packet = Packet(Arc::new((Mutex::new(1), Condvar::new())));\n        let packet2 = Packet(packet.0.clone());\n        let (tx, rx) = channel();\n\n        let _t = thread::spawn(move || -> () {\n            rx.recv().unwrap();\n            let &(ref lock, ref cvar) = &*packet2.0;\n            let _g = lock.lock().unwrap();\n            cvar.notify_one();\n            // Parent should fail when it wakes up.\n            panic!();\n        });\n\n        let &(ref lock, ref cvar) = &*packet.0;\n        let mut lock = lock.lock().unwrap();\n        tx.send(()).unwrap();\n        while *lock == 1 {\n            match cvar.wait(lock) {\n                Ok(l) => {\n                    lock = l;\n                    assert_eq!(*lock, 1);\n                }\n                Err(..) => break,\n            }\n        }\n    }\n\n    #[test]\n    fn test_mutex_arc_poison() {\n        let arc = Arc::new(Mutex::new(1));\n        assert!(!arc.is_poisoned());\n        let arc2 = arc.clone();\n        let _ = thread::spawn(move|| {\n            let lock = arc2.lock().unwrap();\n            assert_eq!(*lock, 2);\n        }).join();\n        assert!(arc.lock().is_err());\n        assert!(arc.is_poisoned());\n    }\n\n    #[test]\n    fn test_mutex_arc_nested() {\n        // Tests nested mutexes and access\n        // to underlying data.\n        let arc = Arc::new(Mutex::new(1));\n        let arc2 = Arc::new(Mutex::new(arc));\n        let (tx, rx) = channel();\n        let _t = thread::spawn(move|| {\n            let lock = arc2.lock().unwrap();\n            let lock2 = lock.lock().unwrap();\n            assert_eq!(*lock2, 1);\n            tx.send(()).unwrap();\n        });\n        rx.recv().unwrap();\n    }\n\n    #[test]\n    fn test_mutex_arc_access_in_unwind() {\n        let arc = Arc::new(Mutex::new(1));\n        let arc2 = arc.clone();\n        let _ = thread::spawn(move|| -> () {\n            struct Unwinder {\n                i: Arc<Mutex<i32>>,\n            }\n            impl Drop for Unwinder {\n                fn drop(&mut self) {\n                    *self.i.lock().unwrap() += 1;\n                }\n            }\n            let _u = Unwinder { i: arc2 };\n            panic!();\n        }).join();\n        let lock = arc.lock().unwrap();\n        assert_eq!(*lock, 2);\n    }\n\n    #[test]\n    fn test_mutex_unsized() {\n        let mutex: &Mutex<[i32]> = &Mutex::new([1, 2, 3]);\n        {\n            let b = &mut *mutex.lock().unwrap();\n            b[0] = 4;\n            b[2] = 5;\n        }\n        let comp: &[i32] = &[4, 2, 5];\n        assert_eq!(&*mutex.lock().unwrap(), comp);\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse fmt;\nuse sync::atomic::{AtomicUsize, Ordering};\nuse sync::{mutex, MutexGuard, PoisonError};\nuse sys_common::condvar as sys;\nuse sys_common::mutex as sys_mutex;\nuse sys_common::poison::{self, LockResult};\nuse time::Duration;\n\n/// A type indicating whether a timed wait on a condition variable returned\n/// due to a time out or not.\n///\n/// It is returned by the [`wait_timeout`] method.\n///\n/// [`wait_timeout`]: struct.Condvar.html#method.wait_timeout\n#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n#[stable(feature = \"wait_timeout\", since = \"1.5.0\")]\npub struct WaitTimeoutResult(bool);\n\nimpl WaitTimeoutResult {\n    /// Returns whether the wait was known to have timed out.\n    ///\n    /// # Examples\n    ///\n    /// This example spawns a thread which will update the boolean value and\n    /// then wait 100 milliseconds before notifying the condvar.\n    ///\n    /// The main thread will wait with a timeout on the condvar and then leave\n    /// once the boolean has been updated and notified.\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    /// use std::time::Duration;\n    ///\n    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let &(ref lock, ref cvar) = &*pair2;\n    ///     let mut started = lock.lock().unwrap();\n    ///     // We update the boolean value.\n    ///     *started = true;\n    ///     // Let's wait 20 milliseconds before notifying the condvar.\n    ///     thread::sleep(Duration::from_millis(20));\n    ///     cvar.notify_one();\n    /// });\n    ///\n    /// // Wait for the thread to start up.\n    /// let &(ref lock, ref cvar) = &*pair;\n    /// let mut started = lock.lock().unwrap();\n    /// loop {\n    ///     // Let's put a timeout on the condvar's wait.\n    ///     let result = cvar.wait_timeout(started, Duration::from_millis(10)).unwrap();\n    ///     // 10 milliseconds have passed, or maybe the value changed!\n    ///     started = result.0;\n    ///     if *started == true {\n    ///         // We received the notification and the value has been updated, we can leave.\n    ///         break\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"wait_timeout\", since = \"1.5.0\")]\n    pub fn timed_out(&self) -> bool {\n        self.0\n    }\n}\n\n/// A Condition Variable\n///\n/// Condition variables represent the ability to block a thread such that it\n/// consumes no CPU time while waiting for an event to occur. Condition\n/// variables are typically associated with a boolean predicate (a condition)\n/// and a mutex. The predicate is always verified inside of the mutex before\n/// determining that a thread must block.\n///\n/// Functions in this module will block the current **thread** of execution and\n/// are bindings to system-provided condition variables where possible. Note\n/// that this module places one additional restriction over the system condition\n/// variables: each condvar can be used with precisely one mutex at runtime. Any\n/// attempt to use multiple mutexes on the same condition variable will result\n/// in a runtime panic. If this is not desired, then the unsafe primitives in\n/// `sys` do not have this restriction but may result in undefined behavior.\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::{Arc, Mutex, Condvar};\n/// use std::thread;\n///\n/// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n/// let pair2 = pair.clone();\n///\n/// // Inside of our lock, spawn a new thread, and then wait for it to start.\n/// thread::spawn(move|| {\n///     let &(ref lock, ref cvar) = &*pair2;\n///     let mut started = lock.lock().unwrap();\n///     *started = true;\n///     // We notify the condvar that the value has changed.\n///     cvar.notify_one();\n/// });\n///\n/// // Wait for the thread to start up.\n/// let &(ref lock, ref cvar) = &*pair;\n/// let mut started = lock.lock().unwrap();\n/// while !*started {\n///     started = cvar.wait(started).unwrap();\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Condvar {\n    inner: Box<sys::Condvar>,\n    mutex: AtomicUsize,\n}\n\nimpl Condvar {\n    /// Creates a new condition variable which is ready to be waited on and\n    /// notified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Condvar;\n    ///\n    /// let condvar = Condvar::new();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> Condvar {\n        let mut c = Condvar {\n            inner: box sys::Condvar::new(),\n            mutex: AtomicUsize::new(0),\n        };\n        unsafe {\n            c.inner.init();\n        }\n        c\n    }\n\n    /// Blocks the current thread until this condition variable receives a\n    /// notification.\n    ///\n    /// This function will atomically unlock the mutex specified (represented by\n    /// `guard`) and block the current thread. This means that any calls\n    /// to [`notify_one`] or [`notify_all`] which happen logically after the\n    /// mutex is unlocked are candidates to wake this thread up. When this\n    /// function call returns, the lock specified will have been re-acquired.\n    ///\n    /// Note that this function is susceptible to spurious wakeups. Condition\n    /// variables normally have a boolean predicate associated with them, and\n    /// the predicate must always be checked each time this function returns to\n    /// protect against spurious wakeups.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the mutex being waited on is\n    /// poisoned when this thread re-acquires the lock. For more information,\n    /// see information about [poisoning] on the [`Mutex`] type.\n    ///\n    /// # Panics\n    ///\n    /// This function will [`panic!`] if it is used with more than one mutex\n    /// over time. Each condition variable is dynamically bound to exactly one\n    /// mutex to ensure defined behavior across platforms. If this functionality\n    /// is not desired, then unsafe primitives in `sys` are provided.\n    ///\n    /// [`notify_one`]: #method.notify_one\n    /// [`notify_all`]: #method.notify_all\n    /// [poisoning]: ../sync/struct.Mutex.html#poisoning\n    /// [`Mutex`]: ../sync/struct.Mutex.html\n    /// [`panic!`]: ../../std/macro.panic.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    ///\n    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let &(ref lock, ref cvar) = &*pair2;\n    ///     let mut started = lock.lock().unwrap();\n    ///     *started = true;\n    ///     // We notify the condvar that the value has changed.\n    ///     cvar.notify_one();\n    /// });\n    ///\n    /// // Wait for the thread to start up.\n    /// let &(ref lock, ref cvar) = &*pair;\n    /// let mut started = lock.lock().unwrap();\n    /// // As long as the value inside the `Mutex` is false, we wait.\n    /// while !*started {\n    ///     started = cvar.wait(started).unwrap();\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)\n                       -> LockResult<MutexGuard<'a, T>> {\n        let poisoned = unsafe {\n            let lock = mutex::guard_lock(&guard);\n            self.verify(lock);\n            self.inner.wait(lock);\n            mutex::guard_poison(&guard).get()\n        };\n        if poisoned {\n            Err(PoisonError::new(guard))\n        } else {\n            Ok(guard)\n        }\n    }\n\n    /// Waits on this condition variable for a notification, timing out after a\n    /// specified duration.\n    ///\n    /// The semantics of this function are equivalent to [`wait`]\n    /// except that the thread will be blocked for roughly no longer\n    /// than `ms` milliseconds. This method should not be used for\n    /// precise timing due to anomalies such as preemption or platform\n    /// differences that may not cause the maximum amount of time\n    /// waited to be precisely `ms`.\n    ///\n    /// Note that the best effort is made to ensure that the time waited is\n    /// measured with a monotonic clock, and not affected by the changes made to\n    /// the system time.\n    ///\n    /// The returned boolean is `false` only if the timeout is known\n    /// to have elapsed.\n    ///\n    /// Like [`wait`], the lock specified will be re-acquired when this function\n    /// returns, regardless of whether the timeout elapsed or not.\n    ///\n    /// [`wait`]: #method.wait\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    ///\n    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let &(ref lock, ref cvar) = &*pair2;\n    ///     let mut started = lock.lock().unwrap();\n    ///     *started = true;\n    ///     // We notify the condvar that the value has changed.\n    ///     cvar.notify_one();\n    /// });\n    ///\n    /// // Wait for the thread to start up.\n    /// let &(ref lock, ref cvar) = &*pair;\n    /// let mut started = lock.lock().unwrap();\n    /// // As long as the value inside the `Mutex` is false, we wait.\n    /// loop {\n    ///     let result = cvar.wait_timeout_ms(started, 10).unwrap();\n    ///     // 10 milliseconds have passed, or maybe the value changed!\n    ///     started = result.0;\n    ///     if *started == true {\n    ///         // We received the notification and the value has been updated, we can leave.\n    ///         break\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::sync::Condvar::wait_timeout`\")]\n    pub fn wait_timeout_ms<'a, T>(&self, guard: MutexGuard<'a, T>, ms: u32)\n                                  -> LockResult<(MutexGuard<'a, T>, bool)> {\n        let res = self.wait_timeout(guard, Duration::from_millis(ms as u64));\n        poison::map_result(res, |(a, b)| {\n            (a, !b.timed_out())\n        })\n    }\n\n    /// Waits on this condition variable for a notification, timing out after a\n    /// specified duration.\n    ///\n    /// The semantics of this function are equivalent to [`wait`] except that\n    /// the thread will be blocked for roughly no longer than `dur`. This\n    /// method should not be used for precise timing due to anomalies such as\n    /// preemption or platform differences that may not cause the maximum\n    /// amount of time waited to be precisely `dur`.\n    ///\n    /// Note that the best effort is made to ensure that the time waited is\n    /// measured with a monotonic clock, and not affected by the changes made to\n    /// the system time.\n    ///\n    /// The returned [`WaitTimeoutResult`] value indicates if the timeout is\n    /// known to have elapsed.\n    ///\n    /// Like [`wait`], the lock specified will be re-acquired when this function\n    /// returns, regardless of whether the timeout elapsed or not.\n    ///\n    /// [`wait`]: #method.wait\n    /// [`WaitTimeoutResult`]: struct.WaitTimeoutResult.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    /// use std::time::Duration;\n    ///\n    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let &(ref lock, ref cvar) = &*pair2;\n    ///     let mut started = lock.lock().unwrap();\n    ///     *started = true;\n    ///     // We notify the condvar that the value has changed.\n    ///     cvar.notify_one();\n    /// });\n    ///\n    /// // wait for the thread to start up\n    /// let &(ref lock, ref cvar) = &*pair;\n    /// let mut started = lock.lock().unwrap();\n    /// // as long as the value inside the `Mutex` is false, we wait\n    /// loop {\n    ///     let result = cvar.wait_timeout(started, Duration::from_millis(10)).unwrap();\n    ///     // 10 milliseconds have passed, or maybe the value changed!\n    ///     started = result.0;\n    ///     if *started == true {\n    ///         // We received the notification and the value has been updated, we can leave.\n    ///         break\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"wait_timeout\", since = \"1.5.0\")]\n    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>,\n                               dur: Duration)\n                               -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n        let (poisoned, result) = unsafe {\n            let lock = mutex::guard_lock(&guard);\n            self.verify(lock);\n            let success = self.inner.wait_timeout(lock, dur);\n            (mutex::guard_poison(&guard).get(), WaitTimeoutResult(!success))\n        };\n        if poisoned {\n            Err(PoisonError::new((guard, result)))\n        } else {\n            Ok((guard, result))\n        }\n    }\n\n    /// Wakes up one blocked thread on this condvar.\n    ///\n    /// If there is a blocked thread on this condition variable, then it will\n    /// be woken up from its call to [`wait`] or [`wait_timeout`]. Calls to\n    /// `notify_one` are not buffered in any way.\n    ///\n    /// To wake up all threads, see [`notify_all`].\n    ///\n    /// [`wait`]: #method.wait\n    /// [`wait_timeout`]: #method.wait_timeout\n    /// [`notify_all`]: #method.notify_all\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    ///\n    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let &(ref lock, ref cvar) = &*pair2;\n    ///     let mut started = lock.lock().unwrap();\n    ///     *started = true;\n    ///     // We notify the condvar that the value has changed.\n    ///     cvar.notify_one();\n    /// });\n    ///\n    /// // Wait for the thread to start up.\n    /// let &(ref lock, ref cvar) = &*pair;\n    /// let mut started = lock.lock().unwrap();\n    /// // As long as the value inside the `Mutex` is false, we wait.\n    /// while !*started {\n    ///     started = cvar.wait(started).unwrap();\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn notify_one(&self) {\n        unsafe { self.inner.notify_one() }\n    }\n\n    /// Wakes up all blocked threads on this condvar.\n    ///\n    /// This method will ensure that any current waiters on the condition\n    /// variable are awoken. Calls to `notify_all()` are not buffered in any\n    /// way.\n    ///\n    /// To wake up only one thread, see [`notify_one`].\n    ///\n    /// [`notify_one`]: #method.notify_one\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    ///\n    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let &(ref lock, ref cvar) = &*pair2;\n    ///     let mut started = lock.lock().unwrap();\n    ///     *started = true;\n    ///     // We notify the condvar that the value has changed.\n    ///     cvar.notify_all();\n    /// });\n    ///\n    /// // Wait for the thread to start up.\n    /// let &(ref lock, ref cvar) = &*pair;\n    /// let mut started = lock.lock().unwrap();\n    /// // As long as the value inside the `Mutex` is false, we wait.\n    /// while !*started {\n    ///     started = cvar.wait(started).unwrap();\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn notify_all(&self) {\n        unsafe { self.inner.notify_all() }\n    }\n\n    fn verify(&self, mutex: &sys_mutex::Mutex) {\n        let addr = mutex as *const _ as usize;\n        match self.mutex.compare_and_swap(0, addr, Ordering::SeqCst) {\n            // If we got out 0, then we have successfully bound the mutex to\n            // this cvar.\n            0 => {}\n\n            // If we get out a value that's the same as `addr`, then someone\n            // already beat us to the punch.\n            n if n == addr => {}\n\n            // Anything else and we're using more than one mutex on this cvar,\n            // which is currently disallowed.\n            _ => panic!(\"attempted to use a condition variable with two \\\n                         mutexes\"),\n        }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Condvar {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"Condvar { .. }\")\n    }\n}\n\n#[stable(feature = \"condvar_default\", since = \"1.10.0\")]\nimpl Default for Condvar {\n    /// Creates a `Condvar` which is ready to be waited on and notified.\n    fn default() -> Condvar {\n        Condvar::new()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Drop for Condvar {\n    fn drop(&mut self) {\n        unsafe { self.inner.destroy() }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use sync::mpsc::channel;\n    use sync::{Condvar, Mutex, Arc};\n    use sync::atomic::{AtomicBool, Ordering};\n    use thread;\n    use time::Duration;\n    use u64;\n\n    #[test]\n    fn smoke() {\n        let c = Condvar::new();\n        c.notify_one();\n        c.notify_all();\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn notify_one() {\n        let m = Arc::new(Mutex::new(()));\n        let m2 = m.clone();\n        let c = Arc::new(Condvar::new());\n        let c2 = c.clone();\n\n        let g = m.lock().unwrap();\n        let _t = thread::spawn(move|| {\n            let _g = m2.lock().unwrap();\n            c2.notify_one();\n        });\n        let g = c.wait(g).unwrap();\n        drop(g);\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn notify_all() {\n        const N: usize = 10;\n\n        let data = Arc::new((Mutex::new(0), Condvar::new()));\n        let (tx, rx) = channel();\n        for _ in 0..N {\n            let data = data.clone();\n            let tx = tx.clone();\n            thread::spawn(move|| {\n                let &(ref lock, ref cond) = &*data;\n                let mut cnt = lock.lock().unwrap();\n                *cnt += 1;\n                if *cnt == N {\n                    tx.send(()).unwrap();\n                }\n                while *cnt != 0 {\n                    cnt = cond.wait(cnt).unwrap();\n                }\n                tx.send(()).unwrap();\n            });\n        }\n        drop(tx);\n\n        let &(ref lock, ref cond) = &*data;\n        rx.recv().unwrap();\n        let mut cnt = lock.lock().unwrap();\n        *cnt = 0;\n        cond.notify_all();\n        drop(cnt);\n\n        for _ in 0..N {\n            rx.recv().unwrap();\n        }\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn wait_timeout_wait() {\n        let m = Arc::new(Mutex::new(()));\n        let c = Arc::new(Condvar::new());\n\n        loop {\n            let g = m.lock().unwrap();\n            let (_g, no_timeout) = c.wait_timeout(g, Duration::from_millis(1)).unwrap();\n            // spurious wakeups mean this isn't necessarily true\n            // so execute test again, if not timeout\n            if !no_timeout.timed_out() {\n                continue;\n            }\n\n            break;\n        }\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn wait_timeout_wake() {\n        let m = Arc::new(Mutex::new(()));\n        let c = Arc::new(Condvar::new());\n\n        loop {\n            let g = m.lock().unwrap();\n\n            let c2 = c.clone();\n            let m2 = m.clone();\n\n            let notified = Arc::new(AtomicBool::new(false));\n            let notified_copy = notified.clone();\n\n            let t = thread::spawn(move || {\n                let _g = m2.lock().unwrap();\n                thread::sleep(Duration::from_millis(1));\n                notified_copy.store(true, Ordering::SeqCst);\n                c2.notify_one();\n            });\n            let (g, timeout_res) = c.wait_timeout(g, Duration::from_millis(u64::MAX)).unwrap();\n            assert!(!timeout_res.timed_out());\n            // spurious wakeups mean this isn't necessarily true\n            // so execute test again, if not notified\n            if !notified.load(Ordering::SeqCst) {\n                t.join().unwrap();\n                continue;\n            }\n            drop(g);\n\n            t.join().unwrap();\n\n            break;\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn two_mutexes() {\n        let m = Arc::new(Mutex::new(()));\n        let m2 = m.clone();\n        let c = Arc::new(Condvar::new());\n        let c2 = c.clone();\n\n        let mut g = m.lock().unwrap();\n        let _t = thread::spawn(move|| {\n            let _g = m2.lock().unwrap();\n            c2.notify_one();\n        });\n        g = c.wait(g).unwrap();\n        drop(g);\n\n        let m = Mutex::new(());\n        let _ = c.wait(m.lock().unwrap()).unwrap();\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse cell::UnsafeCell;\nuse libc;\nuse sys::mutex::{self, Mutex};\nuse time::Duration;\n\npub struct Condvar { inner: UnsafeCell<libc::pthread_cond_t> }\n\nunsafe impl Send for Condvar {}\nunsafe impl Sync for Condvar {}\n\nconst TIMESPEC_MAX: libc::timespec = libc::timespec {\n    tv_sec: <libc::time_t>::max_value(),\n    tv_nsec: 1_000_000_000 - 1,\n};\n\nfn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n    if value > <libc::time_t>::max_value() as u64 {\n        <libc::time_t>::max_value()\n    } else {\n        value as libc::time_t\n    }\n}\n\nimpl Condvar {\n    pub const fn new() -> Condvar {\n        // Might be moved and address is changing it is better to avoid\n        // initialization of potentially opaque OS data before it landed\n        Condvar { inner: UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER) }\n    }\n\n    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\"))]\n    pub unsafe fn init(&mut self) {}\n\n    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\")))]\n    pub unsafe fn init(&mut self) {\n        use mem;\n        let mut attr: libc::pthread_condattr_t = mem::uninitialized();\n        let r = libc::pthread_condattr_init(&mut attr);\n        assert_eq!(r, 0);\n        let r = libc::pthread_condattr_setclock(&mut attr, libc::CLOCK_MONOTONIC);\n        assert_eq!(r, 0);\n        let r = libc::pthread_cond_init(self.inner.get(), &attr);\n        assert_eq!(r, 0);\n        let r = libc::pthread_condattr_destroy(&mut attr);\n        assert_eq!(r, 0);\n    }\n\n    #[inline]\n    pub unsafe fn notify_one(&self) {\n        let r = libc::pthread_cond_signal(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n\n    #[inline]\n    pub unsafe fn notify_all(&self) {\n        let r = libc::pthread_cond_broadcast(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n\n    #[inline]\n    pub unsafe fn wait(&self, mutex: &Mutex) {\n        let r = libc::pthread_cond_wait(self.inner.get(), mutex::raw(mutex));\n        debug_assert_eq!(r, 0);\n    }\n\n    // This implementation is used on systems that support pthread_condattr_setclock\n    // where we configure condition variable to use monotonic clock (instead of\n    // default system clock). This approach avoids all problems that result\n    // from changes made to the system time.\n    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\")))]\n    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n        use mem;\n\n        let mut now: libc::timespec = mem::zeroed();\n        let r = libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now);\n        assert_eq!(r, 0);\n\n        // Nanosecond calculations can't overflow because both values are below 1e9.\n        let nsec = dur.subsec_nanos() as libc::c_long + now.tv_nsec as libc::c_long;\n        let sec = saturating_cast_to_time_t(dur.as_secs())\n            .checked_add((nsec / 1_000_000_000) as libc::time_t)\n            .and_then(|s| s.checked_add(now.tv_sec));\n        let nsec = nsec % 1_000_000_000;\n\n        let timeout = sec.map(|s| {\n            libc::timespec { tv_sec: s, tv_nsec: nsec }\n        }).unwrap_or(TIMESPEC_MAX);\n\n        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n                                            &timeout);\n        assert!(r == libc::ETIMEDOUT || r == 0);\n        r == 0\n    }\n\n\n    // This implementation is modeled after libcxx's condition_variable\n    // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n    // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\"))]\n    pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n        use ptr;\n        use time::Instant;\n\n        // 1000 years\n        let max_dur = Duration::from_secs(1000 * 365 * 86400);\n\n        if dur > max_dur {\n            // OSX implementation of `pthread_cond_timedwait` is buggy\n            // with super long durations. When duration is greater than\n            // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n            // in macOS Sierra return error 316.\n            //\n            // This program demonstrates the issue:\n            // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n            //\n            // To work around this issue, and possible bugs of other OSes, timeout\n            // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n            // because of spurious wakeups.\n\n            dur = max_dur;\n        }\n\n        // First, figure out what time it currently is, in both system and\n        // stable time.  pthread_cond_timedwait uses system time, but we want to\n        // report timeout based on stable time.\n        let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n        let stable_now = Instant::now();\n        let r = libc::gettimeofday(&mut sys_now, ptr::null_mut());\n        debug_assert_eq!(r, 0);\n\n        let nsec = dur.subsec_nanos() as libc::c_long +\n                   (sys_now.tv_usec * 1000) as libc::c_long;\n        let extra = (nsec / 1_000_000_000) as libc::time_t;\n        let nsec = nsec % 1_000_000_000;\n        let seconds = saturating_cast_to_time_t(dur.as_secs());\n\n        let timeout = sys_now.tv_sec.checked_add(extra).and_then(|s| {\n            s.checked_add(seconds)\n        }).map(|s| {\n            libc::timespec { tv_sec: s, tv_nsec: nsec }\n        }).unwrap_or(TIMESPEC_MAX);\n\n        // And wait!\n        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n                                            &timeout);\n        debug_assert!(r == libc::ETIMEDOUT || r == 0);\n\n        // ETIMEDOUT is not a totally reliable method of determining timeout due\n        // to clock shifts, so do the check ourselves\n        stable_now.elapsed() < dur\n    }\n\n    #[inline]\n    #[cfg(not(target_os = \"dragonfly\"))]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_cond_destroy(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n\n    #[inline]\n    #[cfg(target_os = \"dragonfly\")]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_cond_destroy(self.inner.get());\n        // On DragonFly pthread_cond_destroy() returns EINVAL if called on\n        // a condvar that was just initialized with\n        // libc::PTHREAD_COND_INITIALIZER. Once it is used or\n        // pthread_cond_init() is called, this behaviour no longer occurs.\n        debug_assert!(r == 0 || r == libc::EINVAL);\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Functionality for ordering and comparison.\n//!\n//! This module defines both [`PartialOrd`] and [`PartialEq`] traits which are used\n//! by the compiler to implement comparison operators. Rust programs may\n//! implement [`PartialOrd`] to overload the `<`, `<=`, `>`, and `>=` operators,\n//! and may implement [`PartialEq`] to overload the `==` and `!=` operators.\n//!\n//! [`PartialOrd`]: trait.PartialOrd.html\n//! [`PartialEq`]: trait.PartialEq.html\n//!\n//! # Examples\n//!\n//! ```\n//! let x: u32 = 0;\n//! let y: u32 = 1;\n//!\n//! // these two lines are equivalent\n//! assert_eq!(x < y, true);\n//! assert_eq!(x.lt(&y), true);\n//!\n//! // these two lines are also equivalent\n//! assert_eq!(x == y, false);\n//! assert_eq!(x.eq(&y), false);\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse self::Ordering::*;\n\n/// Trait for equality comparisons which are [partial equivalence\n/// relations](http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n///\n/// This trait allows for partial equality, for types that do not have a full\n/// equivalence relation.  For example, in floating point numbers `NaN != NaN`,\n/// so floating point types implement `PartialEq` but not `Eq`.\n///\n/// Formally, the equality must be (for all `a`, `b` and `c`):\n///\n/// - symmetric: `a == b` implies `b == a`; and\n/// - transitive: `a == b` and `b == c` implies `a == c`.\n///\n/// Note that these requirements mean that the trait itself must be implemented\n/// symmetrically and transitively: if `T: PartialEq<U>` and `U: PartialEq<V>`\n/// then `U: PartialEq<T>` and `T: PartialEq<V>`.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d on structs, two\n/// instances are equal if all fields are equal, and not equal if any fields\n/// are not equal. When `derive`d on enums, each variant is equal to itself\n/// and not equal to the other variants.\n///\n/// ## How can I implement `PartialEq`?\n///\n/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n/// in terms of it by default. Any manual implementation of `ne` *must* respect\n/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n/// only if `a != b`.\n///\n/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with\n/// each other. It's easy to accidentally make them disagree by deriving some\n/// of the traits and manually implementing others.\n///\n/// An example implementation for a domain in which two books are considered\n/// the same book if their ISBN matches, even if the formats differ:\n///\n/// ```\n/// enum BookFormat { Paperback, Hardback, Ebook }\n/// struct Book {\n///     isbn: i32,\n///     format: BookFormat,\n/// }\n///\n/// impl PartialEq for Book {\n///     fn eq(&self, other: &Book) -> bool {\n///         self.isbn == other.isbn\n///     }\n/// }\n///\n/// let b1 = Book { isbn: 3, format: BookFormat::Paperback };\n/// let b2 = Book { isbn: 3, format: BookFormat::Ebook };\n/// let b3 = Book { isbn: 10, format: BookFormat::Paperback };\n///\n/// assert!(b1 == b2);\n/// assert!(b1 != b3);\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// let x: u32 = 0;\n/// let y: u32 = 1;\n///\n/// assert_eq!(x == y, false);\n/// assert_eq!(x.eq(&y), false);\n/// ```\n#[lang = \"eq\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"can't compare `{Self}` with `{Rhs}`\"]\npub trait PartialEq<Rhs: ?Sized = Self> {\n    /// This method tests for `self` and `other` values to be equal, and is used\n    /// by `==`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn eq(&self, other: &Rhs) -> bool;\n\n    /// This method tests for `!=`.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }\n}\n\n/// Trait for equality comparisons which are [equivalence relations](\n/// https://en.wikipedia.org/wiki/Equivalence_relation).\n///\n/// This means, that in addition to `a == b` and `a != b` being strict inverses, the equality must\n/// be (for all `a`, `b` and `c`):\n///\n/// - reflexive: `a == a`;\n/// - symmetric: `a == b` implies `b == a`; and\n/// - transitive: `a == b` and `b == c` implies `a == c`.\n///\n/// This property cannot be checked by the compiler, and therefore `Eq` implies\n/// `PartialEq`, and has no extra methods.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d, because `Eq` has\n/// no extra methods, it is only informing the compiler that this is an\n/// equivalence relation rather than a partial equivalence relation. Note that\n/// the `derive` strategy requires all fields are `Eq`, which isn't\n/// always desired.\n///\n/// ## How can I implement `Eq`?\n///\n/// If you cannot use the `derive` strategy, specify that your type implements\n/// `Eq`, which has no methods:\n///\n/// ```\n/// enum BookFormat { Paperback, Hardback, Ebook }\n/// struct Book {\n///     isbn: i32,\n///     format: BookFormat,\n/// }\n/// impl PartialEq for Book {\n///     fn eq(&self, other: &Book) -> bool {\n///         self.isbn == other.isbn\n///     }\n/// }\n/// impl Eq for Book {}\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Eq: PartialEq<Self> {\n    // FIXME #13101: this method is used solely by #[deriving] to\n    // assert that every component of a type implements #[deriving]\n    // itself, the current deriving infrastructure means doing this\n    // assertion without using a method on this trait is nearly\n    // impossible.\n    //\n    // This should never be implemented by hand.\n    #[doc(hidden)]\n    #[inline(always)]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn assert_receiver_is_total_eq(&self) {}\n}\n\n// FIXME: this struct is used solely by #[derive] to\n// assert that every component of a type implements Eq.\n//\n// This struct should never appear in user code.\n#[doc(hidden)]\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"derive_eq\",\n           reason = \"deriving hack, should not be public\",\n           issue = \"0\")]\npub struct AssertParamIsEq<T: Eq + ?Sized> { _field: ::marker::PhantomData<T> }\n\n/// An `Ordering` is the result of a comparison between two values.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// let result = 1.cmp(&2);\n/// assert_eq!(Ordering::Less, result);\n///\n/// let result = 1.cmp(&1);\n/// assert_eq!(Ordering::Equal, result);\n///\n/// let result = 2.cmp(&1);\n/// assert_eq!(Ordering::Greater, result);\n/// ```\n#[derive(Clone, Copy, PartialEq, Debug, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Ordering {\n    /// An ordering where a compared value is less [than another].\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Less = -1,\n    /// An ordering where a compared value is equal [to another].\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Equal = 0,\n    /// An ordering where a compared value is greater [than another].\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Greater = 1,\n}\n\nimpl Ordering {\n    /// Reverses the `Ordering`.\n    ///\n    /// * `Less` becomes `Greater`.\n    /// * `Greater` becomes `Less`.\n    /// * `Equal` becomes `Equal`.\n    ///\n    /// # Examples\n    ///\n    /// Basic behavior:\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(Ordering::Less.reverse(), Ordering::Greater);\n    /// assert_eq!(Ordering::Equal.reverse(), Ordering::Equal);\n    /// assert_eq!(Ordering::Greater.reverse(), Ordering::Less);\n    /// ```\n    ///\n    /// This method can be used to reverse a comparison:\n    ///\n    /// ```\n    /// let mut data: &mut [_] = &mut [2, 10, 5, 8];\n    ///\n    /// // sort the array from largest to smallest.\n    /// data.sort_by(|a, b| a.cmp(b).reverse());\n    ///\n    /// let b: &mut [_] = &mut [10, 8, 5, 2];\n    /// assert!(data == b);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reverse(self) -> Ordering {\n        match self {\n            Less => Greater,\n            Equal => Equal,\n            Greater => Less,\n        }\n    }\n\n    /// Chains two orderings.\n    ///\n    /// Returns `self` when it's not `Equal`. Otherwise returns `other`.\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// let result = Ordering::Equal.then(Ordering::Less);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then(Ordering::Equal);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then(Ordering::Greater);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Equal.then(Ordering::Equal);\n    /// assert_eq!(result, Ordering::Equal);\n    ///\n    /// let x: (i64, i64, i64) = (1, 2, 7);\n    /// let y: (i64, i64, i64) = (1, 5, 3);\n    /// let result = x.0.cmp(&y.0).then(x.1.cmp(&y.1)).then(x.2.cmp(&y.2));\n    ///\n    /// assert_eq!(result, Ordering::Less);\n    /// ```\n    #[inline]\n    #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n    pub fn then(self, other: Ordering) -> Ordering {\n        match self {\n            Equal => other,\n            _ => self,\n        }\n    }\n\n    /// Chains the ordering with the given function.\n    ///\n    /// Returns `self` when it's not `Equal`. Otherwise calls `f` and returns\n    /// the result.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// let result = Ordering::Equal.then_with(|| Ordering::Less);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then_with(|| Ordering::Equal);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then_with(|| Ordering::Greater);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Equal.then_with(|| Ordering::Equal);\n    /// assert_eq!(result, Ordering::Equal);\n    ///\n    /// let x: (i64, i64, i64) = (1, 2, 7);\n    /// let y: (i64, i64, i64)  = (1, 5, 3);\n    /// let result = x.0.cmp(&y.0).then_with(|| x.1.cmp(&y.1)).then_with(|| x.2.cmp(&y.2));\n    ///\n    /// assert_eq!(result, Ordering::Less);\n    /// ```\n    #[inline]\n    #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n    pub fn then_with<F: FnOnce() -> Ordering>(self, f: F) -> Ordering {\n        match self {\n            Equal => f(),\n            _ => self,\n        }\n    }\n}\n\n/// A helper struct for reverse ordering.\n///\n/// This struct is a helper to be used with functions like `Vec::sort_by_key` and\n/// can be used to reverse order a part of a key.\n///\n/// Example usage:\n///\n/// ```\n/// use std::cmp::Reverse;\n///\n/// let mut v = vec![1, 2, 3, 4, 5, 6];\n/// v.sort_by_key(|&num| (num > 3, Reverse(num)));\n/// assert_eq!(v, vec![3, 2, 1, 6, 5, 4]);\n/// ```\n#[derive(PartialEq, Eq, Debug)]\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\npub struct Reverse<T>(#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")] pub T);\n\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool { other.0 < self.0 }\n    #[inline]\n    fn le(&self, other: &Self) -> bool { other.0 <= self.0 }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool { other.0 >= self.0 }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool { other.0 > self.0 }\n}\n\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n/// Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).\n///\n/// An order is a total order if it is (for all `a`, `b` and `c`):\n///\n/// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and\n/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n/// lexicographic ordering based on the top-to-bottom declaration order of the struct's members.\n/// When `derive`d on enums, variants are ordered by their top-to-bottom declaration order.\n///\n/// ## How can I implement `Ord`?\n///\n/// `Ord` requires that the type also be `PartialOrd` and `Eq` (which requires `PartialEq`).\n///\n/// Then you must define an implementation for `cmp()`. You may find it useful to use\n/// `cmp()` on your type's fields.\n///\n/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n/// easy to accidentally make them disagree by deriving some of the traits and manually\n/// implementing others.\n///\n/// Here's an example where you want to sort people by height only, disregarding `id`\n/// and `name`:\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// #[derive(Eq)]\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     height: u32,\n/// }\n///\n/// impl Ord for Person {\n///     fn cmp(&self, other: &Person) -> Ordering {\n///         self.height.cmp(&other.height)\n///     }\n/// }\n///\n/// impl PartialOrd for Person {\n///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n///         Some(self.cmp(other))\n///     }\n/// }\n///\n/// impl PartialEq for Person {\n///     fn eq(&self, other: &Person) -> bool {\n///         self.height == other.height\n///     }\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Ord: Eq + PartialOrd<Self> {\n    /// This method returns an `Ordering` between `self` and `other`.\n    ///\n    /// By convention, `self.cmp(&other)` returns the ordering matching the expression\n    /// `self <operator> other` if true.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(5.cmp(&10), Ordering::Less);\n    /// assert_eq!(10.cmp(&5), Ordering::Greater);\n    /// assert_eq!(5.cmp(&5), Ordering::Equal);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn cmp(&self, other: &Self) -> Ordering;\n\n    /// Compares and returns the maximum of two values.\n    ///\n    /// Returns the second argument if the comparison determines them to be equal.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ord_max_min)]\n    ///\n    /// assert_eq!(2, 1.max(2));\n    /// assert_eq!(2, 2.max(2));\n    /// ```\n    #[unstable(feature = \"ord_max_min\", issue = \"25663\")]\n    fn max(self, other: Self) -> Self\n    where Self: Sized {\n        if other >= self { other } else { self }\n    }\n\n    /// Compares and returns the minimum of two values.\n    ///\n    /// Returns the first argument if the comparison determines them to be equal.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ord_max_min)]\n    ///\n    /// assert_eq!(1, 1.min(2));\n    /// assert_eq!(2, 2.min(2));\n    /// ```\n    #[unstable(feature = \"ord_max_min\", issue = \"25663\")]\n    fn min(self, other: Self) -> Self\n    where Self: Sized {\n        if self <= other { self } else { other }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for Ordering {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for Ordering {\n    #[inline]\n    fn cmp(&self, other: &Ordering) -> Ordering {\n        (*self as i32).cmp(&(*other as i32))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for Ordering {\n    #[inline]\n    fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n        (*self as i32).partial_cmp(&(*other as i32))\n    }\n}\n\n/// Trait for values that can be compared for a sort-order.\n///\n/// The comparison must satisfy, for all `a`, `b` and `c`:\n///\n/// - antisymmetry: if `a < b` then `!(a > b)`, as well as `a > b` implying `!(a < b)`; and\n/// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n///\n/// Note that these requirements mean that the trait itself must be implemented symmetrically and\n/// transitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n/// PartialOrd<V>`.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n/// lexicographic ordering based on the top-to-bottom declaration order of the struct's members.\n/// When `derive`d on enums, variants are ordered by their top-to-bottom declaration order.\n///\n/// ## How can I implement `PartialOrd`?\n///\n/// `PartialOrd` only requires implementation of the `partial_cmp` method, with the others\n/// generated from default implementations.\n///\n/// However it remains possible to implement the others separately for types which do not have a\n/// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n/// false` (cf. IEEE 754-2008 section 5.11).\n///\n/// `PartialOrd` requires your type to be `PartialEq`.\n///\n/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n/// easy to accidentally make them disagree by deriving some of the traits and manually\n/// implementing others.\n///\n/// If your type is `Ord`, you can implement `partial_cmp()` by using `cmp()`:\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// #[derive(Eq)]\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     height: u32,\n/// }\n///\n/// impl PartialOrd for Person {\n///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n///         Some(self.cmp(other))\n///     }\n/// }\n///\n/// impl Ord for Person {\n///     fn cmp(&self, other: &Person) -> Ordering {\n///         self.height.cmp(&other.height)\n///     }\n/// }\n///\n/// impl PartialEq for Person {\n///     fn eq(&self, other: &Person) -> bool {\n///         self.height == other.height\n///     }\n/// }\n/// ```\n///\n/// You may also find it useful to use `partial_cmp()` on your type's fields. Here\n/// is an example of `Person` types who have a floating-point `height` field that\n/// is the only field to be used for sorting:\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     height: f64,\n/// }\n///\n/// impl PartialOrd for Person {\n///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n///         self.height.partial_cmp(&other.height)\n///     }\n/// }\n///\n/// impl PartialEq for Person {\n///     fn eq(&self, other: &Person) -> bool {\n///         self.height == other.height\n///     }\n/// }\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// let x : u32 = 0;\n/// let y : u32 = 1;\n///\n/// assert_eq!(x < y, true);\n/// assert_eq!(x.lt(&y), true);\n/// ```\n#[lang = \"ord\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"can't compare `{Self}` with `{Rhs}`\"]\npub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n    /// This method returns an ordering between `self` and `other` values if one exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// let result = 1.0.partial_cmp(&2.0);\n    /// assert_eq!(result, Some(Ordering::Less));\n    ///\n    /// let result = 1.0.partial_cmp(&1.0);\n    /// assert_eq!(result, Some(Ordering::Equal));\n    ///\n    /// let result = 2.0.partial_cmp(&1.0);\n    /// assert_eq!(result, Some(Ordering::Greater));\n    /// ```\n    ///\n    /// When comparison is impossible:\n    ///\n    /// ```\n    /// let result = std::f64::NAN.partial_cmp(&1.0);\n    /// assert_eq!(result, None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n\n    /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 1.0 < 2.0;\n    /// assert_eq!(result, true);\n    ///\n    /// let result = 2.0 < 1.0;\n    /// assert_eq!(result, false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn lt(&self, other: &Rhs) -> bool {\n        match self.partial_cmp(other) {\n            Some(Less) => true,\n            _ => false,\n        }\n    }\n\n    /// This method tests less than or equal to (for `self` and `other`) and is used by the `<=`\n    /// operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 1.0 <= 2.0;\n    /// assert_eq!(result, true);\n    ///\n    /// let result = 2.0 <= 2.0;\n    /// assert_eq!(result, true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn le(&self, other: &Rhs) -> bool {\n        match self.partial_cmp(other) {\n            Some(Less) | Some(Equal) => true,\n            _ => false,\n        }\n    }\n\n    /// This method tests greater than (for `self` and `other`) and is used by the `>` operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 1.0 > 2.0;\n    /// assert_eq!(result, false);\n    ///\n    /// let result = 2.0 > 2.0;\n    /// assert_eq!(result, false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn gt(&self, other: &Rhs) -> bool {\n        match self.partial_cmp(other) {\n            Some(Greater) => true,\n            _ => false,\n        }\n    }\n\n    /// This method tests greater than or equal to (for `self` and `other`) and is used by the `>=`\n    /// operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 2.0 >= 1.0;\n    /// assert_eq!(result, true);\n    ///\n    /// let result = 2.0 >= 2.0;\n    /// assert_eq!(result, true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn ge(&self, other: &Rhs) -> bool {\n        match self.partial_cmp(other) {\n            Some(Greater) | Some(Equal) => true,\n            _ => false,\n        }\n    }\n}\n\n/// Compares and returns the minimum of two values.\n///\n/// Returns the first argument if the comparison determines them to be equal.\n///\n/// Internally uses an alias to `Ord::min`.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp;\n///\n/// assert_eq!(1, cmp::min(1, 2));\n/// assert_eq!(2, cmp::min(2, 2));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn min<T: Ord>(v1: T, v2: T) -> T {\n    v1.min(v2)\n}\n\n/// Compares and returns the maximum of two values.\n///\n/// Returns the second argument if the comparison determines them to be equal.\n///\n/// Internally uses an alias to `Ord::max`.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp;\n///\n/// assert_eq!(2, cmp::max(1, 2));\n/// assert_eq!(2, cmp::max(2, 2));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn max<T: Ord>(v1: T, v2: T) -> T {\n    v1.max(v2)\n}\n\n// Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types\nmod impls {\n    use cmp::Ordering::{self, Less, Greater, Equal};\n\n    macro_rules! partial_eq_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialEq for $t {\n                #[inline]\n                fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n                #[inline]\n                fn ne(&self, other: &$t) -> bool { (*self) != (*other) }\n            }\n        )*)\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialEq for () {\n        #[inline]\n        fn eq(&self, _other: &()) -> bool { true }\n        #[inline]\n        fn ne(&self, _other: &()) -> bool { false }\n    }\n\n    partial_eq_impl! {\n        bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64\n    }\n\n    macro_rules! eq_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Eq for $t {}\n        )*)\n    }\n\n    eq_impl! { () bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n    macro_rules! partial_ord_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialOrd for $t {\n                #[inline]\n                fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n                    match (self <= other, self >= other) {\n                        (false, false) => None,\n                        (false, true) => Some(Greater),\n                        (true, false) => Some(Less),\n                        (true, true) => Some(Equal),\n                    }\n                }\n                #[inline]\n                fn lt(&self, other: &$t) -> bool { (*self) < (*other) }\n                #[inline]\n                fn le(&self, other: &$t) -> bool { (*self) <= (*other) }\n                #[inline]\n                fn ge(&self, other: &$t) -> bool { (*self) >= (*other) }\n                #[inline]\n                fn gt(&self, other: &$t) -> bool { (*self) > (*other) }\n            }\n        )*)\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialOrd for () {\n        #[inline]\n        fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n            Some(Equal)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialOrd for bool {\n        #[inline]\n        fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n            (*self as u8).partial_cmp(&(*other as u8))\n        }\n    }\n\n    partial_ord_impl! { f32 f64 }\n\n    macro_rules! ord_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialOrd for $t {\n                #[inline]\n                fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n                    Some(self.cmp(other))\n                }\n                #[inline]\n                fn lt(&self, other: &$t) -> bool { (*self) < (*other) }\n                #[inline]\n                fn le(&self, other: &$t) -> bool { (*self) <= (*other) }\n                #[inline]\n                fn ge(&self, other: &$t) -> bool { (*self) >= (*other) }\n                #[inline]\n                fn gt(&self, other: &$t) -> bool { (*self) > (*other) }\n            }\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Ord for $t {\n                #[inline]\n                fn cmp(&self, other: &$t) -> Ordering {\n                    if *self == *other { Equal }\n                    else if *self < *other { Less }\n                    else { Greater }\n                }\n            }\n        )*)\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Ord for () {\n        #[inline]\n        fn cmp(&self, _other: &()) -> Ordering { Equal }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Ord for bool {\n        #[inline]\n        fn cmp(&self, other: &bool) -> Ordering {\n            (*self as u8).cmp(&(*other as u8))\n        }\n    }\n\n    ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n    #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n    impl PartialEq for ! {\n        fn eq(&self, _: &!) -> bool {\n            *self\n        }\n    }\n\n    #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n    impl Eq for ! {}\n\n    #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n    impl PartialOrd for ! {\n        fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n            *self\n        }\n    }\n\n    #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n    impl Ord for ! {\n        fn cmp(&self, _: &!) -> Ordering {\n            *self\n        }\n    }\n\n    // & pointers\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n        #[inline]\n        fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n        #[inline]\n        fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n        #[inline]\n        fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n            PartialOrd::partial_cmp(*self, *other)\n        }\n        #[inline]\n        fn lt(&self, other: & &'b B) -> bool { PartialOrd::lt(*self, *other) }\n        #[inline]\n        fn le(&self, other: & &'b B) -> bool { PartialOrd::le(*self, *other) }\n        #[inline]\n        fn ge(&self, other: & &'b B) -> bool { PartialOrd::ge(*self, *other) }\n        #[inline]\n        fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, A: ?Sized> Ord for &'a A where A: Ord {\n        #[inline]\n        fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, A: ?Sized> Eq for &'a A where A: Eq {}\n\n    // &mut pointers\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n        #[inline]\n        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n        #[inline]\n        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n        #[inline]\n        fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n            PartialOrd::partial_cmp(*self, *other)\n        }\n        #[inline]\n        fn lt(&self, other: &&'b mut B) -> bool { PartialOrd::lt(*self, *other) }\n        #[inline]\n        fn le(&self, other: &&'b mut B) -> bool { PartialOrd::le(*self, *other) }\n        #[inline]\n        fn ge(&self, other: &&'b mut B) -> bool { PartialOrd::ge(*self, *other) }\n        #[inline]\n        fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, A: ?Sized> Ord for &'a mut A where A: Ord {\n        #[inline]\n        fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, A: ?Sized> Eq for &'a mut A where A: Eq {}\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n        #[inline]\n        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n        #[inline]\n        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n        #[inline]\n        fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }\n        #[inline]\n        fn ne(&self, other: &&'b B) -> bool { PartialEq::ne(*self, *other) }\n    }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n\nuse cmp;\nuse io::{self, Read};\nuse libc::{self, c_int, c_void, ssize_t};\nuse mem;\nuse sync::atomic::{AtomicBool, Ordering};\nuse sys::cvt;\nuse sys_common::AsInner;\n\n#[derive(Debug)]\npub struct FileDesc {\n    fd: c_int,\n}\n\nfn max_len() -> usize {\n    // The maximum read limit on most posix-like systems is `SSIZE_MAX`,\n    // with the man page quoting that if the count of bytes to read is\n    // greater than `SSIZE_MAX` the result is \"unspecified\".\n    //\n    // On macOS, however, apparently the 64-bit libc is either buggy or\n    // intentionally showing odd behavior by rejecting any read with a size\n    // larger than or equal to INT_MAX. To handle both of these the read\n    // size is capped on both platforms.\n    if cfg!(target_os = \"macos\") {\n        <c_int>::max_value() as usize - 1\n    } else {\n        <ssize_t>::max_value() as usize\n    }\n}\n\nimpl FileDesc {\n    pub fn new(fd: c_int) -> FileDesc {\n        FileDesc { fd: fd }\n    }\n\n    pub fn raw(&self) -> c_int { self.fd }\n\n    /// Extracts the actual filedescriptor without closing it.\n    pub fn into_raw(self) -> c_int {\n        let fd = self.fd;\n        mem::forget(self);\n        fd\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        let ret = cvt(unsafe {\n            libc::read(self.fd,\n                       buf.as_mut_ptr() as *mut c_void,\n                       cmp::min(buf.len(), max_len()))\n        })?;\n        Ok(ret as usize)\n    }\n\n    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        let mut me = self;\n        (&mut me).read_to_end(buf)\n    }\n\n    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n        #[cfg(target_os = \"android\")]\n        use super::android::cvt_pread64;\n\n        #[cfg(not(target_os = \"android\"))]\n        unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: usize, offset: i64)\n            -> io::Result<isize>\n        {\n            #[cfg(any(target_os = \"linux\", target_os = \"emscripten\"))]\n            use libc::pread64;\n            #[cfg(not(any(target_os = \"linux\", target_os = \"emscripten\")))]\n            use libc::pread as pread64;\n            cvt(pread64(fd, buf, count, offset))\n        }\n\n        unsafe {\n            cvt_pread64(self.fd,\n                        buf.as_mut_ptr() as *mut c_void,\n                        cmp::min(buf.len(), max_len()),\n                        offset as i64)\n                .map(|n| n as usize)\n        }\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        let ret = cvt(unsafe {\n            libc::write(self.fd,\n                        buf.as_ptr() as *const c_void,\n                        cmp::min(buf.len(), max_len()))\n        })?;\n        Ok(ret as usize)\n    }\n\n    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n        #[cfg(target_os = \"android\")]\n        use super::android::cvt_pwrite64;\n\n        #[cfg(not(target_os = \"android\"))]\n        unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: usize, offset: i64)\n            -> io::Result<isize>\n        {\n            #[cfg(any(target_os = \"linux\", target_os = \"emscripten\"))]\n            use libc::pwrite64;\n            #[cfg(not(any(target_os = \"linux\", target_os = \"emscripten\")))]\n            use libc::pwrite as pwrite64;\n            cvt(pwrite64(fd, buf, count, offset))\n        }\n\n        unsafe {\n            cvt_pwrite64(self.fd,\n                         buf.as_ptr() as *const c_void,\n                         cmp::min(buf.len(), max_len()),\n                         offset as i64)\n                .map(|n| n as usize)\n        }\n    }\n\n    #[cfg(not(any(target_env = \"newlib\",\n                  target_os = \"solaris\",\n                  target_os = \"emscripten\",\n                  target_os = \"fuchsia\",\n                  target_os = \"haiku\")))]\n    pub fn set_cloexec(&self) -> io::Result<()> {\n        unsafe {\n            cvt(libc::ioctl(self.fd, libc::FIOCLEX))?;\n            Ok(())\n        }\n    }\n    #[cfg(any(target_env = \"newlib\",\n              target_os = \"solaris\",\n              target_os = \"emscripten\",\n              target_os = \"fuchsia\",\n              target_os = \"haiku\"))]\n    pub fn set_cloexec(&self) -> io::Result<()> {\n        unsafe {\n            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD))?;\n            let new = previous | libc::FD_CLOEXEC;\n            if new != previous {\n                cvt(libc::fcntl(self.fd, libc::F_SETFD, new))?;\n            }\n            Ok(())\n        }\n    }\n\n    #[cfg(target_os = \"linux\")]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        unsafe {\n            let v = nonblocking as c_int;\n            cvt(libc::ioctl(self.fd, libc::FIONBIO, &v))?;\n            Ok(())\n        }\n    }\n\n    #[cfg(not(target_os = \"linux\"))]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        unsafe {\n            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFL))?;\n            let new = if nonblocking {\n                previous | libc::O_NONBLOCK\n            } else {\n                previous & !libc::O_NONBLOCK\n            };\n            if new != previous {\n                cvt(libc::fcntl(self.fd, libc::F_SETFL, new))?;\n            }\n            Ok(())\n        }\n    }\n\n    pub fn duplicate(&self) -> io::Result<FileDesc> {\n        // We want to atomically duplicate this file descriptor and set the\n        // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n        // flag, however, isn't supported on older Linux kernels (earlier than\n        // 2.6.24).\n        //\n        // To detect this and ensure that CLOEXEC is still set, we\n        // follow a strategy similar to musl [1] where if passing\n        // F_DUPFD_CLOEXEC causes `fcntl` to return EINVAL it means it's not\n        // supported (the third parameter, 0, is always valid), so we stop\n        // trying that.\n        //\n        // Also note that Android doesn't have F_DUPFD_CLOEXEC, but get it to\n        // resolve so we at least compile this.\n        //\n        // [1]: http://comments.gmane.org/gmane.linux.lib.musl.general/2963\n        #[cfg(any(target_os = \"android\", target_os = \"haiku\"))]\n        use libc::F_DUPFD as F_DUPFD_CLOEXEC;\n        #[cfg(not(any(target_os = \"android\", target_os=\"haiku\")))]\n        use libc::F_DUPFD_CLOEXEC;\n\n        let make_filedesc = |fd| {\n            let fd = FileDesc::new(fd);\n            fd.set_cloexec()?;\n            Ok(fd)\n        };\n        static TRY_CLOEXEC: AtomicBool =\n            AtomicBool::new(!cfg!(target_os = \"android\"));\n        let fd = self.raw();\n        if TRY_CLOEXEC.load(Ordering::Relaxed) {\n            match cvt(unsafe { libc::fcntl(fd, F_DUPFD_CLOEXEC, 0) }) {\n                // We *still* call the `set_cloexec` method as apparently some\n                // linux kernel at some point stopped setting CLOEXEC even\n                // though it reported doing so on F_DUPFD_CLOEXEC.\n                Ok(fd) => {\n                    return Ok(if cfg!(target_os = \"linux\") {\n                        make_filedesc(fd)?\n                    } else {\n                        FileDesc::new(fd)\n                    })\n                }\n                Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {\n                    TRY_CLOEXEC.store(false, Ordering::Relaxed);\n                }\n                Err(e) => return Err(e),\n            }\n        }\n        cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD, 0) }).and_then(make_filedesc)\n    }\n}\n\nimpl<'a> Read for &'a FileDesc {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n}\n\nimpl AsInner<c_int> for FileDesc {\n    fn as_inner(&self) -> &c_int { &self.fd }\n}\n\nimpl Drop for FileDesc {\n    fn drop(&mut self) {\n        // Note that errors are ignored when closing a file descriptor. The\n        // reason for this is that if an error occurs we don't actually know if\n        // the file descriptor was closed or not, and if we retried (for\n        // something like EINTR), we might close another valid file descriptor\n        // (opened after we closed ours.\n        let _ = unsafe { libc::close(self.fd) };\n    }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse io;\nuse libc;\nuse sys::fd::FileDesc;\n\npub struct Stdin(());\npub struct Stdout(());\npub struct Stderr(());\n\nimpl Stdin {\n    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n\n    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n        let fd = FileDesc::new(libc::STDIN_FILENO);\n        let ret = fd.read(data);\n        fd.into_raw();\n        ret\n    }\n}\n\nimpl Stdout {\n    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n\n    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n        let fd = FileDesc::new(libc::STDOUT_FILENO);\n        let ret = fd.write(data);\n        fd.into_raw();\n        ret\n    }\n\n    pub fn flush(&self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl Stderr {\n    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n\n    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n        let fd = FileDesc::new(libc::STDERR_FILENO);\n        let ret = fd.write(data);\n        fd.into_raw();\n        ret\n    }\n\n    pub fn flush(&self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n// FIXME: right now this raw stderr handle is used in a few places because\n//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n//        should go away\nimpl io::Write for Stderr {\n    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n        Stderr::write(self, data)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Stderr::flush(self)\n    }\n}\n\npub const EBADF_ERR: i32 = ::libc::EBADF as i32;\npub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse cmp;\nuse io::{self, SeekFrom, Read, Initializer, Write, Seek, BufRead, Error, ErrorKind};\nuse fmt;\nuse mem;\n\n// =============================================================================\n// Forwarding implementations\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, R: Read + ?Sized> Read for &'a mut R {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        (**self).initializer()\n    }\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_to_end(buf)\n    }\n\n    #[inline]\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_to_string(buf)\n    }\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        (**self).read_exact(buf)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, W: Write + ?Sized> Write for &'a mut W {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        (**self).write_all(buf)\n    }\n\n    #[inline]\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> {\n        (**self).write_fmt(fmt)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, S: Seek + ?Sized> Seek for &'a mut S {\n    #[inline]\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, B: BufRead + ?Sized> BufRead for &'a mut B {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n\n    #[inline]\n    fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n\n    #[inline]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_until(byte, buf)\n    }\n\n    #[inline]\n    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_line(buf)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read + ?Sized> Read for Box<R> {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        (**self).initializer()\n    }\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_to_end(buf)\n    }\n\n    #[inline]\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_to_string(buf)\n    }\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        (**self).read_exact(buf)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write + ?Sized> Write for Box<W> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        (**self).write_all(buf)\n    }\n\n    #[inline]\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> {\n        (**self).write_fmt(fmt)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<S: Seek + ?Sized> Seek for Box<S> {\n    #[inline]\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead + ?Sized> BufRead for Box<B> {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n\n    #[inline]\n    fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n\n    #[inline]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_until(byte, buf)\n    }\n\n    #[inline]\n    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_line(buf)\n    }\n}\n\n// =============================================================================\n// In-memory buffer implementations\n\n/// Read is implemented for `&[u8]` by copying from the slice.\n///\n/// Note that reading updates the slice to point to the yet unread part.\n/// The slice will be empty when EOF is reached.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Read for &'a [u8] {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let amt = cmp::min(buf.len(), self.len());\n        let (a, b) = self.split_at(amt);\n\n        // First check if the amount of bytes we want to read is small:\n        // `copy_from_slice` will generally expand to a call to `memcpy`, and\n        // for a single byte the overhead is significant.\n        if amt == 1 {\n            buf[0] = a[0];\n        } else {\n            buf[..amt].copy_from_slice(a);\n        }\n\n        *self = b;\n        Ok(amt)\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        if buf.len() > self.len() {\n            return Err(Error::new(ErrorKind::UnexpectedEof,\n                                  \"failed to fill whole buffer\"));\n        }\n        let (a, b) = self.split_at(buf.len());\n\n        // First check if the amount of bytes we want to read is small:\n        // `copy_from_slice` will generally expand to a call to `memcpy`, and\n        // for a single byte the overhead is significant.\n        if buf.len() == 1 {\n            buf[0] = a[0];\n        } else {\n            buf.copy_from_slice(a);\n        }\n\n        *self = b;\n        Ok(())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> BufRead for &'a [u8] {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(*self) }\n\n    #[inline]\n    fn consume(&mut self, amt: usize) { *self = &self[amt..]; }\n}\n\n/// Write is implemented for `&mut [u8]` by copying into the slice, overwriting\n/// its data.\n///\n/// Note that writing updates the slice to point to the yet unwritten part.\n/// The slice will be empty when it has been completely overwritten.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Write for &'a mut [u8] {\n    #[inline]\n    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n        let amt = cmp::min(data.len(), self.len());\n        let (a, b) = mem::replace(self, &mut []).split_at_mut(amt);\n        a.copy_from_slice(&data[..amt]);\n        *self = b;\n        Ok(amt)\n    }\n\n    #[inline]\n    fn write_all(&mut self, data: &[u8]) -> io::Result<()> {\n        if self.write(data)? == data.len() {\n            Ok(())\n        } else {\n            Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\"))\n        }\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n}\n\n/// Write is implemented for `Vec<u8>` by appending to the vector.\n/// The vector will grow as needed.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Vec<u8> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.extend_from_slice(buf);\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.extend_from_slice(buf);\n        Ok(())\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n}\n\n#[cfg(test)]\nmod tests {\n    use io::prelude::*;\n    use test;\n\n    #[bench]\n    fn bench_read_slice(b: &mut test::Bencher) {\n        let buf = [5; 1024];\n        let mut dst = [0; 128];\n\n        b.iter(|| {\n            let mut rd = &buf[..];\n            for _ in 0..8 {\n                let _ = rd.read(&mut dst);\n                test::black_box(&dst);\n            }\n        })\n    }\n\n    #[bench]\n    fn bench_write_slice(b: &mut test::Bencher) {\n        let mut buf = [0; 1024];\n        let src = [5; 128];\n\n        b.iter(|| {\n            let mut wr = &mut buf[..];\n            for _ in 0..8 {\n                let _ = wr.write_all(&src);\n                test::black_box(&wr);\n            }\n        })\n    }\n\n    #[bench]\n    fn bench_read_vec(b: &mut test::Bencher) {\n        let buf = vec![5; 1024];\n        let mut dst = [0; 128];\n\n        b.iter(|| {\n            let mut rd = &buf[..];\n            for _ in 0..8 {\n                let _ = rd.read(&mut dst);\n                test::black_box(&dst);\n            }\n        })\n    }\n\n    #[bench]\n    fn bench_write_vec(b: &mut test::Bencher) {\n        let mut buf = Vec::with_capacity(1024);\n        let src = [5; 128];\n\n        b.iter(|| {\n            let mut wr = &mut buf[..];\n            for _ in 0..8 {\n                let _ = wr.write_all(&src);\n                test::black_box(&wr);\n            }\n        })\n    }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Traits, helpers, and type definitions for core I/O functionality.\n//!\n//! The `std::io` module contains a number of common things you'll need\n//! when doing input and output. The most core part of this module is\n//! the [`Read`] and [`Write`] traits, which provide the\n//! most general interface for reading and writing input and output.\n//!\n//! # Read and Write\n//!\n//! Because they are traits, [`Read`] and [`Write`] are implemented by a number\n//! of other types, and you can implement them for your types too. As such,\n//! you'll see a few different types of I/O throughout the documentation in\n//! this module: [`File`]s, [`TcpStream`]s, and sometimes even [`Vec<T>`]s. For\n//! example, [`Read`] adds a [`read`][`Read::read`] method, which we can use on\n//! `File`s:\n//!\n//! ```\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::fs::File;\n//!\n//! # fn foo() -> io::Result<()> {\n//! let mut f = File::open(\"foo.txt\")?;\n//! let mut buffer = [0; 10];\n//!\n//! // read up to 10 bytes\n//! f.read(&mut buffer)?;\n//!\n//! println!(\"The bytes: {:?}\", buffer);\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! [`Read`] and [`Write`] are so important, implementors of the two traits have a\n//! nickname: readers and writers. So you'll sometimes see 'a reader' instead\n//! of 'a type that implements the [`Read`] trait'. Much easier!\n//!\n//! ## Seek and BufRead\n//!\n//! Beyond that, there are two important traits that are provided: [`Seek`]\n//! and [`BufRead`]. Both of these build on top of a reader to control\n//! how the reading happens. [`Seek`] lets you control where the next byte is\n//! coming from:\n//!\n//! ```\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::SeekFrom;\n//! use std::fs::File;\n//!\n//! # fn foo() -> io::Result<()> {\n//! let mut f = File::open(\"foo.txt\")?;\n//! let mut buffer = [0; 10];\n//!\n//! // skip to the last 10 bytes of the file\n//! f.seek(SeekFrom::End(-10))?;\n//!\n//! // read up to 10 bytes\n//! f.read(&mut buffer)?;\n//!\n//! println!(\"The bytes: {:?}\", buffer);\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! [`BufRead`] uses an internal buffer to provide a number of other ways to read, but\n//! to show it off, we'll need to talk about buffers in general. Keep reading!\n//!\n//! ## BufReader and BufWriter\n//!\n//! Byte-based interfaces are unwieldy and can be inefficient, as we'd need to be\n//! making near-constant calls to the operating system. To help with this,\n//! `std::io` comes with two structs, [`BufReader`] and [`BufWriter`], which wrap\n//! readers and writers. The wrapper uses a buffer, reducing the number of\n//! calls and providing nicer methods for accessing exactly what you want.\n//!\n//! For example, [`BufReader`] works with the [`BufRead`] trait to add extra\n//! methods to any reader:\n//!\n//! ```\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufReader;\n//! use std::fs::File;\n//!\n//! # fn foo() -> io::Result<()> {\n//! let f = File::open(\"foo.txt\")?;\n//! let mut reader = BufReader::new(f);\n//! let mut buffer = String::new();\n//!\n//! // read a line into buffer\n//! reader.read_line(&mut buffer)?;\n//!\n//! println!(\"{}\", buffer);\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! [`BufWriter`] doesn't add any new ways of writing; it just buffers every call\n//! to [`write`][`Write::write`]:\n//!\n//! ```\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufWriter;\n//! use std::fs::File;\n//!\n//! # fn foo() -> io::Result<()> {\n//! let f = File::create(\"foo.txt\")?;\n//! {\n//!     let mut writer = BufWriter::new(f);\n//!\n//!     // write a byte to the buffer\n//!     writer.write(&[42])?;\n//!\n//! } // the buffer is flushed once writer goes out of scope\n//!\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! ## Standard input and output\n//!\n//! A very common source of input is standard input:\n//!\n//! ```\n//! use std::io;\n//!\n//! # fn foo() -> io::Result<()> {\n//! let mut input = String::new();\n//!\n//! io::stdin().read_line(&mut input)?;\n//!\n//! println!(\"You typed: {}\", input.trim());\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! Note that you cannot use the `?` operator in functions that do not return\n//! a `Result<T, E>` (e.g. `main`). Instead, you can call `.unwrap()` or `match`\n//! on the return value to catch any possible errors:\n//!\n//! ```\n//! use std::io;\n//!\n//! let mut input = String::new();\n//!\n//! io::stdin().read_line(&mut input).unwrap();\n//! ```\n//!\n//! And a very common source of output is standard output:\n//!\n//! ```\n//! use std::io;\n//! use std::io::prelude::*;\n//!\n//! # fn foo() -> io::Result<()> {\n//! io::stdout().write(&[42])?;\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! Of course, using [`io::stdout`] directly is less common than something like\n//! [`println!`].\n//!\n//! ## Iterator types\n//!\n//! A large number of the structures provided by `std::io` are for various\n//! ways of iterating over I/O. For example, [`Lines`] is used to split over\n//! lines:\n//!\n//! ```\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufReader;\n//! use std::fs::File;\n//!\n//! # fn foo() -> io::Result<()> {\n//! let f = File::open(\"foo.txt\")?;\n//! let reader = BufReader::new(f);\n//!\n//! for line in reader.lines() {\n//!     println!(\"{}\", line?);\n//! }\n//!\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! ## Functions\n//!\n//! There are a number of [functions][functions-list] that offer access to various\n//! features. For example, we can use three of these functions to copy everything\n//! from standard input to standard output:\n//!\n//! ```\n//! use std::io;\n//!\n//! # fn foo() -> io::Result<()> {\n//! io::copy(&mut io::stdin(), &mut io::stdout())?;\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! [functions-list]: #functions-1\n//!\n//! ## io::Result\n//!\n//! Last, but certainly not least, is [`io::Result`]. This type is used\n//! as the return type of many `std::io` functions that can cause an error, and\n//! can be returned from your own functions as well. Many of the examples in this\n//! module use the [`?` operator]:\n//!\n//! ```\n//! use std::io;\n//!\n//! fn read_input() -> io::Result<()> {\n//!     let mut input = String::new();\n//!\n//!     io::stdin().read_line(&mut input)?;\n//!\n//!     println!(\"You typed: {}\", input.trim());\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! The return type of `read_input()`, [`io::Result<()>`][`io::Result`], is a very\n//! common type for functions which don't have a 'real' return value, but do want to\n//! return errors if they happen. In this case, the only purpose of this function is\n//! to read the line and print it, so we use `()`.\n//!\n//! ## Platform-specific behavior\n//!\n//! Many I/O functions throughout the standard library are documented to indicate\n//! what various library or syscalls they are delegated to. This is done to help\n//! applications both understand what's happening under the hood as well as investigate\n//! any possibly unclear semantics. Note, however, that this is informative, not a binding\n//! contract. The implementation of many of these functions are subject to change over\n//! time and may call fewer or more syscalls/library functions.\n//!\n//! [`Read`]: trait.Read.html\n//! [`Write`]: trait.Write.html\n//! [`Seek`]: trait.Seek.html\n//! [`BufRead`]: trait.BufRead.html\n//! [`File`]: ../fs/struct.File.html\n//! [`TcpStream`]: ../net/struct.TcpStream.html\n//! [`Vec<T>`]: ../vec/struct.Vec.html\n//! [`BufReader`]: struct.BufReader.html\n//! [`BufWriter`]: struct.BufWriter.html\n//! [`Write::write`]: trait.Write.html#tymethod.write\n//! [`io::stdout`]: fn.stdout.html\n//! [`println!`]: ../macro.println.html\n//! [`Lines`]: struct.Lines.html\n//! [`io::Result`]: type.Result.html\n//! [`?` operator]: ../../book/first-edition/syntax-index.html\n//! [`Read::read`]: trait.Read.html#tymethod.read\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse cmp;\nuse core::str as core_str;\nuse error as std_error;\nuse fmt;\nuse result;\nuse str;\nuse memchr;\nuse ptr;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::buffered::{BufReader, BufWriter, LineWriter};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::buffered::IntoInnerError;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::cursor::Cursor;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::error::{Result, Error, ErrorKind};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::util::{copy, sink, Sink, empty, Empty, repeat, Repeat};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::stdio::{stdin, stdout, stderr, Stdin, Stdout, Stderr};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::stdio::{StdoutLock, StderrLock, StdinLock};\n#[unstable(feature = \"print_internals\", issue = \"0\")]\npub use self::stdio::{_print, _eprint};\n#[unstable(feature = \"libstd_io_internals\", issue = \"42788\")]\n#[doc(no_inline, hidden)]\npub use self::stdio::{set_panic, set_print};\n\npub mod prelude;\nmod buffered;\nmod cursor;\nmod error;\nmod impls;\nmod lazy;\nmod util;\nmod stdio;\n\nconst DEFAULT_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;\n\nstruct Guard<'a> { buf: &'a mut Vec<u8>, len: usize }\n\nimpl<'a> Drop for Guard<'a> {\n    fn drop(&mut self) {\n        unsafe { self.buf.set_len(self.len); }\n    }\n}\n\n// A few methods below (read_to_string, read_line) will append data into a\n// `String` buffer, but we need to be pretty careful when doing this. The\n// implementation will just call `.as_mut_vec()` and then delegate to a\n// byte-oriented reading method, but we must ensure that when returning we never\n// leave `buf` in a state such that it contains invalid UTF-8 in its bounds.\n//\n// To this end, we use an RAII guard (to protect against panics) which updates\n// the length of the string when it is dropped. This guard initially truncates\n// the string to the prior length and only after we've validated that the\n// new contents are valid UTF-8 do we allow it to set a longer length.\n//\n// The unsafety in this function is twofold:\n//\n// 1. We're looking at the raw bytes of `buf`, so we take on the burden of UTF-8\n//    checks.\n// 2. We're passing a raw buffer to the function `f`, and it is expected that\n//    the function only *appends* bytes to the buffer. We'll get undefined\n//    behavior if existing bytes are overwritten to have non-UTF-8 data.\nfn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n    where F: FnOnce(&mut Vec<u8>) -> Result<usize>\n{\n    unsafe {\n        let mut g = Guard { len: buf.len(), buf: buf.as_mut_vec() };\n        let ret = f(g.buf);\n        if str::from_utf8(&g.buf[g.len..]).is_err() {\n            ret.and_then(|_| {\n                Err(Error::new(ErrorKind::InvalidData,\n                               \"stream did not contain valid UTF-8\"))\n            })\n        } else {\n            g.len = g.buf.len();\n            ret\n        }\n    }\n}\n\n// This uses an adaptive system to extend the vector when it fills. We want to\n// avoid paying to allocate and zero a huge chunk of memory if the reader only\n// has 4 bytes while still making large reads if the reader does have a ton\n// of data to return. Simply tacking on an extra DEFAULT_BUF_SIZE space every\n// time is 4,500 times (!) slower than this if the reader has a very small\n// amount of data to return.\n//\n// Because we're extending the buffer with uninitialized data for trusted\n// readers, we need to make sure to truncate that if any of this panics.\nfn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n    let start_len = buf.len();\n    let mut g = Guard { len: buf.len(), buf: buf };\n    let mut new_write_size = 16;\n    let ret;\n    loop {\n        if g.len == g.buf.len() {\n            if new_write_size < DEFAULT_BUF_SIZE {\n                new_write_size *= 2;\n            }\n            unsafe {\n                g.buf.reserve(new_write_size);\n                g.buf.set_len(g.len + new_write_size);\n                r.initializer().initialize(&mut g.buf[g.len..]);\n            }\n        }\n\n        match r.read(&mut g.buf[g.len..]) {\n            Ok(0) => {\n                ret = Ok(g.len - start_len);\n                break;\n            }\n            Ok(n) => g.len += n,\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n            Err(e) => {\n                ret = Err(e);\n                break;\n            }\n        }\n    }\n\n    ret\n}\n\n/// The `Read` trait allows for reading bytes from a source.\n///\n/// Implementors of the `Read` trait are called 'readers'.\n///\n/// Readers are defined by one required method, `read()`. Each call to `read`\n/// will attempt to pull bytes from this source into a provided buffer. A\n/// number of other methods are implemented in terms of `read()`, giving\n/// implementors a number of ways to read bytes while only needing to implement\n/// a single method.\n///\n/// Readers are intended to be composable with one another. Many implementors\n/// throughout `std::io` take and provide types which implement the `Read`\n/// trait.\n///\n/// Please note that each call to `read` may involve a system call, and\n/// therefore, using something that implements [`BufRead`][bufread], such as\n/// [`BufReader`][bufreader], will be more efficient.\n///\n/// [bufread]: trait.BufRead.html\n/// [bufreader]: struct.BufReader.html\n///\n/// # Examples\n///\n/// [`File`][file]s implement `Read`:\n///\n/// [file]: ../fs/struct.File.html\n///\n/// ```\n/// use std::io;\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// # fn foo() -> io::Result<()> {\n/// let mut f = File::open(\"foo.txt\")?;\n/// let mut buffer = [0; 10];\n///\n/// // read up to 10 bytes\n/// f.read(&mut buffer)?;\n///\n/// let mut buffer = vec![0; 10];\n/// // read the whole file\n/// f.read_to_end(&mut buffer)?;\n///\n/// // read into a String, so that you don't need to do the conversion.\n/// let mut buffer = String::new();\n/// f.read_to_string(&mut buffer)?;\n///\n/// // and more! See the other methods for more details.\n/// # Ok(())\n/// # }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Read {\n    /// Pull some bytes from this source into the specified buffer, returning\n    /// how many bytes were read.\n    ///\n    /// This function does not provide any guarantees about whether it blocks\n    /// waiting for data, but if an object needs to block for a read but cannot\n    /// it will typically signal this via an `Err` return value.\n    ///\n    /// If the return value of this method is `Ok(n)`, then it must be\n    /// guaranteed that `0 <= n <= buf.len()`. A nonzero `n` value indicates\n    /// that the buffer `buf` has been filled in with `n` bytes of data from this\n    /// source. If `n` is `0`, then it can indicate one of two scenarios:\n    ///\n    /// 1. This reader has reached its \"end of file\" and will likely no longer\n    ///    be able to produce bytes. Note that this does not mean that the\n    ///    reader will *always* no longer be able to produce bytes.\n    /// 2. The buffer specified was 0 bytes in length.\n    ///\n    /// No guarantees are provided about the contents of `buf` when this\n    /// function is called, implementations cannot rely on any property of the\n    /// contents of `buf` being true. It is recommended that implementations\n    /// only write data to `buf` instead of reading its contents.\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters any form of I/O or other error, an error\n    /// variant will be returned. If an error is returned then it must be\n    /// guaranteed that no bytes were read.\n    ///\n    /// An error of the `ErrorKind::Interrupted` kind is non-fatal and the read\n    /// operation should be retried if there is nothing else to do.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    /// let mut buffer = [0; 10];\n    ///\n    /// // read up to 10 bytes\n    /// f.read(&mut buffer[..])?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n\n    /// Determines if this `Read`er can work with buffers of uninitialized\n    /// memory.\n    ///\n    /// The default implementation returns an initializer which will zero\n    /// buffers.\n    ///\n    /// If a `Read`er guarantees that it can work properly with uninitialized\n    /// memory, it should call `Initializer::nop()`. See the documentation for\n    /// `Initializer` for details.\n    ///\n    /// The behavior of this method must be independent of the state of the\n    /// `Read`er - the method only takes `&self` so that it can be used through\n    /// trait objects.\n    ///\n    /// # Unsafety\n    ///\n    /// This method is unsafe because a `Read`er could otherwise return a\n    /// non-zeroing `Initializer` from another `Read` type without an `unsafe`\n    /// block.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::zeroing()\n    }\n\n    /// Read all bytes until EOF in this source, placing them into `buf`.\n    ///\n    /// All bytes read from this source will be appended to the specified buffer\n    /// `buf`. This function will continuously call `read` to append more data to\n    /// `buf` until `read` returns either `Ok(0)` or an error of\n    /// non-`ErrorKind::Interrupted` kind.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters an error of the kind\n    /// `ErrorKind::Interrupted` then the error is ignored and the operation\n    /// will continue.\n    ///\n    /// If any other read error is encountered then this function immediately\n    /// returns. Any bytes which have already been read will be appended to\n    /// `buf`.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    /// let mut buffer = Vec::new();\n    ///\n    /// // read the whole file\n    /// f.read_to_end(&mut buffer)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n        read_to_end(self, buf)\n    }\n\n    /// Read all bytes until EOF in this source, placing them into `buf`.\n    ///\n    /// If successful, this function returns the number of bytes which were read\n    /// and appended to `buf`.\n    ///\n    /// # Errors\n    ///\n    /// If the data in this stream is *not* valid UTF-8 then an error is\n    /// returned and `buf` is unchanged.\n    ///\n    /// See [`read_to_end`][readtoend] for other error semantics.\n    ///\n    /// [readtoend]: #method.read_to_end\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    /// let mut buffer = String::new();\n    ///\n    /// f.read_to_string(&mut buffer)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n        // Note that we do *not* call `.read_to_end()` here. We are passing\n        // `&mut Vec<u8>` (the raw contents of `buf`) into the `read_to_end`\n        // method to fill it up. An arbitrary implementation could overwrite the\n        // entire contents of the vector, not just append to it (which is what\n        // we are expecting).\n        //\n        // To prevent extraneously checking the UTF-8-ness of the entire buffer\n        // we pass it to our hardcoded `read_to_end` implementation which we\n        // know is guaranteed to only read data into the end of the buffer.\n        append_to_string(buf, |b| read_to_end(self, b))\n    }\n\n    /// Read the exact number of bytes required to fill `buf`.\n    ///\n    /// This function reads as many bytes as necessary to completely fill the\n    /// specified buffer `buf`.\n    ///\n    /// No guarantees are provided about the contents of `buf` when this\n    /// function is called, implementations cannot rely on any property of the\n    /// contents of `buf` being true. It is recommended that implementations\n    /// only write data to `buf` instead of reading its contents.\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters an error of the kind\n    /// `ErrorKind::Interrupted` then the error is ignored and the operation\n    /// will continue.\n    ///\n    /// If this function encounters an \"end of file\" before completely filling\n    /// the buffer, it returns an error of the kind `ErrorKind::UnexpectedEof`.\n    /// The contents of `buf` are unspecified in this case.\n    ///\n    /// If any other read error is encountered then this function immediately\n    /// returns. The contents of `buf` are unspecified in this case.\n    ///\n    /// If this function returns an error, it is unspecified how many bytes it\n    /// has read, but it will never read more than would be necessary to\n    /// completely fill the buffer.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    /// let mut buffer = [0; 10];\n    ///\n    /// // read exactly 10 bytes\n    /// f.read_exact(&mut buffer)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"read_exact\", since = \"1.6.0\")]\n    fn read_exact(&mut self, mut buf: &mut [u8]) -> Result<()> {\n        while !buf.is_empty() {\n            match self.read(buf) {\n                Ok(0) => break,\n                Ok(n) => { let tmp = buf; buf = &mut tmp[n..]; }\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                Err(e) => return Err(e),\n            }\n        }\n        if !buf.is_empty() {\n            Err(Error::new(ErrorKind::UnexpectedEof,\n                           \"failed to fill whole buffer\"))\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Creates a \"by reference\" adaptor for this instance of `Read`.\n    ///\n    /// The returned adaptor also implements `Read` and will simply borrow this\n    /// current reader.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::Read;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    /// let mut buffer = Vec::new();\n    /// let mut other_buffer = Vec::new();\n    ///\n    /// {\n    ///     let reference = f.by_ref();\n    ///\n    ///     // read at most 5 bytes\n    ///     reference.take(5).read_to_end(&mut buffer)?;\n    ///\n    /// } // drop our &mut reference so we can use f again\n    ///\n    /// // original file still usable, read the rest\n    /// f.read_to_end(&mut other_buffer)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n\n    /// Transforms this `Read` instance to an `Iterator` over its bytes.\n    ///\n    /// The returned type implements `Iterator` where the `Item` is `Result<u8,\n    /// R::Err>`.  The yielded item is `Ok` if a byte was successfully read and\n    /// `Err` otherwise for I/O errors. EOF is mapped to returning `None` from\n    /// this iterator.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    ///\n    /// for byte in f.bytes() {\n    ///     println!(\"{}\", byte.unwrap());\n    /// }\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn bytes(self) -> Bytes<Self> where Self: Sized {\n        Bytes { inner: self }\n    }\n\n    /// Transforms this `Read` instance to an `Iterator` over `char`s.\n    ///\n    /// This adaptor will attempt to interpret this reader as a UTF-8 encoded\n    /// sequence of characters. The returned iterator will return `None` once\n    /// EOF is reached for this reader. Otherwise each element yielded will be a\n    /// `Result<char, E>` where `E` may contain information about what I/O error\n    /// occurred or where decoding failed.\n    ///\n    /// Currently this adaptor will discard intermediate data read, and should\n    /// be avoided if this is not desired.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// #![feature(io)]\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    ///\n    /// for c in f.chars() {\n    ///     println!(\"{}\", c.unwrap());\n    /// }\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                         of where errors happen is currently \\\n                                         unclear and may change\",\n               issue = \"27802\")]\n    fn chars(self) -> Chars<Self> where Self: Sized {\n        Chars { inner: self }\n    }\n\n    /// Creates an adaptor which will chain this stream with another.\n    ///\n    /// The returned `Read` instance will first read all bytes from this object\n    /// until EOF is encountered. Afterwards the output is equivalent to the\n    /// output of `next`.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f1 = File::open(\"foo.txt\")?;\n    /// let mut f2 = File::open(\"bar.txt\")?;\n    ///\n    /// let mut handle = f1.chain(f2);\n    /// let mut buffer = String::new();\n    ///\n    /// // read the value into a String. We could use any Read method here,\n    /// // this is just one example.\n    /// handle.read_to_string(&mut buffer)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized {\n        Chain { first: self, second: next, done_first: false }\n    }\n\n    /// Creates an adaptor which will read at most `limit` bytes from it.\n    ///\n    /// This function returns a new instance of `Read` which will read at most\n    /// `limit` bytes, after which it will always return EOF (`Ok(0)`). Any\n    /// read errors will not count towards the number of bytes read and future\n    /// calls to `read` may succeed.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    /// let mut buffer = [0; 5];\n    ///\n    /// // read at most five bytes\n    /// let mut handle = f.take(5);\n    ///\n    /// handle.read(&mut buffer)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn take(self, limit: u64) -> Take<Self> where Self: Sized {\n        Take { inner: self, limit: limit }\n    }\n}\n\n/// A type used to conditionally initialize buffers passed to `Read` methods.\n#[unstable(feature = \"read_initializer\", issue = \"42788\")]\n#[derive(Debug)]\npub struct Initializer(bool);\n\nimpl Initializer {\n    /// Returns a new `Initializer` which will zero out buffers.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn zeroing() -> Initializer {\n        Initializer(true)\n    }\n\n    /// Returns a new `Initializer` which will not zero out buffers.\n    ///\n    /// # Unsafety\n    ///\n    /// This may only be called by `Read`ers which guarantee that they will not\n    /// read from buffers passed to `Read` methods, and that the return value of\n    /// the method accurately reflects the number of bytes that have been\n    /// written to the head of the buffer.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub unsafe fn nop() -> Initializer {\n        Initializer(false)\n    }\n\n    /// Indicates if a buffer should be initialized.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn should_initialize(&self) -> bool {\n        self.0\n    }\n\n    /// Initializes a buffer if necessary.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn initialize(&self, buf: &mut [u8]) {\n        if self.should_initialize() {\n            unsafe { ptr::write_bytes(buf.as_mut_ptr(), 0, buf.len()) }\n        }\n    }\n}\n\n/// A trait for objects which are byte-oriented sinks.\n///\n/// Implementors of the `Write` trait are sometimes called 'writers'.\n///\n/// Writers are defined by two required methods, [`write`] and [`flush`]:\n///\n/// * The [`write`] method will attempt to write some data into the object,\n///   returning how many bytes were successfully written.\n///\n/// * The [`flush`] method is useful for adaptors and explicit buffers\n///   themselves for ensuring that all buffered data has been pushed out to the\n///   'true sink'.\n///\n/// Writers are intended to be composable with one another. Many implementors\n/// throughout [`std::io`] take and provide types which implement the `Write`\n/// trait.\n///\n/// [`write`]: #tymethod.write\n/// [`flush`]: #tymethod.flush\n/// [`std::io`]: index.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// # fn foo() -> std::io::Result<()> {\n/// let mut buffer = File::create(\"foo.txt\")?;\n///\n/// buffer.write(b\"some bytes\")?;\n/// # Ok(())\n/// # }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Write {\n    /// Write a buffer into this object, returning how many bytes were written.\n    ///\n    /// This function will attempt to write the entire contents of `buf`, but\n    /// the entire write may not succeed, or the write may also generate an\n    /// error. A call to `write` represents *at most one* attempt to write to\n    /// any wrapped object.\n    ///\n    /// Calls to `write` are not guaranteed to block waiting for data to be\n    /// written, and a write which would otherwise block can be indicated through\n    /// an `Err` variant.\n    ///\n    /// If the return value is `Ok(n)` then it must be guaranteed that\n    /// `0 <= n <= buf.len()`. A return value of `0` typically means that the\n    /// underlying object is no longer able to accept bytes and will likely not\n    /// be able to in the future as well, or that the buffer provided is empty.\n    ///\n    /// # Errors\n    ///\n    /// Each call to `write` may generate an I/O error indicating that the\n    /// operation could not be completed. If an error is returned then no bytes\n    /// in the buffer were written to this writer.\n    ///\n    /// It is **not** considered an error if the entire buffer could not be\n    /// written to this writer.\n    ///\n    /// An error of the `ErrorKind::Interrupted` kind is non-fatal and the\n    /// write operation should be retried if there is nothing else to do.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    /// // Writes some prefix of the byte string, not necessarily all of it.\n    /// buffer.write(b\"some bytes\")?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n\n    /// Flush this output stream, ensuring that all intermediately buffered\n    /// contents reach their destination.\n    ///\n    /// # Errors\n    ///\n    /// It is considered an error if not all bytes could be written due to\n    /// I/O errors or EOF being reached.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::prelude::*;\n    /// use std::io::BufWriter;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut buffer = BufWriter::new(File::create(\"foo.txt\")?);\n    ///\n    /// buffer.write(b\"some bytes\")?;\n    /// buffer.flush()?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn flush(&mut self) -> Result<()>;\n\n    /// Attempts to write an entire buffer into this write.\n    ///\n    /// This method will continuously call `write` until there is no more data\n    /// to be written or an error of non-`ErrorKind::Interrupted` kind is\n    /// returned. This method will not return until the entire buffer has been\n    /// successfully written or such an error occurs. The first error that is\n    /// not of `ErrorKind::Interrupted` kind generated from this method will be\n    /// returned.\n    ///\n    /// # Errors\n    ///\n    /// This function will return the first error of\n    /// non-`ErrorKind::Interrupted` kind that `write` returns.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    /// buffer.write_all(b\"some bytes\")?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n        while !buf.is_empty() {\n            match self.write(buf) {\n                Ok(0) => return Err(Error::new(ErrorKind::WriteZero,\n                                               \"failed to write whole buffer\")),\n                Ok(n) => buf = &buf[n..],\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(())\n    }\n\n    /// Writes a formatted string into this writer, returning any error\n    /// encountered.\n    ///\n    /// This method is primarily used to interface with the\n    /// [`format_args!`][formatargs] macro, but it is rare that this should\n    /// explicitly be called. The [`write!`][write] macro should be favored to\n    /// invoke this method instead.\n    ///\n    /// [formatargs]: ../macro.format_args.html\n    /// [write]: ../macro.write.html\n    ///\n    /// This function internally uses the [`write_all`][writeall] method on\n    /// this trait and hence will continuously write data so long as no errors\n    /// are received. This also means that partial writes are not indicated in\n    /// this signature.\n    ///\n    /// [writeall]: #method.write_all\n    ///\n    /// # Errors\n    ///\n    /// This function will return any I/O error reported while formatting.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    /// // this call\n    /// write!(buffer, \"{:.*}\", 2, 1.234567)?;\n    /// // turns into this:\n    /// buffer.write_fmt(format_args!(\"{:.*}\", 2, 1.234567))?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()> {\n        // Create a shim which translates a Write to a fmt::Write and saves\n        // off I/O errors. instead of discarding them\n        struct Adaptor<'a, T: ?Sized + 'a> {\n            inner: &'a mut T,\n            error: Result<()>,\n        }\n\n        impl<'a, T: Write + ?Sized> fmt::Write for Adaptor<'a, T> {\n            fn write_str(&mut self, s: &str) -> fmt::Result {\n                match self.inner.write_all(s.as_bytes()) {\n                    Ok(()) => Ok(()),\n                    Err(e) => {\n                        self.error = Err(e);\n                        Err(fmt::Error)\n                    }\n                }\n            }\n        }\n\n        let mut output = Adaptor { inner: self, error: Ok(()) };\n        match fmt::write(&mut output, fmt) {\n            Ok(()) => Ok(()),\n            Err(..) => {\n                // check if the error came from the underlying `Write` or not\n                if output.error.is_err() {\n                    output.error\n                } else {\n                    Err(Error::new(ErrorKind::Other, \"formatter error\"))\n                }\n            }\n        }\n    }\n\n    /// Creates a \"by reference\" adaptor for this instance of `Write`.\n    ///\n    /// The returned adaptor also implements `Write` and will simply borrow this\n    /// current writer.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Write;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    /// let reference = buffer.by_ref();\n    ///\n    /// // we can use reference just like our original buffer\n    /// reference.write_all(b\"some bytes\")?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n}\n\n/// The `Seek` trait provides a cursor which can be moved within a stream of\n/// bytes.\n///\n/// The stream typically has a fixed size, allowing seeking relative to either\n/// end or the current offset.\n///\n/// # Examples\n///\n/// [`File`][file]s implement `Seek`:\n///\n/// [file]: ../fs/struct.File.html\n///\n/// ```\n/// use std::io;\n/// use std::io::prelude::*;\n/// use std::fs::File;\n/// use std::io::SeekFrom;\n///\n/// # fn foo() -> io::Result<()> {\n/// let mut f = File::open(\"foo.txt\")?;\n///\n/// // move the cursor 42 bytes from the start of the file\n/// f.seek(SeekFrom::Start(42))?;\n/// # Ok(())\n/// # }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Seek {\n    /// Seek to an offset, in bytes, in a stream.\n    ///\n    /// A seek beyond the end of a stream is allowed, but implementation\n    /// defined.\n    ///\n    /// If the seek operation completed successfully,\n    /// this method returns the new position from the start of the stream.\n    /// That position can be used later with [`SeekFrom::Start`].\n    ///\n    /// # Errors\n    ///\n    /// Seeking to a negative offset is considered an error.\n    ///\n    /// [`SeekFrom::Start`]: enum.SeekFrom.html#variant.Start\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n}\n\n/// Enumeration of possible methods to seek within an I/O object.\n///\n/// It is used by the [`Seek`] trait.\n///\n/// [`Seek`]: trait.Seek.html\n#[derive(Copy, PartialEq, Eq, Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum SeekFrom {\n    /// Set the offset to the provided number of bytes.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Start(#[stable(feature = \"rust1\", since = \"1.0.0\")] u64),\n\n    /// Set the offset to the size of this object plus the specified number of\n    /// bytes.\n    ///\n    /// It is possible to seek beyond the end of an object, but it's an error to\n    /// seek before byte 0.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    End(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n\n    /// Set the offset to the current position plus the specified number of\n    /// bytes.\n    ///\n    /// It is possible to seek beyond the end of an object, but it's an error to\n    /// seek before byte 0.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Current(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n}\n\nfn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n                                   -> Result<usize> {\n    let mut read = 0;\n    loop {\n        let (done, used) = {\n            let available = match r.fill_buf() {\n                Ok(n) => n,\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                Err(e) => return Err(e)\n            };\n            match memchr::memchr(delim, available) {\n                Some(i) => {\n                    buf.extend_from_slice(&available[..i + 1]);\n                    (true, i + 1)\n                }\n                None => {\n                    buf.extend_from_slice(available);\n                    (false, available.len())\n                }\n            }\n        };\n        r.consume(used);\n        read += used;\n        if done || used == 0 {\n            return Ok(read);\n        }\n    }\n}\n\n/// A `BufRead` is a type of `Read`er which has an internal buffer, allowing it\n/// to perform extra ways of reading.\n///\n/// For example, reading line-by-line is inefficient without using a buffer, so\n/// if you want to read by line, you'll need `BufRead`, which includes a\n/// [`read_line`] method as well as a [`lines`] iterator.\n///\n/// # Examples\n///\n/// A locked standard input implements `BufRead`:\n///\n/// ```\n/// use std::io;\n/// use std::io::prelude::*;\n///\n/// let stdin = io::stdin();\n/// for line in stdin.lock().lines() {\n///     println!(\"{}\", line.unwrap());\n/// }\n/// ```\n///\n/// If you have something that implements [`Read`], you can use the [`BufReader`\n/// type][`BufReader`] to turn it into a `BufRead`.\n///\n/// For example, [`File`] implements [`Read`], but not `BufRead`.\n/// [`BufReader`] to the rescue!\n///\n/// [`BufReader`]: struct.BufReader.html\n/// [`File`]: ../fs/struct.File.html\n/// [`read_line`]: #method.read_line\n/// [`lines`]: #method.lines\n/// [`Read`]: trait.Read.html\n///\n/// ```\n/// use std::io::{self, BufReader};\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// # fn foo() -> io::Result<()> {\n/// let f = File::open(\"foo.txt\")?;\n/// let f = BufReader::new(f);\n///\n/// for line in f.lines() {\n///     println!(\"{}\", line.unwrap());\n/// }\n///\n/// # Ok(())\n/// # }\n/// ```\n///\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait BufRead: Read {\n    /// Fills the internal buffer of this object, returning the buffer contents.\n    ///\n    /// This function is a lower-level call. It needs to be paired with the\n    /// [`consume`] method to function properly. When calling this\n    /// method, none of the contents will be \"read\" in the sense that later\n    /// calling `read` may return the same contents. As such, [`consume`] must\n    /// be called with the number of bytes that are consumed from this buffer to\n    /// ensure that the bytes are never returned twice.\n    ///\n    /// [`consume`]: #tymethod.consume\n    ///\n    /// An empty buffer returned indicates that the stream has reached EOF.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an I/O error if the underlying reader was\n    /// read, but returned an error.\n    ///\n    /// # Examples\n    ///\n    /// A locked standard input implements `BufRead`:\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    ///\n    /// let stdin = io::stdin();\n    /// let mut stdin = stdin.lock();\n    ///\n    /// // we can't have two `&mut` references to `stdin`, so use a block\n    /// // to end the borrow early.\n    /// let length = {\n    ///     let buffer = stdin.fill_buf().unwrap();\n    ///\n    ///     // work with buffer\n    ///     println!(\"{:?}\", buffer);\n    ///\n    ///     buffer.len()\n    /// };\n    ///\n    /// // ensure the bytes we worked with aren't returned again later\n    /// stdin.consume(length);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fill_buf(&mut self) -> Result<&[u8]>;\n\n    /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n    /// so they should no longer be returned in calls to `read`.\n    ///\n    /// This function is a lower-level call. It needs to be paired with the\n    /// [`fill_buf`] method to function properly. This function does\n    /// not perform any I/O, it simply informs this object that some amount of\n    /// its buffer, returned from [`fill_buf`], has been consumed and should\n    /// no longer be returned. As such, this function may do odd things if\n    /// [`fill_buf`] isn't called before calling it.\n    ///\n    /// The `amt` must be `<=` the number of bytes in the buffer returned by\n    /// [`fill_buf`].\n    ///\n    /// # Examples\n    ///\n    /// Since `consume()` is meant to be used with [`fill_buf`],\n    /// that method's example includes an example of `consume()`.\n    ///\n    /// [`fill_buf`]: #tymethod.fill_buf\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn consume(&mut self, amt: usize);\n\n    /// Read all bytes into `buf` until the delimiter `byte` or EOF is reached.\n    ///\n    /// This function will read bytes from the underlying stream until the\n    /// delimiter or EOF is found. Once found, all bytes up to, and including,\n    /// the delimiter (if found) will be appended to `buf`.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// # Errors\n    ///\n    /// This function will ignore all instances of [`ErrorKind::Interrupted`] and\n    /// will otherwise return any errors returned by [`fill_buf`].\n    ///\n    /// If an I/O error is encountered then all bytes read so far will be\n    /// present in `buf` and its length will have been adjusted appropriately.\n    ///\n    /// [`fill_buf`]: #tymethod.fill_buf\n    /// [`ErrorKind::Interrupted`]: enum.ErrorKind.html#variant.Interrupted\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to read all the bytes in a byte slice\n    /// in hyphen delimited segments:\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let mut cursor = io::Cursor::new(b\"lorem-ipsum\");\n    /// let mut buf = vec![];\n    ///\n    /// // cursor is at 'l'\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 6);\n    /// assert_eq!(buf, b\"lorem-\");\n    /// buf.clear();\n    ///\n    /// // cursor is at 'i'\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 5);\n    /// assert_eq!(buf, b\"ipsum\");\n    /// buf.clear();\n    ///\n    /// // cursor is at EOF\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 0);\n    /// assert_eq!(buf, b\"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> {\n        read_until(self, byte, buf)\n    }\n\n    /// Read all bytes until a newline (the 0xA byte) is reached, and append\n    /// them to the provided buffer.\n    ///\n    /// This function will read bytes from the underlying stream until the\n    /// newline delimiter (the 0xA byte) or EOF is found. Once found, all bytes\n    /// up to, and including, the delimiter (if found) will be appended to\n    /// `buf`.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// # Errors\n    ///\n    /// This function has the same error semantics as [`read_until`] and will\n    /// also return an error if the read bytes are not valid UTF-8. If an I/O\n    /// error is encountered then `buf` may contain some bytes already read in\n    /// the event that all data read so far was valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to read all the lines in a byte slice:\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let mut cursor = io::Cursor::new(b\"foo\\nbar\");\n    /// let mut buf = String::new();\n    ///\n    /// // cursor is at 'f'\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 4);\n    /// assert_eq!(buf, \"foo\\n\");\n    /// buf.clear();\n    ///\n    /// // cursor is at 'b'\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 3);\n    /// assert_eq!(buf, \"bar\");\n    /// buf.clear();\n    ///\n    /// // cursor is at EOF\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 0);\n    /// assert_eq!(buf, \"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_line(&mut self, buf: &mut String) -> Result<usize> {\n        // Note that we are not calling the `.read_until` method here, but\n        // rather our hardcoded implementation. For more details as to why, see\n        // the comments in `read_to_end`.\n        append_to_string(buf, |b| read_until(self, b'\\n', b))\n    }\n\n    /// Returns an iterator over the contents of this reader split on the byte\n    /// `byte`.\n    ///\n    /// The iterator returned from this function will return instances of\n    /// [`io::Result`]`<`[`Vec<u8>`]`>`. Each vector returned will *not* have\n    /// the delimiter byte at the end.\n    ///\n    /// This function will yield errors whenever [`read_until`] would have\n    /// also yielded an error.\n    ///\n    /// [`io::Result`]: type.Result.html\n    /// [`Vec<u8>`]: ../vec/struct.Vec.html\n    /// [`read_until`]: #method.read_until\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to iterate over all hyphen delimited\n    /// segments in a byte slice\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let cursor = io::Cursor::new(b\"lorem-ipsum-dolor\");\n    ///\n    /// let mut split_iter = cursor.split(b'-').map(|l| l.unwrap());\n    /// assert_eq!(split_iter.next(), Some(b\"lorem\".to_vec()));\n    /// assert_eq!(split_iter.next(), Some(b\"ipsum\".to_vec()));\n    /// assert_eq!(split_iter.next(), Some(b\"dolor\".to_vec()));\n    /// assert_eq!(split_iter.next(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn split(self, byte: u8) -> Split<Self> where Self: Sized {\n        Split { buf: self, delim: byte }\n    }\n\n    /// Returns an iterator over the lines of this reader.\n    ///\n    /// The iterator returned from this function will yield instances of\n    /// [`io::Result`]`<`[`String`]`>`. Each string returned will *not* have a newline\n    /// byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.\n    ///\n    /// [`io::Result`]: type.Result.html\n    /// [`String`]: ../string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to iterate over all the lines in a byte\n    /// slice.\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n    ///\n    /// let mut lines_iter = cursor.lines().map(|l| l.unwrap());\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"lorem\")));\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"ipsum\")));\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"dolor\")));\n    /// assert_eq!(lines_iter.next(), None);\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// Each line of the iterator has the same error semantics as [`BufRead::read_line`].\n    ///\n    /// [`BufRead::read_line`]: trait.BufRead.html#method.read_line\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn lines(self) -> Lines<Self> where Self: Sized {\n        Lines { buf: self }\n    }\n}\n\n/// Adaptor to chain together two readers.\n///\n/// This struct is generally created by calling [`chain`] on a reader.\n/// Please see the documentation of [`chain`] for more details.\n///\n/// [`chain`]: trait.Read.html#method.chain\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Chain<T, U> {\n    first: T,\n    second: U,\n    done_first: bool,\n}\n\nimpl<T, U> Chain<T, U> {\n    /// Consumes the `Chain`, returning the wrapped readers.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut foo_file = File::open(\"foo.txt\")?;\n    /// let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    /// let chain = foo_file.chain(bar_file);\n    /// let (foo_file, bar_file) = chain.into_inner();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn into_inner(self) -> (T, U) {\n        (self.first, self.second)\n    }\n\n    /// Gets references to the underlying readers in this `Chain`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut foo_file = File::open(\"foo.txt\")?;\n    /// let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    /// let chain = foo_file.chain(bar_file);\n    /// let (foo_file, bar_file) = chain.get_ref();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_ref(&self) -> (&T, &U) {\n        (&self.first, &self.second)\n    }\n\n    /// Gets mutable references to the underlying readers in this `Chain`.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying readers as doing so may corrupt the internal state of this\n    /// `Chain`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut foo_file = File::open(\"foo.txt\")?;\n    /// let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    /// let mut chain = foo_file.chain(bar_file);\n    /// let (foo_file, bar_file) = chain.get_mut();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_mut(&mut self) -> (&mut T, &mut U) {\n        (&mut self.first, &mut self.second)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T: fmt::Debug, U: fmt::Debug> fmt::Debug for Chain<T, U> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Chain\")\n            .field(\"t\", &self.first)\n            .field(\"u\", &self.second)\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Read, U: Read> Read for Chain<T, U> {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n        if !self.done_first {\n            match self.first.read(buf)? {\n                0 if buf.len() != 0 => { self.done_first = true; }\n                n => return Ok(n),\n            }\n        }\n        self.second.read(buf)\n    }\n\n    unsafe fn initializer(&self) -> Initializer {\n        let initializer = self.first.initializer();\n        if initializer.should_initialize() {\n            initializer\n        } else {\n            self.second.initializer()\n        }\n    }\n}\n\n#[stable(feature = \"chain_bufread\", since = \"1.9.0\")]\nimpl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n    fn fill_buf(&mut self) -> Result<&[u8]> {\n        if !self.done_first {\n            match self.first.fill_buf()? {\n                buf if buf.len() == 0 => { self.done_first = true; }\n                buf => return Ok(buf),\n            }\n        }\n        self.second.fill_buf()\n    }\n\n    fn consume(&mut self, amt: usize) {\n        if !self.done_first {\n            self.first.consume(amt)\n        } else {\n            self.second.consume(amt)\n        }\n    }\n}\n\n/// Reader adaptor which limits the bytes read from an underlying reader.\n///\n/// This struct is generally created by calling [`take`] on a reader.\n/// Please see the documentation of [`take`] for more details.\n///\n/// [`take`]: trait.Read.html#method.take\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Take<T> {\n    inner: T,\n    limit: u64,\n}\n\nimpl<T> Take<T> {\n    /// Returns the number of bytes that can be read before this instance will\n    /// return EOF.\n    ///\n    /// # Note\n    ///\n    /// This instance may reach `EOF` after reading fewer bytes than indicated by\n    /// this method if the underlying [`Read`] instance reaches EOF.\n    ///\n    /// [`Read`]: ../../std/io/trait.Read.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let f = File::open(\"foo.txt\")?;\n    ///\n    /// // read at most five bytes\n    /// let handle = f.take(5);\n    ///\n    /// println!(\"limit: {}\", handle.limit());\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn limit(&self) -> u64 { self.limit }\n\n    /// Consumes the `Take`, returning the wrapped reader.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut file = File::open(\"foo.txt\")?;\n    ///\n    /// let mut buffer = [0; 5];\n    /// let mut handle = file.take(5);\n    /// handle.read(&mut buffer)?;\n    ///\n    /// let file = handle.into_inner();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"io_take_into_inner\", since = \"1.15.0\")]\n    pub fn into_inner(self) -> T {\n        self.inner\n    }\n\n    /// Gets a reference to the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut file = File::open(\"foo.txt\")?;\n    ///\n    /// let mut buffer = [0; 5];\n    /// let mut handle = file.take(5);\n    /// handle.read(&mut buffer)?;\n    ///\n    /// let file = handle.get_ref();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_ref(&self) -> &T {\n        &self.inner\n    }\n\n    /// Gets a mutable reference to the underlying reader.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying reader as doing so may corrupt the internal limit of this\n    /// `Take`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut file = File::open(\"foo.txt\")?;\n    ///\n    /// let mut buffer = [0; 5];\n    /// let mut handle = file.take(5);\n    /// handle.read(&mut buffer)?;\n    ///\n    /// let file = handle.get_mut();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_mut(&mut self) -> &mut T {\n        &mut self.inner\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Read> Read for Take<T> {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n        // Don't call into inner reader at all at EOF because it may still block\n        if self.limit == 0 {\n            return Ok(0);\n        }\n\n        let max = cmp::min(buf.len() as u64, self.limit) as usize;\n        let n = self.inner.read(&mut buf[..max])?;\n        self.limit -= n as u64;\n        Ok(n)\n    }\n\n    unsafe fn initializer(&self) -> Initializer {\n        self.inner.initializer()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: BufRead> BufRead for Take<T> {\n    fn fill_buf(&mut self) -> Result<&[u8]> {\n        // Don't call into inner reader at all at EOF because it may still block\n        if self.limit == 0 {\n            return Ok(&[]);\n        }\n\n        let buf = self.inner.fill_buf()?;\n        let cap = cmp::min(buf.len() as u64, self.limit) as usize;\n        Ok(&buf[..cap])\n    }\n\n    fn consume(&mut self, amt: usize) {\n        // Don't let callers reset the limit by passing an overlarge value\n        let amt = cmp::min(amt as u64, self.limit) as usize;\n        self.limit -= amt as u64;\n        self.inner.consume(amt);\n    }\n}\n\nfn read_one_byte(reader: &mut Read) -> Option<Result<u8>> {\n    let mut buf = [0];\n    loop {\n        return match reader.read(&mut buf) {\n            Ok(0) => None,\n            Ok(..) => Some(Ok(buf[0])),\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n            Err(e) => Some(Err(e)),\n        };\n    }\n}\n\n/// An iterator over `u8` values of a reader.\n///\n/// This struct is generally created by calling [`bytes`] on a reader.\n/// Please see the documentation of [`bytes`] for more details.\n///\n/// [`bytes`]: trait.Read.html#method.bytes\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Bytes<R> {\n    inner: R,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> Iterator for Bytes<R> {\n    type Item = Result<u8>;\n\n    fn next(&mut self) -> Option<Result<u8>> {\n        read_one_byte(&mut self.inner)\n    }\n}\n\n/// An iterator over the `char`s of a reader.\n///\n/// This struct is generally created by calling [`chars`][chars] on a reader.\n/// Please see the documentation of `chars()` for more details.\n///\n/// [chars]: trait.Read.html#method.chars\n#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n           issue = \"27802\")]\n#[derive(Debug)]\npub struct Chars<R> {\n    inner: R,\n}\n\n/// An enumeration of possible errors that can be generated from the `Chars`\n/// adapter.\n#[derive(Debug)]\n#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n           issue = \"27802\")]\npub enum CharsError {\n    /// Variant representing that the underlying stream was read successfully\n    /// but it did not contain valid utf8 data.\n    NotUtf8,\n\n    /// Variant representing that an I/O error occurred.\n    Other(Error),\n}\n\n#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n           issue = \"27802\")]\nimpl<R: Read> Iterator for Chars<R> {\n    type Item = result::Result<char, CharsError>;\n\n    fn next(&mut self) -> Option<result::Result<char, CharsError>> {\n        let first_byte = match read_one_byte(&mut self.inner) {\n            None => return None,\n            Some(Ok(b)) => b,\n            Some(Err(e)) => return Some(Err(CharsError::Other(e))),\n        };\n        let width = core_str::utf8_char_width(first_byte);\n        if width == 1 { return Some(Ok(first_byte as char)) }\n        if width == 0 { return Some(Err(CharsError::NotUtf8)) }\n        let mut buf = [first_byte, 0, 0, 0];\n        {\n            let mut start = 1;\n            while start < width {\n                match self.inner.read(&mut buf[start..width]) {\n                    Ok(0) => return Some(Err(CharsError::NotUtf8)),\n                    Ok(n) => start += n,\n                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                    Err(e) => return Some(Err(CharsError::Other(e))),\n                }\n            }\n        }\n        Some(match str::from_utf8(&buf[..width]).ok() {\n            Some(s) => Ok(s.chars().next().unwrap()),\n            None => Err(CharsError::NotUtf8),\n        })\n    }\n}\n\n#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n           issue = \"27802\")]\nimpl std_error::Error for CharsError {\n    fn description(&self) -> &str {\n        match *self {\n            CharsError::NotUtf8 => \"invalid utf8 encoding\",\n            CharsError::Other(ref e) => std_error::Error::description(e),\n        }\n    }\n    fn cause(&self) -> Option<&std_error::Error> {\n        match *self {\n            CharsError::NotUtf8 => None,\n            CharsError::Other(ref e) => e.cause(),\n        }\n    }\n}\n\n#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n           issue = \"27802\")]\nimpl fmt::Display for CharsError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            CharsError::NotUtf8 => {\n                \"byte stream did not contain valid utf8\".fmt(f)\n            }\n            CharsError::Other(ref e) => e.fmt(f),\n        }\n    }\n}\n\n/// An iterator over the contents of an instance of `BufRead` split on a\n/// particular byte.\n///\n/// This struct is generally created by calling [`split`][split] on a\n/// `BufRead`. Please see the documentation of `split()` for more details.\n///\n/// [split]: trait.BufRead.html#method.split\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Split<B> {\n    buf: B,\n    delim: u8,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead> Iterator for Split<B> {\n    type Item = Result<Vec<u8>>;\n\n    fn next(&mut self) -> Option<Result<Vec<u8>>> {\n        let mut buf = Vec::new();\n        match self.buf.read_until(self.delim, &mut buf) {\n            Ok(0) => None,\n            Ok(_n) => {\n                if buf[buf.len() - 1] == self.delim {\n                    buf.pop();\n                }\n                Some(Ok(buf))\n            }\n            Err(e) => Some(Err(e))\n        }\n    }\n}\n\n/// An iterator over the lines of an instance of `BufRead`.\n///\n/// This struct is generally created by calling [`lines`][lines] on a\n/// `BufRead`. Please see the documentation of `lines()` for more details.\n///\n/// [lines]: trait.BufRead.html#method.lines\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Lines<B> {\n    buf: B,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead> Iterator for Lines<B> {\n    type Item = Result<String>;\n\n    fn next(&mut self) -> Option<Result<String>> {\n        let mut buf = String::new();\n        match self.buf.read_line(&mut buf) {\n            Ok(0) => None,\n            Ok(_n) => {\n                if buf.ends_with(\"\\n\") {\n                    buf.pop();\n                    if buf.ends_with(\"\\r\") {\n                        buf.pop();\n                    }\n                }\n                Some(Ok(buf))\n            }\n            Err(e) => Some(Err(e))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use io::prelude::*;\n    use io;\n    use super::Cursor;\n    use test;\n    use super::repeat;\n\n    #[test]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn read_until() {\n        let mut buf = Cursor::new(&b\"12\"[..]);\n        let mut v = Vec::new();\n        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 2);\n        assert_eq!(v, b\"12\");\n\n        let mut buf = Cursor::new(&b\"1233\"[..]);\n        let mut v = Vec::new();\n        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 3);\n        assert_eq!(v, b\"123\");\n        v.truncate(0);\n        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 1);\n        assert_eq!(v, b\"3\");\n        v.truncate(0);\n        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 0);\n        assert_eq!(v, []);\n    }\n\n    #[test]\n    fn split() {\n        let buf = Cursor::new(&b\"12\"[..]);\n        let mut s = buf.split(b'3');\n        assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n        assert!(s.next().is_none());\n\n        let buf = Cursor::new(&b\"1233\"[..]);\n        let mut s = buf.split(b'3');\n        assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n        assert_eq!(s.next().unwrap().unwrap(), vec![]);\n        assert!(s.next().is_none());\n    }\n\n    #[test]\n    fn read_line() {\n        let mut buf = Cursor::new(&b\"12\"[..]);\n        let mut v = String::new();\n        assert_eq!(buf.read_line(&mut v).unwrap(), 2);\n        assert_eq!(v, \"12\");\n\n        let mut buf = Cursor::new(&b\"12\\n\\n\"[..]);\n        let mut v = String::new();\n        assert_eq!(buf.read_line(&mut v).unwrap(), 3);\n        assert_eq!(v, \"12\\n\");\n        v.truncate(0);\n        assert_eq!(buf.read_line(&mut v).unwrap(), 1);\n        assert_eq!(v, \"\\n\");\n        v.truncate(0);\n        assert_eq!(buf.read_line(&mut v).unwrap(), 0);\n        assert_eq!(v, \"\");\n    }\n\n    #[test]\n    fn lines() {\n        let buf = Cursor::new(&b\"12\\r\"[..]);\n        let mut s = buf.lines();\n        assert_eq!(s.next().unwrap().unwrap(), \"12\\r\".to_string());\n        assert!(s.next().is_none());\n\n        let buf = Cursor::new(&b\"12\\r\\n\\n\"[..]);\n        let mut s = buf.lines();\n        assert_eq!(s.next().unwrap().unwrap(), \"12\".to_string());\n        assert_eq!(s.next().unwrap().unwrap(), \"\".to_string());\n        assert!(s.next().is_none());\n    }\n\n    #[test]\n    fn read_to_end() {\n        let mut c = Cursor::new(&b\"\"[..]);\n        let mut v = Vec::new();\n        assert_eq!(c.read_to_end(&mut v).unwrap(), 0);\n        assert_eq!(v, []);\n\n        let mut c = Cursor::new(&b\"1\"[..]);\n        let mut v = Vec::new();\n        assert_eq!(c.read_to_end(&mut v).unwrap(), 1);\n        assert_eq!(v, b\"1\");\n\n        let cap = 1024 * 1024;\n        let data = (0..cap).map(|i| (i / 3) as u8).collect::<Vec<_>>();\n        let mut v = Vec::new();\n        let (a, b) = data.split_at(data.len() / 2);\n        assert_eq!(Cursor::new(a).read_to_end(&mut v).unwrap(), a.len());\n        assert_eq!(Cursor::new(b).read_to_end(&mut v).unwrap(), b.len());\n        assert_eq!(v, data);\n    }\n\n    #[test]\n    fn read_to_string() {\n        let mut c = Cursor::new(&b\"\"[..]);\n        let mut v = String::new();\n        assert_eq!(c.read_to_string(&mut v).unwrap(), 0);\n        assert_eq!(v, \"\");\n\n        let mut c = Cursor::new(&b\"1\"[..]);\n        let mut v = String::new();\n        assert_eq!(c.read_to_string(&mut v).unwrap(), 1);\n        assert_eq!(v, \"1\");\n\n        let mut c = Cursor::new(&b\"\\xff\"[..]);\n        let mut v = String::new();\n        assert!(c.read_to_string(&mut v).is_err());\n    }\n\n    #[test]\n    fn read_exact() {\n        let mut buf = [0; 4];\n\n        let mut c = Cursor::new(&b\"\"[..]);\n        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n                   io::ErrorKind::UnexpectedEof);\n\n        let mut c = Cursor::new(&b\"123\"[..]).chain(Cursor::new(&b\"456789\"[..]));\n        c.read_exact(&mut buf).unwrap();\n        assert_eq!(&buf, b\"1234\");\n        c.read_exact(&mut buf).unwrap();\n        assert_eq!(&buf, b\"5678\");\n        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n                   io::ErrorKind::UnexpectedEof);\n    }\n\n    #[test]\n    fn read_exact_slice() {\n        let mut buf = [0; 4];\n\n        let mut c = &b\"\"[..];\n        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n                   io::ErrorKind::UnexpectedEof);\n\n        let mut c = &b\"123\"[..];\n        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n                   io::ErrorKind::UnexpectedEof);\n        // make sure the optimized (early returning) method is being used\n        assert_eq!(&buf, &[0; 4]);\n\n        let mut c = &b\"1234\"[..];\n        c.read_exact(&mut buf).unwrap();\n        assert_eq!(&buf, b\"1234\");\n\n        let mut c = &b\"56789\"[..];\n        c.read_exact(&mut buf).unwrap();\n        assert_eq!(&buf, b\"5678\");\n        assert_eq!(c, b\"9\");\n    }\n\n    #[test]\n    fn take_eof() {\n        struct R;\n\n        impl Read for R {\n            fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n                Err(io::Error::new(io::ErrorKind::Other, \"\"))\n            }\n        }\n        impl BufRead for R {\n            fn fill_buf(&mut self) -> io::Result<&[u8]> {\n                Err(io::Error::new(io::ErrorKind::Other, \"\"))\n            }\n            fn consume(&mut self, _amt: usize) { }\n        }\n\n        let mut buf = [0; 1];\n        assert_eq!(0, R.take(0).read(&mut buf).unwrap());\n        assert_eq!(b\"\", R.take(0).fill_buf().unwrap());\n    }\n\n    fn cmp_bufread<Br1: BufRead, Br2: BufRead>(mut br1: Br1, mut br2: Br2, exp: &[u8]) {\n        let mut cat = Vec::new();\n        loop {\n            let consume = {\n                let buf1 = br1.fill_buf().unwrap();\n                let buf2 = br2.fill_buf().unwrap();\n                let minlen = if buf1.len() < buf2.len() { buf1.len() } else { buf2.len() };\n                assert_eq!(buf1[..minlen], buf2[..minlen]);\n                cat.extend_from_slice(&buf1[..minlen]);\n                minlen\n            };\n            if consume == 0 {\n                break;\n            }\n            br1.consume(consume);\n            br2.consume(consume);\n        }\n        assert_eq!(br1.fill_buf().unwrap().len(), 0);\n        assert_eq!(br2.fill_buf().unwrap().len(), 0);\n        assert_eq!(&cat[..], &exp[..])\n    }\n\n    #[test]\n    fn chain_bufread() {\n        let testdata = b\"ABCDEFGHIJKL\";\n        let chain1 = (&testdata[..3]).chain(&testdata[3..6])\n                                     .chain(&testdata[6..9])\n                                     .chain(&testdata[9..]);\n        let chain2 = (&testdata[..4]).chain(&testdata[4..8])\n                                     .chain(&testdata[8..]);\n        cmp_bufread(chain1, chain2, &testdata[..]);\n    }\n\n    #[test]\n    fn chain_zero_length_read_is_not_eof() {\n        let a = b\"A\";\n        let b = b\"B\";\n        let mut s = String::new();\n        let mut chain = (&a[..]).chain(&b[..]);\n        chain.read(&mut []).unwrap();\n        chain.read_to_string(&mut s).unwrap();\n        assert_eq!(\"AB\", s);\n    }\n\n    #[bench]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn bench_read_to_end(b: &mut test::Bencher) {\n        b.iter(|| {\n            let mut lr = repeat(1).take(10000000);\n            let mut vec = Vec::with_capacity(1024);\n            super::read_to_end(&mut lr, &mut vec)\n        });\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Traits for working with Errors.\n//!\n//! # The `Error` trait\n//!\n//! `Error` is a trait representing the basic expectations for error values,\n//! i.e. values of type `E` in [`Result<T, E>`]. At a minimum, errors must provide\n//! a description, but they may optionally provide additional detail (via\n//! [`Display`]) and cause chain information:\n//!\n//! ```\n//! use std::fmt::Display;\n//!\n//! trait Error: Display {\n//!     fn description(&self) -> &str;\n//!\n//!     fn cause(&self) -> Option<&Error> { None }\n//! }\n//! ```\n//!\n//! The [`cause`] method is generally used when errors cross \"abstraction\n//! boundaries\", i.e.  when a one module must report an error that is \"caused\"\n//! by an error from a lower-level module. This setup makes it possible for the\n//! high-level module to provide its own errors that do not commit to any\n//! particular implementation, but also reveal some of its implementation for\n//! debugging via [`cause`] chains.\n//!\n//! [`Result<T, E>`]: ../result/enum.Result.html\n//! [`Display`]: ../fmt/trait.Display.html\n//! [`cause`]: trait.Error.html#method.cause\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n// A note about crates and the facade:\n//\n// Originally, the `Error` trait was defined in libcore, and the impls\n// were scattered about. However, coherence objected to this\n// arrangement, because to create the blanket impls for `Box` required\n// knowing that `&str: !Error`, and we have no means to deal with that\n// sort of conflict just now. Therefore, for the time being, we have\n// moved the `Error` trait into libstd. As we evolve a sol'n to the\n// coherence challenge (e.g., specialization, neg impls, etc) we can\n// reconsider what crate these items belong in.\n\nuse alloc::allocator;\nuse any::TypeId;\nuse cell;\nuse char;\nuse fmt::{self, Debug, Display};\nuse mem::transmute;\nuse num;\nuse str;\nuse string;\n\n/// Base functionality for all errors in Rust.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Error: Debug + Display {\n    /// A short description of the error.\n    ///\n    /// The description should only be used for a simple message.\n    /// It should not contain newlines or sentence-ending punctuation,\n    /// to facilitate embedding in larger user-facing strings.\n    /// For showing formatted error messages with more information see\n    /// [`Display`].\n    ///\n    /// [`Display`]: ../fmt/trait.Display.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// match \"xc\".parse::<u32>() {\n    ///     Err(e) => {\n    ///         println!(\"Error: {}\", e.description());\n    ///     }\n    ///     _ => println!(\"No error\"),\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn description(&self) -> &str;\n\n    /// The lower-level cause of this error, if any.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::fmt;\n    ///\n    /// #[derive(Debug)]\n    /// struct SuperError {\n    ///     side: SuperErrorSideKick,\n    /// }\n    ///\n    /// impl fmt::Display for SuperError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    ///         write!(f, \"SuperError is here!\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for SuperError {\n    ///     fn description(&self) -> &str {\n    ///         \"I'm the superhero of errors\"\n    ///     }\n    ///\n    ///     fn cause(&self) -> Option<&Error> {\n    ///         Some(&self.side)\n    ///     }\n    /// }\n    ///\n    /// #[derive(Debug)]\n    /// struct SuperErrorSideKick;\n    ///\n    /// impl fmt::Display for SuperErrorSideKick {\n    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    ///         write!(f, \"SuperErrorSideKick is here!\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for SuperErrorSideKick {\n    ///     fn description(&self) -> &str {\n    ///         \"I'm SuperError side kick\"\n    ///     }\n    /// }\n    ///\n    /// fn get_super_error() -> Result<(), SuperError> {\n    ///     Err(SuperError { side: SuperErrorSideKick })\n    /// }\n    ///\n    /// fn main() {\n    ///     match get_super_error() {\n    ///         Err(e) => {\n    ///             println!(\"Error: {}\", e.description());\n    ///             println!(\"Caused by: {}\", e.cause().unwrap());\n    ///         }\n    ///         _ => println!(\"No error\"),\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn cause(&self) -> Option<&Error> { None }\n\n    /// Get the `TypeId` of `self`\n    #[doc(hidden)]\n    #[unstable(feature = \"error_type_id\",\n               reason = \"unclear whether to commit to this public implementation detail\",\n               issue = \"27745\")]\n    fn type_id(&self) -> TypeId where Self: 'static {\n        TypeId::of::<Self>()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, E: Error + 'a> From<E> for Box<Error + 'a> {\n    fn from(err: E) -> Box<Error + 'a> {\n        Box::new(err)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, E: Error + Send + Sync + 'a> From<E> for Box<Error + Send + Sync + 'a> {\n    fn from(err: E) -> Box<Error + Send + Sync + 'a> {\n        Box::new(err)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<String> for Box<Error + Send + Sync> {\n    fn from(err: String) -> Box<Error + Send + Sync> {\n        #[derive(Debug)]\n        struct StringError(String);\n\n        impl Error for StringError {\n            fn description(&self) -> &str { &self.0 }\n        }\n\n        impl Display for StringError {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                Display::fmt(&self.0, f)\n            }\n        }\n\n        Box::new(StringError(err))\n    }\n}\n\n#[stable(feature = \"string_box_error\", since = \"1.6.0\")]\nimpl From<String> for Box<Error> {\n    fn from(str_err: String) -> Box<Error> {\n        let err1: Box<Error + Send + Sync> = From::from(str_err);\n        let err2: Box<Error> = err1;\n        err2\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, 'b> From<&'b str> for Box<Error + Send + Sync + 'a> {\n    fn from(err: &'b str) -> Box<Error + Send + Sync + 'a> {\n        From::from(String::from(err))\n    }\n}\n\n#[stable(feature = \"string_box_error\", since = \"1.6.0\")]\nimpl<'a> From<&'a str> for Box<Error> {\n    fn from(err: &'a str) -> Box<Error> {\n        From::from(String::from(err))\n    }\n}\n\n#[unstable(feature = \"never_type_impls\", issue = \"35121\")]\nimpl Error for ! {\n    fn description(&self) -> &str { *self }\n}\n\n#[unstable(feature = \"allocator_api\",\n           reason = \"the precise API and guarantees it provides may be tweaked.\",\n           issue = \"27700\")]\nimpl Error for allocator::AllocErr {\n    fn description(&self) -> &str {\n        allocator::AllocErr::description(self)\n    }\n}\n\n#[unstable(feature = \"allocator_api\",\n           reason = \"the precise API and guarantees it provides may be tweaked.\",\n           issue = \"27700\")]\nimpl Error for allocator::CannotReallocInPlace {\n    fn description(&self) -> &str {\n        allocator::CannotReallocInPlace::description(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for str::ParseBoolError {\n    fn description(&self) -> &str { \"failed to parse bool\" }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for str::Utf8Error {\n    fn description(&self) -> &str {\n        \"invalid utf-8: corrupt contents\"\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for num::ParseIntError {\n    fn description(&self) -> &str {\n        self.__description()\n    }\n}\n\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl Error for num::TryFromIntError {\n    fn description(&self) -> &str {\n        self.__description()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for num::ParseFloatError {\n    fn description(&self) -> &str {\n        self.__description()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for string::FromUtf8Error {\n    fn description(&self) -> &str {\n        \"invalid utf-8\"\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for string::FromUtf16Error {\n    fn description(&self) -> &str {\n        \"invalid utf-16\"\n    }\n}\n\n#[stable(feature = \"str_parse_error2\", since = \"1.8.0\")]\nimpl Error for string::ParseError {\n    fn description(&self) -> &str {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\nimpl Error for char::DecodeUtf16Error {\n    fn description(&self) -> &str {\n        \"unpaired surrogate found\"\n    }\n}\n\n#[stable(feature = \"box_error\", since = \"1.8.0\")]\nimpl<T: Error> Error for Box<T> {\n    fn description(&self) -> &str {\n        Error::description(&**self)\n    }\n\n    fn cause(&self) -> Option<&Error> {\n        Error::cause(&**self)\n    }\n}\n\n#[stable(feature = \"fmt_error\", since = \"1.11.0\")]\nimpl Error for fmt::Error {\n    fn description(&self) -> &str {\n        \"an error occurred when formatting an argument\"\n    }\n}\n\n#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\nimpl Error for cell::BorrowError {\n    fn description(&self) -> &str {\n        \"already mutably borrowed\"\n    }\n}\n\n#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\nimpl Error for cell::BorrowMutError {\n    fn description(&self) -> &str {\n        \"already borrowed\"\n    }\n}\n\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl Error for char::CharTryFromError {\n    fn description(&self) -> &str {\n        \"converted integer out of range for `char`\"\n    }\n}\n\n#[stable(feature = \"char_from_str\", since = \"1.19.0\")]\nimpl Error for char::ParseCharError {\n    fn description(&self) -> &str {\n        self.__description()\n    }\n}\n\n\n// copied from any.rs\nimpl Error + 'static {\n    /// Returns true if the boxed type is the same as `T`\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn is<T: Error + 'static>(&self) -> bool {\n        // Get TypeId of the type this function is instantiated with\n        let t = TypeId::of::<T>();\n\n        // Get TypeId of the type in the trait object\n        let boxed = self.type_id();\n\n        // Compare both TypeIds on equality\n        t == boxed\n    }\n\n    /// Returns some reference to the boxed value if it is of type `T`, or\n    /// `None` if it isn't.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n        if self.is::<T>() {\n            unsafe {\n                Some(&*(self as *const Error as *const T))\n            }\n        } else {\n            None\n        }\n    }\n\n    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n    /// `None` if it isn't.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n        if self.is::<T>() {\n            unsafe {\n                Some(&mut *(self as *mut Error as *mut T))\n            }\n        } else {\n            None\n        }\n    }\n}\n\nimpl Error + 'static + Send {\n    /// Forwards to the method defined on the type `Any`.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn is<T: Error + 'static>(&self) -> bool {\n        <Error + 'static>::is::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `Any`.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n        <Error + 'static>::downcast_ref::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `Any`.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n        <Error + 'static>::downcast_mut::<T>(self)\n    }\n}\n\nimpl Error + 'static + Send + Sync {\n    /// Forwards to the method defined on the type `Any`.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn is<T: Error + 'static>(&self) -> bool {\n        <Error + 'static>::is::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `Any`.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n        <Error + 'static>::downcast_ref::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `Any`.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n        <Error + 'static>::downcast_mut::<T>(self)\n    }\n}\n\nimpl Error {\n    #[inline]\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    /// Attempt to downcast the box to a concrete type.\n    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<Error>> {\n        if self.is::<T>() {\n            unsafe {\n                let raw: *mut Error = Box::into_raw(self);\n                Ok(Box::from_raw(raw as *mut T))\n            }\n        } else {\n            Err(self)\n        }\n    }\n}\n\nimpl Error + Send {\n    #[inline]\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    /// Attempt to downcast the box to a concrete type.\n    pub fn downcast<T: Error + 'static>(self: Box<Self>)\n                                        -> Result<Box<T>, Box<Error + Send>> {\n        let err: Box<Error> = self;\n        <Error>::downcast(err).map_err(|s| unsafe {\n            // reapply the Send marker\n            transmute::<Box<Error>, Box<Error + Send>>(s)\n        })\n    }\n}\n\nimpl Error + Send + Sync {\n    #[inline]\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    /// Attempt to downcast the box to a concrete type.\n    pub fn downcast<T: Error + 'static>(self: Box<Self>)\n                                        -> Result<Box<T>, Box<Self>> {\n        let err: Box<Error> = self;\n        <Error>::downcast(err).map_err(|s| unsafe {\n            // reapply the Send+Sync marker\n            transmute::<Box<Error>, Box<Error + Send + Sync>>(s)\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Error;\n    use fmt;\n\n    #[derive(Debug, PartialEq)]\n    struct A;\n    #[derive(Debug, PartialEq)]\n    struct B;\n\n    impl fmt::Display for A {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            write!(f, \"A\")\n        }\n    }\n    impl fmt::Display for B {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            write!(f, \"B\")\n        }\n    }\n\n    impl Error for A {\n        fn description(&self) -> &str { \"A-desc\" }\n    }\n    impl Error for B {\n        fn description(&self) -> &str { \"A-desc\" }\n    }\n\n    #[test]\n    fn downcasting() {\n        let mut a = A;\n        let mut a = &mut a as &mut (Error + 'static);\n        assert_eq!(a.downcast_ref::<A>(), Some(&A));\n        assert_eq!(a.downcast_ref::<B>(), None);\n        assert_eq!(a.downcast_mut::<A>(), Some(&mut A));\n        assert_eq!(a.downcast_mut::<B>(), None);\n\n        let a: Box<Error> = Box::new(A);\n        match a.downcast::<B>() {\n            Ok(..) => panic!(\"expected error\"),\n            Err(e) => assert_eq!(*e.downcast::<A>().unwrap(), A),\n        }\n    }\n}\n","// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse error::Error;\nuse io;\nuse libc;\nuse sys::backtrace::BacktraceContext;\nuse sys_common::backtrace::Frame;\n\nuse unwind as uw;\n\nstruct Context<'a> {\n    idx: usize,\n    frames: &'a mut [Frame],\n}\n\n#[derive(Debug)]\nstruct UnwindError(uw::_Unwind_Reason_Code);\n\nimpl Error for UnwindError {\n    fn description(&self) -> &'static str {\n        \"unexpected return value while unwinding\"\n    }\n}\n\nimpl ::fmt::Display for UnwindError {\n    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n        write!(f, \"{}: {:?}\", self.description(), self.0)\n    }\n}\n\n#[inline(never)] // if we know this is a function call, we can skip it when\n                 // tracing\npub fn unwind_backtrace(frames: &mut [Frame])\n    -> io::Result<(usize, BacktraceContext)>\n{\n    let mut cx = Context {\n        idx: 0,\n        frames: frames,\n    };\n    let result_unwind = unsafe {\n        uw::_Unwind_Backtrace(trace_fn,\n                              &mut cx as *mut Context\n                              as *mut libc::c_void)\n    };\n    // See libunwind:src/unwind/Backtrace.c for the return values.\n    // No, there is no doc.\n    match result_unwind {\n        // These return codes seem to be benign and need to be ignored for backtraces\n        // to show up properly on all tested platforms.\n        uw::_URC_END_OF_STACK | uw::_URC_FATAL_PHASE1_ERROR | uw::_URC_FAILURE => {\n            Ok((cx.idx, BacktraceContext))\n        }\n        _ => {\n            Err(io::Error::new(io::ErrorKind::Other,\n                               UnwindError(result_unwind)))\n        }\n    }\n}\n\nextern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n                   arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n    let cx = unsafe { &mut *(arg as *mut Context) };\n    let mut ip_before_insn = 0;\n    let mut ip = unsafe {\n        uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n    };\n    if !ip.is_null() && ip_before_insn == 0 {\n        // this is a non-signaling frame, so `ip` refers to the address\n        // after the calling instruction. account for that.\n        ip = (ip as usize - 1) as *mut _;\n    }\n\n    // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n    // it appears to work fine without it, so we only use\n    // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n    // slightly more accurate stack trace in the process.\n    //\n    // This is often because panic involves the last instruction of a\n    // function being \"call std::rt::begin_unwind\", with no ret\n    // instructions after it. This means that the return instruction\n    // pointer points *outside* of the calling function, and by\n    // unwinding it we go back to the original function.\n    let symaddr = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n        ip\n    } else {\n        unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n    };\n\n    if cx.idx < cx.frames.len() {\n        cx.frames[cx.idx] = Frame {\n            symbol_addr: symaddr,\n            exact_position: ip,\n        };\n        cx.idx += 1;\n    }\n\n    uw::_URC_NO_REASON\n}\n","// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n/// The addition operator `+`.\n///\n/// # Examples\n///\n/// This example creates a `Point` struct that implements the `Add` trait, and\n/// then demonstrates adding two `Point`s.\n///\n/// ```\n/// use std::ops::Add;\n///\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl Add for Point {\n///     type Output = Point;\n///\n///     fn add(self, other: Point) -> Point {\n///         Point {\n///             x: self.x + other.x,\n///             y: self.y + other.y,\n///         }\n///     }\n/// }\n///\n/// impl PartialEq for Point {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.x == other.x && self.y == other.y\n///     }\n/// }\n///\n/// fn main() {\n///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n///                Point { x: 3, y: 3 });\n/// }\n/// ```\n///\n/// Here is an example of the same `Point` struct implementing the `Add` trait\n/// using generics.\n///\n/// ```\n/// use std::ops::Add;\n///\n/// #[derive(Debug)]\n/// struct Point<T> {\n///     x: T,\n///     y: T,\n/// }\n///\n/// // Notice that the implementation uses the `Output` associated type\n/// impl<T: Add<Output=T>> Add for Point<T> {\n///     type Output = Point<T>;\n///\n///     fn add(self, other: Point<T>) -> Point<T> {\n///         Point {\n///             x: self.x + other.x,\n///             y: self.y + other.y,\n///         }\n///     }\n/// }\n///\n/// impl<T: PartialEq> PartialEq for Point<T> {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.x == other.x && self.y == other.y\n///     }\n/// }\n///\n/// fn main() {\n///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n///                Point { x: 3, y: 3 });\n/// }\n/// ```\n///\n/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n/// [std::time::SystemTime] implements `Add<Duration>`, which permits\n/// operations of the form `SystemTime = SystemTime + Duration`.\n///\n/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n#[lang = \"add\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"no implementation for `{Self} + {RHS}`\"]\npub trait Add<RHS=Self> {\n    /// The resulting type after applying the `+` operator\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// The method for the `+` operator\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn add(self, rhs: RHS) -> Self::Output;\n}\n\nmacro_rules! add_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Add for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn add(self, other: $t) -> $t { self + other }\n        }\n\n        forward_ref_binop! { impl Add, add for $t, $t }\n    )*)\n}\n\nadd_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The subtraction operator `-`.\n///\n/// # Examples\n///\n/// This example creates a `Point` struct that implements the `Sub` trait, and\n/// then demonstrates subtracting two `Point`s.\n///\n/// ```\n/// use std::ops::Sub;\n///\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl Sub for Point {\n///     type Output = Point;\n///\n///     fn sub(self, other: Point) -> Point {\n///         Point {\n///             x: self.x - other.x,\n///             y: self.y - other.y,\n///         }\n///     }\n/// }\n///\n/// impl PartialEq for Point {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.x == other.x && self.y == other.y\n///     }\n/// }\n///\n/// fn main() {\n///     assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n///                Point { x: 1, y: 0 });\n/// }\n/// ```\n///\n/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n/// [std::time::SystemTime] implements `Sub<Duration>`, which permits\n/// operations of the form `SystemTime = SystemTime - Duration`.\n///\n/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n#[lang = \"sub\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"no implementation for `{Self} - {RHS}`\"]\npub trait Sub<RHS=Self> {\n    /// The resulting type after applying the `-` operator\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// The method for the `-` operator\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn sub(self, rhs: RHS) -> Self::Output;\n}\n\nmacro_rules! sub_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Sub for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn sub(self, other: $t) -> $t { self - other }\n        }\n\n        forward_ref_binop! { impl Sub, sub for $t, $t }\n    )*)\n}\n\nsub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The multiplication operator `*`.\n///\n/// # Examples\n///\n/// Implementing a `Mul`tipliable rational number struct:\n///\n/// ```\n/// use std::ops::Mul;\n///\n/// // The uniqueness of rational numbers in lowest terms is a consequence of\n/// // the fundamental theorem of arithmetic.\n/// #[derive(Eq)]\n/// #[derive(PartialEq, Debug)]\n/// struct Rational {\n///     nominator: usize,\n///     denominator: usize,\n/// }\n///\n/// impl Rational {\n///     fn new(nominator: usize, denominator: usize) -> Self {\n///         if denominator == 0 {\n///             panic!(\"Zero is an invalid denominator!\");\n///         }\n///\n///         // Reduce to lowest terms by dividing by the greatest common\n///         // divisor.\n///         let gcd = gcd(nominator, denominator);\n///         Rational {\n///             nominator: nominator / gcd,\n///             denominator: denominator / gcd,\n///         }\n///     }\n/// }\n///\n/// impl Mul for Rational {\n///     // The multiplication of rational numbers is a closed operation.\n///     type Output = Self;\n///\n///     fn mul(self, rhs: Self) -> Self {\n///         let nominator = self.nominator * rhs.nominator;\n///         let denominator = self.denominator * rhs.denominator;\n///         Rational::new(nominator, denominator)\n///     }\n/// }\n///\n/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n/// // divisor.\n/// fn gcd(x: usize, y: usize) -> usize {\n///     let mut x = x;\n///     let mut y = y;\n///     while y != 0 {\n///         let t = y;\n///         y = x % y;\n///         x = t;\n///     }\n///     x\n/// }\n///\n/// assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n/// assert_eq!(Rational::new(2, 3) * Rational::new(3, 4),\n///            Rational::new(1, 2));\n/// ```\n///\n/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n/// implementation which enables multiplication of vectors by scalars, as is\n/// done in linear algebra.\n///\n/// ```\n/// use std::ops::Mul;\n///\n/// struct Scalar {value: usize};\n///\n/// #[derive(Debug)]\n/// struct Vector {value: Vec<usize>};\n///\n/// impl Mul<Vector> for Scalar {\n///     type Output = Vector;\n///\n///     fn mul(self, rhs: Vector) -> Vector {\n///         Vector {value: rhs.value.iter().map(|v| self.value * v).collect()}\n///     }\n/// }\n///\n/// impl PartialEq<Vector> for Vector {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.value == other.value\n///     }\n/// }\n///\n/// let scalar = Scalar{value: 3};\n/// let vector = Vector{value: vec![2, 4, 6]};\n/// assert_eq!(scalar * vector, Vector{value: vec![6, 12, 18]});\n/// ```\n#[lang = \"mul\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"no implementation for `{Self} * {RHS}`\"]\npub trait Mul<RHS=Self> {\n    /// The resulting type after applying the `*` operator\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// The method for the `*` operator\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn mul(self, rhs: RHS) -> Self::Output;\n}\n\nmacro_rules! mul_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Mul for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn mul(self, other: $t) -> $t { self * other }\n        }\n\n        forward_ref_binop! { impl Mul, mul for $t, $t }\n    )*)\n}\n\nmul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The division operator `/`.\n///\n/// # Examples\n///\n/// Implementing a `Div`idable rational number struct:\n///\n/// ```\n/// use std::ops::Div;\n///\n/// // The uniqueness of rational numbers in lowest terms is a consequence of\n/// // the fundamental theorem of arithmetic.\n/// #[derive(Eq)]\n/// #[derive(PartialEq, Debug)]\n/// struct Rational {\n///     nominator: usize,\n///     denominator: usize,\n/// }\n///\n/// impl Rational {\n///     fn new(nominator: usize, denominator: usize) -> Self {\n///         if denominator == 0 {\n///             panic!(\"Zero is an invalid denominator!\");\n///         }\n///\n///         // Reduce to lowest terms by dividing by the greatest common\n///         // divisor.\n///         let gcd = gcd(nominator, denominator);\n///         Rational {\n///             nominator: nominator / gcd,\n///             denominator: denominator / gcd,\n///         }\n///     }\n/// }\n///\n/// impl Div for Rational {\n///     // The division of rational numbers is a closed operation.\n///     type Output = Self;\n///\n///     fn div(self, rhs: Self) -> Self {\n///         if rhs.nominator == 0 {\n///             panic!(\"Cannot divide by zero-valued `Rational`!\");\n///         }\n///\n///         let nominator = self.nominator * rhs.denominator;\n///         let denominator = self.denominator * rhs.nominator;\n///         Rational::new(nominator, denominator)\n///     }\n/// }\n///\n/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n/// // divisor.\n/// fn gcd(x: usize, y: usize) -> usize {\n///     let mut x = x;\n///     let mut y = y;\n///     while y != 0 {\n///         let t = y;\n///         y = x % y;\n///         x = t;\n///     }\n///     x\n/// }\n///\n/// fn main() {\n///     assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n///     assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n///                Rational::new(2, 3));\n/// }\n/// ```\n///\n/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n/// implementation which enables division of vectors by scalars, as is done in\n/// linear algebra.\n///\n/// ```\n/// use std::ops::Div;\n///\n/// struct Scalar {value: f32};\n///\n/// #[derive(Debug)]\n/// struct Vector {value: Vec<f32>};\n///\n/// impl Div<Scalar> for Vector {\n///     type Output = Vector;\n///\n///     fn div(self, rhs: Scalar) -> Vector {\n///         Vector {value: self.value.iter().map(|v| v / rhs.value).collect()}\n///     }\n/// }\n///\n/// impl PartialEq<Vector> for Vector {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.value == other.value\n///     }\n/// }\n///\n/// let scalar = Scalar{value: 2f32};\n/// let vector = Vector{value: vec![2f32, 4f32, 6f32]};\n/// assert_eq!(vector / scalar, Vector{value: vec![1f32, 2f32, 3f32]});\n/// ```\n#[lang = \"div\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"no implementation for `{Self} / {RHS}`\"]\npub trait Div<RHS=Self> {\n    /// The resulting type after applying the `/` operator\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// The method for the `/` operator\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn div(self, rhs: RHS) -> Self::Output;\n}\n\nmacro_rules! div_impl_integer {\n    ($($t:ty)*) => ($(\n        /// This operation rounds towards zero, truncating any\n        /// fractional part of the exact result.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Div for $t {\n            type Output = $t;\n\n            #[inline]\n            fn div(self, other: $t) -> $t { self / other }\n        }\n\n        forward_ref_binop! { impl Div, div for $t, $t }\n    )*)\n}\n\ndiv_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\nmacro_rules! div_impl_float {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Div for $t {\n            type Output = $t;\n\n            #[inline]\n            fn div(self, other: $t) -> $t { self / other }\n        }\n\n        forward_ref_binop! { impl Div, div for $t, $t }\n    )*)\n}\n\ndiv_impl_float! { f32 f64 }\n\n/// The remainder operator `%`.\n///\n/// # Examples\n///\n/// This example implements `Rem` on a `SplitSlice` object. After `Rem` is\n/// implemented, one can use the `%` operator to find out what the remaining\n/// elements of the slice would be after splitting it into equal slices of a\n/// given length.\n///\n/// ```\n/// use std::ops::Rem;\n///\n/// #[derive(PartialEq, Debug)]\n/// struct SplitSlice<'a, T: 'a> {\n///     slice: &'a [T],\n/// }\n///\n/// impl<'a, T> Rem<usize> for SplitSlice<'a, T> {\n///     type Output = SplitSlice<'a, T>;\n///\n///     fn rem(self, modulus: usize) -> Self {\n///         let len = self.slice.len();\n///         let rem = len % modulus;\n///         let start = len - rem;\n///         SplitSlice {slice: &self.slice[start..]}\n///     }\n/// }\n///\n/// // If we were to divide &[0, 1, 2, 3, 4, 5, 6, 7] into slices of size 3,\n/// // the remainder would be &[6, 7]\n/// assert_eq!(SplitSlice { slice: &[0, 1, 2, 3, 4, 5, 6, 7] } % 3,\n///            SplitSlice { slice: &[6, 7] });\n/// ```\n#[lang = \"rem\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"no implementation for `{Self} % {RHS}`\"]\npub trait Rem<RHS=Self> {\n    /// The resulting type after applying the `%` operator\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output = Self;\n\n    /// The method for the `%` operator\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn rem(self, rhs: RHS) -> Self::Output;\n}\n\nmacro_rules! rem_impl_integer {\n    ($($t:ty)*) => ($(\n        /// This operation satisfies `n % d == n - (n / d) * d`.  The\n        /// result has the same sign as the left operand.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Rem for $t {\n            type Output = $t;\n\n            #[inline]\n            fn rem(self, other: $t) -> $t { self % other }\n        }\n\n        forward_ref_binop! { impl Rem, rem for $t, $t }\n    )*)\n}\n\nrem_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n\nmacro_rules! rem_impl_float {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Rem for $t {\n            type Output = $t;\n\n            #[inline]\n            fn rem(self, other: $t) -> $t { self % other }\n        }\n\n        forward_ref_binop! { impl Rem, rem for $t, $t }\n    )*)\n}\n\nrem_impl_float! { f32 f64 }\n\n/// The unary negation operator `-`.\n///\n/// # Examples\n///\n/// An implementation of `Neg` for `Sign`, which allows the use of `-` to\n/// negate its value.\n///\n/// ```\n/// use std::ops::Neg;\n///\n/// #[derive(Debug, PartialEq)]\n/// enum Sign {\n///     Negative,\n///     Zero,\n///     Positive,\n/// }\n///\n/// impl Neg for Sign {\n///     type Output = Sign;\n///\n///     fn neg(self) -> Sign {\n///         match self {\n///             Sign::Negative => Sign::Positive,\n///             Sign::Zero => Sign::Zero,\n///             Sign::Positive => Sign::Negative,\n///         }\n///     }\n/// }\n///\n/// // a negative positive is a negative\n/// assert_eq!(-Sign::Positive, Sign::Negative);\n/// // a double negative is a positive\n/// assert_eq!(-Sign::Negative, Sign::Positive);\n/// // zero is its own negation\n/// assert_eq!(-Sign::Zero, Sign::Zero);\n/// ```\n#[lang = \"neg\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Neg {\n    /// The resulting type after applying the `-` operator\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// The method for the unary `-` operator\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn neg(self) -> Self::Output;\n}\n\n\n\nmacro_rules! neg_impl_core {\n    ($id:ident => $body:expr, $($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Neg for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn neg(self) -> $t { let $id = self; $body }\n        }\n\n        forward_ref_unop! { impl Neg, neg for $t }\n    )*)\n}\n\nmacro_rules! neg_impl_numeric {\n    ($($t:ty)*) => { neg_impl_core!{ x => -x, $($t)*} }\n}\n\n#[allow(unused_macros)]\nmacro_rules! neg_impl_unsigned {\n    ($($t:ty)*) => {\n        neg_impl_core!{ x => {\n            !x.wrapping_add(1)\n        }, $($t)*} }\n}\n\n// neg_impl_unsigned! { usize u8 u16 u32 u64 }\nneg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The addition assignment operator `+=`.\n///\n/// # Examples\n///\n/// This example creates a `Point` struct that implements the `AddAssign`\n/// trait, and then demonstrates add-assigning to a mutable `Point`.\n///\n/// ```\n/// use std::ops::AddAssign;\n///\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl AddAssign for Point {\n///     fn add_assign(&mut self, other: Point) {\n///         *self = Point {\n///             x: self.x + other.x,\n///             y: self.y + other.y,\n///         };\n///     }\n/// }\n///\n/// impl PartialEq for Point {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.x == other.x && self.y == other.y\n///     }\n/// }\n///\n/// let mut point = Point { x: 1, y: 0 };\n/// point += Point { x: 2, y: 3 };\n/// assert_eq!(point, Point { x: 3, y: 3 });\n/// ```\n#[lang = \"add_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented = \"no implementation for `{Self} += {Rhs}`\"]\npub trait AddAssign<Rhs=Self> {\n    /// The method for the `+=` operator\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn add_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! add_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl AddAssign for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn add_assign(&mut self, other: $t) { *self += other }\n        }\n    )+)\n}\n\nadd_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The subtraction assignment operator `-=`.\n///\n/// # Examples\n///\n/// This example creates a `Point` struct that implements the `SubAssign`\n/// trait, and then demonstrates sub-assigning to a mutable `Point`.\n///\n/// ```\n/// use std::ops::SubAssign;\n///\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl SubAssign for Point {\n///     fn sub_assign(&mut self, other: Point) {\n///         *self = Point {\n///             x: self.x - other.x,\n///             y: self.y - other.y,\n///         };\n///     }\n/// }\n///\n/// impl PartialEq for Point {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.x == other.x && self.y == other.y\n///     }\n/// }\n///\n/// let mut point = Point { x: 3, y: 3 };\n/// point -= Point { x: 2, y: 3 };\n/// assert_eq!(point, Point {x: 1, y: 0});\n/// ```\n#[lang = \"sub_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented = \"no implementation for `{Self} -= {Rhs}`\"]\npub trait SubAssign<Rhs=Self> {\n    /// The method for the `-=` operator\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn sub_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! sub_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl SubAssign for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn sub_assign(&mut self, other: $t) { *self -= other }\n        }\n    )+)\n}\n\nsub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The multiplication assignment operator `*=`.\n///\n/// # Examples\n///\n/// A trivial implementation of `MulAssign`. When `Foo *= Foo` happens, it ends up\n/// calling `mul_assign`, and therefore, `main` prints `Multiplying!`.\n///\n/// ```\n/// use std::ops::MulAssign;\n///\n/// struct Foo;\n///\n/// impl MulAssign for Foo {\n///     fn mul_assign(&mut self, _rhs: Foo) {\n///         println!(\"Multiplying!\");\n///     }\n/// }\n///\n/// # #[allow(unused_assignments)]\n/// fn main() {\n///     let mut foo = Foo;\n///     foo *= Foo;\n/// }\n/// ```\n#[lang = \"mul_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented = \"no implementation for `{Self} *= {Rhs}`\"]\npub trait MulAssign<Rhs=Self> {\n    /// The method for the `*=` operator\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn mul_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! mul_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl MulAssign for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn mul_assign(&mut self, other: $t) { *self *= other }\n        }\n    )+)\n}\n\nmul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The division assignment operator `/=`.\n///\n/// # Examples\n///\n/// A trivial implementation of `DivAssign`. When `Foo /= Foo` happens, it ends up\n/// calling `div_assign`, and therefore, `main` prints `Dividing!`.\n///\n/// ```\n/// use std::ops::DivAssign;\n///\n/// struct Foo;\n///\n/// impl DivAssign for Foo {\n///     fn div_assign(&mut self, _rhs: Foo) {\n///         println!(\"Dividing!\");\n///     }\n/// }\n///\n/// # #[allow(unused_assignments)]\n/// fn main() {\n///     let mut foo = Foo;\n///     foo /= Foo;\n/// }\n/// ```\n#[lang = \"div_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented = \"no implementation for `{Self} /= {Rhs}`\"]\npub trait DivAssign<Rhs=Self> {\n    /// The method for the `/=` operator\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn div_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! div_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl DivAssign for $t {\n            #[inline]\n            fn div_assign(&mut self, other: $t) { *self /= other }\n        }\n    )+)\n}\n\ndiv_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The remainder assignment operator `%=`.\n///\n/// # Examples\n///\n/// A trivial implementation of `RemAssign`. When `Foo %= Foo` happens, it ends up\n/// calling `rem_assign`, and therefore, `main` prints `Remainder-ing!`.\n///\n/// ```\n/// use std::ops::RemAssign;\n///\n/// struct Foo;\n///\n/// impl RemAssign for Foo {\n///     fn rem_assign(&mut self, _rhs: Foo) {\n///         println!(\"Remainder-ing!\");\n///     }\n/// }\n///\n/// # #[allow(unused_assignments)]\n/// fn main() {\n///     let mut foo = Foo;\n///     foo %= Foo;\n/// }\n/// ```\n#[lang = \"rem_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented = \"no implementation for `{Self} %= {Rhs}`\"]\npub trait RemAssign<Rhs=Self> {\n    /// The method for the `%=` operator\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn rem_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! rem_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl RemAssign for $t {\n            #[inline]\n            fn rem_assign(&mut self, other: $t) { *self %= other }\n        }\n    )+)\n}\n\nrem_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Native threads.\n//!\n//! ## The threading model\n//!\n//! An executing Rust program consists of a collection of native OS threads,\n//! each with their own stack and local state. Threads can be named, and\n//! provide some built-in support for low-level synchronization.\n//!\n//! Communication between threads can be done through\n//! [channels], Rust's message-passing types, along with [other forms of thread\n//! synchronization](../../std/sync/index.html) and shared-memory data\n//! structures. In particular, types that are guaranteed to be\n//! threadsafe are easily shared between threads using the\n//! atomically-reference-counted container, [`Arc`].\n//!\n//! Fatal logic errors in Rust cause *thread panic*, during which\n//! a thread will unwind the stack, running destructors and freeing\n//! owned resources. Thread panic is unrecoverable from within\n//! the panicking thread (i.e. there is no 'try/catch' in Rust), but\n//! the panic may optionally be detected from a different thread. If\n//! the main thread panics, the application will exit with a non-zero\n//! exit code.\n//!\n//! When the main thread of a Rust program terminates, the entire program shuts\n//! down, even if other threads are still running. However, this module provides\n//! convenient facilities for automatically waiting for the termination of a\n//! child thread (i.e., join).\n//!\n//! ## Spawning a thread\n//!\n//! A new thread can be spawned using the [`thread::spawn`][`spawn`] function:\n//!\n//! ```rust\n//! use std::thread;\n//!\n//! thread::spawn(move || {\n//!     // some work here\n//! });\n//! ```\n//!\n//! In this example, the spawned thread is \"detached\" from the current\n//! thread. This means that it can outlive its parent (the thread that spawned\n//! it), unless this parent is the main thread.\n//!\n//! The parent thread can also wait on the completion of the child\n//! thread; a call to [`spawn`] produces a [`JoinHandle`], which provides\n//! a `join` method for waiting:\n//!\n//! ```rust\n//! use std::thread;\n//!\n//! let child = thread::spawn(move || {\n//!     // some work here\n//! });\n//! // some work here\n//! let res = child.join();\n//! ```\n//!\n//! The [`join`] method returns a [`thread::Result`] containing [`Ok`] of the final\n//! value produced by the child thread, or [`Err`] of the value given to\n//! a call to [`panic!`] if the child panicked.\n//!\n//! ## Configuring threads\n//!\n//! A new thread can be configured before it is spawned via the [`Builder`] type,\n//! which currently allows you to set the name and stack size for the child thread:\n//!\n//! ```rust\n//! # #![allow(unused_must_use)]\n//! use std::thread;\n//!\n//! thread::Builder::new().name(\"child1\".to_string()).spawn(move || {\n//!     println!(\"Hello, world!\");\n//! });\n//! ```\n//!\n//! ## The `Thread` type\n//!\n//! Threads are represented via the [`Thread`] type, which you can get in one of\n//! two ways:\n//!\n//! * By spawning a new thread, e.g. using the [`thread::spawn`][`spawn`]\n//!   function, and calling [`thread`][`JoinHandle::thread`] on the [`JoinHandle`].\n//! * By requesting the current thread, using the [`thread::current`] function.\n//!\n//! The [`thread::current`] function is available even for threads not spawned\n//! by the APIs of this module.\n//!\n//! ## Thread-local storage\n//!\n//! This module also provides an implementation of thread-local storage for Rust\n//! programs. Thread-local storage is a method of storing data into a global\n//! variable that each thread in the program will have its own copy of.\n//! Threads do not share this data, so accesses do not need to be synchronized.\n//!\n//! A thread-local key owns the value it contains and will destroy the value when the\n//! thread exits. It is created with the [`thread_local!`] macro and can contain any\n//! value that is `'static` (no borrowed pointers). It provides an accessor function,\n//! [`with`], that yields a shared reference to the value to the specified\n//! closure. Thread-local keys allow only shared access to values, as there would be no\n//! way to guarantee uniqueness if mutable borrows were allowed. Most values\n//! will want to make use of some form of **interior mutability** through the\n//! [`Cell`] or [`RefCell`] types.\n//!\n//! [channels]: ../../std/sync/mpsc/index.html\n//! [`Arc`]: ../../std/sync/struct.Arc.html\n//! [`spawn`]: ../../std/thread/fn.spawn.html\n//! [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n//! [`JoinHandle::thread`]: ../../std/thread/struct.JoinHandle.html#method.thread\n//! [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n//! [`Result`]: ../../std/result/enum.Result.html\n//! [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n//! [`Err`]: ../../std/result/enum.Result.html#variant.Err\n//! [`panic!`]: ../../std/macro.panic.html\n//! [`Builder`]: ../../std/thread/struct.Builder.html\n//! [`thread::current`]: ../../std/thread/fn.current.html\n//! [`thread::Result`]: ../../std/thread/type.Result.html\n//! [`Thread`]: ../../std/thread/struct.Thread.html\n//! [`park`]: ../../std/thread/fn.park.html\n//! [`unpark`]: ../../std/thread/struct.Thread.html#method.unpark\n//! [`thread::park_timeout`]: ../../std/thread/fn.park_timeout.html\n//! [`Cell`]: ../cell/struct.Cell.html\n//! [`RefCell`]: ../cell/struct.RefCell.html\n//! [`thread_local!`]: ../macro.thread_local.html\n//! [`with`]: struct.LocalKey.html#method.with\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse any::Any;\nuse cell::UnsafeCell;\nuse ffi::{CStr, CString};\nuse fmt;\nuse io;\nuse panic;\nuse panicking;\nuse str;\nuse sync::{Mutex, Condvar, Arc};\nuse sys::thread as imp;\nuse sys_common::mutex;\nuse sys_common::thread_info;\nuse sys_common::util;\nuse sys_common::{AsInner, IntoInner};\nuse time::Duration;\n\n////////////////////////////////////////////////////////////////////////////////\n// Thread-local storage\n////////////////////////////////////////////////////////////////////////////////\n\n#[macro_use] mod local;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::local::{LocalKey, LocalKeyState};\n\n// The types used by the thread_local! macro to access TLS keys. Note that there\n// are two types, the \"OS\" type and the \"fast\" type. The OS thread local key\n// type is accessed via platform-specific API calls and is slow, while the fast\n// key type is accessed via code generated via LLVM, where TLS keys are set up\n// by the elf linker. Note that the OS TLS type is always available: on macOS\n// the standard library is compiled with support for older platform versions\n// where fast TLS was not available; end-user code is compiled with fast TLS\n// where available, but both are needed.\n\n#[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n#[cfg(target_thread_local)]\n#[doc(hidden)] pub use self::local::fast::Key as __FastLocalKeyInner;\n#[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n#[doc(hidden)] pub use self::local::os::Key as __OsLocalKeyInner;\n\n////////////////////////////////////////////////////////////////////////////////\n// Builder\n////////////////////////////////////////////////////////////////////////////////\n\n/// Thread factory, which can be used in order to configure the properties of\n/// a new thread.\n///\n/// Methods can be chained on it in order to configure it.\n///\n/// The two configurations available are:\n///\n/// - [`name`]: allows to give a name to the thread which is currently\n///   only used in `panic` messages.\n/// - [`stack_size`]: specifies the desired stack size. Note that this can\n///   be overriden by the OS.\n///\n/// If the [`stack_size`] field is not specified, the stack size\n/// will be the `RUST_MIN_STACK` environment variable. If it is\n/// not specified either, a sensible default will be set.\n///\n/// If the [`name`] field is not specified, the thread will not be named.\n///\n/// The [`spawn`] method will take ownership of the builder and create an\n/// [`io::Result`] to the thread handle with the given configuration.\n///\n/// The [`thread::spawn`] free function uses a `Builder` with default\n/// configuration and [`unwrap`]s its return value.\n///\n/// You may want to use [`spawn`] instead of [`thread::spawn`], when you want\n/// to recover from a failure to launch a thread, indeed the free function will\n/// panick where the `Builder` method will return a [`io::Result`].\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n///\n/// let builder = thread::Builder::new();\n///\n/// let handler = builder.spawn(|| {\n///     // thread code\n/// }).unwrap();\n///\n/// handler.join().unwrap();\n/// ```\n///\n/// [`thread::spawn`]: ../../std/thread/fn.spawn.html\n/// [`stack_size`]: ../../std/thread/struct.Builder.html#method.stack_size\n/// [`name`]: ../../std/thread/struct.Builder.html#method.name\n/// [`spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n/// [`io::Result`]: ../../std/io/type.Result.html\n/// [`unwrap`]: ../../std/result/enum.Result.html#method.unwrap\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Builder {\n    // A name for the thread-to-be, for identification in panic messages\n    name: Option<String>,\n    // The size of the stack for the spawned thread in bytes\n    stack_size: Option<usize>,\n}\n\nimpl Builder {\n    /// Generates the base configuration for spawning a thread, from which\n    /// configuration methods can be chained.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new()\n    ///                               .name(\"foo\".into())\n    ///                               .stack_size(10);\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     // thread code\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> Builder {\n        Builder {\n            name: None,\n            stack_size: None,\n        }\n    }\n\n    /// Names the thread-to-be. Currently the name is used for identification\n    /// only in panic messages.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new()\n    ///     .name(\"foo\".into());\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     assert_eq!(thread::current().name(), Some(\"foo\"))\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn name(mut self, name: String) -> Builder {\n        self.name = Some(name);\n        self\n    }\n\n    /// Sets the size of the stack (in bytes) for the new thread.\n    ///\n    /// The actual stack size may be greater than this value if\n    /// the platform specifies minimal stack size.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new().stack_size(32 * 1024);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn stack_size(mut self, size: usize) -> Builder {\n        self.stack_size = Some(size);\n        self\n    }\n\n    /// Spawns a new thread by taking ownership of the `Builder`, and returns an\n    /// [`io::Result`] to its [`JoinHandle`].\n    ///\n    /// The spawned thread may outlive the caller (unless the caller thread\n    /// is the main thread; the whole process is terminated when the main\n    /// thread finishes). The join handle can be used to block on\n    /// termination of the child thread, including recovering its panics.\n    ///\n    /// For a more complete documentation see [`thread::spawn`][`spawn`].\n    ///\n    /// # Errors\n    ///\n    /// Unlike the [`spawn`] free function, this method yields an\n    /// [`io::Result`] to capture any failure to create the thread at\n    /// the OS level.\n    ///\n    /// [`spawn`]: ../../std/thread/fn.spawn.html\n    /// [`io::Result`]: ../../std/io/type.Result.html\n    /// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     // thread code\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>> where\n        F: FnOnce() -> T, F: Send + 'static, T: Send + 'static\n    {\n        let Builder { name, stack_size } = self;\n\n        let stack_size = stack_size.unwrap_or(util::min_stack());\n\n        let my_thread = Thread::new(name);\n        let their_thread = my_thread.clone();\n\n        let my_packet : Arc<UnsafeCell<Option<Result<T>>>>\n            = Arc::new(UnsafeCell::new(None));\n        let their_packet = my_packet.clone();\n\n        let main = move || {\n            if let Some(name) = their_thread.cname() {\n                imp::Thread::set_name(name);\n            }\n            unsafe {\n                thread_info::set(imp::guard::current(), their_thread);\n                #[cfg(feature = \"backtrace\")]\n                let try_result = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n                    ::sys_common::backtrace::__rust_begin_short_backtrace(f)\n                }));\n                #[cfg(not(feature = \"backtrace\"))]\n                let try_result = panic::catch_unwind(panic::AssertUnwindSafe(f));\n                *their_packet.get() = Some(try_result);\n            }\n        };\n\n        Ok(JoinHandle(JoinInner {\n            native: unsafe {\n                Some(imp::Thread::new(stack_size, Box::new(main))?)\n            },\n            thread: my_thread,\n            packet: Packet(my_packet),\n        }))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Free functions\n////////////////////////////////////////////////////////////////////////////////\n\n/// Spawns a new thread, returning a [`JoinHandle`] for it.\n///\n/// The join handle will implicitly *detach* the child thread upon being\n/// dropped. In this case, the child thread may outlive the parent (unless\n/// the parent thread is the main thread; the whole process is terminated when\n/// the main thread finishes). Additionally, the join handle provides a [`join`]\n/// method that can be used to join the child thread. If the child thread\n/// panics, [`join`] will return an [`Err`] containing the argument given to\n/// [`panic`].\n///\n/// This will create a thread using default parameters of [`Builder`], if you\n/// want to specify the stack size or the name of the thread, use this API\n/// instead.\n///\n/// As you can see in the signature of `spawn` there are two constraints on\n/// both the closure given to `spawn` and its return value, let's explain them:\n///\n/// - The `'static` constraint means that the closure and its return value\n///   must have a lifetime of the whole program execution. The reason for this\n///   is that threads can `detach` and outlive the lifetime they have been\n///   created in.\n///   Indeed if the thread, and by extension its return value, can outlive their\n///   caller, we need to make sure that they will be valid afterwards, and since\n///   we *can't* know when it will return we need to have them valid as long as\n///   possible, that is until the end of the program, hence the `'static`\n///   lifetime.\n/// - The [`Send`] constraint is because the closure will need to be passed\n///   *by value* from the thread where it is spawned to the new thread. Its\n///   return value will need to be passed from the new thread to the thread\n///   where it is `join`ed.\n///   As a reminder, the [`Send`] marker trait, expresses that it is safe to be\n///   passed from thread to thread. [`Sync`] expresses that it is safe to have a\n///   reference be passed from thread to thread.\n///\n/// # Panics\n///\n/// Panics if the OS fails to create a thread; use [`Builder::spawn`]\n/// to recover from such errors.\n///\n/// # Examples\n///\n/// Creating a thread.\n///\n/// ```\n/// use std::thread;\n///\n/// let handler = thread::spawn(|| {\n///     // thread code\n/// });\n///\n/// handler.join().unwrap();\n/// ```\n///\n/// As mentioned in the module documentation, threads are usually made to\n/// communicate using [`channels`], here is how it usually looks.\n///\n/// This example also shows how to use `move`, in order to give ownership\n/// of values to a thread.\n///\n/// ```\n/// use std::thread;\n/// use std::sync::mpsc::channel;\n///\n/// let (tx, rx) = channel();\n///\n/// let sender = thread::spawn(move || {\n///     let _ = tx.send(\"Hello, thread\".to_owned());\n/// });\n///\n/// let receiver = thread::spawn(move || {\n///     println!(\"{}\", rx.recv().unwrap());\n/// });\n///\n/// let _ = sender.join();\n/// let _ = receiver.join();\n/// ```\n///\n/// A thread can also return a value through its [`JoinHandle`], you can use\n/// this to make asynchronous computations (futures might be more appropriate\n/// though).\n///\n/// ```\n/// use std::thread;\n///\n/// let computation = thread::spawn(|| {\n///     // Some expensive computation.\n///     42\n/// });\n///\n/// let result = computation.join().unwrap();\n/// println!(\"{}\", result);\n/// ```\n///\n/// [`channels`]: ../../std/sync/mpsc/index.html\n/// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n/// [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n/// [`panic`]: ../../std/macro.panic.html\n/// [`Builder::spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n/// [`Builder`]: ../../std/thread/struct.Builder.html\n/// [`Send`]: ../../std/marker/trait.Send.html\n/// [`Sync`]: ../../std/marker/trait.Sync.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn spawn<F, T>(f: F) -> JoinHandle<T> where\n    F: FnOnce() -> T, F: Send + 'static, T: Send + 'static\n{\n    Builder::new().spawn(f).unwrap()\n}\n\n/// Gets a handle to the thread that invokes it.\n///\n/// # Examples\n///\n/// Getting a handle to the current thread with `thread::current()`:\n///\n/// ```\n/// use std::thread;\n///\n/// let handler = thread::Builder::new()\n///     .name(\"named thread\".into())\n///     .spawn(|| {\n///         let handle = thread::current();\n///         assert_eq!(handle.name(), Some(\"named thread\"));\n///     })\n///     .unwrap();\n///\n/// handler.join().unwrap();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn current() -> Thread {\n    thread_info::current_thread().expect(\"use of std::thread::current() is not \\\n                                          possible after the thread's local \\\n                                          data has been destroyed\")\n}\n\n/// Cooperatively gives up a timeslice to the OS scheduler.\n///\n/// This is used when the programmer knows that the thread will have nothing\n/// to do for some time, and thus avoid wasting computing time.\n///\n/// For example when polling on a resource, it is common to check that it is\n/// available, and if not to yield in order to avoid busy waiting.\n///\n/// Thus the pattern of `yield`ing after a failed poll is rather common when\n/// implementing low-level shared resources or synchronization primitives.\n///\n/// However programmers will usualy prefer to use, [`channel`]s, [`Condvar`]s,\n/// [`Mutex`]es or [`join`] for their synchronisation routines, as they avoid\n/// thinking about thread schedulling.\n///\n/// Note that [`channel`]s for example are implemented using this primitive.\n/// Indeed when you call `send` or `recv`, which are blocking, they will yield\n/// if the channel is not available.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n///\n/// thread::yield_now();\n/// ```\n///\n/// [`channel`]: ../../std/sync/mpsc/index.html\n/// [`spawn`]: ../../std/thread/fn.spawn.html\n/// [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n/// [`Mutex`]: ../../std/sync/struct.Mutex.html\n/// [`Condvar`]: ../../std/sync/struct.Condvar.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn yield_now() {\n    imp::Thread::yield_now()\n}\n\n/// Determines whether the current thread is unwinding because of panic.\n///\n/// A common use of this feature is to poison shared resources when writing\n/// unsafe code, by checking `panicking` when the `drop` is called.\n///\n/// This is usually not needed when writing safe code, as [`Mutex`es][Mutex]\n/// already poison themselves when a thread panics while holding the lock.\n///\n/// This can also be used in multithreaded applications, in order to send a\n/// message to other threads warning that a thread has panicked (e.g. for\n/// monitoring purposes).\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::thread;\n///\n/// struct SomeStruct;\n///\n/// impl Drop for SomeStruct {\n///     fn drop(&mut self) {\n///         if thread::panicking() {\n///             println!(\"dropped while unwinding\");\n///         } else {\n///             println!(\"dropped while not unwinding\");\n///         }\n///     }\n/// }\n///\n/// {\n///     print!(\"a: \");\n///     let a = SomeStruct;\n/// }\n///\n/// {\n///     print!(\"b: \");\n///     let b = SomeStruct;\n///     panic!()\n/// }\n/// ```\n///\n/// [Mutex]: ../../std/sync/struct.Mutex.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn panicking() -> bool {\n    panicking::panicking()\n}\n\n/// Puts the current thread to sleep for the specified amount of time.\n///\n/// The thread may sleep longer than the duration specified due to scheduling\n/// specifics or platform-dependent functionality.\n///\n/// # Platform behavior\n///\n/// On Unix platforms this function will not return early due to a\n/// signal being received or a spurious wakeup.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::thread;\n///\n/// // Let's sleep for 2 seconds:\n/// thread::sleep_ms(2000);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::sleep`\")]\npub fn sleep_ms(ms: u32) {\n    sleep(Duration::from_millis(ms as u64))\n}\n\n/// Puts the current thread to sleep for the specified amount of time.\n///\n/// The thread may sleep longer than the duration specified due to scheduling\n/// specifics or platform-dependent functionality.\n///\n/// # Platform behavior\n///\n/// On Unix platforms this function will not return early due to a\n/// signal being received or a spurious wakeup. Platforms which do not support\n/// nanosecond precision for sleeping will have `dur` rounded up to the nearest\n/// granularity of time they can sleep for.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::{thread, time};\n///\n/// let ten_millis = time::Duration::from_millis(10);\n/// let now = time::Instant::now();\n///\n/// thread::sleep(ten_millis);\n///\n/// assert!(now.elapsed() >= ten_millis);\n/// ```\n#[stable(feature = \"thread_sleep\", since = \"1.4.0\")]\npub fn sleep(dur: Duration) {\n    imp::Thread::sleep(dur)\n}\n\n/// Blocks unless or until the current thread's token is made available.\n///\n/// A call to `park` does not guarantee that the thread will remain parked\n/// forever, and callers should be prepared for this possibility.\n///\n/// # park and unpark\n///\n/// Every thread is equipped with some basic low-level blocking support, via the\n/// [`thread::park`][`park`] function and [`thread::Thread::unpark`][`unpark`]\n/// method. [`park`] blocks the current thread, which can then be resumed from\n/// another thread by calling the [`unpark`] method on the blocked thread's\n/// handle.\n///\n/// Conceptually, each [`Thread`] handle has an associated token, which is\n/// initially not present:\n///\n/// * The [`thread::park`][`park`] function blocks the current thread unless or\n///   until the token is available for its thread handle, at which point it\n///   atomically consumes the token. It may also return *spuriously*, without\n///   consuming the token. [`thread::park_timeout`] does the same, but allows\n///   specifying a maximum time to block the thread for.\n///\n/// * The [`unpark`] method on a [`Thread`] atomically makes the token available\n///   if it wasn't already.\n///\n/// In other words, each [`Thread`] acts a bit like a spinlock that can be\n/// locked and unlocked using `park` and `unpark`.\n///\n/// The API is typically used by acquiring a handle to the current thread,\n/// placing that handle in a shared data structure so that other threads can\n/// find it, and then `park`ing. When some desired condition is met, another\n/// thread calls [`unpark`] on the handle.\n///\n/// The motivation for this design is twofold:\n///\n/// * It avoids the need to allocate mutexes and condvars when building new\n///   synchronization primitives; the threads already provide basic\n///   blocking/signaling.\n///\n/// * It can be implemented very efficiently on many platforms.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n///\n/// let parked_thread = thread::Builder::new()\n///     .spawn(|| {\n///         println!(\"Parking thread\");\n///         thread::park();\n///         println!(\"Thread unparked\");\n///     })\n///     .unwrap();\n///\n/// // Let some time pass for the thread to be spawned.\n/// thread::sleep(Duration::from_millis(10));\n///\n/// println!(\"Unpark the thread\");\n/// parked_thread.thread().unpark();\n///\n/// parked_thread.join().unwrap();\n/// ```\n///\n/// [`Thread`]: ../../std/thread/struct.Thread.html\n/// [`park`]: ../../std/thread/fn.park.html\n/// [`unpark`]: ../../std/thread/struct.Thread.html#method.unpark\n/// [`thread::park_timeout`]: ../../std/thread/fn.park_timeout.html\n//\n// The implementation currently uses the trivial strategy of a Mutex+Condvar\n// with wakeup flag, which does not actually allow spurious wakeups. In the\n// future, this will be implemented in a more efficient way, perhaps along the lines of\n//   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n// or futuxes, and in either case may allow spurious wakeups.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn park() {\n    let thread = current();\n    let mut guard = thread.inner.lock.lock().unwrap();\n    while !*guard {\n        guard = thread.inner.cvar.wait(guard).unwrap();\n    }\n    *guard = false;\n}\n\n/// Use [`park_timeout`].\n///\n/// Blocks unless or until the current thread's token is made available or\n/// the specified duration has been reached (may wake spuriously).\n///\n/// The semantics of this function are equivalent to [`park`] except\n/// that the thread will be blocked for roughly no longer than `dur`. This\n/// method should not be used for precise timing due to anomalies such as\n/// preemption or platform differences that may not cause the maximum\n/// amount of time waited to be precisely `ms` long.\n///\n/// See the [park documentation][`park`] for more detail.\n///\n/// [`park_timeout`]: fn.park_timeout.html\n/// [`park`]: ../../std/thread/fn.park.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::park_timeout`\")]\npub fn park_timeout_ms(ms: u32) {\n    park_timeout(Duration::from_millis(ms as u64))\n}\n\n/// Blocks unless or until the current thread's token is made available or\n/// the specified duration has been reached (may wake spuriously).\n///\n/// The semantics of this function are equivalent to [`park`][park] except\n/// that the thread will be blocked for roughly no longer than `dur`. This\n/// method should not be used for precise timing due to anomalies such as\n/// preemption or platform differences that may not cause the maximum\n/// amount of time waited to be precisely `dur` long.\n///\n/// See the [park dococumentation][park] for more details.\n///\n/// # Platform behavior\n///\n/// Platforms which do not support nanosecond precision for sleeping will have\n/// `dur` rounded up to the nearest granularity of time they can sleep for.\n///\n/// # Example\n///\n/// Waiting for the complete expiration of the timeout:\n///\n/// ```rust,no_run\n/// use std::thread::park_timeout;\n/// use std::time::{Instant, Duration};\n///\n/// let timeout = Duration::from_secs(2);\n/// let beginning_park = Instant::now();\n///\n/// let mut timeout_remaining = timeout;\n/// loop {\n///     park_timeout(timeout_remaining);\n///     let elapsed = beginning_park.elapsed();\n///     if elapsed >= timeout {\n///         break;\n///     }\n///     println!(\"restarting park_timeout after {:?}\", elapsed);\n///     timeout_remaining = timeout - elapsed;\n/// }\n/// ```\n///\n/// [park]: fn.park.html\n#[stable(feature = \"park_timeout\", since = \"1.4.0\")]\npub fn park_timeout(dur: Duration) {\n    let thread = current();\n    let mut guard = thread.inner.lock.lock().unwrap();\n    if !*guard {\n        let (g, _) = thread.inner.cvar.wait_timeout(guard, dur).unwrap();\n        guard = g;\n    }\n    *guard = false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ThreadId\n////////////////////////////////////////////////////////////////////////////////\n\n/// A unique identifier for a running thread.\n///\n/// A `ThreadId` is an opaque object that has a unique value for each thread\n/// that creates one. `ThreadId`s are not guaranteed to correspond to a thread's\n/// system-designated identifier.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n///\n/// let other_thread = thread::spawn(|| {\n///     thread::current().id()\n/// });\n///\n/// let other_thread_id = other_thread.join().unwrap();\n/// assert!(thread::current().id() != other_thread_id);\n/// ```\n#[stable(feature = \"thread_id\", since = \"1.19.0\")]\n#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\npub struct ThreadId(u64);\n\nimpl ThreadId {\n    // Generate a new unique thread ID.\n    fn new() -> ThreadId {\n        static GUARD: mutex::Mutex = mutex::Mutex::new();\n        static mut COUNTER: u64 = 0;\n\n        unsafe {\n            GUARD.lock();\n\n            // If we somehow use up all our bits, panic so that we're not\n            // covering up subtle bugs of IDs being reused.\n            if COUNTER == ::u64::MAX {\n                GUARD.unlock();\n                panic!(\"failed to generate unique thread ID: bitspace exhausted\");\n            }\n\n            let id = COUNTER;\n            COUNTER += 1;\n\n            GUARD.unlock();\n\n            ThreadId(id)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Thread\n////////////////////////////////////////////////////////////////////////////////\n\n/// The internal representation of a `Thread` handle\nstruct Inner {\n    name: Option<CString>,      // Guaranteed to be UTF-8\n    id: ThreadId,\n    lock: Mutex<bool>,          // true when there is a buffered unpark\n    cvar: Condvar,\n}\n\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n/// A handle to a thread.\n///\n/// Threads are represented via the `Thread` type, which you can get in one of\n/// two ways:\n///\n/// * By spawning a new thread, e.g. using the [`thread::spawn`][`spawn`]\n///   function, and calling [`thread`][`JoinHandle::thread`] on the\n///   [`JoinHandle`].\n/// * By requesting the current thread, using the [`thread::current`] function.\n///\n/// The [`thread::current`] function is available even for threads not spawned\n/// by the APIs of this module.\n///\n/// There is usualy no need to create a `Thread` struct yourself, one\n/// should instead use a function like `spawn` to create new threads, see the\n/// docs of [`Builder`] and [`spawn`] for more details.\n///\n/// [`Builder`]: ../../std/thread/struct.Builder.html\n/// [`spawn`]: ../../std/thread/fn.spawn.html\n\npub struct Thread {\n    inner: Arc<Inner>,\n}\n\nimpl Thread {\n    // Used only internally to construct a thread object without spawning\n    pub(crate) fn new(name: Option<String>) -> Thread {\n        let cname = name.map(|n| {\n            CString::new(n).expect(\"thread name may not contain interior null bytes\")\n        });\n        Thread {\n            inner: Arc::new(Inner {\n                name: cname,\n                id: ThreadId::new(),\n                lock: Mutex::new(false),\n                cvar: Condvar::new(),\n            })\n        }\n    }\n\n    /// Atomically makes the handle's token available if it is not already.\n    ///\n    /// Every thread is equipped with some basic low-level blocking support, via\n    /// the [`park`][park] function and the `unpark()` method. These can be\n    /// used as a more CPU-efficient implementation of a spinlock.\n    ///\n    /// See the [park documentation][park] for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    ///\n    /// let parked_thread = thread::Builder::new()\n    ///     .spawn(|| {\n    ///         println!(\"Parking thread\");\n    ///         thread::park();\n    ///         println!(\"Thread unparked\");\n    ///     })\n    ///     .unwrap();\n    ///\n    /// // Let some time pass for the thread to be spawned.\n    /// thread::sleep(Duration::from_millis(10));\n    ///\n    /// println!(\"Unpark the thread\");\n    /// parked_thread.thread().unpark();\n    ///\n    /// parked_thread.join().unwrap();\n    /// ```\n    ///\n    /// [park]: fn.park.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unpark(&self) {\n        let mut guard = self.inner.lock.lock().unwrap();\n        if !*guard {\n            *guard = true;\n            self.inner.cvar.notify_one();\n        }\n    }\n\n    /// Gets the thread's unique identifier.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let other_thread = thread::spawn(|| {\n    ///     thread::current().id()\n    /// });\n    ///\n    /// let other_thread_id = other_thread.join().unwrap();\n    /// assert!(thread::current().id() != other_thread_id);\n    /// ```\n    #[stable(feature = \"thread_id\", since = \"1.19.0\")]\n    pub fn id(&self) -> ThreadId {\n        self.inner.id\n    }\n\n    /// Gets the thread's name.\n    ///\n    /// # Examples\n    ///\n    /// Threads by default have no name specified:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     assert!(thread::current().name().is_none());\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// Thread with a specified name:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new()\n    ///     .name(\"foo\".into());\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     assert_eq!(thread::current().name(), Some(\"foo\"))\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn name(&self) -> Option<&str> {\n        self.cname().map(|s| unsafe { str::from_utf8_unchecked(s.to_bytes()) } )\n    }\n\n    fn cname(&self) -> Option<&CStr> {\n        self.inner.name.as_ref().map(|s| &**s)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Thread {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&self.name(), f)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// JoinHandle\n////////////////////////////////////////////////////////////////////////////////\n\n/// A specialized [`Result`] type for threads.\n///\n/// Indicates the manner in which a thread exited.\n///\n/// A thread that completes without panicking is considered to exit successfully.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::thread;\n/// use std::fs;\n///\n/// fn copy_in_thread() -> thread::Result<()> {\n///     thread::spawn(move || { fs::copy(\"foo.txt\", \"bar.txt\").unwrap(); }).join()\n/// }\n///\n/// fn main() {\n///     match copy_in_thread() {\n///         Ok(_) => println!(\"this is fine\"),\n///         Err(_) => println!(\"thread panicked\"),\n///     }\n/// }\n/// ```\n///\n/// [`Result`]: ../../std/result/enum.Result.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result<T> = ::result::Result<T, Box<Any + Send + 'static>>;\n\n// This packet is used to communicate the return value between the child thread\n// and the parent thread. Memory is shared through the `Arc` within and there's\n// no need for a mutex here because synchronization happens with `join()` (the\n// parent thread never reads this packet until the child has exited).\n//\n// This packet itself is then stored into a `JoinInner` which in turns is placed\n// in `JoinHandle` and `JoinGuard`. Due to the usage of `UnsafeCell` we need to\n// manually worry about impls like Send and Sync. The type `T` should\n// already always be Send (otherwise the thread could not have been created) and\n// this type is inherently Sync because no methods take &self. Regardless,\n// however, we add inheriting impls for Send/Sync to this type to ensure it's\n// Send/Sync and that future modifications will still appropriately classify it.\nstruct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n\nunsafe impl<T: Send> Send for Packet<T> {}\nunsafe impl<T: Sync> Sync for Packet<T> {}\n\n/// Inner representation for JoinHandle\nstruct JoinInner<T> {\n    native: Option<imp::Thread>,\n    thread: Thread,\n    packet: Packet<T>,\n}\n\nimpl<T> JoinInner<T> {\n    fn join(&mut self) -> Result<T> {\n        self.native.take().unwrap().join();\n        unsafe {\n            (*self.packet.0.get()).take().unwrap()\n        }\n    }\n}\n\n/// An owned permission to join on a thread (block on its termination).\n///\n/// A `JoinHandle` *detaches* the associated thread when it is dropped, which\n/// means that there is no longer any handle to thread and no way to `join`\n/// on it.\n///\n/// Due to platform restrictions, it is not possible to [`Clone`] this\n/// handle: the ability to join a thread is a uniquely-owned permission.\n///\n/// This `struct` is created by the [`thread::spawn`] function and the\n/// [`thread::Builder::spawn`] method.\n///\n/// # Examples\n///\n/// Creation from [`thread::spawn`]:\n///\n/// ```\n/// use std::thread;\n///\n/// let join_handle: thread::JoinHandle<_> = thread::spawn(|| {\n///     // some work here\n/// });\n/// ```\n///\n/// Creation from [`thread::Builder::spawn`]:\n///\n/// ```\n/// use std::thread;\n///\n/// let builder = thread::Builder::new();\n///\n/// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n///     // some work here\n/// }).unwrap();\n/// ```\n///\n/// Child being detached and outliving its parent:\n///\n/// ```no_run\n/// use std::thread;\n/// use std::time::Duration;\n///\n/// let original_thread = thread::spawn(|| {\n///     let _detached_thread = thread::spawn(|| {\n///         // Here we sleep to make sure that the first thread returns before.\n///         thread::sleep(Duration::from_millis(10));\n///         // This will be called, even though the JoinHandle is dropped.\n///         println!(\" Still alive \");\n///     });\n/// });\n///\n/// let _ = original_thread.join();\n/// println!(\"Original thread is joined.\");\n///\n/// // We make sure that the new thread has time to run, before the main\n/// // thread returns.\n///\n/// thread::sleep(Duration::from_millis(1000));\n/// ```\n///\n/// [`Clone`]: ../../std/clone/trait.Clone.html\n/// [`thread::spawn`]: fn.spawn.html\n/// [`thread::Builder::spawn`]: struct.Builder.html#method.spawn\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct JoinHandle<T>(JoinInner<T>);\n\nimpl<T> JoinHandle<T> {\n    /// Extracts a handle to the underlying thread.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n    ///     // some work here\n    /// }).unwrap();\n    ///\n    /// let thread = join_handle.thread();\n    /// println!(\"thread id: {:?}\", thread.id());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn thread(&self) -> &Thread {\n        &self.0.thread\n    }\n\n    /// Waits for the associated thread to finish.\n    ///\n    /// If the child thread panics, [`Err`] is returned with the parameter given\n    /// to [`panic`].\n    ///\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`panic`]: ../../std/macro.panic.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n    ///     // some work here\n    /// }).unwrap();\n    /// join_handle.join().expect(\"Couldn't join on the associated thread\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn join(mut self) -> Result<T> {\n        self.0.join()\n    }\n}\n\nimpl<T> AsInner<imp::Thread> for JoinHandle<T> {\n    fn as_inner(&self) -> &imp::Thread { self.0.native.as_ref().unwrap() }\n}\n\nimpl<T> IntoInner<imp::Thread> for JoinHandle<T> {\n    fn into_inner(self) -> imp::Thread { self.0.native.unwrap() }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T> fmt::Debug for JoinHandle<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"JoinHandle { .. }\")\n    }\n}\n\nfn _assert_sync_and_send() {\n    fn _assert_both<T: Send + Sync>() {}\n    _assert_both::<JoinHandle<()>>();\n    _assert_both::<Thread>();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Tests\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use any::Any;\n    use sync::mpsc::{channel, Sender};\n    use result;\n    use super::{Builder};\n    use thread;\n    use time::Duration;\n    use u32;\n\n    // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n    // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n\n    #[test]\n    fn test_unnamed_thread() {\n        thread::spawn(move|| {\n            assert!(thread::current().name().is_none());\n        }).join().ok().unwrap();\n    }\n\n    #[test]\n    fn test_named_thread() {\n        Builder::new().name(\"ada lovelace\".to_string()).spawn(move|| {\n            assert!(thread::current().name().unwrap() == \"ada lovelace\".to_string());\n        }).unwrap().join().unwrap();\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_invalid_named_thread() {\n        let _ = Builder::new().name(\"ada l\\0velace\".to_string()).spawn(|| {});\n    }\n\n    #[test]\n    fn test_run_basic() {\n        let (tx, rx) = channel();\n        thread::spawn(move|| {\n            tx.send(()).unwrap();\n        });\n        rx.recv().unwrap();\n    }\n\n    #[test]\n    fn test_join_panic() {\n        match thread::spawn(move|| {\n            panic!()\n        }).join() {\n            result::Result::Err(_) => (),\n            result::Result::Ok(()) => panic!()\n        }\n    }\n\n    #[test]\n    fn test_spawn_sched() {\n        let (tx, rx) = channel();\n\n        fn f(i: i32, tx: Sender<()>) {\n            let tx = tx.clone();\n            thread::spawn(move|| {\n                if i == 0 {\n                    tx.send(()).unwrap();\n                } else {\n                    f(i - 1, tx);\n                }\n            });\n\n        }\n        f(10, tx);\n        rx.recv().unwrap();\n    }\n\n    #[test]\n    fn test_spawn_sched_childs_on_default_sched() {\n        let (tx, rx) = channel();\n\n        thread::spawn(move|| {\n            thread::spawn(move|| {\n                tx.send(()).unwrap();\n            });\n        });\n\n        rx.recv().unwrap();\n    }\n\n    fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Box<Fn() + Send>) {\n        let (tx, rx) = channel();\n\n        let x: Box<_> = box 1;\n        let x_in_parent = (&*x) as *const i32 as usize;\n\n        spawnfn(Box::new(move|| {\n            let x_in_child = (&*x) as *const i32 as usize;\n            tx.send(x_in_child).unwrap();\n        }));\n\n        let x_in_child = rx.recv().unwrap();\n        assert_eq!(x_in_parent, x_in_child);\n    }\n\n    #[test]\n    fn test_avoid_copying_the_body_spawn() {\n        avoid_copying_the_body(|v| {\n            thread::spawn(move || v());\n        });\n    }\n\n    #[test]\n    fn test_avoid_copying_the_body_thread_spawn() {\n        avoid_copying_the_body(|f| {\n            thread::spawn(move|| {\n                f();\n            });\n        })\n    }\n\n    #[test]\n    fn test_avoid_copying_the_body_join() {\n        avoid_copying_the_body(|f| {\n            let _ = thread::spawn(move|| {\n                f()\n            }).join();\n        })\n    }\n\n    #[test]\n    fn test_child_doesnt_ref_parent() {\n        // If the child refcounts the parent thread, this will stack overflow when\n        // climbing the thread tree to dereference each ancestor. (See #1789)\n        // (well, it would if the constant were 8000+ - I lowered it to be more\n        // valgrind-friendly. try this at home, instead..!)\n        const GENERATIONS: u32 = 16;\n        fn child_no(x: u32) -> Box<Fn() + Send> {\n            return Box::new(move|| {\n                if x < GENERATIONS {\n                    thread::spawn(move|| child_no(x+1)());\n                }\n            });\n        }\n        thread::spawn(|| child_no(0)());\n    }\n\n    #[test]\n    fn test_simple_newsched_spawn() {\n        thread::spawn(move || {});\n    }\n\n    #[test]\n    fn test_try_panic_message_static_str() {\n        match thread::spawn(move|| {\n            panic!(\"static string\");\n        }).join() {\n            Err(e) => {\n                type T = &'static str;\n                assert!(e.is::<T>());\n                assert_eq!(*e.downcast::<T>().unwrap(), \"static string\");\n            }\n            Ok(()) => panic!()\n        }\n    }\n\n    #[test]\n    fn test_try_panic_message_owned_str() {\n        match thread::spawn(move|| {\n            panic!(\"owned string\".to_string());\n        }).join() {\n            Err(e) => {\n                type T = String;\n                assert!(e.is::<T>());\n                assert_eq!(*e.downcast::<T>().unwrap(), \"owned string\".to_string());\n            }\n            Ok(()) => panic!()\n        }\n    }\n\n    #[test]\n    fn test_try_panic_message_any() {\n        match thread::spawn(move|| {\n            panic!(box 413u16 as Box<Any + Send>);\n        }).join() {\n            Err(e) => {\n                type T = Box<Any + Send>;\n                assert!(e.is::<T>());\n                let any = e.downcast::<T>().unwrap();\n                assert!(any.is::<u16>());\n                assert_eq!(*any.downcast::<u16>().unwrap(), 413);\n            }\n            Ok(()) => panic!()\n        }\n    }\n\n    #[test]\n    fn test_try_panic_message_unit_struct() {\n        struct Juju;\n\n        match thread::spawn(move|| {\n            panic!(Juju)\n        }).join() {\n            Err(ref e) if e.is::<Juju>() => {}\n            Err(_) | Ok(()) => panic!()\n        }\n    }\n\n    #[test]\n    fn test_park_timeout_unpark_before() {\n        for _ in 0..10 {\n            thread::current().unpark();\n            thread::park_timeout(Duration::from_millis(u32::MAX as u64));\n        }\n    }\n\n    #[test]\n    fn test_park_timeout_unpark_not_called() {\n        for _ in 0..10 {\n            thread::park_timeout(Duration::from_millis(10));\n        }\n    }\n\n    #[test]\n    fn test_park_timeout_unpark_called_other_thread() {\n        for _ in 0..10 {\n            let th = thread::current();\n\n            let _guard = thread::spawn(move || {\n                super::sleep(Duration::from_millis(50));\n                th.unpark();\n            });\n\n            thread::park_timeout(Duration::from_millis(u32::MAX as u64));\n        }\n    }\n\n    #[test]\n    fn sleep_ms_smoke() {\n        thread::sleep(Duration::from_millis(2));\n    }\n\n    #[test]\n    fn test_thread_id_equal() {\n        assert!(thread::current().id() == thread::current().id());\n    }\n\n    #[test]\n    fn test_thread_id_not_equal() {\n        let spawned_id = thread::spawn(|| thread::current().id()).join().unwrap();\n        assert!(thread::current().id() != spawned_id);\n    }\n\n    // NOTE: the corresponding test for stderr is in run-pass/thread-stderr, due\n    // to the test harness apparently interfering with stderr configuration.\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse sys::mutex as imp;\n\n/// An OS-based mutual exclusion lock.\n///\n/// This is the thinnest cross-platform wrapper around OS mutexes. All usage of\n/// this mutex is unsafe and it is recommended to instead use the safe wrapper\n/// at the top level of the crate instead of this type.\npub struct Mutex(imp::Mutex);\n\nunsafe impl Sync for Mutex {}\n\nimpl Mutex {\n    /// Creates a new mutex for use.\n    ///\n    /// Behavior is undefined if the mutex is moved after it is\n    /// first used with any of the functions below.\n    pub const fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n\n    /// Prepare the mutex for use.\n    ///\n    /// This should be called once the mutex is at a stable memory address.\n    #[inline]\n    pub unsafe fn init(&mut self) { self.0.init() }\n\n    /// Locks the mutex blocking the current thread until it is available.\n    ///\n    /// Behavior is undefined if the mutex has been moved between this and any\n    /// previous function call.\n    #[inline]\n    pub unsafe fn lock(&self) { self.0.lock() }\n\n    /// Attempts to lock the mutex without blocking, returning whether it was\n    /// successfully acquired or not.\n    ///\n    /// Behavior is undefined if the mutex has been moved between this and any\n    /// previous function call.\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool { self.0.try_lock() }\n\n    /// Unlocks the mutex.\n    ///\n    /// Behavior is undefined if the current thread does not actually hold the\n    /// mutex.\n    #[inline]\n    pub unsafe fn unlock(&self) { self.0.unlock() }\n\n    /// Deallocates all resources associated with this mutex.\n    ///\n    /// Behavior is undefined if there are current or will be future users of\n    /// this mutex.\n    #[inline]\n    pub unsafe fn destroy(&self) { self.0.destroy() }\n}\n\n// not meant to be exported to the outside world, just the containing module\npub fn raw(mutex: &Mutex) -> &imp::Mutex { &mutex.0 }\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse time::Duration;\nuse sys_common::mutex::{self, Mutex};\nuse sys::condvar as imp;\n\n/// An OS-based condition variable.\n///\n/// This structure is the lowest layer possible on top of the OS-provided\n/// condition variables. It is consequently entirely unsafe to use. It is\n/// recommended to use the safer types at the top level of this crate instead of\n/// this type.\npub struct Condvar(imp::Condvar);\n\nimpl Condvar {\n    /// Creates a new condition variable for use.\n    ///\n    /// Behavior is undefined if the condition variable is moved after it is\n    /// first used with any of the functions below.\n    pub const fn new() -> Condvar { Condvar(imp::Condvar::new()) }\n\n    /// Prepares the condition variable for use.\n    ///\n    /// This should be called once the condition variable is at a stable memory\n    /// address.\n    #[inline]\n    pub unsafe fn init(&mut self) { self.0.init() }\n\n    /// Signals one waiter on this condition variable to wake up.\n    #[inline]\n    pub unsafe fn notify_one(&self) { self.0.notify_one() }\n\n    /// Awakens all current waiters on this condition variable.\n    #[inline]\n    pub unsafe fn notify_all(&self) { self.0.notify_all() }\n\n    /// Waits for a signal on the specified mutex.\n    ///\n    /// Behavior is undefined if the mutex is not locked by the current thread.\n    /// Behavior is also undefined if more than one mutex is used concurrently\n    /// on this condition variable.\n    #[inline]\n    pub unsafe fn wait(&self, mutex: &Mutex) { self.0.wait(mutex::raw(mutex)) }\n\n    /// Waits for a signal on the specified mutex with a timeout duration\n    /// specified by `dur` (a relative time into the future).\n    ///\n    /// Behavior is undefined if the mutex is not locked by the current thread.\n    /// Behavior is also undefined if more than one mutex is used concurrently\n    /// on this condition variable.\n    #[inline]\n    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n        self.0.wait_timeout(mutex::raw(mutex), dur)\n    }\n\n    /// Deallocates all resources associated with this condition variable.\n    ///\n    /// Behavior is undefined if there are current or will be future users of\n    /// this condition variable.\n    #[inline]\n    pub unsafe fn destroy(&self) { self.0.destroy() }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Exposes the NonZero lang item which provides optimization hints.\n#![unstable(feature = \"nonzero\",\n            reason = \"needs an RFC to flesh out the design\",\n            issue = \"27730\")]\n\nuse ops::CoerceUnsized;\n\n/// Unsafe trait to indicate what types are usable with the NonZero struct\npub unsafe trait Zeroable {}\n\nunsafe impl<T:?Sized> Zeroable for *const T {}\nunsafe impl<T:?Sized> Zeroable for *mut T {}\nunsafe impl Zeroable for isize {}\nunsafe impl Zeroable for usize {}\nunsafe impl Zeroable for i8 {}\nunsafe impl Zeroable for u8 {}\nunsafe impl Zeroable for i16 {}\nunsafe impl Zeroable for u16 {}\nunsafe impl Zeroable for i32 {}\nunsafe impl Zeroable for u32 {}\nunsafe impl Zeroable for i64 {}\nunsafe impl Zeroable for u64 {}\nunsafe impl Zeroable for i128 {}\nunsafe impl Zeroable for u128 {}\n\n/// A wrapper type for raw pointers and integers that will never be\n/// NULL or 0 that might allow certain optimizations.\n#[lang = \"non_zero\"]\n#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\npub struct NonZero<T: Zeroable>(T);\n\nimpl<T: Zeroable> NonZero<T> {\n    /// Creates an instance of NonZero with the provided value.\n    /// You must indeed ensure that the value is actually \"non-zero\".\n    #[inline(always)]\n    pub const unsafe fn new(inner: T) -> NonZero<T> {\n        NonZero(inner)\n    }\n\n    /// Gets the inner value.\n    pub fn get(self) -> T {\n        self.0\n    }\n}\n\nimpl<T: Zeroable+CoerceUnsized<U>, U: Zeroable> CoerceUnsized<NonZero<U>> for NonZero<T> {}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n//\n// Original implementation taken from rust-memchr\n// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n\npub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n    use libc;\n\n    let p = unsafe {\n        libc::memchr(\n            haystack.as_ptr() as *const libc::c_void,\n            needle as libc::c_int,\n            haystack.len())\n    };\n    if p.is_null() {\n        None\n    } else {\n        Some(p as usize - (haystack.as_ptr() as usize))\n    }\n}\n\npub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n\n    #[cfg(target_os = \"linux\")]\n    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n        use libc;\n\n        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n        if haystack.is_empty() {return None}\n        let p = unsafe {\n            libc::memrchr(\n                haystack.as_ptr() as *const libc::c_void,\n                needle as libc::c_int,\n                haystack.len())\n        };\n        if p.is_null() {\n            None\n        } else {\n            Some(p as usize - (haystack.as_ptr() as usize))\n        }\n    }\n\n    #[cfg(not(target_os = \"linux\"))]\n    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n        ::sys_common::memchr::fallback::memrchr(needle, haystack)\n    }\n\n    memrchr_specific(needle, haystack)\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse fmt::{self, FlagV1};\n\nstruct PadAdapter<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    on_newline: bool,\n}\n\nimpl<'a, 'b: 'a> PadAdapter<'a, 'b> {\n    fn new(fmt: &'a mut fmt::Formatter<'b>) -> PadAdapter<'a, 'b> {\n        PadAdapter {\n            fmt: fmt,\n            on_newline: false,\n        }\n    }\n}\n\nimpl<'a, 'b: 'a> fmt::Write for PadAdapter<'a, 'b> {\n    fn write_str(&mut self, mut s: &str) -> fmt::Result {\n        while !s.is_empty() {\n            if self.on_newline {\n                self.fmt.write_str(\"    \")?;\n            }\n\n            let split = match s.find('\\n') {\n                Some(pos) => {\n                    self.on_newline = true;\n                    pos + 1\n                }\n                None => {\n                    self.on_newline = false;\n                    s.len()\n                }\n            };\n            self.fmt.write_str(&s[..split])?;\n            s = &s[split..];\n        }\n\n        Ok(())\n    }\n}\n\n/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n///\n/// This is useful when you wish to output a formatted struct as a part of your\n/// [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n///\n/// This can be constructed by the\n/// [`Formatter::debug_struct`](struct.Formatter.html#method.debug_struct)\n/// method.\n///\n/// # Example\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo {\n///     bar: i32,\n///     baz: String,\n/// }\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_struct(\"Foo\")\n///            .field(\"bar\", &self.bar)\n///            .field(\"baz\", &self.baz)\n///            .finish()\n///     }\n/// }\n///\n/// // prints \"Foo { bar: 10, baz: \"Hello World\" }\"\n/// println!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() });\n/// ```\n#[must_use]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugStruct<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    result: fmt::Result,\n    has_fields: bool,\n}\n\npub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>,\n                                name: &str)\n                                -> DebugStruct<'a, 'b> {\n    let result = fmt.write_str(name);\n    DebugStruct {\n        fmt: fmt,\n        result: result,\n        has_fields: false,\n    }\n}\n\nimpl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n    /// Adds a new field to the generated struct output.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn field(&mut self, name: &str, value: &fmt::Debug) -> &mut DebugStruct<'a, 'b> {\n        self.result = self.result.and_then(|_| {\n            let prefix = if self.has_fields {\n                \",\"\n            } else {\n                \" {\"\n            };\n\n            if self.is_pretty() {\n                let mut writer = PadAdapter::new(self.fmt);\n                fmt::write(&mut writer,\n                           format_args!(\"{}\\n{}: {:#?}\", prefix, name, value))\n            } else {\n                write!(self.fmt, \"{} {}: {:?}\", prefix, name, value)\n            }\n        });\n\n        self.has_fields = true;\n        self\n    }\n\n    /// Finishes output and returns any error encountered.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn finish(&mut self) -> fmt::Result {\n        if self.has_fields {\n            self.result = self.result.and_then(|_| {\n                if self.is_pretty() {\n                    self.fmt.write_str(\"\\n}\")\n                } else {\n                    self.fmt.write_str(\" }\")\n                }\n            });\n        }\n        self.result\n    }\n\n    fn is_pretty(&self) -> bool {\n        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n    }\n}\n\n/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n///\n/// This is useful when you wish to output a formatted tuple as a part of your\n/// [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n///\n/// This can be constructed by the\n/// [`Formatter::debug_tuple`](struct.Formatter.html#method.debug_tuple)\n/// method.\n///\n/// # Example\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo(i32, String);\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_tuple(\"Foo\")\n///            .field(&self.0)\n///            .field(&self.1)\n///            .finish()\n///     }\n/// }\n///\n/// // prints \"Foo(10, \"Hello World\")\"\n/// println!(\"{:?}\", Foo(10, \"Hello World\".to_string()));\n/// ```\n#[must_use]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugTuple<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    result: fmt::Result,\n    fields: usize,\n    empty_name: bool,\n}\n\npub fn debug_tuple_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugTuple<'a, 'b> {\n    let result = fmt.write_str(name);\n    DebugTuple {\n        fmt: fmt,\n        result: result,\n        fields: 0,\n        empty_name: name.is_empty(),\n    }\n}\n\nimpl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n    /// Adds a new field to the generated tuple struct output.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn field(&mut self, value: &fmt::Debug) -> &mut DebugTuple<'a, 'b> {\n        self.result = self.result.and_then(|_| {\n            let (prefix, space) = if self.fields > 0 {\n                (\",\", \" \")\n            } else {\n                (\"(\", \"\")\n            };\n\n            if self.is_pretty() {\n                let mut writer = PadAdapter::new(self.fmt);\n                fmt::write(&mut writer, format_args!(\"{}\\n{:#?}\", prefix, value))\n            } else {\n                write!(self.fmt, \"{}{}{:?}\", prefix, space, value)\n            }\n        });\n\n        self.fields += 1;\n        self\n    }\n\n    /// Finishes output and returns any error encountered.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn finish(&mut self) -> fmt::Result {\n        if self.fields > 0 {\n            self.result = self.result.and_then(|_| {\n                if self.is_pretty() {\n                    self.fmt.write_str(\"\\n\")?;\n                }\n                if self.fields == 1 && self.empty_name {\n                    self.fmt.write_str(\",\")?;\n                }\n                self.fmt.write_str(\")\")\n            });\n        }\n        self.result\n    }\n\n    fn is_pretty(&self) -> bool {\n        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n    }\n}\n\nstruct DebugInner<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    result: fmt::Result,\n    has_fields: bool,\n}\n\nimpl<'a, 'b: 'a> DebugInner<'a, 'b> {\n    fn entry(&mut self, entry: &fmt::Debug) {\n        self.result = self.result.and_then(|_| {\n            if self.is_pretty() {\n                let mut writer = PadAdapter::new(self.fmt);\n                let prefix = if self.has_fields {\n                    \",\"\n                } else {\n                    \"\"\n                };\n                fmt::write(&mut writer, format_args!(\"{}\\n{:#?}\", prefix, entry))\n            } else {\n                let prefix = if self.has_fields {\n                    \", \"\n                } else {\n                    \"\"\n                };\n                write!(self.fmt, \"{}{:?}\", prefix, entry)\n            }\n        });\n\n        self.has_fields = true;\n    }\n\n    pub fn finish(&mut self) {\n        let prefix = if self.is_pretty() && self.has_fields {\n            \"\\n\"\n        } else {\n            \"\"\n        };\n        self.result = self.result.and_then(|_| self.fmt.write_str(prefix));\n    }\n\n    fn is_pretty(&self) -> bool {\n        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n    }\n}\n\n/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n///\n/// This is useful when you wish to output a formatted set of items as a part\n/// of your [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n///\n/// This can be constructed by the\n/// [`Formatter::debug_set`](struct.Formatter.html#method.debug_set)\n/// method.\n///\n/// # Example\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo(Vec<i32>);\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_set().entries(self.0.iter()).finish()\n///     }\n/// }\n///\n/// // prints \"{10, 11}\"\n/// println!(\"{:?}\", Foo(vec![10, 11]));\n/// ```\n#[must_use]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugSet<'a, 'b: 'a> {\n    inner: DebugInner<'a, 'b>,\n}\n\npub fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b> {\n    let result = write!(fmt, \"{{\");\n    DebugSet {\n        inner: DebugInner {\n            fmt: fmt,\n            result: result,\n            has_fields: false,\n        },\n    }\n}\n\nimpl<'a, 'b: 'a> DebugSet<'a, 'b> {\n    /// Adds a new entry to the set output.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entry(&mut self, entry: &fmt::Debug) -> &mut DebugSet<'a, 'b> {\n        self.inner.entry(entry);\n        self\n    }\n\n    /// Adds the contents of an iterator of entries to the set output.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugSet<'a, 'b>\n        where D: fmt::Debug,\n              I: IntoIterator<Item = D>\n    {\n        for entry in entries {\n            self.entry(&entry);\n        }\n        self\n    }\n\n    /// Finishes output and returns any error encountered.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn finish(&mut self) -> fmt::Result {\n        self.inner.finish();\n        self.inner.result.and_then(|_| self.inner.fmt.write_str(\"}\"))\n    }\n}\n\n/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n///\n/// This is useful when you wish to output a formatted list of items as a part\n/// of your [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n///\n/// This can be constructed by the\n/// [`Formatter::debug_list`](struct.Formatter.html#method.debug_list)\n/// method.\n///\n/// # Example\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo(Vec<i32>);\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_list().entries(self.0.iter()).finish()\n///     }\n/// }\n///\n/// // prints \"[10, 11]\"\n/// println!(\"{:?}\", Foo(vec![10, 11]));\n/// ```\n#[must_use]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugList<'a, 'b: 'a> {\n    inner: DebugInner<'a, 'b>,\n}\n\npub fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a, 'b> {\n    let result = write!(fmt, \"[\");\n    DebugList {\n        inner: DebugInner {\n            fmt: fmt,\n            result: result,\n            has_fields: false,\n        },\n    }\n}\n\nimpl<'a, 'b: 'a> DebugList<'a, 'b> {\n    /// Adds a new entry to the list output.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entry(&mut self, entry: &fmt::Debug) -> &mut DebugList<'a, 'b> {\n        self.inner.entry(entry);\n        self\n    }\n\n    /// Adds the contents of an iterator of entries to the list output.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugList<'a, 'b>\n        where D: fmt::Debug,\n              I: IntoIterator<Item = D>\n    {\n        for entry in entries {\n            self.entry(&entry);\n        }\n        self\n    }\n\n    /// Finishes output and returns any error encountered.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn finish(&mut self) -> fmt::Result {\n        self.inner.finish();\n        self.inner.result.and_then(|_| self.inner.fmt.write_str(\"]\"))\n    }\n}\n\n/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n///\n/// This is useful when you wish to output a formatted map as a part of your\n/// [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n///\n/// This can be constructed by the\n/// [`Formatter::debug_map`](struct.Formatter.html#method.debug_map)\n/// method.\n///\n/// # Example\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo(Vec<(String, i32)>);\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref v)| (k, v))).finish()\n///     }\n/// }\n///\n/// // prints \"{\"A\": 10, \"B\": 11}\"\n/// println!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)]));\n/// ```\n#[must_use]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugMap<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    result: fmt::Result,\n    has_fields: bool,\n}\n\npub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> {\n    let result = write!(fmt, \"{{\");\n    DebugMap {\n        fmt: fmt,\n        result: result,\n        has_fields: false,\n    }\n}\n\nimpl<'a, 'b: 'a> DebugMap<'a, 'b> {\n    /// Adds a new entry to the map output.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entry(&mut self, key: &fmt::Debug, value: &fmt::Debug) -> &mut DebugMap<'a, 'b> {\n        self.result = self.result.and_then(|_| {\n            if self.is_pretty() {\n                let mut writer = PadAdapter::new(self.fmt);\n                let prefix = if self.has_fields {\n                    \",\"\n                } else {\n                    \"\"\n                };\n                fmt::write(&mut writer,\n                           format_args!(\"{}\\n{:#?}: {:#?}\", prefix, key, value))\n            } else {\n                let prefix = if self.has_fields {\n                    \", \"\n                } else {\n                    \"\"\n                };\n                write!(self.fmt, \"{}{:?}: {:?}\", prefix, key, value)\n            }\n        });\n\n        self.has_fields = true;\n        self\n    }\n\n    /// Adds the contents of an iterator of entries to the map output.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entries<K, V, I>(&mut self, entries: I) -> &mut DebugMap<'a, 'b>\n        where K: fmt::Debug,\n              V: fmt::Debug,\n              I: IntoIterator<Item = (K, V)>\n    {\n        for (k, v) in entries {\n            self.entry(&k, &v);\n        }\n        self\n    }\n\n    /// Finishes output and returns any error encountered.\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn finish(&mut self) -> fmt::Result {\n        let prefix = if self.is_pretty() && self.has_fields {\n            \"\\n\"\n        } else {\n            \"\"\n        };\n        self.result.and_then(|_| write!(self.fmt, \"{}}}\", prefix))\n    }\n\n    fn is_pretty(&self) -> bool {\n        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n    }\n}\n","(unknown)","(unknown)","// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! The `Clone` trait for types that cannot be 'implicitly copied'.\n//!\n//! In Rust, some simple types are \"implicitly copyable\" and when you\n//! assign them or pass them as arguments, the receiver will get a copy,\n//! leaving the original value in place. These types do not require\n//! allocation to copy and do not have finalizers (i.e. they do not\n//! contain owned boxes or implement [`Drop`]), so the compiler considers\n//! them cheap and safe to copy. For other types copies must be made\n//! explicitly, by convention implementing the [`Clone`] trait and calling\n//! the [`clone`][clone] method.\n//!\n//! [`Clone`]: trait.Clone.html\n//! [clone]: trait.Clone.html#tymethod.clone\n//! [`Drop`]: ../../std/ops/trait.Drop.html\n//!\n//! Basic usage example:\n//!\n//! ```\n//! let s = String::new(); // String type implements Clone\n//! let copy = s.clone(); // so we can clone it\n//! ```\n//!\n//! To easily implement the Clone trait, you can also use\n//! `#[derive(Clone)]`. Example:\n//!\n//! ```\n//! #[derive(Clone)] // we add the Clone trait to Morpheus struct\n//! struct Morpheus {\n//!    blue_pill: f32,\n//!    red_pill: i64,\n//! }\n//!\n//! fn main() {\n//!    let f = Morpheus { blue_pill: 0.0, red_pill: 0 };\n//!    let copy = f.clone(); // and now we can clone it!\n//! }\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n/// A common trait for the ability to explicitly duplicate an object.\n///\n/// Differs from [`Copy`] in that [`Copy`] is implicit and extremely inexpensive, while\n/// `Clone` is always explicit and may or may not be expensive. In order to enforce\n/// these characteristics, Rust does not allow you to reimplement [`Copy`], but you\n/// may reimplement `Clone` and run arbitrary code.\n///\n/// Since `Clone` is more general than [`Copy`], you can automatically make anything\n/// [`Copy`] be `Clone` as well.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d\n/// implementation of [`clone`] calls [`clone`] on each field.\n///\n/// ## How can I implement `Clone`?\n///\n/// Types that are [`Copy`] should have a trivial implementation of `Clone`. More formally:\n/// if `T: Copy`, `x: T`, and `y: &T`, then `let x = y.clone();` is equivalent to `let x = *y;`.\n/// Manual implementations should be careful to uphold this invariant; however, unsafe code\n/// must not rely on it to ensure memory safety.\n///\n/// An example is an array holding more than 32 elements of a type that is `Clone`; the standard\n/// library only implements `Clone` up until arrays of size 32. In this case, the implementation of\n/// `Clone` cannot be `derive`d, but can be implemented as:\n///\n/// [`Copy`]: ../../std/marker/trait.Copy.html\n/// [`clone`]: trait.Clone.html#tymethod.clone\n///\n/// ```\n/// #[derive(Copy)]\n/// struct Stats {\n///    frequencies: [i32; 100],\n/// }\n///\n/// impl Clone for Stats {\n///     fn clone(&self) -> Stats { *self }\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Clone : Sized {\n    /// Returns a copy of the value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let hello = \"Hello\"; // &str implements Clone\n    ///\n    /// assert_eq!(\"Hello\", hello.clone());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn clone(&self) -> Self;\n\n    /// Performs copy-assignment from `source`.\n    ///\n    /// `a.clone_from(&b)` is equivalent to `a = b.clone()` in functionality,\n    /// but can be overridden to reuse the resources of `a` to avoid unnecessary\n    /// allocations.\n    #[inline(always)]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn clone_from(&mut self, source: &Self) {\n        *self = source.clone()\n    }\n}\n\n// FIXME(aburka): these structs are used solely by #[derive] to\n// assert that every component of a type implements Clone or Copy.\n//\n// These structs should never appear in user code.\n#[doc(hidden)]\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"derive_clone_copy\",\n           reason = \"deriving hack, should not be public\",\n           issue = \"0\")]\npub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData<T> }\n#[doc(hidden)]\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"derive_clone_copy\",\n           reason = \"deriving hack, should not be public\",\n           issue = \"0\")]\npub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized> Clone for &'a T {\n    /// Returns a shallow copy of the reference.\n    #[inline]\n    fn clone(&self) -> &'a T { *self }\n}\n\nmacro_rules! clone_impl {\n    ($t:ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Clone for $t {\n            /// Returns a deep copy of the value.\n            #[inline]\n            fn clone(&self) -> $t { *self }\n        }\n    }\n}\n\nclone_impl! { isize }\nclone_impl! { i8 }\nclone_impl! { i16 }\nclone_impl! { i32 }\nclone_impl! { i64 }\nclone_impl! { i128 }\n\nclone_impl! { usize }\nclone_impl! { u8 }\nclone_impl! { u16 }\nclone_impl! { u32 }\nclone_impl! { u64 }\nclone_impl! { u128 }\n\nclone_impl! { f32 }\nclone_impl! { f64 }\n\nclone_impl! { () }\nclone_impl! { bool }\nclone_impl! { char }\n","// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A dynamically-sized view into a contiguous sequence, `[T]`.\n//!\n//! Slices are a view into a block of memory represented as a pointer and a\n//! length.\n//!\n//! ```\n//! // slicing a Vec\n//! let vec = vec![1, 2, 3];\n//! let int_slice = &vec[..];\n//! // coercing an array to a slice\n//! let str_slice: &[&str] = &[\"one\", \"two\", \"three\"];\n//! ```\n//!\n//! Slices are either mutable or shared. The shared slice type is `&[T]`,\n//! while the mutable slice type is `&mut [T]`, where `T` represents the element\n//! type. For example, you can mutate the block of memory that a mutable slice\n//! points to:\n//!\n//! ```\n//! let x = &mut [1, 2, 3];\n//! x[1] = 7;\n//! assert_eq!(x, &[1, 7, 3]);\n//! ```\n//!\n//! Here are some of the things this module contains:\n//!\n//! ## Structs\n//!\n//! There are several structs that are useful for slices, such as [`Iter`], which\n//! represents iteration over a slice.\n//!\n//! ## Trait Implementations\n//!\n//! There are several implementations of common traits for slices. Some examples\n//! include:\n//!\n//! * [`Clone`]\n//! * [`Eq`], [`Ord`] - for slices whose element type are [`Eq`] or [`Ord`].\n//! * [`Hash`] - for slices whose element type is [`Hash`].\n//!\n//! ## Iteration\n//!\n//! The slices implement `IntoIterator`. The iterator yields references to the\n//! slice elements.\n//!\n//! ```\n//! let numbers = &[0, 1, 2];\n//! for n in numbers {\n//!     println!(\"{} is a number!\", n);\n//! }\n//! ```\n//!\n//! The mutable slice yields mutable references to the elements:\n//!\n//! ```\n//! let mut scores = [7, 8, 9];\n//! for score in &mut scores[..] {\n//!     *score += 1;\n//! }\n//! ```\n//!\n//! This iterator yields mutable references to the slice's elements, so while\n//! the element type of the slice is `i32`, the element type of the iterator is\n//! `&mut i32`.\n//!\n//! * [`.iter`] and [`.iter_mut`] are the explicit methods to return the default\n//!   iterators.\n//! * Further methods that return iterators are [`.split`], [`.splitn`],\n//!   [`.chunks`], [`.windows`] and more.\n//!\n//! *[See also the slice primitive type](../../std/primitive.slice.html).*\n//!\n//! [`Clone`]: ../../std/clone/trait.Clone.html\n//! [`Eq`]: ../../std/cmp/trait.Eq.html\n//! [`Ord`]: ../../std/cmp/trait.Ord.html\n//! [`Iter`]: struct.Iter.html\n//! [`Hash`]: ../../std/hash/trait.Hash.html\n//! [`.iter`]: ../../std/primitive.slice.html#method.iter\n//! [`.iter_mut`]: ../../std/primitive.slice.html#method.iter_mut\n//! [`.split`]: ../../std/primitive.slice.html#method.split\n//! [`.splitn`]: ../../std/primitive.slice.html#method.splitn\n//! [`.chunks`]: ../../std/primitive.slice.html#method.chunks\n//! [`.windows`]: ../../std/primitive.slice.html#method.windows\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n// Many of the usings in this module are only used in the test configuration.\n// It's cleaner to just turn off the unused_imports warning than to fix them.\n#![cfg_attr(test, allow(unused_imports, dead_code))]\n\nuse core::cmp::Ordering::{self, Less};\nuse core::mem::size_of;\nuse core::mem;\nuse core::ptr;\nuse core::slice as core_slice;\n\nuse borrow::{Borrow, BorrowMut, ToOwned};\nuse boxed::Box;\nuse vec::Vec;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{Chunks, Windows};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{Iter, IterMut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{SplitMut, ChunksMut, Split};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\npub use core::slice::{RSplit, RSplitMut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{from_raw_parts, from_raw_parts_mut};\n#[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\npub use core::slice::SliceIndex;\n\n////////////////////////////////////////////////////////////////////////////////\n// Basic slice extension methods\n////////////////////////////////////////////////////////////////////////////////\n\n// HACK(japaric) needed for the implementation of `vec!` macro during testing\n// NB see the hack module in this file for more details\n#[cfg(test)]\npub use self::hack::into_vec;\n\n// HACK(japaric) needed for the implementation of `Vec::clone` during testing\n// NB see the hack module in this file for more details\n#[cfg(test)]\npub use self::hack::to_vec;\n\n// HACK(japaric): With cfg(test) `impl [T]` is not available, these three\n// functions are actually methods that are in `impl [T]` but not in\n// `core::slice::SliceExt` - we need to supply these functions for the\n// `test_permutations` test\nmod hack {\n    use boxed::Box;\n    use core::mem;\n\n    #[cfg(test)]\n    use string::ToString;\n    use vec::Vec;\n\n    pub fn into_vec<T>(mut b: Box<[T]>) -> Vec<T> {\n        unsafe {\n            let xs = Vec::from_raw_parts(b.as_mut_ptr(), b.len(), b.len());\n            mem::forget(b);\n            xs\n        }\n    }\n\n    #[inline]\n    pub fn to_vec<T>(s: &[T]) -> Vec<T>\n        where T: Clone\n    {\n        let mut vector = Vec::with_capacity(s.len());\n        vector.extend_from_slice(s);\n        vector\n    }\n}\n\n#[lang = \"slice\"]\n#[cfg(not(test))]\nimpl<T> [T] {\n    /// Returns the number of elements in the slice.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert_eq!(a.len(), 3);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn len(&self) -> usize {\n        core_slice::SliceExt::len(self)\n    }\n\n    /// Returns `true` if the slice has a length of 0.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert!(!a.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        core_slice::SliceExt::is_empty(self)\n    }\n\n    /// Returns the first element of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert_eq!(Some(&10), v.first());\n    ///\n    /// let w: &[i32] = &[];\n    /// assert_eq!(None, w.first());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn first(&self) -> Option<&T> {\n        core_slice::SliceExt::first(self)\n    }\n\n    /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some(first) = x.first_mut() {\n    ///     *first = 5;\n    /// }\n    /// assert_eq!(x, &[5, 1, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn first_mut(&mut self) -> Option<&mut T> {\n        core_slice::SliceExt::first_mut(self)\n    }\n\n    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[0, 1, 2];\n    ///\n    /// if let Some((first, elements)) = x.split_first() {\n    ///     assert_eq!(first, &0);\n    ///     assert_eq!(elements, &[1, 2]);\n    /// }\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[inline]\n    pub fn split_first(&self) -> Option<(&T, &[T])> {\n        core_slice::SliceExt::split_first(self)\n    }\n\n    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some((first, elements)) = x.split_first_mut() {\n    ///     *first = 3;\n    ///     elements[0] = 4;\n    ///     elements[1] = 5;\n    /// }\n    /// assert_eq!(x, &[3, 4, 5]);\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[inline]\n    pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n        core_slice::SliceExt::split_first_mut(self)\n    }\n\n    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[0, 1, 2];\n    ///\n    /// if let Some((last, elements)) = x.split_last() {\n    ///     assert_eq!(last, &2);\n    ///     assert_eq!(elements, &[0, 1]);\n    /// }\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[inline]\n    pub fn split_last(&self) -> Option<(&T, &[T])> {\n        core_slice::SliceExt::split_last(self)\n\n    }\n\n    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some((last, elements)) = x.split_last_mut() {\n    ///     *last = 3;\n    ///     elements[0] = 4;\n    ///     elements[1] = 5;\n    /// }\n    /// assert_eq!(x, &[4, 5, 3]);\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[inline]\n    pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n        core_slice::SliceExt::split_last_mut(self)\n    }\n\n    /// Returns the last element of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert_eq!(Some(&30), v.last());\n    ///\n    /// let w: &[i32] = &[];\n    /// assert_eq!(None, w.last());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn last(&self) -> Option<&T> {\n        core_slice::SliceExt::last(self)\n    }\n\n    /// Returns a mutable pointer to the last item in the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some(last) = x.last_mut() {\n    ///     *last = 10;\n    /// }\n    /// assert_eq!(x, &[0, 1, 10]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn last_mut(&mut self) -> Option<&mut T> {\n        core_slice::SliceExt::last_mut(self)\n    }\n\n    /// Returns a reference to an element or subslice depending on the type of\n    /// index.\n    ///\n    /// - If given a position, returns a reference to the element at that\n    ///   position or `None` if out of bounds.\n    /// - If given a range, returns the subslice corresponding to that range,\n    ///   or `None` if out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert_eq!(Some(&40), v.get(1));\n    /// assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n    /// assert_eq!(None, v.get(3));\n    /// assert_eq!(None, v.get(0..4));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn get<I>(&self, index: I) -> Option<&I::Output>\n        where I: SliceIndex<Self>\n    {\n        core_slice::SliceExt::get(self, index)\n    }\n\n    /// Returns a mutable reference to an element or subslice depending on the\n    /// type of index (see [`get`]) or `None` if the index is out of bounds.\n    ///\n    /// [`get`]: #method.get\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some(elem) = x.get_mut(1) {\n    ///     *elem = 42;\n    /// }\n    /// assert_eq!(x, &[0, 42, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n        where I: SliceIndex<Self>\n    {\n        core_slice::SliceExt::get_mut(self, index)\n    }\n\n    /// Returns a reference to an element or subslice, without doing bounds\n    /// checking.\n    ///\n    /// This is generally not recommended, use with caution! For a safe\n    /// alternative see [`get`].\n    ///\n    /// [`get`]: #method.get\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[1, 2, 4];\n    ///\n    /// unsafe {\n    ///     assert_eq!(x.get_unchecked(1), &2);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n        where I: SliceIndex<Self>\n    {\n        core_slice::SliceExt::get_unchecked(self, index)\n    }\n\n    /// Returns a mutable reference to an element or subslice, without doing\n    /// bounds checking.\n    ///\n    /// This is generally not recommended, use with caution! For a safe\n    /// alternative see [`get_mut`].\n    ///\n    /// [`get_mut`]: #method.get_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [1, 2, 4];\n    ///\n    /// unsafe {\n    ///     let elem = x.get_unchecked_mut(1);\n    ///     *elem = 13;\n    /// }\n    /// assert_eq!(x, &[1, 13, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n        where I: SliceIndex<Self>\n    {\n        core_slice::SliceExt::get_unchecked_mut(self, index)\n    }\n\n    /// Returns a raw pointer to the slice's buffer.\n    ///\n    /// The caller must ensure that the slice outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    ///\n    /// Modifying the container referenced by this slice may cause its buffer\n    /// to be reallocated, which would also make any pointers to it invalid.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[1, 2, 4];\n    /// let x_ptr = x.as_ptr();\n    ///\n    /// unsafe {\n    ///     for i in 0..x.len() {\n    ///         assert_eq!(x.get_unchecked(i), &*x_ptr.offset(i as isize));\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn as_ptr(&self) -> *const T {\n        core_slice::SliceExt::as_ptr(self)\n    }\n\n    /// Returns an unsafe mutable pointer to the slice's buffer.\n    ///\n    /// The caller must ensure that the slice outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    ///\n    /// Modifying the container referenced by this slice may cause its buffer\n    /// to be reallocated, which would also make any pointers to it invalid.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [1, 2, 4];\n    /// let x_ptr = x.as_mut_ptr();\n    ///\n    /// unsafe {\n    ///     for i in 0..x.len() {\n    ///         *x_ptr.offset(i as isize) += 2;\n    ///     }\n    /// }\n    /// assert_eq!(x, &[3, 4, 6]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn as_mut_ptr(&mut self) -> *mut T {\n        core_slice::SliceExt::as_mut_ptr(self)\n    }\n\n    /// Swaps two elements in the slice.\n    ///\n    /// # Arguments\n    ///\n    /// * a - The index of the first element\n    /// * b - The index of the second element\n    ///\n    /// # Panics\n    ///\n    /// Panics if `a` or `b` are out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n    /// v.swap(1, 3);\n    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn swap(&mut self, a: usize, b: usize) {\n        core_slice::SliceExt::swap(self, a, b)\n    }\n\n    /// Reverses the order of elements in the slice, in place.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let mut v = [1, 2, 3];\n    /// v.reverse();\n    /// assert!(v == [3, 2, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn reverse(&mut self) {\n        core_slice::SliceExt::reverse(self)\n    }\n\n    /// Returns an iterator over the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[1, 2, 4];\n    /// let mut iterator = x.iter();\n    ///\n    /// assert_eq!(iterator.next(), Some(&1));\n    /// assert_eq!(iterator.next(), Some(&2));\n    /// assert_eq!(iterator.next(), Some(&4));\n    /// assert_eq!(iterator.next(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn iter(&self) -> Iter<T> {\n        core_slice::SliceExt::iter(self)\n    }\n\n    /// Returns an iterator that allows modifying each value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [1, 2, 4];\n    /// for elem in x.iter_mut() {\n    ///     *elem += 2;\n    /// }\n    /// assert_eq!(x, &[3, 4, 6]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        core_slice::SliceExt::iter_mut(self)\n    }\n\n    /// Returns an iterator over all contiguous windows of length\n    /// `size`. The windows overlap. If the slice is shorter than\n    /// `size`, the iterator returns no values.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `size` is 0.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let slice = ['r', 'u', 's', 't'];\n    /// let mut iter = slice.windows(2);\n    /// assert_eq!(iter.next().unwrap(), &['r', 'u']);\n    /// assert_eq!(iter.next().unwrap(), &['u', 's']);\n    /// assert_eq!(iter.next().unwrap(), &['s', 't']);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If the slice is shorter than `size`:\n    ///\n    /// ```\n    /// let slice = ['f', 'o', 'o'];\n    /// let mut iter = slice.windows(4);\n    /// assert!(iter.next().is_none());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn windows(&self, size: usize) -> Windows<T> {\n        core_slice::SliceExt::windows(self, size)\n    }\n\n    /// Returns an iterator over `size` elements of the slice at a\n    /// time. The chunks are slices and do not overlap. If `size` does\n    /// not divide the length of the slice, then the last chunk will\n    /// not have length `size`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `size` is 0.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let mut iter = slice.chunks(2);\n    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n    /// assert_eq!(iter.next().unwrap(), &['m']);\n    /// assert!(iter.next().is_none());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn chunks(&self, size: usize) -> Chunks<T> {\n        core_slice::SliceExt::chunks(self, size)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n    /// not divide the length of the slice, then the last chunk will not\n    /// have length `chunk_size`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// for chunk in v.chunks_mut(2) {\n    ///     for elem in chunk.iter_mut() {\n    ///         *elem += count;\n    ///     }\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n        core_slice::SliceExt::chunks_mut(self, chunk_size)\n    }\n\n    /// Divides one slice into two at an index.\n    ///\n    /// The first will contain all indices from `[0, mid)` (excluding\n    /// the index `mid` itself) and the second will contain all\n    /// indices from `[mid, len)` (excluding the index `len` itself).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `mid > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30, 20, 50];\n    /// let (v1, v2) = v.split_at(2);\n    /// assert_eq!([10, 40], v1);\n    /// assert_eq!([30, 20, 50], v2);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        core_slice::SliceExt::split_at(self, mid)\n    }\n\n    /// Divides one `&mut` into two at an index.\n    ///\n    /// The first will contain all indices from `[0, mid)` (excluding\n    /// the index `mid` itself) and the second will contain all\n    /// indices from `[mid, len)` (excluding the index `len` itself).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `mid > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [1, 2, 3, 4, 5, 6];\n    ///\n    /// // scoped to restrict the lifetime of the borrows\n    /// {\n    ///    let (left, right) = v.split_at_mut(0);\n    ///    assert!(left == []);\n    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n    /// }\n    ///\n    /// {\n    ///     let (left, right) = v.split_at_mut(2);\n    ///     assert!(left == [1, 2]);\n    ///     assert!(right == [3, 4, 5, 6]);\n    /// }\n    ///\n    /// {\n    ///     let (left, right) = v.split_at_mut(6);\n    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n    ///     assert!(right == []);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n        core_slice::SliceExt::split_at_mut(self, mid)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`. The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = [10, 40, 33, 20];\n    /// let mut iter = slice.split(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n    /// assert_eq!(iter.next().unwrap(), &[20]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If the first element is matched, an empty slice will be the first item\n    /// returned by the iterator. Similarly, if the last element in the slice\n    /// is matched, an empty slice will be the last item returned by the\n    /// iterator:\n    ///\n    /// ```\n    /// let slice = [10, 40, 33];\n    /// let mut iter = slice.split(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n    /// assert_eq!(iter.next().unwrap(), &[]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If two matched elements are directly adjacent, an empty slice will be\n    /// present between them:\n    ///\n    /// ```\n    /// let slice = [10, 6, 33, 20];\n    /// let mut iter = slice.split(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10]);\n    /// assert_eq!(iter.next().unwrap(), &[]);\n    /// assert_eq!(iter.next().unwrap(), &[20]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split<F>(&self, pred: F) -> Split<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::split(self, pred)\n    }\n\n    /// Returns an iterator over mutable subslices separated by elements that\n    /// match `pred`. The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.split_mut(|num| *num % 3 == 0) {\n    ///     group[0] = 1;\n    /// }\n    /// assert_eq!(v, [1, 40, 30, 1, 60, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::split_mut(self, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`, starting at the end of the slice and working backwards.\n    /// The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_rsplit)]\n    ///\n    /// let slice = [11, 22, 33, 0, 44, 55];\n    /// let mut iter = slice.rsplit(|num| *num == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[44, 55]);\n    /// assert_eq!(iter.next().unwrap(), &[11, 22, 33]);\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// As with `split()`, if the first or last element is matched, an empty\n    /// slice will be the first (or last) item returned by the iterator.\n    ///\n    /// ```\n    /// #![feature(slice_rsplit)]\n    ///\n    /// let v = &[0, 1, 1, 2, 3, 5, 8];\n    /// let mut it = v.rsplit(|n| *n % 2 == 0);\n    /// assert_eq!(it.next().unwrap(), &[]);\n    /// assert_eq!(it.next().unwrap(), &[3, 5]);\n    /// assert_eq!(it.next().unwrap(), &[1, 1]);\n    /// assert_eq!(it.next().unwrap(), &[]);\n    /// assert_eq!(it.next(), None);\n    /// ```\n    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n    #[inline]\n    pub fn rsplit<F>(&self, pred: F) -> RSplit<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::rsplit(self, pred)\n    }\n\n    /// Returns an iterator over mutable subslices separated by elements that\n    /// match `pred`, starting at the end of the slice and working\n    /// backwards. The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_rsplit)]\n    ///\n    /// let mut v = [100, 400, 300, 200, 600, 500];\n    ///\n    /// let mut count = 0;\n    /// for group in v.rsplit_mut(|num| *num % 3 == 0) {\n    ///     count += 1;\n    ///     group[0] = count;\n    /// }\n    /// assert_eq!(v, [3, 400, 300, 2, 600, 1]);\n    /// ```\n    ///\n    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n    #[inline]\n    pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::rsplit_mut(self, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`, limited to returning at most `n` items. The matched element is\n    /// not contained in the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n    /// `[20, 60, 50]`):\n    ///\n    /// ```\n    /// let v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.splitn(2, |num| *num % 3 == 0) {\n    ///     println!(\"{:?}\", group);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::splitn(self, n, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`, limited to returning at most `n` items. The matched element is\n    /// not contained in the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.splitn_mut(2, |num| *num % 3 == 0) {\n    ///     group[0] = 1;\n    /// }\n    /// assert_eq!(v, [1, 40, 30, 1, 60, 50]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::splitn_mut(self, n, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred` limited to returning at most `n` items. This starts at the end of\n    /// the slice and works backwards.  The matched element is not contained in\n    /// the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// Print the slice split once, starting from the end, by numbers divisible\n    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n    ///\n    /// ```\n    /// let v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n    ///     println!(\"{:?}\", group);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::rsplitn(self, n, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred` limited to returning at most `n` items. This starts at the end of\n    /// the slice and works backwards. The matched element is not contained in\n    /// the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut s = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in s.rsplitn_mut(2, |num| *num % 3 == 0) {\n    ///     group[0] = 1;\n    /// }\n    /// assert_eq!(s, [1, 40, 30, 20, 60, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n    }\n\n    /// Returns `true` if the slice contains an element with the given value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert!(v.contains(&30));\n    /// assert!(!v.contains(&50));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn contains(&self, x: &T) -> bool\n        where T: PartialEq\n    {\n        core_slice::SliceExt::contains(self, x)\n    }\n\n    /// Returns `true` if `needle` is a prefix of the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert!(v.starts_with(&[10]));\n    /// assert!(v.starts_with(&[10, 40]));\n    /// assert!(!v.starts_with(&[50]));\n    /// assert!(!v.starts_with(&[10, 50]));\n    /// ```\n    ///\n    /// Always returns `true` if `needle` is an empty slice:\n    ///\n    /// ```\n    /// let v = &[10, 40, 30];\n    /// assert!(v.starts_with(&[]));\n    /// let v: &[u8] = &[];\n    /// assert!(v.starts_with(&[]));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn starts_with(&self, needle: &[T]) -> bool\n        where T: PartialEq\n    {\n        core_slice::SliceExt::starts_with(self, needle)\n    }\n\n    /// Returns `true` if `needle` is a suffix of the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert!(v.ends_with(&[30]));\n    /// assert!(v.ends_with(&[40, 30]));\n    /// assert!(!v.ends_with(&[50]));\n    /// assert!(!v.ends_with(&[50, 30]));\n    /// ```\n    ///\n    /// Always returns `true` if `needle` is an empty slice:\n    ///\n    /// ```\n    /// let v = &[10, 40, 30];\n    /// assert!(v.ends_with(&[]));\n    /// let v: &[u8] = &[];\n    /// assert!(v.ends_with(&[]));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ends_with(&self, needle: &[T]) -> bool\n        where T: PartialEq\n    {\n        core_slice::SliceExt::ends_with(self, needle)\n    }\n\n    /// Binary searches this sorted slice for a given element.\n    ///\n    /// If the value is found then `Ok` is returned, containing the\n    /// index of the matching element; if the value is not found then\n    /// `Err` is returned, containing the index where a matching\n    /// element could be inserted while maintaining sorted order.\n    ///\n    /// # Example\n    ///\n    /// Looks up a series of four elements. The first is found, with a\n    /// uniquely determined position; the second and third are not\n    /// found; the fourth could match any position in `[1, 4]`.\n    ///\n    /// ```\n    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n    ///\n    /// assert_eq!(s.binary_search(&13),  Ok(9));\n    /// assert_eq!(s.binary_search(&4),   Err(7));\n    /// assert_eq!(s.binary_search(&100), Err(13));\n    /// let r = s.binary_search(&1);\n    /// assert!(match r { Ok(1...4) => true, _ => false, });\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n        where T: Ord\n    {\n        core_slice::SliceExt::binary_search(self, x)\n    }\n\n    /// Binary searches this sorted slice with a comparator function.\n    ///\n    /// The comparator function should implement an order consistent\n    /// with the sort order of the underlying slice, returning an\n    /// order code that indicates whether its argument is `Less`,\n    /// `Equal` or `Greater` the desired target.\n    ///\n    /// If a matching value is found then returns `Ok`, containing\n    /// the index for the matched element; if no match is found then\n    /// `Err` is returned, containing the index where a matching\n    /// element could be inserted while maintaining sorted order.\n    ///\n    /// # Example\n    ///\n    /// Looks up a series of four elements. The first is found, with a\n    /// uniquely determined position; the second and third are not\n    /// found; the fourth could match any position in `[1, 4]`.\n    ///\n    /// ```\n    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n    ///\n    /// let seek = 13;\n    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n    /// let seek = 4;\n    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n    /// let seek = 100;\n    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n    /// let seek = 1;\n    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n    /// assert!(match r { Ok(1...4) => true, _ => false, });\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n        where F: FnMut(&'a T) -> Ordering\n    {\n        core_slice::SliceExt::binary_search_by(self, f)\n    }\n\n    /// Binary searches this sorted slice with a key extraction function.\n    ///\n    /// Assumes that the slice is sorted by the key, for instance with\n    /// [`sort_by_key`] using the same key extraction function.\n    ///\n    /// If a matching value is found then returns `Ok`, containing the\n    /// index for the matched element; if no match is found then `Err`\n    /// is returned, containing the index where a matching element could\n    /// be inserted while maintaining sorted order.\n    ///\n    /// [`sort_by_key`]: #method.sort_by_key\n    ///\n    /// # Examples\n    ///\n    /// Looks up a series of four elements in a slice of pairs sorted by\n    /// their second elements. The first is found, with a uniquely\n    /// determined position; the second and third are not found; the\n    /// fourth could match any position in `[1, 4]`.\n    ///\n    /// ```\n    /// let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n    ///          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n    ///          (1, 21), (2, 34), (4, 55)];\n    ///\n    /// assert_eq!(s.binary_search_by_key(&13, |&(a,b)| b),  Ok(9));\n    /// assert_eq!(s.binary_search_by_key(&4, |&(a,b)| b),   Err(7));\n    /// assert_eq!(s.binary_search_by_key(&100, |&(a,b)| b), Err(13));\n    /// let r = s.binary_search_by_key(&1, |&(a,b)| b);\n    /// assert!(match r { Ok(1...4) => true, _ => false, });\n    /// ```\n    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n    #[inline]\n    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n        where F: FnMut(&'a T) -> B,\n              B: Ord\n    {\n        core_slice::SliceExt::binary_search_by_key(self, b, f)\n    }\n\n    /// Sorts the slice.\n    ///\n    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n    ///\n    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n    /// sorting and it doesn't allocate auxiliary memory.\n    /// See [`sort_unstable`](#method.sort_unstable).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is an adaptive, iterative merge sort inspired by\n    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n    /// two or more sorted sequences concatenated one after another.\n    ///\n    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n    /// non-allocating insertion sort is used instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5, 4, 1, -3, 2];\n    ///\n    /// v.sort();\n    /// assert!(v == [-5, -3, 1, 2, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sort(&mut self)\n        where T: Ord\n    {\n        merge_sort(self, |a, b| a.lt(b));\n    }\n\n    /// Sorts the slice with a comparator function.\n    ///\n    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n    ///\n    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n    /// sorting and it doesn't allocate auxiliary memory.\n    /// See [`sort_unstable_by`](#method.sort_unstable_by).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is an adaptive, iterative merge sort inspired by\n    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n    /// two or more sorted sequences concatenated one after another.\n    ///\n    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n    /// non-allocating insertion sort is used instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [5, 4, 1, 3, 2];\n    /// v.sort_by(|a, b| a.cmp(b));\n    /// assert!(v == [1, 2, 3, 4, 5]);\n    ///\n    /// // reverse sorting\n    /// v.sort_by(|a, b| b.cmp(a));\n    /// assert!(v == [5, 4, 3, 2, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sort_by<F>(&mut self, mut compare: F)\n        where F: FnMut(&T, &T) -> Ordering\n    {\n        merge_sort(self, |a, b| compare(a, b) == Less);\n    }\n\n    /// Sorts the slice with a key extraction function.\n    ///\n    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n    ///\n    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n    /// sorting and it doesn't allocate auxiliary memory.\n    /// See [`sort_unstable_by_key`](#method.sort_unstable_by_key).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is an adaptive, iterative merge sort inspired by\n    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n    /// two or more sorted sequences concatenated one after another.\n    ///\n    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n    /// non-allocating insertion sort is used instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// v.sort_by_key(|k| k.abs());\n    /// assert!(v == [1, 2, -3, 4, -5]);\n    /// ```\n    #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n    #[inline]\n    pub fn sort_by_key<B, F>(&mut self, mut f: F)\n        where F: FnMut(&T) -> B, B: Ord\n    {\n        merge_sort(self, |a, b| f(a).lt(&f(b)));\n    }\n\n    /// Sorts the slice, but may not preserve the order of equal elements.\n    ///\n    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n    /// and `O(n log n)` worst-case.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on Orson Peters' [pattern-defeating quicksort][pdqsort],\n    /// which is a quicksort variant designed to be very fast on certain kinds of patterns,\n    /// sometimes achieving linear time. It is randomized but deterministic, and falls back to\n    /// heapsort on degenerate inputs.\n    ///\n    /// It is generally faster than stable sorting, except in a few special cases, e.g. when the\n    /// slice consists of several concatenated sorted sequences.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5, 4, 1, -3, 2];\n    ///\n    /// v.sort_unstable();\n    /// assert!(v == [-5, -3, 1, 2, 4]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    #[inline]\n    pub fn sort_unstable(&mut self)\n        where T: Ord\n    {\n        core_slice::SliceExt::sort_unstable(self);\n    }\n\n    /// Sorts the slice with a comparator function, but may not preserve the order of equal\n    /// elements.\n    ///\n    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n    /// and `O(n log n)` worst-case.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on Orson Peters' [pattern-defeating quicksort][pdqsort],\n    /// which is a quicksort variant designed to be very fast on certain kinds of patterns,\n    /// sometimes achieving linear time. It is randomized but deterministic, and falls back to\n    /// heapsort on degenerate inputs.\n    ///\n    /// It is generally faster than stable sorting, except in a few special cases, e.g. when the\n    /// slice consists of several concatenated sorted sequences.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [5, 4, 1, 3, 2];\n    /// v.sort_unstable_by(|a, b| a.cmp(b));\n    /// assert!(v == [1, 2, 3, 4, 5]);\n    ///\n    /// // reverse sorting\n    /// v.sort_unstable_by(|a, b| b.cmp(a));\n    /// assert!(v == [5, 4, 3, 2, 1]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    #[inline]\n    pub fn sort_unstable_by<F>(&mut self, compare: F)\n        where F: FnMut(&T, &T) -> Ordering\n    {\n        core_slice::SliceExt::sort_unstable_by(self, compare);\n    }\n\n    /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n    /// elements.\n    ///\n    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n    /// and `O(n log n)` worst-case.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on Orson Peters' [pattern-defeating quicksort][pdqsort],\n    /// which is a quicksort variant designed to be very fast on certain kinds of patterns,\n    /// sometimes achieving linear time. It is randomized but deterministic, and falls back to\n    /// heapsort on degenerate inputs.\n    ///\n    /// It is generally faster than stable sorting, except in a few special cases, e.g. when the\n    /// slice consists of several concatenated sorted sequences.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// v.sort_unstable_by_key(|k| k.abs());\n    /// assert!(v == [1, 2, -3, 4, -5]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    #[inline]\n    pub fn sort_unstable_by_key<B, F>(&mut self, f: F)\n        where F: FnMut(&T) -> B,\n              B: Ord\n    {\n        core_slice::SliceExt::sort_unstable_by_key(self, f);\n    }\n\n    /// Permutes the slice in-place such that `self[mid..]` moves to the\n    /// beginning of the slice while `self[..mid]` moves to the end of the\n    /// slice.  Equivalently, rotates the slice `mid` places to the left\n    /// or `k = self.len() - mid` places to the right.\n    ///\n    /// This is a \"k-rotation\", a permutation in which item `i` moves to\n    /// position `i + k`, modulo the length of the slice.  See _Elements\n    /// of Programming_ [10.4][eop].\n    ///\n    /// Rotation by `mid` and rotation by `k` are inverse operations.\n    ///\n    /// [eop]: https://books.google.com/books?id=CO9ULZGINlsC&pg=PA178&q=k-rotation\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if `mid` is greater than the length of the\n    /// slice.  (Note that `mid == self.len()` does _not_ panic; it's a nop\n    /// rotation with `k == 0`, the inverse of a rotation with `mid == 0`.)\n    ///\n    /// # Complexity\n    ///\n    /// Takes linear (in `self.len()`) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_rotate)]\n    ///\n    /// let mut a = [1, 2, 3, 4, 5, 6, 7];\n    /// let mid = 2;\n    /// a.rotate(mid);\n    /// assert_eq!(&a, &[3, 4, 5, 6, 7, 1, 2]);\n    /// let k = a.len() - mid;\n    /// a.rotate(k);\n    /// assert_eq!(&a, &[1, 2, 3, 4, 5, 6, 7]);\n    ///\n    /// use std::ops::Range;\n    /// fn slide<T>(slice: &mut [T], range: Range<usize>, to: usize) {\n    ///     if to < range.start {\n    ///         slice[to..range.end].rotate(range.start-to);\n    ///     } else if to > range.end {\n    ///         slice[range.start..to].rotate(range.end-range.start);\n    ///     }\n    /// }\n    /// let mut v: Vec<_> = (0..10).collect();\n    /// slide(&mut v, 1..4, 7);\n    /// assert_eq!(&v, &[0, 4, 5, 6, 1, 2, 3, 7, 8, 9]);\n    /// slide(&mut v, 6..8, 1);\n    /// assert_eq!(&v, &[0, 3, 7, 4, 5, 6, 1, 2, 8, 9]);\n    /// ```\n    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n    pub fn rotate(&mut self, mid: usize) {\n        core_slice::SliceExt::rotate(self, mid);\n    }\n\n    /// Copies the elements from `src` into `self`.\n    ///\n    /// The length of `src` must be the same as `self`.\n    ///\n    /// If `src` implements `Copy`, it can be more performant to use\n    /// [`copy_from_slice`].\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let mut dst = [0, 0, 0];\n    /// let src = [1, 2, 3];\n    ///\n    /// dst.clone_from_slice(&src);\n    /// assert!(dst == [1, 2, 3]);\n    /// ```\n    ///\n    /// [`copy_from_slice`]: #method.copy_from_slice\n    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n    pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n        core_slice::SliceExt::clone_from_slice(self, src)\n    }\n\n    /// Copies all elements from `src` into `self`, using a memcpy.\n    ///\n    /// The length of `src` must be the same as `self`.\n    ///\n    /// If `src` does not implement `Copy`, use [`clone_from_slice`].\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let mut dst = [0, 0, 0];\n    /// let src = [1, 2, 3];\n    ///\n    /// dst.copy_from_slice(&src);\n    /// assert_eq!(src, dst);\n    /// ```\n    ///\n    /// [`clone_from_slice`]: #method.clone_from_slice\n    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n    pub fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n        core_slice::SliceExt::copy_from_slice(self, src)\n    }\n\n    /// Copies `self` into a new `Vec`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s = [10, 40, 30];\n    /// let x = s.to_vec();\n    /// // Here, `s` and `x` can be modified independently.\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_vec(&self) -> Vec<T>\n        where T: Clone\n    {\n        // NB see hack module in this file\n        hack::to_vec(self)\n    }\n\n    /// Converts `self` into a vector without clones or allocation.\n    ///\n    /// The resulting vector can be converted back into a box via\n    /// `Vec<T>`'s `into_boxed_slice` method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s: Box<[i32]> = Box::new([10, 40, 30]);\n    /// let x = s.into_vec();\n    /// // `s` cannot be used anymore because it has been converted into `x`.\n    ///\n    /// assert_eq!(x, vec![10, 40, 30]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn into_vec(self: Box<Self>) -> Vec<T> {\n        // NB see hack module in this file\n        hack::into_vec(self)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Extension traits for slices over specific kinds of data\n////////////////////////////////////////////////////////////////////////////////\n#[unstable(feature = \"slice_concat_ext\",\n           reason = \"trait should not have to exist\",\n           issue = \"27747\")]\n/// An extension trait for concatenating slices\npub trait SliceConcatExt<T: ?Sized> {\n    #[unstable(feature = \"slice_concat_ext\",\n               reason = \"trait should not have to exist\",\n               issue = \"27747\")]\n    /// The resulting type after concatenation\n    type Output;\n\n    /// Flattens a slice of `T` into a single value `Self::Output`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n    /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn concat(&self) -> Self::Output;\n\n    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n    /// given separator between each.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n    /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n    /// ```\n    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n    fn join(&self, sep: &T) -> Self::Output;\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n    fn connect(&self, sep: &T) -> Self::Output;\n}\n\n#[unstable(feature = \"slice_concat_ext\",\n           reason = \"trait should not have to exist\",\n           issue = \"27747\")]\nimpl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n    type Output = Vec<T>;\n\n    fn concat(&self) -> Vec<T> {\n        let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n        let mut result = Vec::with_capacity(size);\n        for v in self {\n            result.extend_from_slice(v.borrow())\n        }\n        result\n    }\n\n    fn join(&self, sep: &T) -> Vec<T> {\n        let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n        let mut result = Vec::with_capacity(size + self.len());\n        let mut first = true;\n        for v in self {\n            if first {\n                first = false\n            } else {\n                result.push(sep.clone())\n            }\n            result.extend_from_slice(v.borrow())\n        }\n        result\n    }\n\n    fn connect(&self, sep: &T) -> Vec<T> {\n        self.join(sep)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Standard trait implementations for slices\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Borrow<[T]> for Vec<T> {\n    fn borrow(&self) -> &[T] {\n        &self[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> BorrowMut<[T]> for Vec<T> {\n    fn borrow_mut(&mut self) -> &mut [T] {\n        &mut self[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> ToOwned for [T] {\n    type Owned = Vec<T>;\n    #[cfg(not(test))]\n    fn to_owned(&self) -> Vec<T> {\n        self.to_vec()\n    }\n\n    #[cfg(test)]\n    fn to_owned(&self) -> Vec<T> {\n        hack::to_vec(self)\n    }\n\n    fn clone_into(&self, target: &mut Vec<T>) {\n        // drop anything in target that will not be overwritten\n        target.truncate(self.len());\n        let len = target.len();\n\n        // reuse the contained values' allocations/resources.\n        target.clone_from_slice(&self[..len]);\n\n        // target.len <= self.len due to the truncate above, so the\n        // slice here is always in-bounds.\n        target.extend_from_slice(&self[len..]);\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Sorting\n////////////////////////////////////////////////////////////////////////////////\n\n/// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n///\n/// This is the integral subroutine of insertion sort.\nfn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n    where F: FnMut(&T, &T) -> bool\n{\n    if v.len() >= 2 && is_less(&v[1], &v[0]) {\n        unsafe {\n            // There are three ways to implement insertion here:\n            //\n            // 1. Swap adjacent elements until the first one gets to its final destination.\n            //    However, this way we copy data around more than is necessary. If elements are big\n            //    structures (costly to copy), this method will be slow.\n            //\n            // 2. Iterate until the right place for the first element is found. Then shift the\n            //    elements succeeding it to make room for it and finally place it into the\n            //    remaining hole. This is a good method.\n            //\n            // 3. Copy the first element into a temporary variable. Iterate until the right place\n            //    for it is found. As we go along, copy every traversed element into the slot\n            //    preceding it. Finally, copy data from the temporary variable into the remaining\n            //    hole. This method is very good. Benchmarks demonstrated slightly better\n            //    performance than with the 2nd method.\n            //\n            // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n            let mut tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n\n            // Intermediate state of the insertion process is always tracked by `hole`, which\n            // serves two purposes:\n            // 1. Protects integrity of `v` from panics in `is_less`.\n            // 2. Fills the remaining hole in `v` in the end.\n            //\n            // Panic safety:\n            //\n            // If `is_less` panics at any point during the process, `hole` will get dropped and\n            // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n            // initially held exactly once.\n            let mut hole = InsertionHole {\n                src: &mut *tmp,\n                dest: &mut v[1],\n            };\n            ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n\n            for i in 2..v.len() {\n                if !is_less(&v[i], &*tmp) {\n                    break;\n                }\n                ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n                hole.dest = &mut v[i];\n            }\n            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n        }\n    }\n\n    // When dropped, copies from `src` into `dest`.\n    struct InsertionHole<T> {\n        src: *mut T,\n        dest: *mut T,\n    }\n\n    impl<T> Drop for InsertionHole<T> {\n        fn drop(&mut self) {\n            unsafe { ptr::copy_nonoverlapping(self.src, self.dest, 1); }\n        }\n    }\n}\n\n/// Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `buf` as temporary storage, and\n/// stores the result into `v[..]`.\n///\n/// # Safety\n///\n/// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n/// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\nunsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n    where F: FnMut(&T, &T) -> bool\n{\n    let len = v.len();\n    let v = v.as_mut_ptr();\n    let v_mid = v.offset(mid as isize);\n    let v_end = v.offset(len as isize);\n\n    // The merge process first copies the shorter run into `buf`. Then it traces the newly copied\n    // run and the longer run forwards (or backwards), comparing their next unconsumed elements and\n    // copying the lesser (or greater) one into `v`.\n    //\n    // As soon as the shorter run is fully consumed, the process is done. If the longer run gets\n    // consumed first, then we must copy whatever is left of the shorter run into the remaining\n    // hole in `v`.\n    //\n    // Intermediate state of the process is always tracked by `hole`, which serves two purposes:\n    // 1. Protects integrity of `v` from panics in `is_less`.\n    // 2. Fills the remaining hole in `v` if the longer run gets consumed first.\n    //\n    // Panic safety:\n    //\n    // If `is_less` panics at any point during the process, `hole` will get dropped and fill the\n    // hole in `v` with the unconsumed range in `buf`, thus ensuring that `v` still holds every\n    // object it initially held exactly once.\n    let mut hole;\n\n    if mid <= len - mid {\n        // The left run is shorter.\n        ptr::copy_nonoverlapping(v, buf, mid);\n        hole = MergeHole {\n            start: buf,\n            end: buf.offset(mid as isize),\n            dest: v,\n        };\n\n        // Initially, these pointers point to the beginnings of their arrays.\n        let left = &mut hole.start;\n        let mut right = v_mid;\n        let out = &mut hole.dest;\n\n        while *left < hole.end && right < v_end {\n            // Consume the lesser side.\n            // If equal, prefer the left run to maintain stability.\n            let to_copy = if is_less(&*right, &**left) {\n                get_and_increment(&mut right)\n            } else {\n                get_and_increment(left)\n            };\n            ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n        }\n    } else {\n        // The right run is shorter.\n        ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n        hole = MergeHole {\n            start: buf,\n            end: buf.offset((len - mid) as isize),\n            dest: v_mid,\n        };\n\n        // Initially, these pointers point past the ends of their arrays.\n        let left = &mut hole.dest;\n        let right = &mut hole.end;\n        let mut out = v_end;\n\n        while v < *left && buf < *right {\n            // Consume the greater side.\n            // If equal, prefer the right run to maintain stability.\n            let to_copy = if is_less(&*right.offset(-1), &*left.offset(-1)) {\n                decrement_and_get(left)\n            } else {\n                decrement_and_get(right)\n            };\n            ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n        }\n    }\n    // Finally, `hole` gets dropped. If the shorter run was not fully consumed, whatever remains of\n    // it will now be copied into the hole in `v`.\n\n    unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n        let old = *ptr;\n        *ptr = ptr.offset(1);\n        old\n    }\n\n    unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n        *ptr = ptr.offset(-1);\n        *ptr\n    }\n\n    // When dropped, copies the range `start..end` into `dest..`.\n    struct MergeHole<T> {\n        start: *mut T,\n        end: *mut T,\n        dest: *mut T,\n    }\n\n    impl<T> Drop for MergeHole<T> {\n        fn drop(&mut self) {\n            // `T` is not a zero-sized type, so it's okay to divide by its size.\n            let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n            unsafe { ptr::copy_nonoverlapping(self.start, self.dest, len); }\n        }\n    }\n}\n\n/// This merge sort borrows some (but not all) ideas from TimSort, which is described in detail\n/// [here](http://svn.python.org/projects/python/trunk/Objects/listsort.txt).\n///\n/// The algorithm identifies strictly descending and non-descending subsequences, which are called\n/// natural runs. There is a stack of pending runs yet to be merged. Each newly found run is pushed\n/// onto the stack, and then some pairs of adjacent runs are merged until these two invariants are\n/// satisfied:\n///\n/// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n/// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n///\n/// The invariants ensure that the total running time is `O(n log n)` worst-case.\nfn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n    where F: FnMut(&T, &T) -> bool\n{\n    // Slices of up to this length get sorted using insertion sort.\n    const MAX_INSERTION: usize = 20;\n    // Very short runs are extended using insertion sort to span at least this many elements.\n    const MIN_RUN: usize = 10;\n\n    // Sorting has no meaningful behavior on zero-sized types.\n    if size_of::<T>() == 0 {\n        return;\n    }\n\n    let len = v.len();\n\n    // Short arrays get sorted in-place via insertion sort to avoid allocations.\n    if len <= MAX_INSERTION {\n        if len >= 2 {\n            for i in (0..len-1).rev() {\n                insert_head(&mut v[i..], &mut is_less);\n            }\n        }\n        return;\n    }\n\n    // Allocate a buffer to use as scratch memory. We keep the length 0 so we can keep in it\n    // shallow copies of the contents of `v` without risking the dtors running on copies if\n    // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n    // which will always have length at most `len / 2`.\n    let mut buf = Vec::with_capacity(len / 2);\n\n    // In order to identify natural runs in `v`, we traverse it backwards. That might seem like a\n    // strange decision, but consider the fact that merges more often go in the opposite direction\n    // (forwards). According to benchmarks, merging forwards is slightly faster than merging\n    // backwards. To conclude, identifying runs by traversing backwards improves performance.\n    let mut runs = vec![];\n    let mut end = len;\n    while end > 0 {\n        // Find the next natural run, and reverse it if it's strictly descending.\n        let mut start = end - 1;\n        if start > 0 {\n            start -= 1;\n            unsafe {\n                if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n                    while start > 0 && is_less(v.get_unchecked(start),\n                                               v.get_unchecked(start - 1)) {\n                        start -= 1;\n                    }\n                    v[start..end].reverse();\n                } else {\n                    while start > 0 && !is_less(v.get_unchecked(start),\n                                                v.get_unchecked(start - 1)) {\n                        start -= 1;\n                    }\n                }\n            }\n        }\n\n        // Insert some more elements into the run if it's too short. Insertion sort is faster than\n        // merge sort on short sequences, so this significantly improves performance.\n        while start > 0 && end - start < MIN_RUN {\n            start -= 1;\n            insert_head(&mut v[start..end], &mut is_less);\n        }\n\n        // Push this run onto the stack.\n        runs.push(Run {\n            start: start,\n            len: end - start,\n        });\n        end = start;\n\n        // Merge some pairs of adjacent runs to satisfy the invariants.\n        while let Some(r) = collapse(&runs) {\n            let left = runs[r + 1];\n            let right = runs[r];\n            unsafe {\n                merge(&mut v[left.start .. right.start + right.len], left.len, buf.as_mut_ptr(),\n                      &mut is_less);\n            }\n            runs[r] = Run {\n                start: left.start,\n                len: left.len + right.len,\n            };\n            runs.remove(r + 1);\n        }\n    }\n\n    // Finally, exactly one run must remain in the stack.\n    debug_assert!(runs.len() == 1 && runs[0].start == 0 && runs[0].len == len);\n\n    // Examines the stack of runs and identifies the next pair of runs to merge. More specifically,\n    // if `Some(r)` is returned, that means `runs[r]` and `runs[r + 1]` must be merged next. If the\n    // algorithm should continue building a new run instead, `None` is returned.\n    //\n    // TimSort is infamous for its buggy implementations, as described here:\n    // http://envisage-project.eu/timsort-specification-and-verification/\n    //\n    // The gist of the story is: we must enforce the invariants on the top four runs on the stack.\n    // Enforcing them on just top three is not sufficient to ensure that the invariants will still\n    // hold for *all* runs in the stack.\n    //\n    // This function correctly checks invariants for the top four runs. Additionally, if the top\n    // run starts at index 0, it will always demand a merge operation until the stack is fully\n    // collapsed, in order to complete the sort.\n    #[inline]\n    fn collapse(runs: &[Run]) -> Option<usize> {\n        let n = runs.len();\n        if n >= 2 && (runs[n - 1].start == 0 ||\n                      runs[n - 2].len <= runs[n - 1].len ||\n                      (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len) ||\n                      (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len)) {\n            if n >= 3 && runs[n - 3].len < runs[n - 1].len {\n                Some(n - 3)\n            } else {\n                Some(n - 2)\n            }\n        } else {\n            None\n        }\n    }\n\n    #[derive(Clone, Copy)]\n    struct Run {\n        start: usize,\n        len: usize,\n    }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n/// The underlying OsString/OsStr implementation on Unix systems: just\n/// a `Vec<u8>`/`[u8]`.\n\nuse borrow::Cow;\nuse fmt;\nuse str;\nuse mem;\nuse sys_common::{AsInner, IntoInner};\nuse std_unicode::lossy::Utf8Lossy;\n\n#[derive(Clone, Hash)]\npub struct Buf {\n    pub inner: Vec<u8>\n}\n\npub struct Slice {\n    pub inner: [u8]\n}\n\nimpl fmt::Debug for Slice {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&Utf8Lossy::from_bytes(&self.inner), formatter)\n    }\n}\n\nimpl fmt::Display for Slice {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&Utf8Lossy::from_bytes(&self.inner), formatter)\n    }\n}\n\nimpl fmt::Debug for Buf {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(self.as_slice(), formatter)\n    }\n}\n\nimpl fmt::Display for Buf {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(self.as_slice(), formatter)\n    }\n}\n\nimpl IntoInner<Vec<u8>> for Buf {\n    fn into_inner(self) -> Vec<u8> {\n        self.inner\n    }\n}\n\nimpl AsInner<[u8]> for Buf {\n    fn as_inner(&self) -> &[u8] {\n        &self.inner\n    }\n}\n\n\nimpl Buf {\n    pub fn from_string(s: String) -> Buf {\n        Buf { inner: s.into_bytes() }\n    }\n\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Buf {\n        Buf {\n            inner: Vec::with_capacity(capacity)\n        }\n    }\n\n    #[inline]\n    pub fn clear(&mut self) {\n        self.inner.clear()\n    }\n\n    #[inline]\n    pub fn capacity(&self) -> usize {\n        self.inner.capacity()\n    }\n\n    #[inline]\n    pub fn reserve(&mut self, additional: usize) {\n        self.inner.reserve(additional)\n    }\n\n    #[inline]\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.inner.reserve_exact(additional)\n    }\n\n    #[inline]\n    pub fn shrink_to_fit(&mut self) {\n        self.inner.shrink_to_fit()\n    }\n\n    pub fn as_slice(&self) -> &Slice {\n        unsafe { mem::transmute(&*self.inner) }\n    }\n\n    pub fn into_string(self) -> Result<String, Buf> {\n        String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() } )\n    }\n\n    pub fn push_slice(&mut self, s: &Slice) {\n        self.inner.extend_from_slice(&s.inner)\n    }\n\n    #[inline]\n    pub fn into_box(self) -> Box<Slice> {\n        unsafe { mem::transmute(self.inner.into_boxed_slice()) }\n    }\n\n    #[inline]\n    pub fn from_box(boxed: Box<Slice>) -> Buf {\n        let inner: Box<[u8]> = unsafe { mem::transmute(boxed) };\n        Buf { inner: inner.into_vec() }\n    }\n}\n\nimpl Slice {\n    fn from_u8_slice(s: &[u8]) -> &Slice {\n        unsafe { mem::transmute(s) }\n    }\n\n    pub fn from_str(s: &str) -> &Slice {\n        Slice::from_u8_slice(s.as_bytes())\n    }\n\n    pub fn to_str(&self) -> Option<&str> {\n        str::from_utf8(&self.inner).ok()\n    }\n\n    pub fn to_string_lossy(&self) -> Cow<str> {\n        String::from_utf8_lossy(&self.inner)\n    }\n\n    pub fn to_owned(&self) -> Buf {\n        Buf { inner: self.inner.to_vec() }\n    }\n\n    #[inline]\n    pub fn into_box(&self) -> Box<Slice> {\n        let boxed: Box<[u8]> = self.inner.into();\n        unsafe { mem::transmute(boxed) }\n    }\n\n    pub fn empty_box() -> Box<Slice> {\n        let boxed: Box<[u8]> = Default::default();\n        unsafe { mem::transmute(boxed) }\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse error::{Error};\nuse fmt;\nuse sync::atomic::{AtomicBool, Ordering};\nuse thread;\n\npub struct Flag { failed: AtomicBool }\n\n// Note that the Ordering uses to access the `failed` field of `Flag` below is\n// always `Relaxed`, and that's because this isn't actually protecting any data,\n// it's just a flag whether we've panicked or not.\n//\n// The actual location that this matters is when a mutex is **locked** which is\n// where we have external synchronization ensuring that we see memory\n// reads/writes to this flag.\n//\n// As a result, if it matters, we should see the correct value for `failed` in\n// all cases.\n\nimpl Flag {\n    pub const fn new() -> Flag {\n        Flag { failed: AtomicBool::new(false) }\n    }\n\n    #[inline]\n    pub fn borrow(&self) -> LockResult<Guard> {\n        let ret = Guard { panicking: thread::panicking() };\n        if self.get() {\n            Err(PoisonError::new(ret))\n        } else {\n            Ok(ret)\n        }\n    }\n\n    #[inline]\n    pub fn done(&self, guard: &Guard) {\n        if !guard.panicking && thread::panicking() {\n            self.failed.store(true, Ordering::Relaxed);\n        }\n    }\n\n    #[inline]\n    pub fn get(&self) -> bool {\n        self.failed.load(Ordering::Relaxed)\n    }\n}\n\npub struct Guard {\n    panicking: bool,\n}\n\n/// A type of error which can be returned whenever a lock is acquired.\n///\n/// Both [`Mutex`]es and [`RwLock`]s are poisoned whenever a thread fails while the lock\n/// is held. The precise semantics for when a lock is poisoned is documented on\n/// each lock, but once a lock is poisoned then all future acquisitions will\n/// return this error.\n///\n/// [`Mutex`]: ../../std/sync/struct.Mutex.html\n/// [`RwLock`]: ../../std/sync/struct.RwLock.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct PoisonError<T> {\n    guard: T,\n}\n\n/// An enumeration of possible errors which can occur while calling the\n/// [`try_lock`] method.\n///\n/// [`try_lock`]: struct.Mutex.html#method.try_lock\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum TryLockError<T> {\n    /// The lock could not be acquired because another thread failed while holding\n    /// the lock.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Poisoned(#[stable(feature = \"rust1\", since = \"1.0.0\")] PoisonError<T>),\n    /// The lock could not be acquired at this time because the operation would\n    /// otherwise block.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    WouldBlock,\n}\n\n/// A type alias for the result of a lock method which can be poisoned.\n///\n/// The [`Ok`] variant of this result indicates that the primitive was not\n/// poisoned, and the `Guard` is contained within. The [`Err`] variant indicates\n/// that the primitive was poisoned. Note that the [`Err`] variant *also* carries\n/// the associated guard, and it can be acquired through the [`into_inner`]\n/// method.\n///\n/// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n/// [`into_inner`]: ../../std/sync/struct.Mutex.html#method.into_inner\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n\n/// A type alias for the result of a nonblocking locking method.\n///\n/// For more information, see [`LockResult`]. A `TryLockResult` doesn't\n/// necessarily hold the associated guard in the [`Err`] type as the lock may not\n/// have been acquired for other reasons.\n///\n/// [`LockResult`]: ../../std/sync/type.LockResult.html\n/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> fmt::Debug for PoisonError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        \"PoisonError { inner: .. }\".fmt(f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> fmt::Display for PoisonError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        \"poisoned lock: another task failed inside\".fmt(f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Error for PoisonError<T> {\n    fn description(&self) -> &str {\n        \"poisoned lock: another task failed inside\"\n    }\n}\n\nimpl<T> PoisonError<T> {\n    /// Creates a `PoisonError`.\n    ///\n    /// This is generally created by methods like [`Mutex::lock`] or [`RwLock::read`].\n    ///\n    /// [`Mutex::lock`]: ../../std/sync/struct.Mutex.html#method.lock\n    /// [`RwLock::read`]: ../../std/sync/struct.RwLock.html#method.read\n    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n    pub fn new(guard: T) -> PoisonError<T> {\n        PoisonError { guard: guard }\n    }\n\n    /// Consumes this error indicating that a lock is poisoned, returning the\n    /// underlying guard to allow access regardless.\n    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n    pub fn into_inner(self) -> T { self.guard }\n\n    /// Reaches into this error indicating that a lock is poisoned, returning a\n    /// reference to the underlying guard to allow access regardless.\n    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n    pub fn get_ref(&self) -> &T { &self.guard }\n\n    /// Reaches into this error indicating that a lock is poisoned, returning a\n    /// mutable reference to the underlying guard to allow access regardless.\n    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n    pub fn get_mut(&mut self) -> &mut T { &mut self.guard }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> From<PoisonError<T>> for TryLockError<T> {\n    fn from(err: PoisonError<T>) -> TryLockError<T> {\n        TryLockError::Poisoned(err)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> fmt::Debug for TryLockError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            TryLockError::Poisoned(..) => \"Poisoned(..)\".fmt(f),\n            TryLockError::WouldBlock => \"WouldBlock\".fmt(f)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> fmt::Display for TryLockError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            TryLockError::Poisoned(..) => \"poisoned lock: another task failed inside\",\n            TryLockError::WouldBlock => \"try_lock failed because the operation would block\"\n        }.fmt(f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Error for TryLockError<T> {\n    fn description(&self) -> &str {\n        match *self {\n            TryLockError::Poisoned(ref p) => p.description(),\n            TryLockError::WouldBlock => \"try_lock failed because the operation would block\"\n        }\n    }\n\n    fn cause(&self) -> Option<&Error> {\n        match *self {\n            TryLockError::Poisoned(ref p) => Some(p),\n            _ => None\n        }\n    }\n}\n\npub fn map_result<T, U, F>(result: LockResult<T>, f: F)\n                           -> LockResult<U>\n                           where F: FnOnce(T) -> U {\n    match result {\n        Ok(t) => Ok(f(t)),\n        Err(PoisonError { guard }) => Err(PoisonError::new(f(guard)))\n    }\n}\n","// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of running at_exit routines\n//!\n//! Documentation can be found on the `rt::at_exit` function.\n\nuse alloc::boxed::FnBox;\nuse ptr;\nuse sys_common::mutex::Mutex;\n\ntype Queue = Vec<Box<FnBox()>>;\n\n// NB these are specifically not types from `std::sync` as they currently rely\n// on poisoning and this module needs to operate at a lower level than requiring\n// the thread infrastructure to be in place (useful on the borders of\n// initialization/destruction).\nstatic LOCK: Mutex = Mutex::new();\nstatic mut QUEUE: *mut Queue = ptr::null_mut();\n\n// The maximum number of times the cleanup routines will be run. While running\n// the at_exit closures new ones may be registered, and this count is the number\n// of times the new closures will be allowed to register successfully. After\n// this number of iterations all new registrations will return `false`.\nconst ITERS: usize = 10;\n\nunsafe fn init() -> bool {\n    if QUEUE.is_null() {\n        let state: Box<Queue> = box Vec::new();\n        QUEUE = Box::into_raw(state);\n    } else if QUEUE as usize == 1 {\n        // can't re-init after a cleanup\n        return false\n    }\n\n    true\n}\n\npub fn cleanup() {\n    for i in 0..ITERS {\n        unsafe {\n            LOCK.lock();\n            let queue = QUEUE;\n            QUEUE = if i == ITERS - 1 {1} else {0} as *mut _;\n            LOCK.unlock();\n\n            // make sure we're not recursively cleaning up\n            assert!(queue as usize != 1);\n\n            // If we never called init, not need to cleanup!\n            if queue as usize != 0 {\n                let queue: Box<Queue> = Box::from_raw(queue);\n                for to_run in *queue {\n                    to_run();\n                }\n            }\n        }\n    }\n}\n\npub fn push(f: Box<FnBox()>) -> bool {\n    let mut ret = true;\n    unsafe {\n        LOCK.lock();\n        if init() {\n            (*QUEUE).push(f);\n        } else {\n            ret = false;\n        }\n        LOCK.unlock();\n    }\n    ret\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse cell::Cell;\nuse ptr;\nuse sync::Arc;\nuse sys_common;\nuse sys_common::mutex::Mutex;\n\npub struct Lazy<T> {\n    lock: Mutex,\n    ptr: Cell<*mut Arc<T>>,\n    init: fn() -> Arc<T>,\n}\n\nunsafe impl<T> Sync for Lazy<T> {}\n\nimpl<T: Send + Sync + 'static> Lazy<T> {\n    pub const fn new(init: fn() -> Arc<T>) -> Lazy<T> {\n        Lazy {\n            lock: Mutex::new(),\n            ptr: Cell::new(ptr::null_mut()),\n            init: init\n        }\n    }\n\n    pub fn get(&'static self) -> Option<Arc<T>> {\n        unsafe {\n            self.lock.lock();\n            let ptr = self.ptr.get();\n            let ret = if ptr.is_null() {\n                Some(self.init())\n            } else if ptr as usize == 1 {\n                None\n            } else {\n                Some((*ptr).clone())\n            };\n            self.lock.unlock();\n            return ret\n        }\n    }\n\n    unsafe fn init(&'static self) -> Arc<T> {\n        // If we successfully register an at exit handler, then we cache the\n        // `Arc` allocation in our own internal box (it will get deallocated by\n        // the at exit handler). Otherwise we just return the freshly allocated\n        // `Arc`.\n        let registered = sys_common::at_exit(move || {\n            self.lock.lock();\n            let ptr = self.ptr.get();\n            self.ptr.set(1 as *mut _);\n            self.lock.unlock();\n            drop(Box::from_raw(ptr))\n        });\n        let ret = (self.init)();\n        if registered.is_ok() {\n            self.ptr.set(Box::into_raw(Box::new(ret.clone())));\n        }\n        ret\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Platform-independent platform abstraction\n//!\n//! This is the platform-independent portion of the standard library's\n//! platform abstraction layer, whereas `std::sys` is the\n//! platform-specific portion.\n//!\n//! The relationship between `std::sys_common`, `std::sys` and the\n//! rest of `std` is complex, with dependencies going in all\n//! directions: `std` depending on `sys_common`, `sys_common`\n//! depending on `sys`, and `sys` depending on `sys_common` and `std`.\n//! Ideally `sys_common` would be split into two and the dependencies\n//! between them all would form a dag, facilitating the extraction of\n//! `std::sys` from the standard library.\n\n#![allow(missing_docs)]\n#![allow(missing_debug_implementations)]\n\nuse sync::Once;\nuse sys;\n\npub mod at_exit_imp;\n#[cfg(feature = \"backtrace\")]\npub mod backtrace;\npub mod condvar;\npub mod io;\npub mod memchr;\npub mod mutex;\npub mod poison;\npub mod remutex;\npub mod rwlock;\npub mod thread;\npub mod thread_info;\npub mod thread_local;\npub mod util;\npub mod wtf8;\n\n#[cfg(target_os = \"redox\")]\npub use sys::net;\n\n#[cfg(not(target_os = \"redox\"))]\npub mod net;\n\n#[cfg(feature = \"backtrace\")]\n#[cfg(any(all(unix, not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"emscripten\"))),\n          all(windows, target_env = \"gnu\")))]\npub mod gnu;\n\n// common error constructors\n\n/// A trait for viewing representations from std types\n#[doc(hidden)]\npub trait AsInner<Inner: ?Sized> {\n    fn as_inner(&self) -> &Inner;\n}\n\n/// A trait for viewing representations from std types\n#[doc(hidden)]\npub trait AsInnerMut<Inner: ?Sized> {\n    fn as_inner_mut(&mut self) -> &mut Inner;\n}\n\n/// A trait for extracting representations from std types\n#[doc(hidden)]\npub trait IntoInner<Inner> {\n    fn into_inner(self) -> Inner;\n}\n\n/// A trait for creating std types from internal representations\n#[doc(hidden)]\npub trait FromInner<Inner> {\n    fn from_inner(inner: Inner) -> Self;\n}\n\n/// Enqueues a procedure to run when the main thread exits.\n///\n/// Currently these closures are only run once the main *Rust* thread exits.\n/// Once the `at_exit` handlers begin running, more may be enqueued, but not\n/// infinitely so. Eventually a handler registration will be forced to fail.\n///\n/// Returns `Ok` if the handler was successfully registered, meaning that the\n/// closure will be run once the main thread exits. Returns `Err` to indicate\n/// that the closure could not be registered, meaning that it is not scheduled\n/// to be run.\npub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n    if at_exit_imp::push(Box::new(f)) {Ok(())} else {Err(())}\n}\n\nmacro_rules! rtabort {\n    ($($t:tt)*) => (::sys_common::util::abort(format_args!($($t)*)))\n}\n\n/// One-time runtime cleanup.\npub fn cleanup() {\n    static CLEANUP: Once = Once::new();\n    CLEANUP.call_once(|| unsafe {\n        sys::args::cleanup();\n        sys::stack_overflow::cleanup();\n        at_exit_imp::cleanup();\n    });\n}\n\n// Computes (value*numer)/denom without overflow, as long as both\n// (numer*denom) and the overall result fit into i64 (which is the case\n// for our time conversions).\n#[allow(dead_code)] // not used on all platforms\npub fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64 {\n    let q = value / denom;\n    let r = value % denom;\n    // Decompose value as (value/denom*denom + value%denom),\n    // substitute into (value*numer)/denom and simplify.\n    // r < denom, so (denom*numer) is the upper bound of (r*numer)\n    q * numer + r * numer / denom\n}\n\n#[test]\nfn test_muldiv() {\n    assert_eq!(mul_div_u64( 1_000_000_000_001, 1_000_000_000, 1_000_000),\n               1_000_000_000_001_000);\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse io::prelude::*;\n\nuse cell::RefCell;\nuse fmt;\nuse io::lazy::Lazy;\nuse io::{self, Initializer, BufReader, LineWriter};\nuse sync::{Arc, Mutex, MutexGuard};\nuse sys::stdio;\nuse sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\nuse thread::{LocalKey, LocalKeyState};\n\n/// Stdout used by print! and println! macros\nthread_local! {\n    static LOCAL_STDOUT: RefCell<Option<Box<Write + Send>>> = {\n        RefCell::new(None)\n    }\n}\n\n/// A handle to a raw instance of the standard input stream of this process.\n///\n/// This handle is not synchronized or buffered in any fashion. Constructed via\n/// the `std::io::stdio::stdin_raw` function.\nstruct StdinRaw(stdio::Stdin);\n\n/// A handle to a raw instance of the standard output stream of this process.\n///\n/// This handle is not synchronized or buffered in any fashion. Constructed via\n/// the `std::io::stdio::stdout_raw` function.\nstruct StdoutRaw(stdio::Stdout);\n\n/// A handle to a raw instance of the standard output stream of this process.\n///\n/// This handle is not synchronized or buffered in any fashion. Constructed via\n/// the `std::io::stdio::stderr_raw` function.\nstruct StderrRaw(stdio::Stderr);\n\n/// Constructs a new raw handle to the standard input of this process.\n///\n/// The returned handle does not interact with any other handles created nor\n/// handles returned by `std::io::stdin`. Data buffered by the `std::io::stdin`\n/// handles is **not** available to raw handles returned from this function.\n///\n/// The returned handle has no external synchronization or buffering.\nfn stdin_raw() -> io::Result<StdinRaw> { stdio::Stdin::new().map(StdinRaw) }\n\n/// Constructs a new raw handle to the standard output stream of this process.\n///\n/// The returned handle does not interact with any other handles created nor\n/// handles returned by `std::io::stdout`. Note that data is buffered by the\n/// `std::io::stdout` handles so writes which happen via this raw handle may\n/// appear before previous writes.\n///\n/// The returned handle has no external synchronization or buffering layered on\n/// top.\nfn stdout_raw() -> io::Result<StdoutRaw> { stdio::Stdout::new().map(StdoutRaw) }\n\n/// Constructs a new raw handle to the standard error stream of this process.\n///\n/// The returned handle does not interact with any other handles created nor\n/// handles returned by `std::io::stderr`.\n///\n/// The returned handle has no external synchronization or buffering layered on\n/// top.\nfn stderr_raw() -> io::Result<StderrRaw> { stdio::Stderr::new().map(StderrRaw) }\n\nimpl Read for StdinRaw {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n}\nimpl Write for StdoutRaw {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n    fn flush(&mut self) -> io::Result<()> { self.0.flush() }\n}\nimpl Write for StderrRaw {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n    fn flush(&mut self) -> io::Result<()> { self.0.flush() }\n}\n\nenum Maybe<T> {\n    Real(T),\n    Fake,\n}\n\nimpl<W: io::Write> io::Write for Maybe<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        match *self {\n            Maybe::Real(ref mut w) => handle_ebadf(w.write(buf), buf.len()),\n            Maybe::Fake => Ok(buf.len())\n        }\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        match *self {\n            Maybe::Real(ref mut w) => handle_ebadf(w.flush(), ()),\n            Maybe::Fake => Ok(())\n        }\n    }\n}\n\nimpl<R: io::Read> io::Read for Maybe<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        match *self {\n            Maybe::Real(ref mut r) => handle_ebadf(r.read(buf), 0),\n            Maybe::Fake => Ok(0)\n        }\n    }\n}\n\nfn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n    use sys::stdio::EBADF_ERR;\n\n    match r {\n        Err(ref e) if e.raw_os_error() == Some(EBADF_ERR) => Ok(default),\n        r => r\n    }\n}\n\n/// A handle to the standard input stream of a process.\n///\n/// Each handle is a shared reference to a global buffer of input data to this\n/// process. A handle can be `lock`'d to gain full access to [`BufRead`] methods\n/// (e.g. `.lines()`). Reads to this handle are otherwise locked with respect\n/// to other reads.\n///\n/// This handle implements the `Read` trait, but beware that concurrent reads\n/// of `Stdin` must be executed with care.\n///\n/// Created by the [`io::stdin`] method.\n///\n/// [`io::stdin`]: fn.stdin.html\n/// [`BufRead`]: trait.BufRead.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Stdin {\n    inner: Arc<Mutex<BufReader<Maybe<StdinRaw>>>>,\n}\n\n/// A locked reference to the `Stdin` handle.\n///\n/// This handle implements both the [`Read`] and [`BufRead`] traits, and\n/// is constructed via the [`Stdin::lock`] method.\n///\n/// [`Read`]: trait.Read.html\n/// [`BufRead`]: trait.BufRead.html\n/// [`Stdin::lock`]: struct.Stdin.html#method.lock\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct StdinLock<'a> {\n    inner: MutexGuard<'a, BufReader<Maybe<StdinRaw>>>,\n}\n\n/// Constructs a new handle to the standard input of the current process.\n///\n/// Each handle returned is a reference to a shared global buffer whose access\n/// is synchronized via a mutex. If you need more explicit control over\n/// locking, see the [`lock() method`][lock].\n///\n/// [lock]: struct.Stdin.html#method.lock\n///\n/// # Examples\n///\n/// Using implicit synchronization:\n///\n/// ```\n/// use std::io::{self, Read};\n///\n/// # fn foo() -> io::Result<String> {\n/// let mut buffer = String::new();\n/// io::stdin().read_to_string(&mut buffer)?;\n/// # Ok(buffer)\n/// # }\n/// ```\n///\n/// Using explicit synchronization:\n///\n/// ```\n/// use std::io::{self, Read};\n///\n/// # fn foo() -> io::Result<String> {\n/// let mut buffer = String::new();\n/// let stdin = io::stdin();\n/// let mut handle = stdin.lock();\n///\n/// handle.read_to_string(&mut buffer)?;\n/// # Ok(buffer)\n/// # }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn stdin() -> Stdin {\n    static INSTANCE: Lazy<Mutex<BufReader<Maybe<StdinRaw>>>> = Lazy::new(stdin_init);\n    return Stdin {\n        inner: INSTANCE.get().expect(\"cannot access stdin during shutdown\"),\n    };\n\n    fn stdin_init() -> Arc<Mutex<BufReader<Maybe<StdinRaw>>>> {\n        let stdin = match stdin_raw() {\n            Ok(stdin) => Maybe::Real(stdin),\n            _ => Maybe::Fake\n        };\n\n        Arc::new(Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin)))\n    }\n}\n\nimpl Stdin {\n    /// Locks this handle to the standard input stream, returning a readable\n    /// guard.\n    ///\n    /// The lock is released when the returned lock goes out of scope. The\n    /// returned guard also implements the [`Read`] and [`BufRead`] traits for\n    /// accessing the underlying data.\n    ///\n    /// [`Read`]: trait.Read.html\n    /// [`BufRead`]: trait.BufRead.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Read};\n    ///\n    /// # fn foo() -> io::Result<String> {\n    /// let mut buffer = String::new();\n    /// let stdin = io::stdin();\n    /// let mut handle = stdin.lock();\n    ///\n    /// handle.read_to_string(&mut buffer)?;\n    /// # Ok(buffer)\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> StdinLock {\n        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n    }\n\n    /// Locks this handle and reads a line of input into the specified buffer.\n    ///\n    /// For detailed semantics of this method, see the documentation on\n    /// [`BufRead::read_line`].\n    ///\n    /// [`BufRead::read_line`]: trait.BufRead.html#method.read_line\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    ///\n    /// let mut input = String::new();\n    /// match io::stdin().read_line(&mut input) {\n    ///     Ok(n) => {\n    ///         println!(\"{} bytes read\", n);\n    ///         println!(\"{}\", input);\n    ///     }\n    ///     Err(error) => println!(\"error: {}\", error),\n    /// }\n    /// ```\n    ///\n    /// You can run the example one of two ways:\n    ///\n    /// - Pipe some text to it, e.g. `printf foo | path/to/executable`\n    /// - Give it text interactively by running the executable directly,\n    ///   in which case it will wait for the Enter key to be pressed before\n    ///   continuing\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn read_line(&self, buf: &mut String) -> io::Result<usize> {\n        self.lock().read_line(buf)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stdin {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"Stdin { .. }\")\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for Stdin {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.lock().read(buf)\n    }\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        self.lock().read_to_end(buf)\n    }\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        self.lock().read_to_string(buf)\n    }\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        self.lock().read_exact(buf)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Read for StdinLock<'a> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(buf)\n    }\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> BufRead for StdinLock<'a> {\n    fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }\n    fn consume(&mut self, n: usize) { self.inner.consume(n) }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<'a> fmt::Debug for StdinLock<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"StdinLock { .. }\")\n    }\n}\n\n/// A handle to the global standard output stream of the current process.\n///\n/// Each handle shares a global buffer of data to be written to the standard\n/// output stream. Access is also synchronized via a lock and explicit control\n/// over locking is available via the [`lock`] method.\n///\n/// Created by the [`io::stdout`] method.\n///\n/// [`lock`]: #method.lock\n/// [`io::stdout`]: fn.stdout.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Stdout {\n    // FIXME: this should be LineWriter or BufWriter depending on the state of\n    //        stdout (tty or not). Note that if this is not line buffered it\n    //        should also flush-on-panic or some form of flush-on-abort.\n    inner: Arc<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>>,\n}\n\n/// A locked reference to the `Stdout` handle.\n///\n/// This handle implements the [`Write`] trait, and is constructed via\n/// the [`Stdout::lock`] method.\n///\n/// [`Write`]: trait.Write.html\n/// [`Stdout::lock`]: struct.Stdout.html#method.lock\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct StdoutLock<'a> {\n    inner: ReentrantMutexGuard<'a, RefCell<LineWriter<Maybe<StdoutRaw>>>>,\n}\n\n/// Constructs a new handle to the standard output of the current process.\n///\n/// Each handle returned is a reference to a shared global buffer whose access\n/// is synchronized via a mutex. If you need more explicit control over\n/// locking, see the [Stdout::lock] method.\n///\n/// [Stdout::lock]: struct.Stdout.html#method.lock\n///\n/// # Examples\n///\n/// Using implicit synchronization:\n///\n/// ```\n/// use std::io::{self, Write};\n///\n/// # fn foo() -> io::Result<()> {\n/// io::stdout().write(b\"hello world\")?;\n///\n/// # Ok(())\n/// # }\n/// ```\n///\n/// Using explicit synchronization:\n///\n/// ```\n/// use std::io::{self, Write};\n///\n/// # fn foo() -> io::Result<()> {\n/// let stdout = io::stdout();\n/// let mut handle = stdout.lock();\n///\n/// handle.write(b\"hello world\")?;\n///\n/// # Ok(())\n/// # }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn stdout() -> Stdout {\n    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>>\n        = Lazy::new(stdout_init);\n    return Stdout {\n        inner: INSTANCE.get().expect(\"cannot access stdout during shutdown\"),\n    };\n\n    fn stdout_init() -> Arc<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>> {\n        let stdout = match stdout_raw() {\n            Ok(stdout) => Maybe::Real(stdout),\n            _ => Maybe::Fake,\n        };\n        Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout))))\n    }\n}\n\nimpl Stdout {\n    /// Locks this handle to the standard output stream, returning a writable\n    /// guard.\n    ///\n    /// The lock is released when the returned lock goes out of scope. The\n    /// returned guard also implements the `Write` trait for writing data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Write};\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let stdout = io::stdout();\n    /// let mut handle = stdout.lock();\n    ///\n    /// handle.write(b\"hello world\")?;\n    ///\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> StdoutLock {\n        StdoutLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stdout {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"Stdout { .. }\")\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.lock().write(buf)\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.lock().flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.lock().write_all(buf)\n    }\n    fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> {\n        self.lock().write_fmt(args)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Write for StdoutLock<'a> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.borrow_mut().write(buf)\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.borrow_mut().flush()\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<'a> fmt::Debug for StdoutLock<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"StdoutLock { .. }\")\n    }\n}\n\n/// A handle to the standard error stream of a process.\n///\n/// For more information, see the [`io::stderr`] method.\n///\n/// [`io::stderr`]: fn.stderr.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Stderr {\n    inner: Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>>,\n}\n\n/// A locked reference to the `Stderr` handle.\n///\n/// This handle implements the `Write` trait and is constructed via\n/// the [`Stderr::lock`] method.\n///\n/// [`Stderr::lock`]: struct.Stderr.html#method.lock\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct StderrLock<'a> {\n    inner: ReentrantMutexGuard<'a, RefCell<Maybe<StderrRaw>>>,\n}\n\n/// Constructs a new handle to the standard error of the current process.\n///\n/// This handle is not buffered.\n///\n/// # Examples\n///\n/// Using implicit synchronization:\n///\n/// ```\n/// use std::io::{self, Write};\n///\n/// # fn foo() -> io::Result<()> {\n/// io::stderr().write(b\"hello world\")?;\n///\n/// # Ok(())\n/// # }\n/// ```\n///\n/// Using explicit synchronization:\n///\n/// ```\n/// use std::io::{self, Write};\n///\n/// # fn foo() -> io::Result<()> {\n/// let stderr = io::stderr();\n/// let mut handle = stderr.lock();\n///\n/// handle.write(b\"hello world\")?;\n///\n/// # Ok(())\n/// # }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn stderr() -> Stderr {\n    static INSTANCE: Lazy<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> = Lazy::new(stderr_init);\n    return Stderr {\n        inner: INSTANCE.get().expect(\"cannot access stderr during shutdown\"),\n    };\n\n    fn stderr_init() -> Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> {\n        let stderr = match stderr_raw() {\n            Ok(stderr) => Maybe::Real(stderr),\n            _ => Maybe::Fake,\n        };\n        Arc::new(ReentrantMutex::new(RefCell::new(stderr)))\n    }\n}\n\nimpl Stderr {\n    /// Locks this handle to the standard error stream, returning a writable\n    /// guard.\n    ///\n    /// The lock is released when the returned lock goes out of scope. The\n    /// returned guard also implements the `Write` trait for writing data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Write};\n    ///\n    /// fn foo() -> io::Result<()> {\n    ///     let stderr = io::stderr();\n    ///     let mut handle = stderr.lock();\n    ///\n    ///     handle.write(b\"hello world\")?;\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> StderrLock {\n        StderrLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stderr {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"Stderr { .. }\")\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.lock().write(buf)\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.lock().flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.lock().write_all(buf)\n    }\n    fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> {\n        self.lock().write_fmt(args)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Write for StderrLock<'a> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.borrow_mut().write(buf)\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.borrow_mut().flush()\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<'a> fmt::Debug for StderrLock<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"StderrLock { .. }\")\n    }\n}\n\n/// Resets the thread-local stderr handle to the specified writer\n///\n/// This will replace the current thread's stderr handle, returning the old\n/// handle. All future calls to `panic!` and friends will emit their output to\n/// this specified handle.\n///\n/// Note that this does not need to be called for all new threads; the default\n/// output handle is to the process's stderr stream.\n#[unstable(feature = \"set_stdio\",\n           reason = \"this function may disappear completely or be replaced \\\n                     with a more general mechanism\",\n           issue = \"0\")]\n#[doc(hidden)]\npub fn set_panic(sink: Option<Box<Write + Send>>) -> Option<Box<Write + Send>> {\n    use panicking::LOCAL_STDERR;\n    use mem;\n    LOCAL_STDERR.with(move |slot| {\n        mem::replace(&mut *slot.borrow_mut(), sink)\n    }).and_then(|mut s| {\n        let _ = s.flush();\n        Some(s)\n    })\n}\n\n/// Resets the thread-local stdout handle to the specified writer\n///\n/// This will replace the current thread's stdout handle, returning the old\n/// handle. All future calls to `print!` and friends will emit their output to\n/// this specified handle.\n///\n/// Note that this does not need to be called for all new threads; the default\n/// output handle is to the process's stdout stream.\n#[unstable(feature = \"set_stdio\",\n           reason = \"this function may disappear completely or be replaced \\\n                     with a more general mechanism\",\n           issue = \"0\")]\n#[doc(hidden)]\npub fn set_print(sink: Option<Box<Write + Send>>) -> Option<Box<Write + Send>> {\n    use mem;\n    LOCAL_STDOUT.with(move |slot| {\n        mem::replace(&mut *slot.borrow_mut(), sink)\n    }).and_then(|mut s| {\n        let _ = s.flush();\n        Some(s)\n    })\n}\n\n/// Write `args` to output stream `local_s` if possible, `global_s`\n/// otherwise. `label` identifies the stream in a panic message.\n///\n/// This function is used to print error messages, so it takes extra\n/// care to avoid causing a panic when `local_stream` is unusable.\n/// For instance, if the TLS key for the local stream is uninitialized\n/// or already destroyed, or if the local stream is locked by another\n/// thread, it will just fall back to the global stream.\n///\n/// However, if the actual I/O causes an error, this function does panic.\nfn print_to<T>(args: fmt::Arguments,\n               local_s: &'static LocalKey<RefCell<Option<Box<Write+Send>>>>,\n               global_s: fn() -> T,\n               label: &str) where T: Write {\n    let result = match local_s.state() {\n        LocalKeyState::Uninitialized |\n        LocalKeyState::Destroyed => global_s().write_fmt(args),\n        LocalKeyState::Valid => {\n            local_s.with(|s| {\n                if let Ok(mut borrowed) = s.try_borrow_mut() {\n                    if let Some(w) = borrowed.as_mut() {\n                        return w.write_fmt(args);\n                    }\n                }\n                global_s().write_fmt(args)\n            })\n        }\n    };\n    if let Err(e) = result {\n        panic!(\"failed printing to {}: {}\", label, e);\n    }\n}\n\n#[unstable(feature = \"print_internals\",\n           reason = \"implementation detail which may disappear or be replaced at any time\",\n           issue = \"0\")]\n#[doc(hidden)]\npub fn _print(args: fmt::Arguments) {\n    print_to(args, &LOCAL_STDOUT, stdout, \"stdout\");\n}\n\n#[unstable(feature = \"print_internals\",\n           reason = \"implementation detail which may disappear or be replaced at any time\",\n           issue = \"0\")]\n#[doc(hidden)]\npub fn _eprint(args: fmt::Arguments) {\n    use panicking::LOCAL_STDERR;\n    print_to(args, &LOCAL_STDERR, stderr, \"stderr\");\n}\n\n#[cfg(test)]\nmod tests {\n    use thread;\n    use super::*;\n\n    #[test]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn panic_doesnt_poison() {\n        thread::spawn(|| {\n            let _a = stdin();\n            let _a = _a.lock();\n            let _a = stdout();\n            let _a = _a.lock();\n            let _a = stderr();\n            let _a = _a.lock();\n            panic!();\n        }).join().unwrap_err();\n\n        let _a = stdin();\n        let _a = _a.lock();\n        let _a = stdout();\n        let _a = _a.lock();\n        let _a = stderr();\n        let _a = _a.lock();\n    }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse fmt;\nuse marker;\nuse ops::Deref;\nuse sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\nuse sys::mutex as sys;\n\n/// A re-entrant mutual exclusion\n///\n/// This mutex will block *other* threads waiting for the lock to become\n/// available. The thread which has already locked the mutex can lock it\n/// multiple times without blocking, preventing a common source of deadlocks.\npub struct ReentrantMutex<T> {\n    inner: Box<sys::ReentrantMutex>,\n    poison: poison::Flag,\n    data: T,\n}\n\nunsafe impl<T: Send> Send for ReentrantMutex<T> {}\nunsafe impl<T: Send> Sync for ReentrantMutex<T> {}\n\n\n/// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n/// dropped (falls out of scope), the lock will be unlocked.\n///\n/// The data protected by the mutex can be accessed through this guard via its\n/// Deref implementation.\n///\n/// # Mutability\n///\n/// Unlike `MutexGuard`, `ReentrantMutexGuard` does not implement `DerefMut`,\n/// because implementation of the trait would violate Rusts reference aliasing\n/// rules. Use interior mutability (usually `RefCell`) in order to mutate the\n/// guarded data.\n#[must_use]\npub struct ReentrantMutexGuard<'a, T: 'a> {\n    // funny underscores due to how Deref currently works (it disregards field\n    // privacy).\n    __lock: &'a ReentrantMutex<T>,\n    __poison: poison::Guard,\n}\n\nimpl<'a, T> !marker::Send for ReentrantMutexGuard<'a, T> {}\n\n\nimpl<T> ReentrantMutex<T> {\n    /// Creates a new reentrant mutex in an unlocked state.\n    pub fn new(t: T) -> ReentrantMutex<T> {\n        unsafe {\n            let mut mutex = ReentrantMutex {\n                inner: box sys::ReentrantMutex::uninitialized(),\n                poison: poison::Flag::new(),\n                data: t,\n            };\n            mutex.inner.init();\n            mutex\n        }\n    }\n\n    /// Acquires a mutex, blocking the current thread until it is able to do so.\n    ///\n    /// This function will block the caller until it is available to acquire the mutex.\n    /// Upon returning, the thread is the only thread with the mutex held. When the thread\n    /// calling this method already holds the lock, the call shall succeed without\n    /// blocking.\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return failure if the mutex would otherwise be\n    /// acquired.\n    pub fn lock(&self) -> LockResult<ReentrantMutexGuard<T>> {\n        unsafe { self.inner.lock() }\n        ReentrantMutexGuard::new(&self)\n    }\n\n    /// Attempts to acquire this lock.\n    ///\n    /// If the lock could not be acquired at this time, then `Err` is returned.\n    /// Otherwise, an RAII guard is returned.\n    ///\n    /// This function does not block.\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return failure if the mutex would otherwise be\n    /// acquired.\n    pub fn try_lock(&self) -> TryLockResult<ReentrantMutexGuard<T>> {\n        if unsafe { self.inner.try_lock() } {\n            Ok(ReentrantMutexGuard::new(&self)?)\n        } else {\n            Err(TryLockError::WouldBlock)\n        }\n    }\n}\n\nimpl<T> Drop for ReentrantMutex<T> {\n    fn drop(&mut self) {\n        // This is actually safe b/c we know that there is no further usage of\n        // this mutex (it's up to the user to arrange for a mutex to get\n        // dropped, that's not our job)\n        unsafe { self.inner.destroy() }\n    }\n}\n\nimpl<T: fmt::Debug + 'static> fmt::Debug for ReentrantMutex<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self.try_lock() {\n            Ok(guard) => write!(f, \"ReentrantMutex {{ data: {:?} }}\", &*guard),\n            Err(TryLockError::Poisoned(err)) => {\n                write!(f, \"ReentrantMutex {{ data: Poisoned({:?}) }}\", &**err.get_ref())\n            },\n            Err(TryLockError::WouldBlock) => write!(f, \"ReentrantMutex {{ <locked> }}\")\n        }\n    }\n}\n\nimpl<'mutex, T> ReentrantMutexGuard<'mutex, T> {\n    fn new(lock: &'mutex ReentrantMutex<T>)\n            -> LockResult<ReentrantMutexGuard<'mutex, T>> {\n        poison::map_result(lock.poison.borrow(), |guard| {\n            ReentrantMutexGuard {\n                __lock: lock,\n                __poison: guard,\n            }\n        })\n    }\n}\n\nimpl<'mutex, T> Deref for ReentrantMutexGuard<'mutex, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.__lock.data\n    }\n}\n\nimpl<'a, T> Drop for ReentrantMutexGuard<'a, T> {\n    #[inline]\n    fn drop(&mut self) {\n        unsafe {\n            self.__lock.poison.done(&self.__poison);\n            self.__lock.inner.unlock();\n        }\n    }\n}\n\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n    use cell::RefCell;\n    use sync::Arc;\n    use thread;\n\n    #[test]\n    fn smoke() {\n        let m = ReentrantMutex::new(());\n        {\n            let a = m.lock().unwrap();\n            {\n                let b = m.lock().unwrap();\n                {\n                    let c = m.lock().unwrap();\n                    assert_eq!(*c, ());\n                }\n                assert_eq!(*b, ());\n            }\n            assert_eq!(*a, ());\n        }\n    }\n\n    #[test]\n    fn is_mutex() {\n        let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n        let m2 = m.clone();\n        let lock = m.lock().unwrap();\n        let child = thread::spawn(move || {\n            let lock = m2.lock().unwrap();\n            assert_eq!(*lock.borrow(), 4950);\n        });\n        for i in 0..100 {\n            let lock = m.lock().unwrap();\n            *lock.borrow_mut() += i;\n        }\n        drop(lock);\n        child.join().unwrap();\n    }\n\n    #[test]\n    fn trylock_works() {\n        let m = Arc::new(ReentrantMutex::new(()));\n        let m2 = m.clone();\n        let _lock = m.try_lock().unwrap();\n        let _lock2 = m.try_lock().unwrap();\n        thread::spawn(move || {\n            let lock = m2.try_lock();\n            assert!(lock.is_err());\n        }).join().unwrap();\n        let _lock3 = m.try_lock().unwrap();\n    }\n\n    pub struct Answer<'a>(pub ReentrantMutexGuard<'a, RefCell<u32>>);\n    impl<'a> Drop for Answer<'a> {\n        fn drop(&mut self) {\n            *self.0.borrow_mut() = 42;\n        }\n    }\n\n    #[test]\n    fn poison_works() {\n        let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n        let mc = m.clone();\n        let result = thread::spawn(move ||{\n            let lock = mc.lock().unwrap();\n            *lock.borrow_mut() = 1;\n            let lock2 = mc.lock().unwrap();\n            *lock.borrow_mut() = 2;\n            let _answer = Answer(lock2);\n            panic!(\"What the answer to my lifetimes dilemma is?\");\n        }).join();\n        assert!(result.is_err());\n        let r = m.lock().err().unwrap().into_inner();\n        assert_eq!(*r.borrow(), 42);\n    }\n}\n","// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Buffering wrappers for I/O traits\n\nuse io::prelude::*;\n\nuse cmp;\nuse error;\nuse fmt;\nuse io::{self, Initializer, DEFAULT_BUF_SIZE, Error, ErrorKind, SeekFrom};\nuse memchr;\n\n/// The `BufReader` struct adds buffering to any reader.\n///\n/// It can be excessively inefficient to work directly with a [`Read`] instance.\n/// For example, every call to [`read`][`TcpStream::read`] on [`TcpStream`]\n/// results in a system call. A `BufReader` performs large, infrequent reads on\n/// the underlying [`Read`] and maintains an in-memory buffer of the results.\n///\n/// [`Read`]: ../../std/io/trait.Read.html\n/// [`TcpStream::read`]: ../../std/net/struct.TcpStream.html#method.read\n/// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::io::BufReader;\n/// use std::fs::File;\n///\n/// # fn foo() -> std::io::Result<()> {\n/// let mut f = File::open(\"log.txt\")?;\n/// let mut reader = BufReader::new(f);\n///\n/// let mut line = String::new();\n/// let len = reader.read_line(&mut line)?;\n/// println!(\"First line is {} bytes long\", len);\n/// # Ok(())\n/// # }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct BufReader<R> {\n    inner: R,\n    buf: Box<[u8]>,\n    pos: usize,\n    cap: usize,\n}\n\nimpl<R: Read> BufReader<R> {\n    /// Creates a new `BufReader` with a default buffer capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut f = File::open(\"log.txt\")?;\n    /// let mut reader = BufReader::new(f);\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: R) -> BufReader<R> {\n        BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n    }\n\n    /// Creates a new `BufReader` with the specified buffer capacity.\n    ///\n    /// # Examples\n    ///\n    /// Creating a buffer with ten bytes of capacity:\n    ///\n    /// ```\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut f = File::open(\"log.txt\")?;\n    /// let mut reader = BufReader::with_capacity(10, f);\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(cap: usize, inner: R) -> BufReader<R> {\n        unsafe {\n            let mut buffer = Vec::with_capacity(cap);\n            buffer.set_len(cap);\n            inner.initializer().initialize(&mut buffer);\n            BufReader {\n                inner: inner,\n                buf: buffer.into_boxed_slice(),\n                pos: 0,\n                cap: 0,\n            }\n        }\n    }\n\n    /// Gets a reference to the underlying reader.\n    ///\n    /// It is inadvisable to directly read from the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut f1 = File::open(\"log.txt\")?;\n    /// let mut reader = BufReader::new(f1);\n    ///\n    /// let f2 = reader.get_ref();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &R { &self.inner }\n\n    /// Gets a mutable reference to the underlying reader.\n    ///\n    /// It is inadvisable to directly read from the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut f1 = File::open(\"log.txt\")?;\n    /// let mut reader = BufReader::new(f1);\n    ///\n    /// let f2 = reader.get_mut();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut R { &mut self.inner }\n\n    /// Unwraps this `BufReader`, returning the underlying reader.\n    ///\n    /// Note that any leftover data in the internal buffer is lost.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut f1 = File::open(\"log.txt\")?;\n    /// let mut reader = BufReader::new(f1);\n    ///\n    /// let f2 = reader.into_inner();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> R { self.inner }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> Read for BufReader<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }\n\n    // we can't skip unconditionally because of the large buffer case in read.\n    unsafe fn initializer(&self) -> Initializer {\n        self.inner.initializer()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> BufRead for BufReader<R> {\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        // If we've reached the end of our internal buffer then we need to fetch\n        // some more data from the underlying reader.\n        // Branch using `>=` instead of the more correct `==`\n        // to tell the compiler that the pos..cap slice is always valid.\n        if self.pos >= self.cap {\n            debug_assert!(self.pos == self.cap);\n            self.cap = self.inner.read(&mut self.buf)?;\n            self.pos = 0;\n        }\n        Ok(&self.buf[self.pos..self.cap])\n    }\n\n    fn consume(&mut self, amt: usize) {\n        self.pos = cmp::min(self.pos + amt, self.cap);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R> fmt::Debug for BufReader<R> where R: fmt::Debug {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_struct(\"BufReader\")\n            .field(\"reader\", &self.inner)\n            .field(\"buffer\", &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()))\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Seek> Seek for BufReader<R> {\n    /// Seek to an offset, in bytes, in the underlying reader.\n    ///\n    /// The position used for seeking with `SeekFrom::Current(_)` is the\n    /// position the underlying reader would be at if the `BufReader` had no\n    /// internal buffer.\n    ///\n    /// Seeking always discards the internal buffer, even if the seek position\n    /// would otherwise fall within it. This guarantees that calling\n    /// `.into_inner()` immediately after a seek yields the underlying reader\n    /// at the same position.\n    ///\n    /// See `std::io::Seek` for more details.\n    ///\n    /// Note: In the edge case where you're seeking with `SeekFrom::Current(n)`\n    /// where `n` minus the internal buffer length underflows an `i64`, two\n    /// seeks will be performed instead of one. If the second seek returns\n    /// `Err`, the underlying reader will be left at the same position it would\n    /// have if you seeked to `SeekFrom::Current(0)`.\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        let result: u64;\n        if let SeekFrom::Current(n) = pos {\n            let remainder = (self.cap - self.pos) as i64;\n            // it should be safe to assume that remainder fits within an i64 as the alternative\n            // means we managed to allocate 8 exbibytes and that's absurd.\n            // But it's not out of the realm of possibility for some weird underlying reader to\n            // support seeking by i64::min_value() so we need to handle underflow when subtracting\n            // remainder.\n            if let Some(offset) = n.checked_sub(remainder) {\n                result = self.inner.seek(SeekFrom::Current(offset))?;\n            } else {\n                // seek backwards by our remainder, and then by the offset\n                self.inner.seek(SeekFrom::Current(-remainder))?;\n                self.pos = self.cap; // empty the buffer\n                result = self.inner.seek(SeekFrom::Current(n))?;\n            }\n        } else {\n            // Seeking with Start/End doesn't care about our buffer length.\n            result = self.inner.seek(pos)?;\n        }\n        self.pos = self.cap; // empty the buffer\n        Ok(result)\n    }\n}\n\n/// Wraps a writer and buffers its output.\n///\n/// It can be excessively inefficient to work directly with something that\n/// implements [`Write`]. For example, every call to\n/// [`write`][`Tcpstream::write`] on [`TcpStream`] results in a system call. A\n/// `BufWriter` keeps an in-memory buffer of data and writes it to an underlying\n/// writer in large, infrequent batches.\n///\n/// The buffer will be written out when the writer is dropped.\n///\n/// # Examples\n///\n/// Let's write the numbers one through ten to a [`TcpStream`]:\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::net::TcpStream;\n///\n/// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n///\n/// for i in 1..10 {\n///     stream.write(&[i]).unwrap();\n/// }\n/// ```\n///\n/// Because we're not buffering, we write each one in turn, incurring the\n/// overhead of a system call per byte written. We can fix this with a\n/// `BufWriter`:\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::io::BufWriter;\n/// use std::net::TcpStream;\n///\n/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n///\n/// for i in 1..10 {\n///     stream.write(&[i]).unwrap();\n/// }\n/// ```\n///\n/// By wrapping the stream with a `BufWriter`, these ten writes are all grouped\n/// together by the buffer, and will all be written out in one system call when\n/// the `stream` is dropped.\n///\n/// [`Write`]: ../../std/io/trait.Write.html\n/// [`Tcpstream::write`]: ../../std/net/struct.TcpStream.html#method.write\n/// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct BufWriter<W: Write> {\n    inner: Option<W>,\n    buf: Vec<u8>,\n    // #30888: If the inner writer panics in a call to write, we don't want to\n    // write the buffered data a second time in BufWriter's destructor. This\n    // flag tells the Drop impl if it should skip the flush.\n    panicked: bool,\n}\n\n/// An error returned by `into_inner` which combines an error that\n/// happened while writing out the buffer, and the buffered writer object\n/// which may be used to recover from the condition.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::BufWriter;\n/// use std::net::TcpStream;\n///\n/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n///\n/// // do stuff with the stream\n///\n/// // we want to get our `TcpStream` back, so let's try:\n///\n/// let stream = match stream.into_inner() {\n///     Ok(s) => s,\n///     Err(e) => {\n///         // Here, e is an IntoInnerError\n///         panic!(\"An error occurred\");\n///     }\n/// };\n/// ```\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoInnerError<W>(W, Error);\n\nimpl<W: Write> BufWriter<W> {\n    /// Creates a new `BufWriter` with a default buffer capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: W) -> BufWriter<W> {\n        BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n    }\n\n    /// Creates a new `BufWriter` with the specified buffer capacity.\n    ///\n    /// # Examples\n    ///\n    /// Creating a buffer with a buffer of a hundred bytes.\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n    /// let mut buffer = BufWriter::with_capacity(100, stream);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(cap: usize, inner: W) -> BufWriter<W> {\n        BufWriter {\n            inner: Some(inner),\n            buf: Vec::with_capacity(cap),\n            panicked: false,\n        }\n    }\n\n    fn flush_buf(&mut self) -> io::Result<()> {\n        let mut written = 0;\n        let len = self.buf.len();\n        let mut ret = Ok(());\n        while written < len {\n            self.panicked = true;\n            let r = self.inner.as_mut().unwrap().write(&self.buf[written..]);\n            self.panicked = false;\n\n            match r {\n                Ok(0) => {\n                    ret = Err(Error::new(ErrorKind::WriteZero,\n                                         \"failed to write the buffered data\"));\n                    break;\n                }\n                Ok(n) => written += n,\n                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n                Err(e) => { ret = Err(e); break }\n\n            }\n        }\n        if written > 0 {\n            self.buf.drain(..written);\n        }\n        ret\n    }\n\n    /// Gets a reference to the underlying writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // we can use reference just like buffer\n    /// let reference = buffer.get_ref();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }\n\n    /// Gets a mutable reference to the underlying writer.\n    ///\n    /// It is inadvisable to directly write to the underlying writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // we can use reference just like buffer\n    /// let reference = buffer.get_mut();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }\n\n    /// Unwraps this `BufWriter`, returning the underlying writer.\n    ///\n    /// The buffer is written out before returning the writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // unwrap the TcpStream and flush the buffer\n    /// let stream = buffer.into_inner().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n        match self.flush_buf() {\n            Err(e) => Err(IntoInnerError(self, e)),\n            Ok(()) => Ok(self.inner.take().unwrap())\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> Write for BufWriter<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        if self.buf.len() + buf.len() > self.buf.capacity() {\n            self.flush_buf()?;\n        }\n        if buf.len() >= self.buf.capacity() {\n            self.panicked = true;\n            let r = self.inner.as_mut().unwrap().write(buf);\n            self.panicked = false;\n            r\n        } else {\n            Write::write(&mut self.buf, buf)\n        }\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.flush_buf().and_then(|()| self.get_mut().flush())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> fmt::Debug for BufWriter<W> where W: fmt::Debug {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_struct(\"BufWriter\")\n            .field(\"writer\", &self.inner.as_ref().unwrap())\n            .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write + Seek> Seek for BufWriter<W> {\n    /// Seek to the offset, in bytes, in the underlying writer.\n    ///\n    /// Seeking always writes out the internal buffer before seeking.\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        self.flush_buf().and_then(|_| self.get_mut().seek(pos))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> Drop for BufWriter<W> {\n    fn drop(&mut self) {\n        if self.inner.is_some() && !self.panicked {\n            // dtors should not panic, so we ignore a failed flush\n            let _r = self.flush_buf();\n        }\n    }\n}\n\nimpl<W> IntoInnerError<W> {\n    /// Returns the error which caused the call to `into_inner()` to fail.\n    ///\n    /// This error was returned when attempting to write the internal buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // do stuff with the stream\n    ///\n    /// // we want to get our `TcpStream` back, so let's try:\n    ///\n    /// let stream = match stream.into_inner() {\n    ///     Ok(s) => s,\n    ///     Err(e) => {\n    ///         // Here, e is an IntoInnerError, let's log the inner error.\n    ///         //\n    ///         // We'll just 'log' to stdout for this example.\n    ///         println!(\"{}\", e.error());\n    ///\n    ///         panic!(\"An unexpected error occurred.\");\n    ///     }\n    /// };\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn error(&self) -> &Error { &self.1 }\n\n    /// Returns the buffered writer instance which generated the error.\n    ///\n    /// The returned object can be used for error recovery, such as\n    /// re-inspecting the buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // do stuff with the stream\n    ///\n    /// // we want to get our `TcpStream` back, so let's try:\n    ///\n    /// let stream = match stream.into_inner() {\n    ///     Ok(s) => s,\n    ///     Err(e) => {\n    ///         // Here, e is an IntoInnerError, let's re-examine the buffer:\n    ///         let buffer = e.into_inner();\n    ///\n    ///         // do stuff to try to recover\n    ///\n    ///         // afterwards, let's just return the stream\n    ///         buffer.into_inner().unwrap()\n    ///     }\n    /// };\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> W { self.0 }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W> From<IntoInnerError<W>> for Error {\n    fn from(iie: IntoInnerError<W>) -> Error { iie.1 }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Send + fmt::Debug> error::Error for IntoInnerError<W> {\n    fn description(&self) -> &str {\n        error::Error::description(self.error())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W> fmt::Display for IntoInnerError<W> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.error().fmt(f)\n    }\n}\n\n/// Wraps a writer and buffers output to it, flushing whenever a newline\n/// (`0x0a`, `'\\n'`) is detected.\n///\n/// The [`BufWriter`][bufwriter] struct wraps a writer and buffers its output.\n/// But it only does this batched write when it goes out of scope, or when the\n/// internal buffer is full. Sometimes, you'd prefer to write each line as it's\n/// completed, rather than the entire buffer at once. Enter `LineWriter`. It\n/// does exactly that.\n///\n/// [bufwriter]: struct.BufWriter.html\n///\n/// If there's still a partial line in the buffer when the `LineWriter` is\n/// dropped, it will flush those contents.\n///\n/// # Examples\n///\n/// We can use `LineWriter` to write one line at a time, significantly\n/// reducing the number of actual writes to the file.\n///\n/// ```\n/// use std::fs::File;\n/// use std::io::prelude::*;\n/// use std::io::LineWriter;\n///\n/// # fn foo() -> std::io::Result<()> {\n/// let road_not_taken = b\"I shall be telling this with a sigh\n/// Somewhere ages and ages hence:\n/// Two roads diverged in a wood, and I -\n/// I took the one less traveled by,\n/// And that has made all the difference.\";\n///\n/// let file = File::create(\"poem.txt\")?;\n/// let mut file = LineWriter::new(file);\n///\n/// for &byte in road_not_taken.iter() {\n///    file.write(&[byte]).unwrap();\n/// }\n///\n/// // let's check we did the right thing.\n/// let mut file = File::open(\"poem.txt\")?;\n/// let mut contents = String::new();\n///\n/// file.read_to_string(&mut contents)?;\n///\n/// assert_eq!(contents.as_bytes(), &road_not_taken[..]);\n/// # Ok(())\n/// # }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct LineWriter<W: Write> {\n    inner: BufWriter<W>,\n    need_flush: bool,\n}\n\nimpl<W: Write> LineWriter<W> {\n    /// Creates a new `LineWriter`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let file = File::create(\"poem.txt\")?;\n    /// let file = LineWriter::new(file);\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: W) -> LineWriter<W> {\n        // Lines typically aren't that long, don't use a giant buffer\n        LineWriter::with_capacity(1024, inner)\n    }\n\n    /// Creates a new `LineWriter` with a specified capacity for the internal\n    /// buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let file = File::create(\"poem.txt\")?;\n    /// let file = LineWriter::with_capacity(100, file);\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(cap: usize, inner: W) -> LineWriter<W> {\n        LineWriter {\n            inner: BufWriter::with_capacity(cap, inner),\n            need_flush: false,\n        }\n    }\n\n    /// Gets a reference to the underlying writer.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let file = File::create(\"poem.txt\")?;\n    /// let file = LineWriter::new(file);\n    ///\n    /// let reference = file.get_ref();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &W { self.inner.get_ref() }\n\n    /// Gets a mutable reference to the underlying writer.\n    ///\n    /// Caution must be taken when calling methods on the mutable reference\n    /// returned as extra writes could corrupt the output stream.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let file = File::create(\"poem.txt\")?;\n    /// let mut file = LineWriter::new(file);\n    ///\n    /// // we can use reference just like file\n    /// let reference = file.get_mut();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut W { self.inner.get_mut() }\n\n    /// Unwraps this `LineWriter`, returning the underlying writer.\n    ///\n    /// The internal buffer is written out before returning the writer.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let file = File::create(\"poem.txt\")?;\n    ///\n    /// let writer: LineWriter<File> = LineWriter::new(file);\n    ///\n    /// let file: File = writer.into_inner()?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n        self.inner.into_inner().map_err(|IntoInnerError(buf, e)| {\n            IntoInnerError(LineWriter {\n                inner: buf,\n                need_flush: false,\n            }, e)\n        })\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> Write for LineWriter<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        if self.need_flush {\n            self.flush()?;\n        }\n\n        // Find the last newline character in the buffer provided. If found then\n        // we're going to write all the data up to that point and then flush,\n        // otherewise we just write the whole block to the underlying writer.\n        let i = match memchr::memrchr(b'\\n', buf) {\n            Some(i) => i,\n            None => return self.inner.write(buf),\n        };\n\n\n        // Ok, we're going to write a partial amount of the data given first\n        // followed by flushing the newline. After we've successfully written\n        // some data then we *must* report that we wrote that data, so future\n        // errors are ignored. We set our internal `need_flush` flag, though, in\n        // case flushing fails and we need to try it first next time.\n        let n = self.inner.write(&buf[..i + 1])?;\n        self.need_flush = true;\n        if self.flush().is_err() || n != i + 1 {\n            return Ok(n)\n        }\n\n        // At this point we successfully wrote `i + 1` bytes and flushed it out,\n        // meaning that the entire line is now flushed out on the screen. While\n        // we can attempt to finish writing the rest of the data provided.\n        // Remember though that we ignore errors here as we've successfully\n        // written data, so we need to report that.\n        match self.inner.write(&buf[i + 1..]) {\n            Ok(i) => Ok(n + i),\n            Err(_) => Ok(n),\n        }\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()?;\n        self.need_flush = false;\n        Ok(())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> fmt::Debug for LineWriter<W> where W: fmt::Debug {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_struct(\"LineWriter\")\n            .field(\"writer\", &self.inner.inner)\n            .field(\"buffer\",\n                   &format_args!(\"{}/{}\", self.inner.buf.len(), self.inner.buf.capacity()))\n            .finish()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use io::prelude::*;\n    use io::{self, BufReader, BufWriter, LineWriter, SeekFrom};\n    use sync::atomic::{AtomicUsize, Ordering};\n    use thread;\n    use test;\n\n    /// A dummy reader intended at testing short-reads propagation.\n    pub struct ShortReader {\n        lengths: Vec<usize>,\n    }\n\n    impl Read for ShortReader {\n        fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n            if self.lengths.is_empty() {\n                Ok(0)\n            } else {\n                Ok(self.lengths.remove(0))\n            }\n        }\n    }\n\n    #[test]\n    fn test_buffered_reader() {\n        let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n        let mut reader = BufReader::with_capacity(2, inner);\n\n        let mut buf = [0, 0, 0];\n        let nread = reader.read(&mut buf);\n        assert_eq!(nread.unwrap(), 3);\n        let b: &[_] = &[5, 6, 7];\n        assert_eq!(buf, b);\n\n        let mut buf = [0, 0];\n        let nread = reader.read(&mut buf);\n        assert_eq!(nread.unwrap(), 2);\n        let b: &[_] = &[0, 1];\n        assert_eq!(buf, b);\n\n        let mut buf = [0];\n        let nread = reader.read(&mut buf);\n        assert_eq!(nread.unwrap(), 1);\n        let b: &[_] = &[2];\n        assert_eq!(buf, b);\n\n        let mut buf = [0, 0, 0];\n        let nread = reader.read(&mut buf);\n        assert_eq!(nread.unwrap(), 1);\n        let b: &[_] = &[3, 0, 0];\n        assert_eq!(buf, b);\n\n        let nread = reader.read(&mut buf);\n        assert_eq!(nread.unwrap(), 1);\n        let b: &[_] = &[4, 0, 0];\n        assert_eq!(buf, b);\n\n        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    }\n\n    #[test]\n    fn test_buffered_reader_seek() {\n        let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n        let mut reader = BufReader::with_capacity(2, io::Cursor::new(inner));\n\n        assert_eq!(reader.seek(SeekFrom::Start(3)).ok(), Some(3));\n        assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n        assert_eq!(reader.seek(SeekFrom::Current(0)).ok(), Some(3));\n        assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n        assert_eq!(reader.seek(SeekFrom::Current(1)).ok(), Some(4));\n        assert_eq!(reader.fill_buf().ok(), Some(&[1, 2][..]));\n        reader.consume(1);\n        assert_eq!(reader.seek(SeekFrom::Current(-2)).ok(), Some(3));\n    }\n\n    #[test]\n    fn test_buffered_reader_seek_underflow() {\n        // gimmick reader that yields its position modulo 256 for each byte\n        struct PositionReader {\n            pos: u64\n        }\n        impl Read for PositionReader {\n            fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n                let len = buf.len();\n                for x in buf {\n                    *x = self.pos as u8;\n                    self.pos = self.pos.wrapping_add(1);\n                }\n                Ok(len)\n            }\n        }\n        impl Seek for PositionReader {\n            fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n                match pos {\n                    SeekFrom::Start(n) => {\n                        self.pos = n;\n                    }\n                    SeekFrom::Current(n) => {\n                        self.pos = self.pos.wrapping_add(n as u64);\n                    }\n                    SeekFrom::End(n) => {\n                        self.pos = u64::max_value().wrapping_add(n as u64);\n                    }\n                }\n                Ok(self.pos)\n            }\n        }\n\n        let mut reader = BufReader::with_capacity(5, PositionReader { pos: 0 });\n        assert_eq!(reader.fill_buf().ok(), Some(&[0, 1, 2, 3, 4][..]));\n        assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::max_value()-5));\n        assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n        // the following seek will require two underlying seeks\n        let expected = 9223372036854775802;\n        assert_eq!(reader.seek(SeekFrom::Current(i64::min_value())).ok(), Some(expected));\n        assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n        // seeking to 0 should empty the buffer.\n        assert_eq!(reader.seek(SeekFrom::Current(0)).ok(), Some(expected));\n        assert_eq!(reader.get_ref().pos, expected);\n    }\n\n    #[test]\n    fn test_buffered_writer() {\n        let inner = Vec::new();\n        let mut writer = BufWriter::with_capacity(2, inner);\n\n        writer.write(&[0, 1]).unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1]);\n\n        writer.write(&[2]).unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1]);\n\n        writer.write(&[3]).unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1]);\n\n        writer.flush().unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n\n        writer.write(&[4]).unwrap();\n        writer.write(&[5]).unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n\n        writer.write(&[6]).unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5]);\n\n        writer.write(&[7, 8]).unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8]);\n\n        writer.write(&[9, 10, 11]).unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n\n        writer.flush().unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn test_buffered_writer_inner_flushes() {\n        let mut w = BufWriter::with_capacity(3, Vec::new());\n        w.write(&[0, 1]).unwrap();\n        assert_eq!(*w.get_ref(), []);\n        let w = w.into_inner().unwrap();\n        assert_eq!(w, [0, 1]);\n    }\n\n    #[test]\n    fn test_buffered_writer_seek() {\n        let mut w = BufWriter::with_capacity(3, io::Cursor::new(Vec::new()));\n        w.write_all(&[0, 1, 2, 3, 4, 5]).unwrap();\n        w.write_all(&[6, 7]).unwrap();\n        assert_eq!(w.seek(SeekFrom::Current(0)).ok(), Some(8));\n        assert_eq!(&w.get_ref().get_ref()[..], &[0, 1, 2, 3, 4, 5, 6, 7][..]);\n        assert_eq!(w.seek(SeekFrom::Start(2)).ok(), Some(2));\n        w.write_all(&[8, 9]).unwrap();\n        assert_eq!(&w.into_inner().unwrap().into_inner()[..], &[0, 1, 8, 9, 4, 5, 6, 7]);\n    }\n\n    #[test]\n    fn test_read_until() {\n        let inner: &[u8] = &[0, 1, 2, 1, 0];\n        let mut reader = BufReader::with_capacity(2, inner);\n        let mut v = Vec::new();\n        reader.read_until(0, &mut v).unwrap();\n        assert_eq!(v, [0]);\n        v.truncate(0);\n        reader.read_until(2, &mut v).unwrap();\n        assert_eq!(v, [1, 2]);\n        v.truncate(0);\n        reader.read_until(1, &mut v).unwrap();\n        assert_eq!(v, [1]);\n        v.truncate(0);\n        reader.read_until(8, &mut v).unwrap();\n        assert_eq!(v, [0]);\n        v.truncate(0);\n        reader.read_until(9, &mut v).unwrap();\n        assert_eq!(v, []);\n    }\n\n    #[test]\n    fn test_line_buffer_fail_flush() {\n        // Issue #32085\n        struct FailFlushWriter<'a>(&'a mut Vec<u8>);\n\n        impl<'a> Write for FailFlushWriter<'a> {\n            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n                self.0.extend_from_slice(buf);\n                Ok(buf.len())\n            }\n            fn flush(&mut self) -> io::Result<()> {\n                Err(io::Error::new(io::ErrorKind::Other, \"flush failed\"))\n            }\n        }\n\n        let mut buf = Vec::new();\n        {\n            let mut writer = LineWriter::new(FailFlushWriter(&mut buf));\n            let to_write = b\"abc\\ndef\";\n            if let Ok(written) = writer.write(to_write) {\n                assert!(written < to_write.len(), \"didn't flush on new line\");\n                // PASS\n                return;\n            }\n        }\n        assert!(buf.is_empty(), \"write returned an error but wrote data\");\n    }\n\n    #[test]\n    fn test_line_buffer() {\n        let mut writer = LineWriter::new(Vec::new());\n        writer.write(&[0]).unwrap();\n        assert_eq!(*writer.get_ref(), []);\n        writer.write(&[1]).unwrap();\n        assert_eq!(*writer.get_ref(), []);\n        writer.flush().unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1]);\n        writer.write(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n']);\n        writer.flush().unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2]);\n        writer.write(&[3, b'\\n']).unwrap();\n        assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n']);\n    }\n\n    #[test]\n    fn test_read_line() {\n        let in_buf: &[u8] = b\"a\\nb\\nc\";\n        let mut reader = BufReader::with_capacity(2, in_buf);\n        let mut s = String::new();\n        reader.read_line(&mut s).unwrap();\n        assert_eq!(s, \"a\\n\");\n        s.truncate(0);\n        reader.read_line(&mut s).unwrap();\n        assert_eq!(s, \"b\\n\");\n        s.truncate(0);\n        reader.read_line(&mut s).unwrap();\n        assert_eq!(s, \"c\");\n        s.truncate(0);\n        reader.read_line(&mut s).unwrap();\n        assert_eq!(s, \"\");\n    }\n\n    #[test]\n    fn test_lines() {\n        let in_buf: &[u8] = b\"a\\nb\\nc\";\n        let reader = BufReader::with_capacity(2, in_buf);\n        let mut it = reader.lines();\n        assert_eq!(it.next().unwrap().unwrap(), \"a\".to_string());\n        assert_eq!(it.next().unwrap().unwrap(), \"b\".to_string());\n        assert_eq!(it.next().unwrap().unwrap(), \"c\".to_string());\n        assert!(it.next().is_none());\n    }\n\n    #[test]\n    fn test_short_reads() {\n        let inner = ShortReader{lengths: vec![0, 1, 2, 0, 1, 0]};\n        let mut reader = BufReader::new(inner);\n        let mut buf = [0, 0];\n        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n        assert_eq!(reader.read(&mut buf).unwrap(), 2);\n        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    }\n\n    #[test]\n    fn read_char_buffered() {\n        let buf = [195, 159];\n        let reader = BufReader::with_capacity(1, &buf[..]);\n        assert_eq!(reader.chars().next().unwrap().unwrap(), '');\n    }\n\n    #[test]\n    fn test_chars() {\n        let buf = [195, 159, b'a'];\n        let reader = BufReader::with_capacity(1, &buf[..]);\n        let mut it = reader.chars();\n        assert_eq!(it.next().unwrap().unwrap(), '');\n        assert_eq!(it.next().unwrap().unwrap(), 'a');\n        assert!(it.next().is_none());\n    }\n\n    #[test]\n    #[should_panic]\n    fn dont_panic_in_drop_on_panicked_flush() {\n        struct FailFlushWriter;\n\n        impl Write for FailFlushWriter {\n            fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }\n            fn flush(&mut self) -> io::Result<()> {\n                Err(io::Error::last_os_error())\n            }\n        }\n\n        let writer = FailFlushWriter;\n        let _writer = BufWriter::new(writer);\n\n        // If writer panics *again* due to the flush error then the process will\n        // abort.\n        panic!();\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn panic_in_write_doesnt_flush_in_drop() {\n        static WRITES: AtomicUsize = AtomicUsize::new(0);\n\n        struct PanicWriter;\n\n        impl Write for PanicWriter {\n            fn write(&mut self, _: &[u8]) -> io::Result<usize> {\n                WRITES.fetch_add(1, Ordering::SeqCst);\n                panic!();\n            }\n            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n        }\n\n        thread::spawn(|| {\n            let mut writer = BufWriter::new(PanicWriter);\n            let _ = writer.write(b\"hello world\");\n            let _ = writer.flush();\n        }).join().unwrap_err();\n\n        assert_eq!(WRITES.load(Ordering::SeqCst), 1);\n    }\n\n    #[bench]\n    fn bench_buffered_reader(b: &mut test::Bencher) {\n        b.iter(|| {\n            BufReader::new(io::empty())\n        });\n    }\n\n    #[bench]\n    fn bench_buffered_writer(b: &mut test::Bencher) {\n        b.iter(|| {\n            BufWriter::new(io::sink())\n        });\n    }\n\n    struct AcceptOneThenFail {\n        written: bool,\n        flushed: bool,\n    }\n\n    impl Write for AcceptOneThenFail {\n        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n            if !self.written {\n                assert_eq!(data, b\"a\\nb\\n\");\n                self.written = true;\n                Ok(data.len())\n            } else {\n                Err(io::Error::new(io::ErrorKind::NotFound, \"test\"))\n            }\n        }\n\n        fn flush(&mut self) -> io::Result<()> {\n            assert!(self.written);\n            assert!(!self.flushed);\n            self.flushed = true;\n            Err(io::Error::new(io::ErrorKind::Other, \"test\"))\n        }\n    }\n\n    #[test]\n    fn erroneous_flush_retried() {\n        let a = AcceptOneThenFail {\n            written: false,\n            flushed: false,\n        };\n\n        let mut l = LineWriter::new(a);\n        assert_eq!(l.write(b\"a\\nb\\na\").unwrap(), 4);\n        assert!(l.get_ref().written);\n        assert!(l.get_ref().flushed);\n        l.get_mut().flushed = false;\n\n        assert_eq!(l.write(b\"a\").unwrap_err().kind(), io::ErrorKind::Other)\n    }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n//\n// Original implementation taken from rust-memchr\n// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n\n/// A safe interface to `memchr`.\n///\n/// Returns the index corresponding to the first occurrence of `needle` in\n/// `haystack`, or `None` if one is not found.\n///\n/// memchr reduces to super-optimized machine code at around an order of\n/// magnitude faster than `haystack.iter().position(|&b| b == needle)`.\n/// (See benchmarks.)\n///\n/// # Example\n///\n/// This shows how to find the first position of a byte in a byte string.\n///\n/// ```ignore (cannot-doctest-private-modules)\n/// use memchr::memchr;\n///\n/// let haystack = b\"the quick brown fox\";\n/// assert_eq!(memchr(b'k', haystack), Some(8));\n/// ```\n#[inline]\npub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n    ::sys::memchr::memchr(needle, haystack)\n}\n\n/// A safe interface to `memrchr`.\n///\n/// Returns the index corresponding to the last occurrence of `needle` in\n/// `haystack`, or `None` if one is not found.\n///\n/// # Example\n///\n/// This shows how to find the last position of a byte in a byte string.\n///\n/// ```ignore (cannot-doctest-private-modules)\n/// use memchr::memrchr;\n///\n/// let haystack = b\"the quick brown fox\";\n/// assert_eq!(memrchr(b'o', haystack), Some(17));\n/// ```\n#[inline]\npub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n    ::sys::memchr::memrchr(needle, haystack)\n}\n\n#[cfg(test)]\nmod tests {\n    // test the implementations for the current plattform\n    use super::{memchr, memrchr};\n\n    #[test]\n    fn matches_one() {\n        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n    }\n\n    #[test]\n    fn matches_begin() {\n        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n    }\n\n    #[test]\n    fn matches_end() {\n        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n    }\n\n    #[test]\n    fn matches_nul() {\n        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n    }\n\n    #[test]\n    fn matches_past_nul() {\n        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n    }\n\n    #[test]\n    fn no_match_empty() {\n        assert_eq!(None, memchr(b'a', b\"\"));\n    }\n\n    #[test]\n    fn no_match() {\n        assert_eq!(None, memchr(b'a', b\"xyz\"));\n    }\n\n    #[test]\n    fn matches_one_reversed() {\n        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n    }\n\n    #[test]\n    fn matches_begin_reversed() {\n        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n    }\n\n    #[test]\n    fn matches_end_reversed() {\n        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n    }\n\n    #[test]\n    fn matches_nul_reversed() {\n        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n    }\n\n    #[test]\n    fn matches_past_nul_reversed() {\n        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n    }\n\n    #[test]\n    fn no_match_empty_reversed() {\n        assert_eq!(None, memrchr(b'a', b\"\"));\n    }\n\n    #[test]\n    fn no_match_reversed() {\n        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n    }\n\n    #[test]\n    fn each_alignment() {\n        let mut data = [1u8; 64];\n        let needle = 2;\n        let pos = 40;\n        data[pos] = needle;\n        for start in 0..16 {\n            assert_eq!(Some(pos - start), memchr(needle, &data[start..]));\n        }\n    }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n//\n// Original implementation taken from rust-memchr\n// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n\n#[allow(dead_code)]\npub mod fallback {\n    use cmp;\n    use mem;\n\n    const LO_U64: u64 = 0x0101010101010101;\n    const HI_U64: u64 = 0x8080808080808080;\n\n    // use truncation\n    const LO_USIZE: usize = LO_U64 as usize;\n    const HI_USIZE: usize = HI_U64 as usize;\n\n    /// Return `true` if `x` contains any zero byte.\n    ///\n    /// From *Matters Computational*, J. Arndt\n    ///\n    /// \"The idea is to subtract one from each of the bytes and then look for\n    /// bytes where the borrow propagated all the way to the most significant\n    /// bit.\"\n    #[inline]\n    fn contains_zero_byte(x: usize) -> bool {\n        x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n    }\n\n    #[cfg(target_pointer_width = \"32\")]\n    #[inline]\n    fn repeat_byte(b: u8) -> usize {\n        let mut rep = (b as usize) << 8 | b as usize;\n        rep = rep << 16 | rep;\n        rep\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[inline]\n    fn repeat_byte(b: u8) -> usize {\n        let mut rep = (b as usize) << 8 | b as usize;\n        rep = rep << 16 | rep;\n        rep = rep << 32 | rep;\n        rep\n    }\n\n    /// Return the first index matching the byte `a` in `text`.\n    pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n        // Scan for a single byte value by reading two `usize` words at a time.\n        //\n        // Split `text` in three parts\n        // - unaligned initial part, before the first word aligned address in text\n        // - body, scan by 2 words at a time\n        // - the last remaining part, < 2 word size\n        let len = text.len();\n        let ptr = text.as_ptr();\n        let usize_bytes = mem::size_of::<usize>();\n\n        // search up to an aligned boundary\n        let align = (ptr as usize) & (usize_bytes- 1);\n        let mut offset;\n        if align > 0 {\n            offset = cmp::min(usize_bytes - align, len);\n            if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n                return Some(index);\n            }\n        } else {\n            offset = 0;\n        }\n\n        // search the body of the text\n        let repeated_x = repeat_byte(x);\n\n        if len >= 2 * usize_bytes {\n            while offset <= len - 2 * usize_bytes {\n                unsafe {\n                    let u = *(ptr.offset(offset as isize) as *const usize);\n                    let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n\n                    // break if there is a matching byte\n                    let zu = contains_zero_byte(u ^ repeated_x);\n                    let zv = contains_zero_byte(v ^ repeated_x);\n                    if zu || zv {\n                        break;\n                    }\n                }\n                offset += usize_bytes * 2;\n            }\n        }\n\n        // find the byte after the point the body loop stopped\n        text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n    }\n\n    /// Return the last index matching the byte `a` in `text`.\n    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n        // Scan for a single byte value by reading two `usize` words at a time.\n        //\n        // Split `text` in three parts\n        // - unaligned tail, after the last word aligned address in text\n        // - body, scan by 2 words at a time\n        // - the first remaining bytes, < 2 word size\n        let len = text.len();\n        let ptr = text.as_ptr();\n        let usize_bytes = mem::size_of::<usize>();\n\n        // search to an aligned boundary\n        let end_align = (ptr as usize + len) & (usize_bytes - 1);\n        let mut offset;\n        if end_align > 0 {\n            offset = if end_align >= len { 0 } else { len - end_align };\n            if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n                return Some(offset + index);\n            }\n        } else {\n            offset = len;\n        }\n\n        // search the body of the text\n        let repeated_x = repeat_byte(x);\n\n        while offset >= 2 * usize_bytes {\n            unsafe {\n                let u = *(ptr.offset(offset as isize - 2 * usize_bytes as isize) as *const usize);\n                let v = *(ptr.offset(offset as isize - usize_bytes as isize) as *const usize);\n\n                // break if there is a matching byte\n                let zu = contains_zero_byte(u ^ repeated_x);\n                let zv = contains_zero_byte(v ^ repeated_x);\n                if zu || zv {\n                    break;\n                }\n            }\n            offset -= 2 * usize_bytes;\n        }\n\n        // find the byte before the point the body loop stopped\n        text[..offset].iter().rposition(|elt| *elt == x)\n    }\n\n    // test fallback implementations on all platforms\n    #[test]\n    fn matches_one() {\n        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n    }\n\n    #[test]\n    fn matches_begin() {\n        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n    }\n\n    #[test]\n    fn matches_end() {\n        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n    }\n\n    #[test]\n    fn matches_nul() {\n        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n    }\n\n    #[test]\n    fn matches_past_nul() {\n        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n    }\n\n    #[test]\n    fn no_match_empty() {\n        assert_eq!(None, memchr(b'a', b\"\"));\n    }\n\n    #[test]\n    fn no_match() {\n        assert_eq!(None, memchr(b'a', b\"xyz\"));\n    }\n\n    #[test]\n    fn matches_one_reversed() {\n        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n    }\n\n    #[test]\n    fn matches_begin_reversed() {\n        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n    }\n\n    #[test]\n    fn matches_end_reversed() {\n        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n    }\n\n    #[test]\n    fn matches_nul_reversed() {\n        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n    }\n\n    #[test]\n    fn matches_past_nul_reversed() {\n        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n    }\n\n    #[test]\n    fn no_match_empty_reversed() {\n        assert_eq!(None, memrchr(b'a', b\"\"));\n    }\n\n    #[test]\n    fn no_match_reversed() {\n        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n    }\n\n    #[test]\n    fn each_alignment_reversed() {\n        let mut data = [1u8; 64];\n        let needle = 2;\n        let pos = 40;\n        data[pos] = needle;\n        for start in 0..16 {\n            assert_eq!(Some(pos - start), memrchr(needle, &data[start..]));\n        }\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A \"once initialization\" primitive\n//!\n//! This primitive is meant to be used to run one-time initialization. An\n//! example use case would be for initializing an FFI library.\n\n// A \"once\" is a relatively simple primitive, and it's also typically provided\n// by the OS as well (see `pthread_once` or `InitOnceExecuteOnce`). The OS\n// primitives, however, tend to have surprising restrictions, such as the Unix\n// one doesn't allow an argument to be passed to the function.\n//\n// As a result, we end up implementing it ourselves in the standard library.\n// This also gives us the opportunity to optimize the implementation a bit which\n// should help the fast path on call sites. Consequently, let's explain how this\n// primitive works now!\n//\n// So to recap, the guarantees of a Once are that it will call the\n// initialization closure at most once, and it will never return until the one\n// that's running has finished running. This means that we need some form of\n// blocking here while the custom callback is running at the very least.\n// Additionally, we add on the restriction of **poisoning**. Whenever an\n// initialization closure panics, the Once enters a \"poisoned\" state which means\n// that all future calls will immediately panic as well.\n//\n// So to implement this, one might first reach for a `StaticMutex`, but those\n// unfortunately need to be deallocated (e.g. call `destroy()`) to free memory\n// on all OSes (some of the BSDs allocate memory for mutexes). It also gets a\n// lot harder with poisoning to figure out when the mutex needs to be\n// deallocated because it's not after the closure finishes, but after the first\n// successful closure finishes.\n//\n// All in all, this is instead implemented with atomics and lock-free\n// operations! Whee! Each `Once` has one word of atomic state, and this state is\n// CAS'd on to determine what to do. There are four possible state of a `Once`:\n//\n// * Incomplete - no initialization has run yet, and no thread is currently\n//                using the Once.\n// * Poisoned - some thread has previously attempted to initialize the Once, but\n//              it panicked, so the Once is now poisoned. There are no other\n//              threads currently accessing this Once.\n// * Running - some thread is currently attempting to run initialization. It may\n//             succeed, so all future threads need to wait for it to finish.\n//             Note that this state is accompanied with a payload, described\n//             below.\n// * Complete - initialization has completed and all future calls should finish\n//              immediately.\n//\n// With 4 states we need 2 bits to encode this, and we use the remaining bits\n// in the word we have allocated as a queue of threads waiting for the thread\n// responsible for entering the RUNNING state. This queue is just a linked list\n// of Waiter nodes which is monotonically increasing in size. Each node is\n// allocated on the stack, and whenever the running closure finishes it will\n// consume the entire queue and notify all waiters they should try again.\n//\n// You'll find a few more details in the implementation, but that's the gist of\n// it!\n\nuse fmt;\nuse marker;\nuse ptr;\nuse sync::atomic::{AtomicUsize, AtomicBool, Ordering};\nuse thread::{self, Thread};\n\n/// A synchronization primitive which can be used to run a one-time global\n/// initialization. Useful for one-time initialization for FFI or related\n/// functionality. This type can only be constructed with the [`ONCE_INIT`]\n/// value.\n///\n/// [`ONCE_INIT`]: constant.ONCE_INIT.html\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::{Once, ONCE_INIT};\n///\n/// static START: Once = ONCE_INIT;\n///\n/// START.call_once(|| {\n///     // run initialization here\n/// });\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Once {\n    // This `state` word is actually an encoded version of just a pointer to a\n    // `Waiter`, so we add the `PhantomData` appropriately.\n    state: AtomicUsize,\n    _marker: marker::PhantomData<*mut Waiter>,\n}\n\n// The `PhantomData` of a raw pointer removes these two auto traits, but we\n// enforce both below in the implementation so this should be safe to add.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl Sync for Once {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl Send for Once {}\n\n/// State yielded to the [`call_once_force`] method which can be used to query\n/// whether the [`Once`] was previously poisoned or not.\n///\n/// [`call_once_force`]: struct.Once.html#method.call_once_force\n/// [`Once`]: struct.Once.html\n#[unstable(feature = \"once_poison\", issue = \"33577\")]\n#[derive(Debug)]\npub struct OnceState {\n    poisoned: bool,\n}\n\n/// Initialization value for static [`Once`] values.\n///\n/// [`Once`]: struct.Once.html\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::{Once, ONCE_INIT};\n///\n/// static START: Once = ONCE_INIT;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const ONCE_INIT: Once = Once::new();\n\n// Four states that a Once can be in, encoded into the lower bits of `state` in\n// the Once structure.\nconst INCOMPLETE: usize = 0x0;\nconst POISONED: usize = 0x1;\nconst RUNNING: usize = 0x2;\nconst COMPLETE: usize = 0x3;\n\n// Mask to learn about the state. All other bits are the queue of waiters if\n// this is in the RUNNING state.\nconst STATE_MASK: usize = 0x3;\n\n// Representation of a node in the linked list of waiters in the RUNNING state.\nstruct Waiter {\n    thread: Option<Thread>,\n    signaled: AtomicBool,\n    next: *mut Waiter,\n}\n\n// Helper struct used to clean up after a closure call with a `Drop`\n// implementation to also run on panic.\nstruct Finish {\n    panicked: bool,\n    me: &'static Once,\n}\n\nimpl Once {\n    /// Creates a new `Once` value.\n    #[stable(feature = \"once_new\", since = \"1.2.0\")]\n    pub const fn new() -> Once {\n        Once {\n            state: AtomicUsize::new(INCOMPLETE),\n            _marker: marker::PhantomData,\n        }\n    }\n\n    /// Performs an initialization routine once and only once. The given closure\n    /// will be executed if this is the first time `call_once` has been called,\n    /// and otherwise the routine will *not* be invoked.\n    ///\n    /// This method will block the calling thread if another initialization\n    /// routine is currently running.\n    ///\n    /// When this function returns, it is guaranteed that some initialization\n    /// has run and completed (it may not be the closure specified). It is also\n    /// guaranteed that any memory writes performed by the executed closure can\n    /// be reliably observed by other threads at this point (there is a\n    /// happens-before relation between the closure and code executing after the\n    /// return).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Once, ONCE_INIT};\n    ///\n    /// static mut VAL: usize = 0;\n    /// static INIT: Once = ONCE_INIT;\n    ///\n    /// // Accessing a `static mut` is unsafe much of the time, but if we do so\n    /// // in a synchronized fashion (e.g. write once or read all) then we're\n    /// // good to go!\n    /// //\n    /// // This function will only call `expensive_computation` once, and will\n    /// // otherwise always return the value returned from the first invocation.\n    /// fn get_cached_val() -> usize {\n    ///     unsafe {\n    ///         INIT.call_once(|| {\n    ///             VAL = expensive_computation();\n    ///         });\n    ///         VAL\n    ///     }\n    /// }\n    ///\n    /// fn expensive_computation() -> usize {\n    ///     // ...\n    /// # 2\n    /// }\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// The closure `f` will only be executed once if this is called\n    /// concurrently amongst many threads. If that closure panics, however, then\n    /// it will *poison* this `Once` instance, causing all future invocations of\n    /// `call_once` to also panic.\n    ///\n    /// This is similar to [poisoning with mutexes][poison].\n    ///\n    /// [poison]: struct.Mutex.html#poisoning\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn call_once<F>(&'static self, f: F) where F: FnOnce() {\n        // Fast path, just see if we've completed initialization.\n        if self.state.load(Ordering::SeqCst) == COMPLETE {\n            return\n        }\n\n        let mut f = Some(f);\n        self.call_inner(false, &mut |_| f.take().unwrap()());\n    }\n\n    /// Performs the same function as [`call_once`] except ignores poisoning.\n    ///\n    /// [`call_once`]: struct.Once.html#method.call_once\n    ///\n    /// If this `Once` has been poisoned (some initialization panicked) then\n    /// this function will continue to attempt to call initialization functions\n    /// until one of them doesn't panic.\n    ///\n    /// The closure `f` is yielded a [`OnceState`] structure which can be used to query the\n    /// state of this `Once` (whether initialization has previously panicked or\n    /// not).\n    ///\n    /// [`OnceState`]: struct.OnceState.html\n    #[unstable(feature = \"once_poison\", issue = \"33577\")]\n    pub fn call_once_force<F>(&'static self, f: F) where F: FnOnce(&OnceState) {\n        // same as above, just with a different parameter to `call_inner`.\n        if self.state.load(Ordering::SeqCst) == COMPLETE {\n            return\n        }\n\n        let mut f = Some(f);\n        self.call_inner(true, &mut |p| {\n            f.take().unwrap()(&OnceState { poisoned: p })\n        });\n    }\n\n    // This is a non-generic function to reduce the monomorphization cost of\n    // using `call_once` (this isn't exactly a trivial or small implementation).\n    //\n    // Additionally, this is tagged with `#[cold]` as it should indeed be cold\n    // and it helps let LLVM know that calls to this function should be off the\n    // fast path. Essentially, this should help generate more straight line code\n    // in LLVM.\n    //\n    // Finally, this takes an `FnMut` instead of a `FnOnce` because there's\n    // currently no way to take an `FnOnce` and call it via virtual dispatch\n    // without some allocation overhead.\n    #[cold]\n    fn call_inner(&'static self,\n                  ignore_poisoning: bool,\n                  mut init: &mut FnMut(bool)) {\n        let mut state = self.state.load(Ordering::SeqCst);\n\n        'outer: loop {\n            match state {\n                // If we're complete, then there's nothing to do, we just\n                // jettison out as we shouldn't run the closure.\n                COMPLETE => return,\n\n                // If we're poisoned and we're not in a mode to ignore\n                // poisoning, then we panic here to propagate the poison.\n                POISONED if !ignore_poisoning => {\n                    panic!(\"Once instance has previously been poisoned\");\n                }\n\n                // Otherwise if we see a poisoned or otherwise incomplete state\n                // we will attempt to move ourselves into the RUNNING state. If\n                // we succeed, then the queue of waiters starts at null (all 0\n                // bits).\n                POISONED |\n                INCOMPLETE => {\n                    let old = self.state.compare_and_swap(state, RUNNING,\n                                                          Ordering::SeqCst);\n                    if old != state {\n                        state = old;\n                        continue\n                    }\n\n                    // Run the initialization routine, letting it know if we're\n                    // poisoned or not. The `Finish` struct is then dropped, and\n                    // the `Drop` implementation here is responsible for waking\n                    // up other waiters both in the normal return and panicking\n                    // case.\n                    let mut complete = Finish {\n                        panicked: true,\n                        me: self,\n                    };\n                    init(state == POISONED);\n                    complete.panicked = false;\n                    return\n                }\n\n                // All other values we find should correspond to the RUNNING\n                // state with an encoded waiter list in the more significant\n                // bits. We attempt to enqueue ourselves by moving us to the\n                // head of the list and bail out if we ever see a state that's\n                // not RUNNING.\n                _ => {\n                    assert!(state & STATE_MASK == RUNNING);\n                    let mut node = Waiter {\n                        thread: Some(thread::current()),\n                        signaled: AtomicBool::new(false),\n                        next: ptr::null_mut(),\n                    };\n                    let me = &mut node as *mut Waiter as usize;\n                    assert!(me & STATE_MASK == 0);\n\n                    while state & STATE_MASK == RUNNING {\n                        node.next = (state & !STATE_MASK) as *mut Waiter;\n                        let old = self.state.compare_and_swap(state,\n                                                              me | RUNNING,\n                                                              Ordering::SeqCst);\n                        if old != state {\n                            state = old;\n                            continue\n                        }\n\n                        // Once we've enqueued ourselves, wait in a loop.\n                        // Afterwards reload the state and continue with what we\n                        // were doing from before.\n                        while !node.signaled.load(Ordering::SeqCst) {\n                            thread::park();\n                        }\n                        state = self.state.load(Ordering::SeqCst);\n                        continue 'outer\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Once {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"Once { .. }\")\n    }\n}\n\nimpl Drop for Finish {\n    fn drop(&mut self) {\n        // Swap out our state with however we finished. We should only ever see\n        // an old state which was RUNNING.\n        let queue = if self.panicked {\n            self.me.state.swap(POISONED, Ordering::SeqCst)\n        } else {\n            self.me.state.swap(COMPLETE, Ordering::SeqCst)\n        };\n        assert_eq!(queue & STATE_MASK, RUNNING);\n\n        // Decode the RUNNING to a list of waiters, then walk that entire list\n        // and wake them up. Note that it is crucial that after we store `true`\n        // in the node it can be free'd! As a result we load the `thread` to\n        // signal ahead of time and then unpark it after the store.\n        unsafe {\n            let mut queue = (queue & !STATE_MASK) as *mut Waiter;\n            while !queue.is_null() {\n                let next = (*queue).next;\n                let thread = (*queue).thread.take().unwrap();\n                (*queue).signaled.store(true, Ordering::SeqCst);\n                thread.unpark();\n                queue = next;\n            }\n        }\n    }\n}\n\nimpl OnceState {\n    /// Returns whether the associated [`Once`] has been poisoned.\n    ///\n    /// Once an initalization routine for a [`Once`] has panicked it will forever\n    /// indicate to future forced initialization routines that it is poisoned.\n    ///\n    /// [`Once`]: struct.Once.html\n    #[unstable(feature = \"once_poison\", issue = \"33577\")]\n    pub fn poisoned(&self) -> bool {\n        self.poisoned\n    }\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use panic;\n    use sync::mpsc::channel;\n    use thread;\n    use super::Once;\n\n    #[test]\n    fn smoke_once() {\n        static O: Once = Once::new();\n        let mut a = 0;\n        O.call_once(|| a += 1);\n        assert_eq!(a, 1);\n        O.call_once(|| a += 1);\n        assert_eq!(a, 1);\n    }\n\n    #[test]\n    fn stampede_once() {\n        static O: Once = Once::new();\n        static mut RUN: bool = false;\n\n        let (tx, rx) = channel();\n        for _ in 0..10 {\n            let tx = tx.clone();\n            thread::spawn(move|| {\n                for _ in 0..4 { thread::yield_now() }\n                unsafe {\n                    O.call_once(|| {\n                        assert!(!RUN);\n                        RUN = true;\n                    });\n                    assert!(RUN);\n                }\n                tx.send(()).unwrap();\n            });\n        }\n\n        unsafe {\n            O.call_once(|| {\n                assert!(!RUN);\n                RUN = true;\n            });\n            assert!(RUN);\n        }\n\n        for _ in 0..10 {\n            rx.recv().unwrap();\n        }\n    }\n\n    #[test]\n    fn poison_bad() {\n        static O: Once = Once::new();\n\n        // poison the once\n        let t = panic::catch_unwind(|| {\n            O.call_once(|| panic!());\n        });\n        assert!(t.is_err());\n\n        // poisoning propagates\n        let t = panic::catch_unwind(|| {\n            O.call_once(|| {});\n        });\n        assert!(t.is_err());\n\n        // we can subvert poisoning, however\n        let mut called = false;\n        O.call_once_force(|p| {\n            called = true;\n            assert!(p.poisoned())\n        });\n        assert!(called);\n\n        // once any success happens, we stop propagating the poison\n        O.call_once(|| {});\n    }\n\n    #[test]\n    fn wait_for_force_to_finish() {\n        static O: Once = Once::new();\n\n        // poison the once\n        let t = panic::catch_unwind(|| {\n            O.call_once(|| panic!());\n        });\n        assert!(t.is_err());\n\n        // make sure someone's waiting inside the once via a force\n        let (tx1, rx1) = channel();\n        let (tx2, rx2) = channel();\n        let t1 = thread::spawn(move || {\n            O.call_once_force(|p| {\n                assert!(p.poisoned());\n                tx1.send(()).unwrap();\n                rx2.recv().unwrap();\n            });\n        });\n\n        rx1.recv().unwrap();\n\n        // put another waiter on the once\n        let t2 = thread::spawn(|| {\n            let mut called = false;\n            O.call_once(|| {\n                called = true;\n            });\n            assert!(!called);\n        });\n\n        tx2.send(()).unwrap();\n\n        assert!(t1.join().is_ok());\n        assert!(t2.join().is_ok());\n\n    }\n}\n","// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Global initialization and retreival of command line arguments.\n//!\n//! On some platforms these are stored during runtime startup,\n//! and on some they are retrieved from the system on demand.\n\n#![allow(dead_code)] // runtime init functions not used during testing\n\nuse ffi::OsString;\nuse marker::PhantomData;\nuse vec;\n\n/// One-time global initialization.\npub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n\n/// One-time global cleanup.\npub unsafe fn cleanup() { imp::cleanup() }\n\n/// Returns the command line arguments\npub fn args() -> Args {\n    imp::args()\n}\n\npub struct Args {\n    iter: vec::IntoIter<OsString>,\n    _dont_send_or_sync_me: PhantomData<*mut ()>,\n}\n\nimpl Args {\n    pub fn inner_debug(&self) -> &[OsString] {\n        self.iter.as_slice()\n    }\n}\n\nimpl Iterator for Args {\n    type Item = OsString;\n    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n}\n\nimpl ExactSizeIterator for Args {\n    fn len(&self) -> usize { self.iter.len() }\n}\n\nimpl DoubleEndedIterator for Args {\n    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n}\n\n#[cfg(any(target_os = \"linux\",\n          target_os = \"android\",\n          target_os = \"freebsd\",\n          target_os = \"dragonfly\",\n          target_os = \"bitrig\",\n          target_os = \"netbsd\",\n          target_os = \"openbsd\",\n          target_os = \"solaris\",\n          target_os = \"emscripten\",\n          target_os = \"haiku\",\n          target_os = \"fuchsia\"))]\nmod imp {\n    use os::unix::prelude::*;\n    use mem;\n    use ffi::{CStr, OsString};\n    use marker::PhantomData;\n    use libc;\n    use super::Args;\n\n    use sys_common::mutex::Mutex;\n\n    static mut GLOBAL_ARGS_PTR: usize = 0;\n    static LOCK: Mutex = Mutex::new();\n\n    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n        let args = (0..argc).map(|i| {\n            CStr::from_ptr(*argv.offset(i) as *const libc::c_char).to_bytes().to_vec()\n        }).collect();\n\n        LOCK.lock();\n        let ptr = get_global_ptr();\n        assert!((*ptr).is_none());\n        (*ptr) = Some(box args);\n        LOCK.unlock();\n    }\n\n    pub unsafe fn cleanup() {\n        LOCK.lock();\n        *get_global_ptr() = None;\n        LOCK.unlock();\n    }\n\n    pub fn args() -> Args {\n        let bytes = clone().unwrap_or(Vec::new());\n        let v: Vec<OsString> = bytes.into_iter().map(|v| {\n            OsStringExt::from_vec(v)\n        }).collect();\n        Args { iter: v.into_iter(), _dont_send_or_sync_me: PhantomData }\n    }\n\n    fn clone() -> Option<Vec<Vec<u8>>> {\n        unsafe {\n            LOCK.lock();\n            let ptr = get_global_ptr();\n            let ret = (*ptr).as_ref().map(|s| (**s).clone());\n            LOCK.unlock();\n            return ret\n        }\n    }\n\n    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n        unsafe { mem::transmute(&GLOBAL_ARGS_PTR) }\n    }\n\n}\n\n#[cfg(any(target_os = \"macos\",\n          target_os = \"ios\"))]\nmod imp {\n    use ffi::CStr;\n    use marker::PhantomData;\n    use libc;\n    use super::Args;\n\n    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n    }\n\n    pub fn cleanup() {\n    }\n\n    #[cfg(target_os = \"macos\")]\n    pub fn args() -> Args {\n        use os::unix::prelude::*;\n        extern {\n            // These functions are in crt_externs.h.\n            fn _NSGetArgc() -> *mut libc::c_int;\n            fn _NSGetArgv() -> *mut *mut *mut libc::c_char;\n        }\n\n        let vec = unsafe {\n            let (argc, argv) = (*_NSGetArgc() as isize,\n                                *_NSGetArgv() as *const *const libc::c_char);\n            (0.. argc as isize).map(|i| {\n                let bytes = CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec();\n                OsStringExt::from_vec(bytes)\n            }).collect::<Vec<_>>()\n        };\n        Args {\n            iter: vec.into_iter(),\n            _dont_send_or_sync_me: PhantomData,\n        }\n    }\n\n    // As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n    // and use underscores in their names - they're most probably\n    // are considered private and therefore should be avoided\n    // Here is another way to get arguments using Objective C\n    // runtime\n    //\n    // In general it looks like:\n    // res = Vec::new()\n    // let args = [[NSProcessInfo processInfo] arguments]\n    // for i in (0..[args count])\n    //      res.push([args objectAtIndex:i])\n    // res\n    #[cfg(target_os = \"ios\")]\n    pub fn args() -> Args {\n        use ffi::OsString;\n        use mem;\n        use str;\n\n        extern {\n            fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n            fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n        }\n\n        #[cfg(target_arch=\"aarch64\")]\n        extern {\n            fn objc_msgSend(obj: NsId, sel: Sel) -> NsId;\n            #[link_name=\"objc_msgSend\"]\n            fn objc_msgSend_ul(obj: NsId, sel: Sel, i: libc::c_ulong) -> NsId;\n        }\n\n        #[cfg(not(target_arch=\"aarch64\"))]\n        extern {\n            fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n            #[link_name=\"objc_msgSend\"]\n            fn objc_msgSend_ul(obj: NsId, sel: Sel, ...) -> NsId;\n        }\n\n        type Sel = *const libc::c_void;\n        type NsId = *const libc::c_void;\n\n        let mut res = Vec::new();\n\n        unsafe {\n            let process_info_sel = sel_registerName(\"processInfo\\0\".as_ptr());\n            let arguments_sel = sel_registerName(\"arguments\\0\".as_ptr());\n            let utf8_sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n            let count_sel = sel_registerName(\"count\\0\".as_ptr());\n            let object_at_sel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n\n            let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n            let info = objc_msgSend(klass, process_info_sel);\n            let args = objc_msgSend(info, arguments_sel);\n\n            let cnt: usize = mem::transmute(objc_msgSend(args, count_sel));\n            for i in 0..cnt {\n                let tmp = objc_msgSend_ul(args, object_at_sel, i as libc::c_ulong);\n                let utf_c_str: *const libc::c_char =\n                    mem::transmute(objc_msgSend(tmp, utf8_sel));\n                let bytes = CStr::from_ptr(utf_c_str).to_bytes();\n                res.push(OsString::from(str::from_utf8(bytes).unwrap()))\n            }\n        }\n\n        Args { iter: res.into_iter(), _dont_send_or_sync_me: PhantomData }\n    }\n}\n","// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n/// A version of the call operator that takes an immutable receiver.\n///\n/// # Examples\n///\n/// Closures automatically implement this trait, which allows them to be\n/// invoked. Note, however, that `Fn` takes an immutable reference to any\n/// captured variables. To take a mutable capture, implement [`FnMut`], and to\n/// consume the capture, implement [`FnOnce`].\n///\n/// [`FnMut`]: trait.FnMut.html\n/// [`FnOnce`]: trait.FnOnce.html\n///\n/// ```\n/// let square = |x| x * x;\n/// assert_eq!(square(5), 25);\n/// ```\n///\n/// Closures can also be passed to higher-level functions through a `Fn`\n/// parameter (or a `FnMut` or `FnOnce` parameter, which are supertraits of\n/// `Fn`).\n///\n/// ```\n/// fn call_with_one<F>(func: F) -> usize\n///     where F: Fn(usize) -> usize {\n///     func(1)\n/// }\n///\n/// let double = |x| x * 2;\n/// assert_eq!(call_with_one(double), 2);\n/// ```\n#[lang = \"fn\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[fundamental] // so that regex can rely that `&str: !FnMut`\npub trait Fn<Args> : FnMut<Args> {\n    /// This is called when the call operator is used.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n}\n\n/// A version of the call operator that takes a mutable receiver.\n///\n/// # Examples\n///\n/// Closures that mutably capture variables automatically implement this trait,\n/// which allows them to be invoked.\n///\n/// ```\n/// let mut x = 5;\n/// {\n///     let mut square_x = || x *= x;\n///     square_x();\n/// }\n/// assert_eq!(x, 25);\n/// ```\n///\n/// Closures can also be passed to higher-level functions through a `FnMut`\n/// parameter (or a `FnOnce` parameter, which is a supertrait of `FnMut`).\n///\n/// ```\n/// fn do_twice<F>(mut func: F)\n///     where F: FnMut()\n/// {\n///     func();\n///     func();\n/// }\n///\n/// let mut x: usize = 1;\n/// {\n///     let add_two_to_x = || x += 2;\n///     do_twice(add_two_to_x);\n/// }\n///\n/// assert_eq!(x, 5);\n/// ```\n#[lang = \"fn_mut\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[fundamental] // so that regex can rely that `&str: !FnMut`\npub trait FnMut<Args> : FnOnce<Args> {\n    /// This is called when the call operator is used.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n}\n\n/// A version of the call operator that takes a by-value receiver.\n///\n/// # Examples\n///\n/// By-value closures automatically implement this trait, which allows them to\n/// be invoked.\n///\n/// ```\n/// let x = 5;\n/// let square_x = move || x * x;\n/// assert_eq!(square_x(), 25);\n/// ```\n///\n/// By-value Closures can also be passed to higher-level functions through a\n/// `FnOnce` parameter.\n///\n/// ```\n/// fn consume_with_relish<F>(func: F)\n///     where F: FnOnce() -> String\n/// {\n///     // `func` consumes its captured variables, so it cannot be run more\n///     // than once\n///     println!(\"Consumed: {}\", func());\n///\n///     println!(\"Delicious!\");\n///\n///     // Attempting to invoke `func()` again will throw a `use of moved\n///     // value` error for `func`\n/// }\n///\n/// let x = String::from(\"x\");\n/// let consume_and_return_x = move || x;\n/// consume_with_relish(consume_and_return_x);\n///\n/// // `consume_and_return_x` can no longer be invoked at this point\n/// ```\n#[lang = \"fn_once\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[fundamental] // so that regex can rely that `&str: !FnMut`\npub trait FnOnce<Args> {\n    /// The returned type after the call operator is used.\n    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n    type Output;\n\n    /// This is called when the call operator is used.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n}\n\nmod impls {\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a,A,F:?Sized> Fn<A> for &'a F\n        where F : Fn<A>\n    {\n        extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n            (**self).call(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a,A,F:?Sized> FnMut<A> for &'a F\n        where F : Fn<A>\n    {\n        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n            (**self).call(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a,A,F:?Sized> FnOnce<A> for &'a F\n        where F : Fn<A>\n    {\n        type Output = F::Output;\n\n        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n            (*self).call(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a,A,F:?Sized> FnMut<A> for &'a mut F\n        where F : FnMut<A>\n    {\n        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n            (*self).call_mut(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a,A,F:?Sized> FnOnce<A> for &'a mut F\n        where F : FnMut<A>\n    {\n        type Output = F::Output;\n        extern \"rust-call\" fn call_once(mut self, args: A) -> F::Output {\n            (*self).call_mut(args)\n        }\n    }\n}\n","// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Runtime services\n//!\n//! The `rt` module provides a narrow set of runtime services,\n//! including the global heap (exported in `heap`) and unwinding and\n//! backtrace support. The APIs in this module are highly unstable,\n//! and should be considered as private implementation details for the\n//! time being.\n\n#![unstable(feature = \"rt\",\n            reason = \"this public module should not exist and is highly likely \\\n                      to disappear\",\n            issue = \"0\")]\n#![doc(hidden)]\n\n\n\n// Reexport some of our utilities which are expected by other crates.\npub use panicking::{begin_panic_new, begin_panic, begin_panic_fmt, update_panic_count};\n\n#[cfg(not(test))]\n#[lang = \"start\"]\nfn lang_start(main: fn(), argc: isize, argv: *const *const u8) -> isize {\n    use panic;\n    use sys;\n    use sys_common;\n    use sys_common::thread_info;\n    use thread::Thread;\n    #[cfg(not(feature = \"backtrace\"))]\n    use mem;\n\n    sys::init();\n\n    let failed = unsafe {\n        let main_guard = sys::thread::guard::init();\n        sys::stack_overflow::init();\n\n        // Next, set up the current Thread with the guard information we just\n        // created. Note that this isn't necessary in general for new threads,\n        // but we just do this to name the main thread and to give it correct\n        // info about the stack bounds.\n        let thread = Thread::new(Some(\"main\".to_owned()));\n        thread_info::set(main_guard, thread);\n\n        // Store our args if necessary in a squirreled away location\n        sys::args::init(argc, argv);\n\n        // Let's run some code!\n        #[cfg(feature = \"backtrace\")]\n        let res = panic::catch_unwind(|| {\n            ::sys_common::backtrace::__rust_begin_short_backtrace(main)\n        });\n        #[cfg(not(feature = \"backtrace\"))]\n        let res = panic::catch_unwind(mem::transmute::<_, fn()>(main));\n        sys_common::cleanup();\n        res.is_err()\n    };\n\n    if failed {\n        101\n    } else {\n        0\n    }\n}\n","// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse mem;\nuse ops::{self, Add, Sub};\nuse usize;\n\nuse super::{FusedIterator, TrustedLen};\n\n/// Objects that can be stepped over in both directions.\n///\n/// The `steps_between` function provides a way to efficiently compare\n/// two `Step` objects.\n#[unstable(feature = \"step_trait\",\n           reason = \"likely to be replaced by finer-grained traits\",\n           issue = \"42168\")]\npub trait Step: PartialOrd + Sized {\n    /// Steps `self` if possible.\n    fn step(&self, by: &Self) -> Option<Self>;\n\n    /// Returns the number of steps between two step objects. The count is\n    /// inclusive of `start` and exclusive of `end`.\n    ///\n    /// Returns `None` if it is not possible to calculate `steps_between`\n    /// without overflow.\n    fn steps_between(start: &Self, end: &Self, by: &Self) -> Option<usize>;\n\n    /// Same as `steps_between`, but with a `by` of 1\n    fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize>;\n\n    /// Tests whether this step is negative or not (going backwards)\n    fn is_negative(&self) -> bool;\n\n    /// Replaces this step with `1`, returning itself\n    fn replace_one(&mut self) -> Self;\n\n    /// Replaces this step with `0`, returning itself\n    fn replace_zero(&mut self) -> Self;\n\n    /// Adds one to this step, returning the result\n    fn add_one(&self) -> Self;\n\n    /// Subtracts one to this step, returning the result\n    fn sub_one(&self) -> Self;\n}\n\nmacro_rules! step_impl_unsigned {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"step_trait\",\n                   reason = \"likely to be replaced by finer-grained traits\",\n                   issue = \"42168\")]\n        impl Step for $t {\n            #[inline]\n            fn step(&self, by: &$t) -> Option<$t> {\n                (*self).checked_add(*by)\n            }\n            #[inline]\n            #[allow(trivial_numeric_casts)]\n            fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n                if *by == 0 { return None; }\n                if *start < *end {\n                    // Note: We assume $t <= usize here\n                    let diff = (*end - *start) as usize;\n                    let by = *by as usize;\n                    if diff % by > 0 {\n                        Some(diff / by + 1)\n                    } else {\n                        Some(diff / by)\n                    }\n                } else {\n                    Some(0)\n                }\n            }\n\n            #[inline]\n            fn is_negative(&self) -> bool {\n                false\n            }\n\n            #[inline]\n            fn replace_one(&mut self) -> Self {\n                mem::replace(self, 1)\n            }\n\n            #[inline]\n            fn replace_zero(&mut self) -> Self {\n                mem::replace(self, 0)\n            }\n\n            #[inline]\n            fn add_one(&self) -> Self {\n                Add::add(*self, 1)\n            }\n\n            #[inline]\n            fn sub_one(&self) -> Self {\n                Sub::sub(*self, 1)\n            }\n\n            #[inline]\n            fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize> {\n                Self::steps_between(start, end, &1)\n            }\n        }\n    )*)\n}\nmacro_rules! step_impl_signed {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"step_trait\",\n                   reason = \"likely to be replaced by finer-grained traits\",\n                   issue = \"42168\")]\n        impl Step for $t {\n            #[inline]\n            fn step(&self, by: &$t) -> Option<$t> {\n                (*self).checked_add(*by)\n            }\n            #[inline]\n            #[allow(trivial_numeric_casts)]\n            fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n                if *by == 0 { return None; }\n                let diff: usize;\n                let by_u: usize;\n                if *by > 0 {\n                    if *start >= *end {\n                        return Some(0);\n                    }\n                    // Note: We assume $t <= isize here\n                    // Use .wrapping_sub and cast to usize to compute the\n                    // difference that may not fit inside the range of isize.\n                    diff = (*end as isize).wrapping_sub(*start as isize) as usize;\n                    by_u = *by as usize;\n                } else {\n                    if *start <= *end {\n                        return Some(0);\n                    }\n                    diff = (*start as isize).wrapping_sub(*end as isize) as usize;\n                    by_u = (*by as isize).wrapping_mul(-1) as usize;\n                }\n                if diff % by_u > 0 {\n                    Some(diff / by_u + 1)\n                } else {\n                    Some(diff / by_u)\n                }\n            }\n\n            #[inline]\n            fn is_negative(&self) -> bool {\n                *self < 0\n            }\n\n            #[inline]\n            fn replace_one(&mut self) -> Self {\n                mem::replace(self, 1)\n            }\n\n            #[inline]\n            fn replace_zero(&mut self) -> Self {\n                mem::replace(self, 0)\n            }\n\n            #[inline]\n            fn add_one(&self) -> Self {\n                Add::add(*self, 1)\n            }\n\n            #[inline]\n            fn sub_one(&self) -> Self {\n                Sub::sub(*self, 1)\n            }\n\n            #[inline]\n            fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize> {\n                Self::steps_between(start, end, &1)\n            }\n        }\n    )*)\n}\n\nmacro_rules! step_impl_no_between {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"step_trait\",\n                   reason = \"likely to be replaced by finer-grained traits\",\n                   issue = \"42168\")]\n        impl Step for $t {\n            #[inline]\n            fn step(&self, by: &$t) -> Option<$t> {\n                (*self).checked_add(*by)\n            }\n            #[inline]\n            fn steps_between(_a: &$t, _b: &$t, _by: &$t) -> Option<usize> {\n                None\n            }\n\n            #[inline]\n            #[allow(unused_comparisons)]\n            fn is_negative(&self) -> bool {\n                *self < 0\n            }\n\n            #[inline]\n            fn replace_one(&mut self) -> Self {\n                mem::replace(self, 1)\n            }\n\n            #[inline]\n            fn replace_zero(&mut self) -> Self {\n                mem::replace(self, 0)\n            }\n\n            #[inline]\n            fn add_one(&self) -> Self {\n                Add::add(*self, 1)\n            }\n\n            #[inline]\n            fn sub_one(&self) -> Self {\n                Sub::sub(*self, 1)\n            }\n\n            #[inline]\n            fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize> {\n                Self::steps_between(start, end, &1)\n            }\n        }\n    )*)\n}\n\nstep_impl_unsigned!(usize u8 u16 u32);\nstep_impl_signed!(isize i8 i16 i32);\n#[cfg(target_pointer_width = \"64\")]\nstep_impl_unsigned!(u64);\n#[cfg(target_pointer_width = \"64\")]\nstep_impl_signed!(i64);\n// If the target pointer width is not 64-bits, we\n// assume here that it is less than 64-bits.\n#[cfg(not(target_pointer_width = \"64\"))]\nstep_impl_no_between!(u64 i64);\nstep_impl_no_between!(u128 i128);\n\nmacro_rules! range_exact_iter_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl ExactSizeIterator for ops::Range<$t> { }\n    )*)\n}\n\nmacro_rules! range_incl_exact_iter_impl {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"inclusive_range\",\n                   reason = \"recently added, follows RFC\",\n                   issue = \"28237\")]\n        impl ExactSizeIterator for ops::RangeInclusive<$t> { }\n    )*)\n}\n\nmacro_rules! range_trusted_len_impl {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl TrustedLen for ops::Range<$t> { }\n    )*)\n}\n\nmacro_rules! range_incl_trusted_len_impl {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"inclusive_range\",\n                   reason = \"recently added, follows RFC\",\n                   issue = \"28237\")]\n        unsafe impl TrustedLen for ops::RangeInclusive<$t> { }\n    )*)\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Step> Iterator for ops::Range<A> where\n    for<'a> &'a A: Add<&'a A, Output = A>\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        if self.start < self.end {\n            let mut n = self.start.add_one();\n            mem::swap(&mut n, &mut self.start);\n            Some(n)\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match Step::steps_between_by_one(&self.start, &self.end) {\n            Some(hint) => (hint, Some(hint)),\n            None => (0, None)\n        }\n    }\n}\n\n// These macros generate `ExactSizeIterator` impls for various range types.\n// Range<{u,i}64> and RangeInclusive<{u,i}{32,64,size}> are excluded\n// because they cannot guarantee having a length <= usize::MAX, which is\n// required by ExactSizeIterator.\nrange_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\nrange_incl_exact_iter_impl!(u8 u16 i8 i16);\n\n// These macros generate `TrustedLen` impls.\n//\n// They need to guarantee that .size_hint() is either exact, or that\n// the upper bound is None when it does not fit the type limits.\nrange_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 i64 u64);\nrange_incl_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 i64 u64);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Step + Clone> DoubleEndedIterator for ops::Range<A> where\n    for<'a> &'a A: Add<&'a A, Output = A>,\n    for<'a> &'a A: Sub<&'a A, Output = A>\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<A> {\n        if self.start < self.end {\n            self.end = self.end.sub_one();\n            Some(self.end.clone())\n        } else {\n            None\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<A> FusedIterator for ops::Range<A>\n    where A: Step, for<'a> &'a A: Add<&'a A, Output = A> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Step> Iterator for ops::RangeFrom<A> where\n    for<'a> &'a A: Add<&'a A, Output = A>\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        let mut n = self.start.add_one();\n        mem::swap(&mut n, &mut self.start);\n        Some(n)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::MAX, None)\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<A> FusedIterator for ops::RangeFrom<A>\n    where A: Step, for<'a> &'a A: Add<&'a A, Output = A> {}\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<A: Step> Iterator for ops::RangeInclusive<A> where\n    for<'a> &'a A: Add<&'a A, Output = A>\n{\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        use cmp::Ordering::*;\n\n        match self.start.partial_cmp(&self.end) {\n            Some(Less) => {\n                let n = self.start.add_one();\n                Some(mem::replace(&mut self.start, n))\n            },\n            Some(Equal) => {\n                let last = self.start.replace_one();\n                self.end.replace_zero();\n                Some(last)\n            },\n            _ => None,\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if !(self.start <= self.end) {\n            return (0, Some(0));\n        }\n\n        match Step::steps_between_by_one(&self.start, &self.end) {\n            Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n            None => (0, None),\n        }\n    }\n}\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> where\n    for<'a> &'a A: Add<&'a A, Output = A>,\n    for<'a> &'a A: Sub<&'a A, Output = A>\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<A> {\n        use cmp::Ordering::*;\n\n        match self.start.partial_cmp(&self.end) {\n            Some(Less) => {\n                let n = self.end.sub_one();\n                Some(mem::replace(&mut self.end, n))\n            },\n            Some(Equal) => {\n                let last = self.end.replace_zero();\n                self.start.replace_one();\n                Some(last)\n            },\n            _ => None,\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<A> FusedIterator for ops::RangeInclusive<A>\n    where A: Step, for<'a> &'a A: Add<&'a A, Output = A> {}\n","// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Unwinding for emscripten\n//!\n//! Whereas Rust's usual unwinding implementation for Unix platforms\n//! calls into the libunwind APIs directly, on emscripten we instead\n//! call into the C++ unwinding APIs. This is just an expedience since\n//! emscripten's runtime always implements those APIs and does not\n//! implement libunwind.\n\n#![allow(private_no_mangle_fns)]\n\nuse core::any::Any;\nuse core::ptr;\nuse alloc::boxed::Box;\nuse libc::{self, c_int};\nuse unwind as uw;\nuse core::mem;\n\npub fn payload() -> *mut u8 {\n    ptr::null_mut()\n}\n\npub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {\n    assert!(!ptr.is_null());\n    let ex = ptr::read(ptr as *mut _);\n    __cxa_free_exception(ptr as *mut _);\n    ex\n}\n\npub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n    let sz = mem::size_of_val(&data);\n    let exception = __cxa_allocate_exception(sz);\n    if exception == ptr::null_mut() {\n        return uw::_URC_FATAL_PHASE1_ERROR as u32;\n    }\n    let exception = exception as *mut Box<Any + Send>;\n    ptr::write(exception, data);\n    __cxa_throw(exception as *mut _, ptr::null_mut(), ptr::null_mut());\n\n    unreachable!()\n}\n\n#[lang = \"eh_personality\"]\n#[no_mangle]\nunsafe extern \"C\" fn rust_eh_personality(version: c_int,\n                                         actions: uw::_Unwind_Action,\n                                         exception_class: uw::_Unwind_Exception_Class,\n                                         exception_object: *mut uw::_Unwind_Exception,\n                                         context: *mut uw::_Unwind_Context)\n                                         -> uw::_Unwind_Reason_Code {\n    __gxx_personality_v0(version, actions, exception_class, exception_object, context)\n}\n\nextern \"C\" {\n    fn __cxa_allocate_exception(thrown_size: libc::size_t) -> *mut libc::c_void;\n    fn __cxa_free_exception(thrown_exception: *mut libc::c_void);\n    fn __cxa_throw(thrown_exception: *mut libc::c_void,\n                   tinfo: *mut libc::c_void,\n                   dest: *mut libc::c_void);\n    fn __gxx_personality_v0(version: c_int,\n                            actions: uw::_Unwind_Action,\n                            exception_class: uw::_Unwind_Exception_Class,\n                            exception_object: *mut uw::_Unwind_Exception,\n                            context: *mut uw::_Unwind_Context)\n                            -> uw::_Unwind_Reason_Code;\n}\n","// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of panics via stack unwinding\n//!\n//! This crate is an implementation of panics in Rust using \"most native\" stack\n//! unwinding mechanism of the platform this is being compiled for. This\n//! essentially gets categorized into three buckets currently:\n//!\n//! 1. MSVC targets use SEH in the `seh.rs` file.\n//! 2. The 64-bit MinGW target half-uses SEH and half-use gcc-like information\n//!    in the `seh64_gnu.rs` module.\n//! 3. All other targets use libunwind/libgcc in the `gcc/mod.rs` module.\n//!\n//! More documentation about each implementation can be found in the respective\n//! module.\n\n#![no_std]\n#![crate_name = \"panic_unwind\"]\n#![crate_type = \"rlib\"]\n#![unstable(feature = \"panic_unwind\", issue = \"32837\")]\n#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n       issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n#![deny(warnings)]\n\n#![feature(alloc)]\n#![feature(core_intrinsics)]\n#![feature(lang_items)]\n#![feature(libc)]\n#![feature(panic_unwind)]\n#![feature(raw)]\n#![feature(staged_api)]\n#![feature(unwind_attributes)]\n#![cfg_attr(target_env = \"msvc\", feature(raw))]\n\n#![panic_runtime]\n#![feature(panic_runtime)]\n\nextern crate alloc;\nextern crate libc;\nextern crate unwind;\n\nuse core::intrinsics;\nuse core::mem;\nuse core::raw;\n\n// Rust runtime's startup objects depend on these symbols, so make them public.\n#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\npub use imp::eh_frame_registry::*;\n\n// *-pc-windows-msvc\n#[cfg(target_env = \"msvc\")]\n#[path = \"seh.rs\"]\nmod imp;\n\n// x86_64-pc-windows-gnu\n#[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))]\n#[path = \"seh64_gnu.rs\"]\nmod imp;\n\n// i686-pc-windows-gnu and all others\n#[cfg(any(all(unix, not(target_os = \"emscripten\")),\n          target_os = \"redox\",\n          all(windows, target_arch = \"x86\", target_env = \"gnu\")))]\n#[path = \"gcc.rs\"]\nmod imp;\n\n// emscripten\n#[cfg(target_os = \"emscripten\")]\n#[path = \"emcc.rs\"]\nmod imp;\n\nmod dwarf;\nmod windows;\n\n// Entry point for catching an exception, implemented using the `try` intrinsic\n// in the compiler.\n//\n// The interaction between the `payload` function and the compiler is pretty\n// hairy and tightly coupled, for more information see the compiler's\n// implementation of this.\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n                                                  data: *mut u8,\n                                                  data_ptr: *mut usize,\n                                                  vtable_ptr: *mut usize)\n                                                  -> u32 {\n    let mut payload = imp::payload();\n    if intrinsics::try(f, data, &mut payload as *mut _ as *mut _) == 0 {\n        0\n    } else {\n        let obj = mem::transmute::<_, raw::TraitObject>(imp::cleanup(payload));\n        *data_ptr = obj.data as usize;\n        *vtable_ptr = obj.vtable as usize;\n        1\n    }\n}\n\n// Entry point for raising an exception, just delegates to the platform-specific\n// implementation.\n#[no_mangle]\n#[unwind]\npub unsafe extern \"C\" fn __rust_start_panic(data: usize, vtable: usize) -> u32 {\n    imp::panic(mem::transmute(raw::TraitObject {\n        data: data as *mut (),\n        vtable: vtable as *mut (),\n    }))\n}\n","// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![allow(bad_style)]\n\nmacro_rules! cfg_if {\n    ( $( if #[cfg( $meta:meta )] { $($it1:item)* } else { $($it2:item)* } )* ) =>\n        ( $( $( #[cfg($meta)] $it1)* $( #[cfg(not($meta))] $it2)* )* )\n}\n\nuse libc::{c_int, c_void, uintptr_t};\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone, PartialEq)]\npub enum _Unwind_Reason_Code {\n    _URC_NO_REASON = 0,\n    _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n    _URC_FATAL_PHASE2_ERROR = 2,\n    _URC_FATAL_PHASE1_ERROR = 3,\n    _URC_NORMAL_STOP = 4,\n    _URC_END_OF_STACK = 5,\n    _URC_HANDLER_FOUND = 6,\n    _URC_INSTALL_CONTEXT = 7,\n    _URC_CONTINUE_UNWIND = 8,\n    _URC_FAILURE = 9, // used only by ARM EHABI\n}\npub use self::_Unwind_Reason_Code::*;\n\npub type _Unwind_Exception_Class = u64;\npub type _Unwind_Word = uintptr_t;\npub type _Unwind_Ptr = uintptr_t;\npub type _Unwind_Trace_Fn = extern \"C\" fn(ctx: *mut _Unwind_Context, arg: *mut c_void)\n                                          -> _Unwind_Reason_Code;\n#[cfg(target_arch = \"x86\")]\npub const unwinder_private_data_size: usize = 5;\n\n#[cfg(target_arch = \"x86_64\")]\npub const unwinder_private_data_size: usize = 6;\n\n#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]\npub const unwinder_private_data_size: usize = 20;\n\n#[cfg(all(target_arch = \"arm\", target_os = \"ios\"))]\npub const unwinder_private_data_size: usize = 5;\n\n#[cfg(target_arch = \"aarch64\")]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(target_arch = \"mips\")]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(target_arch = \"mips64\")]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(target_arch = \"s390x\")]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(target_arch = \"sparc64\")]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(target_os = \"emscripten\")]\npub const unwinder_private_data_size: usize = 20;\n\n#[repr(C)]\npub struct _Unwind_Exception {\n    pub exception_class: _Unwind_Exception_Class,\n    pub exception_cleanup: _Unwind_Exception_Cleanup_Fn,\n    pub private: [_Unwind_Word; unwinder_private_data_size],\n}\n\npub enum _Unwind_Context {}\n\npub type _Unwind_Exception_Cleanup_Fn = extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n                                                      exception: *mut _Unwind_Exception);\nextern \"C\" {\n    #[unwind]\n    pub fn _Unwind_Resume(exception: *mut _Unwind_Exception) -> !;\n    pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);\n    pub fn _Unwind_GetLanguageSpecificData(ctx: *mut _Unwind_Context) -> *mut c_void;\n    pub fn _Unwind_GetRegionStart(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n    pub fn _Unwind_GetTextRelBase(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n    pub fn _Unwind_GetDataRelBase(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n}\n\ncfg_if! {\nif #[cfg(not(any(all(target_os = \"android\", target_arch = \"arm\"),\n                 all(target_os = \"linux\", target_arch = \"arm\"))))] {\n    // Not ARM EHABI\n    #[repr(C)]\n    #[derive(Copy, Clone, PartialEq)]\n    pub enum _Unwind_Action {\n        _UA_SEARCH_PHASE = 1,\n        _UA_CLEANUP_PHASE = 2,\n        _UA_HANDLER_FRAME = 4,\n        _UA_FORCE_UNWIND = 8,\n        _UA_END_OF_STACK = 16,\n    }\n    pub use self::_Unwind_Action::*;\n\n    extern \"C\" {\n        pub fn _Unwind_GetGR(ctx: *mut _Unwind_Context, reg_index: c_int) -> _Unwind_Word;\n        pub fn _Unwind_SetGR(ctx: *mut _Unwind_Context, reg_index: c_int, value: _Unwind_Word);\n        pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> _Unwind_Word;\n        pub fn _Unwind_SetIP(ctx: *mut _Unwind_Context, value: _Unwind_Word);\n        pub fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context, ip_before_insn: *mut c_int)\n                                 -> _Unwind_Word;\n        pub fn _Unwind_FindEnclosingFunction(pc: *mut c_void) -> *mut c_void;\n    }\n\n} else {\n    // ARM EHABI\n    #[repr(C)]\n    #[derive(Copy, Clone, PartialEq)]\n    pub enum _Unwind_State {\n        _US_VIRTUAL_UNWIND_FRAME = 0,\n        _US_UNWIND_FRAME_STARTING = 1,\n        _US_UNWIND_FRAME_RESUME = 2,\n        _US_ACTION_MASK = 3,\n        _US_FORCE_UNWIND = 8,\n        _US_END_OF_STACK = 16,\n    }\n    pub use self::_Unwind_State::*;\n\n    #[repr(C)]\n    enum _Unwind_VRS_Result {\n        _UVRSR_OK = 0,\n        _UVRSR_NOT_IMPLEMENTED = 1,\n        _UVRSR_FAILED = 2,\n    }\n    #[repr(C)]\n    enum _Unwind_VRS_RegClass {\n        _UVRSC_CORE = 0,\n        _UVRSC_VFP = 1,\n        _UVRSC_FPA = 2,\n        _UVRSC_WMMXD = 3,\n        _UVRSC_WMMXC = 4,\n    }\n    use self::_Unwind_VRS_RegClass::*;\n    #[repr(C)]\n    enum _Unwind_VRS_DataRepresentation {\n        _UVRSD_UINT32 = 0,\n        _UVRSD_VFPX = 1,\n        _UVRSD_FPAX = 2,\n        _UVRSD_UINT64 = 3,\n        _UVRSD_FLOAT = 4,\n        _UVRSD_DOUBLE = 5,\n    }\n    use self::_Unwind_VRS_DataRepresentation::*;\n\n    pub const UNWIND_POINTER_REG: c_int = 12;\n    pub const UNWIND_IP_REG: c_int = 15;\n\n    extern \"C\" {\n        fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n                           regclass: _Unwind_VRS_RegClass,\n                           regno: _Unwind_Word,\n                           repr: _Unwind_VRS_DataRepresentation,\n                           data: *mut c_void)\n                           -> _Unwind_VRS_Result;\n\n        fn _Unwind_VRS_Set(ctx: *mut _Unwind_Context,\n                           regclass: _Unwind_VRS_RegClass,\n                           regno: _Unwind_Word,\n                           repr: _Unwind_VRS_DataRepresentation,\n                           data: *mut c_void)\n                           -> _Unwind_VRS_Result;\n    }\n\n    // On Android or ARM/Linux, these are implemented as macros:\n\n    pub unsafe fn _Unwind_GetGR(ctx: *mut _Unwind_Context, reg_index: c_int) -> _Unwind_Word {\n        let mut val: _Unwind_Word = 0;\n        _Unwind_VRS_Get(ctx, _UVRSC_CORE, reg_index as _Unwind_Word, _UVRSD_UINT32,\n                        &mut val as *mut _ as *mut c_void);\n        val\n    }\n\n    pub unsafe fn _Unwind_SetGR(ctx: *mut _Unwind_Context, reg_index: c_int, value: _Unwind_Word) {\n        let mut value = value;\n        _Unwind_VRS_Set(ctx, _UVRSC_CORE, reg_index as _Unwind_Word, _UVRSD_UINT32,\n                        &mut value as *mut _ as *mut c_void);\n    }\n\n    pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context)\n                                -> _Unwind_Word {\n        let val = _Unwind_GetGR(ctx, UNWIND_IP_REG);\n        (val & !1) as _Unwind_Word\n    }\n\n    pub unsafe fn _Unwind_SetIP(ctx: *mut _Unwind_Context,\n                                value: _Unwind_Word) {\n        // Propagate thumb bit to instruction pointer\n        let thumb_state = _Unwind_GetGR(ctx, UNWIND_IP_REG) & 1;\n        let value = value | thumb_state;\n        _Unwind_SetGR(ctx, UNWIND_IP_REG, value);\n    }\n\n    pub unsafe fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n                                    ip_before_insn: *mut c_int)\n                                    -> _Unwind_Word {\n        *ip_before_insn = 0;\n        _Unwind_GetIP(ctx)\n    }\n\n    // This function also doesn't exist on Android or ARM/Linux, so make it a no-op\n    pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut c_void) -> *mut c_void {\n        pc\n    }\n}\n\nif #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n    // Not 32-bit iOS\n    extern \"C\" {\n        #[unwind]\n        pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n        pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n                                 trace_argument: *mut c_void)\n                                 -> _Unwind_Reason_Code;\n    }\n} else {\n    // 32-bit iOS uses SjLj and does not provide _Unwind_Backtrace()\n    extern \"C\" {\n        #[unwind]\n        pub fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n    }\n\n    #[inline]\n    pub unsafe fn _Unwind_RaiseException(exc: *mut _Unwind_Exception) -> _Unwind_Reason_Code {\n        _Unwind_SjLj_RaiseException(exc)\n    }\n}\n} // cfg_if!\n","// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#[cfg(target_has_atomic = \"ptr\")]\npub use self::imp::set_oom_handler;\nuse core::intrinsics;\n\nfn default_oom_handler() -> ! {\n    // The default handler can't do much more since we can't assume the presence\n    // of libc or any way of printing an error message.\n    unsafe { intrinsics::abort() }\n}\n\n/// Common out-of-memory routine\n#[cold]\n#[inline(never)]\n#[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n           issue = \"27700\")]\npub fn oom() -> ! {\n    self::imp::oom()\n}\n\n#[cfg(target_has_atomic = \"ptr\")]\nmod imp {\n    use core::mem;\n    use core::sync::atomic::{AtomicPtr, Ordering};\n\n    static OOM_HANDLER: AtomicPtr<()> = AtomicPtr::new(super::default_oom_handler as *mut ());\n\n    #[inline(always)]\n    pub fn oom() -> ! {\n        let value = OOM_HANDLER.load(Ordering::SeqCst);\n        let handler: fn() -> ! = unsafe { mem::transmute(value) };\n        handler();\n    }\n\n    /// Set a custom handler for out-of-memory conditions\n    ///\n    /// To avoid recursive OOM failures, it is critical that the OOM handler does\n    /// not allocate any memory itself.\n    #[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n               issue = \"27700\")]\n    pub fn set_oom_handler(handler: fn() -> !) {\n        OOM_HANDLER.store(handler as *mut (), Ordering::SeqCst);\n    }\n}\n\n#[cfg(not(target_has_atomic = \"ptr\"))]\nmod imp {\n    #[inline(always)]\n    pub fn oom() -> ! {\n        super::default_oom_handler()\n    }\n}\n","// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Unicode string slices.\n//!\n//! The `&str` type is one of the two main string types, the other being `String`.\n//! Unlike its `String` counterpart, its contents are borrowed.\n//!\n//! # Basic Usage\n//!\n//! A basic string declaration of `&str` type:\n//!\n//! ```\n//! let hello_world = \"Hello, World!\";\n//! ```\n//!\n//! Here we have declared a string literal, also known as a string slice.\n//! String literals have a static lifetime, which means the string `hello_world`\n//! is guaranteed to be valid for the duration of the entire program.\n//! We can explicitly specify `hello_world`'s lifetime as well:\n//!\n//! ```\n//! let hello_world: &'static str = \"Hello, world!\";\n//! ```\n//!\n//! *[See also the `str` primitive type](../../std/primitive.str.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n// Many of the usings in this module are only used in the test configuration.\n// It's cleaner to just turn off the unused_imports warning than to fix them.\n#![allow(unused_imports)]\n\nuse core::fmt;\nuse core::str as core_str;\nuse core::str::pattern::Pattern;\nuse core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\nuse core::mem;\nuse core::iter::FusedIterator;\nuse std_unicode::str::{UnicodeStr, Utf16Encoder};\n\nuse vec_deque::VecDeque;\nuse borrow::{Borrow, ToOwned};\nuse string::String;\nuse std_unicode;\nuse vec::Vec;\nuse slice::{SliceConcatExt, SliceIndex};\nuse boxed::Box;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{FromStr, Utf8Error};\n#[allow(deprecated)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{Lines, LinesAny};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{Split, RSplit};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{SplitN, RSplitN};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{SplitTerminator, RSplitTerminator};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{Matches, RMatches};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{MatchIndices, RMatchIndices};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{from_utf8, from_utf8_mut, Chars, CharIndices, Bytes};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{from_utf8_unchecked, from_utf8_unchecked_mut, ParseBoolError};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use std_unicode::str::SplitWhitespace;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::pattern;\n\n\n#[unstable(feature = \"slice_concat_ext\",\n           reason = \"trait should not have to exist\",\n           issue = \"27747\")]\nimpl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n    type Output = String;\n\n    fn concat(&self) -> String {\n        if self.is_empty() {\n            return String::new();\n        }\n\n        // `len` calculation may overflow but push_str will check boundaries\n        let len = self.iter().map(|s| s.borrow().len()).sum();\n        let mut result = String::with_capacity(len);\n\n        for s in self {\n            result.push_str(s.borrow())\n        }\n\n        result\n    }\n\n    fn join(&self, sep: &str) -> String {\n        if self.is_empty() {\n            return String::new();\n        }\n\n        // concat is faster\n        if sep.is_empty() {\n            return self.concat();\n        }\n\n        // this is wrong without the guarantee that `self` is non-empty\n        // `len` calculation may overflow but push_str but will check boundaries\n        let len = sep.len() * (self.len() - 1) +\n                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n        let mut result = String::with_capacity(len);\n        let mut first = true;\n\n        for s in self {\n            if first {\n                first = false;\n            } else {\n                result.push_str(sep);\n            }\n            result.push_str(s.borrow());\n        }\n        result\n    }\n\n    fn connect(&self, sep: &str) -> String {\n        self.join(sep)\n    }\n}\n\n/// An iterator of [`u16`] over the string encoded as UTF-16.\n///\n/// [`u16`]: ../../std/primitive.u16.html\n///\n/// This struct is created by the [`encode_utf16`] method on [`str`].\n/// See its documentation for more.\n///\n/// [`encode_utf16`]: ../../std/primitive.str.html#method.encode_utf16\n/// [`str`]: ../../std/primitive.str.html\n#[derive(Clone)]\n#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\npub struct EncodeUtf16<'a> {\n    encoder: Utf16Encoder<Chars<'a>>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<'a> fmt::Debug for EncodeUtf16<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"EncodeUtf16 { .. }\")\n    }\n}\n\n#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\nimpl<'a> Iterator for EncodeUtf16<'a> {\n    type Item = u16;\n\n    #[inline]\n    fn next(&mut self) -> Option<u16> {\n        self.encoder.next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.encoder.size_hint()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a> FusedIterator for EncodeUtf16<'a> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Borrow<str> for String {\n    #[inline]\n    fn borrow(&self) -> &str {\n        &self[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToOwned for str {\n    type Owned = String;\n    fn to_owned(&self) -> String {\n        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n    }\n\n    fn clone_into(&self, target: &mut String) {\n        let mut b = mem::replace(target, String::new()).into_bytes();\n        self.as_bytes().clone_into(&mut b);\n        *target = unsafe { String::from_utf8_unchecked(b) }\n    }\n}\n\n/// Methods for string slices.\n#[lang = \"str\"]\n#[cfg(not(test))]\nimpl str {\n    /// Returns the length of `self`.\n    ///\n    /// This length is in bytes, not [`char`]s or graphemes. In other words,\n    /// it may not be what a human considers the length of the string.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let len = \"foo\".len();\n    /// assert_eq!(3, len);\n    ///\n    /// let len = \"oo\".len(); // fancy f!\n    /// assert_eq!(4, len);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn len(&self) -> usize {\n        core_str::StrExt::len(self)\n    }\n\n    /// Returns `true` if `self` has a length of zero bytes.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"\";\n    /// assert!(s.is_empty());\n    ///\n    /// let s = \"not empty\";\n    /// assert!(!s.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n        core_str::StrExt::is_empty(self)\n    }\n\n    /// Checks that `index`-th byte lies at the start and/or end of a\n    /// UTF-8 code point sequence.\n    ///\n    /// The start and end of the string (when `index == self.len()`) are\n    /// considered to be\n    /// boundaries.\n    ///\n    /// Returns `false` if `index` is greater than `self.len()`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s = \"Lwe  Lopard\";\n    /// assert!(s.is_char_boundary(0));\n    /// // start of ``\n    /// assert!(s.is_char_boundary(6));\n    /// assert!(s.is_char_boundary(s.len()));\n    ///\n    /// // second byte of ``\n    /// assert!(!s.is_char_boundary(2));\n    ///\n    /// // third byte of ``\n    /// assert!(!s.is_char_boundary(8));\n    /// ```\n    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n    #[inline]\n    pub fn is_char_boundary(&self, index: usize) -> bool {\n        core_str::StrExt::is_char_boundary(self, index)\n    }\n\n    /// Converts a string slice to a byte slice.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let bytes = \"bors\".as_bytes();\n    /// assert_eq!(b\"bors\", bytes);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline(always)]\n    pub fn as_bytes(&self) -> &[u8] {\n        core_str::StrExt::as_bytes(self)\n    }\n\n    /// Converts a mutable string slice to a mutable byte slice.\n    #[unstable(feature = \"str_mut_extras\", issue = \"41119\")]\n    #[inline(always)]\n    pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n        core_str::StrExt::as_bytes_mut(self)\n    }\n\n    /// Converts a string slice to a raw pointer.\n    ///\n    /// As string slices are a slice of bytes, the raw pointer points to a\n    /// [`u8`]. This pointer will be pointing to the first byte of the string\n    /// slice.\n    ///\n    /// [`u8`]: primitive.u8.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"Hello\";\n    /// let ptr = s.as_ptr();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn as_ptr(&self) -> *const u8 {\n        core_str::StrExt::as_ptr(self)\n    }\n\n    /// Returns a subslice of `str`.\n    ///\n    /// This is the non-panicking alternative to indexing the `str`. Returns\n    /// [`None`] whenever equivalent indexing operation would panic.\n    ///\n    /// [`None`]: option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(str_checked_slicing)]\n    /// let v = \"\";\n    /// assert_eq!(Some(\"\"), v.get(0..4));\n    /// assert!(v.get(1..).is_none());\n    /// assert!(v.get(..8).is_none());\n    /// assert!(v.get(..42).is_none());\n    /// ```\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    #[inline]\n    pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n        core_str::StrExt::get(self, i)\n    }\n\n    /// Returns a mutable subslice of `str`.\n    ///\n    /// This is the non-panicking alternative to indexing the `str`. Returns\n    /// [`None`] whenever equivalent indexing operation would panic.\n    ///\n    /// [`None`]: option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(str_checked_slicing)]\n    /// let mut v = String::from(\"\");\n    /// assert_eq!(Some(\"\"), v.get_mut(0..4).map(|v| &*v));\n    /// assert!(v.get_mut(1..).is_none());\n    /// assert!(v.get_mut(..8).is_none());\n    /// assert!(v.get_mut(..42).is_none());\n    /// ```\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    #[inline]\n    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n        core_str::StrExt::get_mut(self, i)\n    }\n\n    /// Returns a unchecked subslice of `str`.\n    ///\n    /// This is the unchecked alternative to indexing the `str`.\n    ///\n    /// # Safety\n    ///\n    /// Callers of this function are responsible that these preconditions are\n    /// satisfied:\n    ///\n    /// * The starting index must come before the ending index;\n    /// * Indexes must be within bounds of the original slice;\n    /// * Indexes must lie on UTF-8 sequence boundaries.\n    ///\n    /// Failing that, the returned string slice may reference invalid memory or\n    /// violate the invariants communicated by the `str` type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(str_checked_slicing)]\n    /// let v = \"\";\n    /// unsafe {\n    ///     assert_eq!(\"\", v.get_unchecked(0..4));\n    ///     assert_eq!(\"\", v.get_unchecked(4..7));\n    ///     assert_eq!(\"\", v.get_unchecked(7..11));\n    /// }\n    /// ```\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    #[inline]\n    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n        core_str::StrExt::get_unchecked(self, i)\n    }\n\n    /// Returns a mutable, unchecked subslice of `str`.\n    ///\n    /// This is the unchecked alternative to indexing the `str`.\n    ///\n    /// # Safety\n    ///\n    /// Callers of this function are responsible that these preconditions are\n    /// satisfied:\n    ///\n    /// * The starting index must come before the ending index;\n    /// * Indexes must be within bounds of the original slice;\n    /// * Indexes must lie on UTF-8 sequence boundaries.\n    ///\n    /// Failing that, the returned string slice may reference invalid memory or\n    /// violate the invariants communicated by the `str` type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(str_checked_slicing)]\n    /// let mut v = String::from(\"\");\n    /// unsafe {\n    ///     assert_eq!(\"\", v.get_unchecked_mut(0..4));\n    ///     assert_eq!(\"\", v.get_unchecked_mut(4..7));\n    ///     assert_eq!(\"\", v.get_unchecked_mut(7..11));\n    /// }\n    /// ```\n    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n    #[inline]\n    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n        core_str::StrExt::get_unchecked_mut(self, i)\n    }\n\n    /// Creates a string slice from another string slice, bypassing safety\n    /// checks.\n    ///\n    /// This is generally not recommended, use with caution! For a safe\n    /// alternative see [`str`] and [`Index`].\n    ///\n    /// [`str`]: primitive.str.html\n    /// [`Index`]: ops/trait.Index.html\n    ///\n    /// This new slice goes from `begin` to `end`, including `begin` but\n    /// excluding `end`.\n    ///\n    /// To get a mutable string slice instead, see the\n    /// [`slice_mut_unchecked`] method.\n    ///\n    /// [`slice_mut_unchecked`]: #method.slice_mut_unchecked\n    ///\n    /// # Safety\n    ///\n    /// Callers of this function are responsible that three preconditions are\n    /// satisfied:\n    ///\n    /// * `begin` must come before `end`.\n    /// * `begin` and `end` must be byte positions within the string slice.\n    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"Lwe  Lopard\";\n    ///\n    /// unsafe {\n    ///     assert_eq!(\"Lwe  Lopard\", s.slice_unchecked(0, 21));\n    /// }\n    ///\n    /// let s = \"Hello, world!\";\n    ///\n    /// unsafe {\n    ///     assert_eq!(\"world\", s.slice_unchecked(7, 12));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n        core_str::StrExt::slice_unchecked(self, begin, end)\n    }\n\n    /// Creates a string slice from another string slice, bypassing safety\n    /// checks.\n    /// This is generally not recommended, use with caution! For a safe\n    /// alternative see [`str`] and [`IndexMut`].\n    ///\n    /// [`str`]: primitive.str.html\n    /// [`IndexMut`]: ops/trait.IndexMut.html\n    ///\n    /// This new slice goes from `begin` to `end`, including `begin` but\n    /// excluding `end`.\n    ///\n    /// To get an immutable string slice instead, see the\n    /// [`slice_unchecked`] method.\n    ///\n    /// [`slice_unchecked`]: #method.slice_unchecked\n    ///\n    /// # Safety\n    ///\n    /// Callers of this function are responsible that three preconditions are\n    /// satisfied:\n    ///\n    /// * `begin` must come before `end`.\n    /// * `begin` and `end` must be byte positions within the string slice.\n    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n    #[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]\n    #[inline]\n    pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n        core_str::StrExt::slice_mut_unchecked(self, begin, end)\n    }\n\n    /// Divide one string slice into two at an index.\n    ///\n    /// The argument, `mid`, should be a byte offset from the start of the\n    /// string. It must also be on the boundary of a UTF-8 code point.\n    ///\n    /// The two slices returned go from the start of the string slice to `mid`,\n    /// and from `mid` to the end of the string slice.\n    ///\n    /// To get mutable string slices instead, see the [`split_at_mut`]\n    /// method.\n    ///\n    /// [`split_at_mut`]: #method.split_at_mut\n    ///\n    /// # Panics\n    ///\n    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n    /// beyond the last code point of the string slice.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"Per Martin-Lf\";\n    ///\n    /// let (first, last) = s.split_at(3);\n    ///\n    /// assert_eq!(\"Per\", first);\n    /// assert_eq!(\" Martin-Lf\", last);\n    /// ```\n    #[inline]\n    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n    pub fn split_at(&self, mid: usize) -> (&str, &str) {\n        core_str::StrExt::split_at(self, mid)\n    }\n\n    /// Divide one mutable string slice into two at an index.\n    ///\n    /// The argument, `mid`, should be a byte offset from the start of the\n    /// string. It must also be on the boundary of a UTF-8 code point.\n    ///\n    /// The two slices returned go from the start of the string slice to `mid`,\n    /// and from `mid` to the end of the string slice.\n    ///\n    /// To get immutable string slices instead, see the [`split_at`] method.\n    ///\n    /// [`split_at`]: #method.split_at\n    ///\n    /// # Panics\n    ///\n    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n    /// beyond the last code point of the string slice.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = \"Per Martin-Lf\".to_string();\n    ///\n    /// let (first, last) = s.split_at_mut(3);\n    ///\n    /// assert_eq!(\"Per\", first);\n    /// assert_eq!(\" Martin-Lf\", last);\n    /// ```\n    #[inline]\n    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n    pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n        core_str::StrExt::split_at_mut(self, mid)\n    }\n\n    /// Returns an iterator over the [`char`]s of a string slice.\n    ///\n    /// As a string slice consists of valid UTF-8, we can iterate through a\n    /// string slice by [`char`]. This method returns such an iterator.\n    ///\n    /// It's important to remember that [`char`] represents a Unicode Scalar\n    /// Value, and may not match your idea of what a 'character' is. Iteration\n    /// over grapheme clusters may be what you actually want.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let word = \"goodbye\";\n    ///\n    /// let count = word.chars().count();\n    /// assert_eq!(7, count);\n    ///\n    /// let mut chars = word.chars();\n    ///\n    /// assert_eq!(Some('g'), chars.next());\n    /// assert_eq!(Some('o'), chars.next());\n    /// assert_eq!(Some('o'), chars.next());\n    /// assert_eq!(Some('d'), chars.next());\n    /// assert_eq!(Some('b'), chars.next());\n    /// assert_eq!(Some('y'), chars.next());\n    /// assert_eq!(Some('e'), chars.next());\n    ///\n    /// assert_eq!(None, chars.next());\n    /// ```\n    ///\n    /// Remember, [`char`]s may not match your human intuition about characters:\n    ///\n    /// ```\n    /// let y = \"y\";\n    ///\n    /// let mut chars = y.chars();\n    ///\n    /// assert_eq!(Some('y'), chars.next()); // not 'y'\n    /// assert_eq!(Some('\\u{0306}'), chars.next());\n    ///\n    /// assert_eq!(None, chars.next());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn chars(&self) -> Chars {\n        core_str::StrExt::chars(self)\n    }\n    /// Returns an iterator over the [`char`]s of a string slice, and their\n    /// positions.\n    ///\n    /// As a string slice consists of valid UTF-8, we can iterate through a\n    /// string slice by [`char`]. This method returns an iterator of both\n    /// these [`char`]s, as well as their byte positions.\n    ///\n    /// The iterator yields tuples. The position is first, the [`char`] is\n    /// second.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let word = \"goodbye\";\n    ///\n    /// let count = word.char_indices().count();\n    /// assert_eq!(7, count);\n    ///\n    /// let mut char_indices = word.char_indices();\n    ///\n    /// assert_eq!(Some((0, 'g')), char_indices.next());\n    /// assert_eq!(Some((1, 'o')), char_indices.next());\n    /// assert_eq!(Some((2, 'o')), char_indices.next());\n    /// assert_eq!(Some((3, 'd')), char_indices.next());\n    /// assert_eq!(Some((4, 'b')), char_indices.next());\n    /// assert_eq!(Some((5, 'y')), char_indices.next());\n    /// assert_eq!(Some((6, 'e')), char_indices.next());\n    ///\n    /// assert_eq!(None, char_indices.next());\n    /// ```\n    ///\n    /// Remember, [`char`]s may not match your human intuition about characters:\n    ///\n    /// ```\n    /// let y = \"y\";\n    ///\n    /// let mut char_indices = y.char_indices();\n    ///\n    /// assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y')\n    /// assert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n    ///\n    /// assert_eq!(None, char_indices.next());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn char_indices(&self) -> CharIndices {\n        core_str::StrExt::char_indices(self)\n    }\n\n    /// An iterator over the bytes of a string slice.\n    ///\n    /// As a string slice consists of a sequence of bytes, we can iterate\n    /// through a string slice by byte. This method returns such an iterator.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut bytes = \"bors\".bytes();\n    ///\n    /// assert_eq!(Some(b'b'), bytes.next());\n    /// assert_eq!(Some(b'o'), bytes.next());\n    /// assert_eq!(Some(b'r'), bytes.next());\n    /// assert_eq!(Some(b's'), bytes.next());\n    ///\n    /// assert_eq!(None, bytes.next());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn bytes(&self) -> Bytes {\n        core_str::StrExt::bytes(self)\n    }\n\n    /// Split a string slice by whitespace.\n    ///\n    /// The iterator returned will return string slices that are sub-slices of\n    /// the original string slice, separated by any amount of whitespace.\n    ///\n    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n    /// Core Property `White_Space`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut iter = \"A few words\".split_whitespace();\n    ///\n    /// assert_eq!(Some(\"A\"), iter.next());\n    /// assert_eq!(Some(\"few\"), iter.next());\n    /// assert_eq!(Some(\"words\"), iter.next());\n    ///\n    /// assert_eq!(None, iter.next());\n    /// ```\n    ///\n    /// All kinds of whitespace are considered:\n    ///\n    /// ```\n    /// let mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\n    /// assert_eq!(Some(\"Mary\"), iter.next());\n    /// assert_eq!(Some(\"had\"), iter.next());\n    /// assert_eq!(Some(\"a\"), iter.next());\n    /// assert_eq!(Some(\"little\"), iter.next());\n    /// assert_eq!(Some(\"lamb\"), iter.next());\n    ///\n    /// assert_eq!(None, iter.next());\n    /// ```\n    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n    #[inline]\n    pub fn split_whitespace(&self) -> SplitWhitespace {\n        UnicodeStr::split_whitespace(self)\n    }\n\n    /// An iterator over the lines of a string, as string slices.\n    ///\n    /// Lines are ended with either a newline (`\\n`) or a carriage return with\n    /// a line feed (`\\r\\n`).\n    ///\n    /// The final line ending is optional.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let text = \"foo\\r\\nbar\\n\\nbaz\\n\";\n    /// let mut lines = text.lines();\n    ///\n    /// assert_eq!(Some(\"foo\"), lines.next());\n    /// assert_eq!(Some(\"bar\"), lines.next());\n    /// assert_eq!(Some(\"\"), lines.next());\n    /// assert_eq!(Some(\"baz\"), lines.next());\n    ///\n    /// assert_eq!(None, lines.next());\n    /// ```\n    ///\n    /// The final line ending isn't required:\n    ///\n    /// ```\n    /// let text = \"foo\\nbar\\n\\r\\nbaz\";\n    /// let mut lines = text.lines();\n    ///\n    /// assert_eq!(Some(\"foo\"), lines.next());\n    /// assert_eq!(Some(\"bar\"), lines.next());\n    /// assert_eq!(Some(\"\"), lines.next());\n    /// assert_eq!(Some(\"baz\"), lines.next());\n    ///\n    /// assert_eq!(None, lines.next());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn lines(&self) -> Lines {\n        core_str::StrExt::lines(self)\n    }\n\n    /// An iterator over the lines of a string.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")]\n    #[inline]\n    #[allow(deprecated)]\n    pub fn lines_any(&self) -> LinesAny {\n        core_str::StrExt::lines_any(self)\n    }\n\n    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n    #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n    pub fn encode_utf16(&self) -> EncodeUtf16 {\n        EncodeUtf16 { encoder: Utf16Encoder::new(self[..].chars()) }\n    }\n\n    /// Returns `true` if the given pattern matches a sub-slice of\n    /// this string slice.\n    ///\n    /// Returns `false` if it does not.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let bananas = \"bananas\";\n    ///\n    /// assert!(bananas.contains(\"nana\"));\n    /// assert!(!bananas.contains(\"apples\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n        core_str::StrExt::contains(self, pat)\n    }\n\n    /// Returns `true` if the given pattern matches a prefix of this\n    /// string slice.\n    ///\n    /// Returns `false` if it does not.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let bananas = \"bananas\";\n    ///\n    /// assert!(bananas.starts_with(\"bana\"));\n    /// assert!(!bananas.starts_with(\"nana\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n        core_str::StrExt::starts_with(self, pat)\n    }\n\n    /// Returns `true` if the given pattern matches a suffix of this\n    /// string slice.\n    ///\n    /// Returns `false` if it does not.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let bananas = \"bananas\";\n    ///\n    /// assert!(bananas.ends_with(\"anas\"));\n    /// assert!(!bananas.ends_with(\"nana\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        core_str::StrExt::ends_with(self, pat)\n    }\n\n    /// Returns the byte index of the first character of this string slice that\n    /// matches the pattern.\n    ///\n    /// Returns [`None`] if the pattern doesn't match.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n    /// a character matches.\n    ///\n    /// [`char`]: primitive.char.html\n    /// [`None`]: option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Simple patterns:\n    ///\n    /// ```\n    /// let s = \"Lwe  Lopard\";\n    ///\n    /// assert_eq!(s.find('L'), Some(0));\n    /// assert_eq!(s.find(''), Some(14));\n    /// assert_eq!(s.find(\"Lopard\"), Some(13));\n    /// ```\n    ///\n    /// More complex patterns with closures:\n    ///\n    /// ```\n    /// let s = \"Lwe  Lopard\";\n    ///\n    /// assert_eq!(s.find(char::is_whitespace), Some(5));\n    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n    /// ```\n    ///\n    /// Not finding the pattern:\n    ///\n    /// ```\n    /// let s = \"Lwe  Lopard\";\n    /// let x: &[_] = &['1', '2'];\n    ///\n    /// assert_eq!(s.find(x), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n        core_str::StrExt::find(self, pat)\n    }\n\n    /// Returns the byte index of the last character of this string slice that\n    /// matches the pattern.\n    ///\n    /// Returns [`None`] if the pattern doesn't match.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n    /// a character matches.\n    ///\n    /// [`char`]: primitive.char.html\n    /// [`None`]: option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Simple patterns:\n    ///\n    /// ```\n    /// let s = \"Lwe  Lopard\";\n    ///\n    /// assert_eq!(s.rfind('L'), Some(13));\n    /// assert_eq!(s.rfind(''), Some(14));\n    /// ```\n    ///\n    /// More complex patterns with closures:\n    ///\n    /// ```\n    /// let s = \"Lwe  Lopard\";\n    ///\n    /// assert_eq!(s.rfind(char::is_whitespace), Some(12));\n    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n    /// ```\n    ///\n    /// Not finding the pattern:\n    ///\n    /// ```\n    /// let s = \"Lwe  Lopard\";\n    /// let x: &[_] = &['1', '2'];\n    ///\n    /// assert_eq!(s.rfind(x), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        core_str::StrExt::rfind(self, pat)\n    }\n\n    /// An iterator over substrings of this string slice, separated by\n    /// characters matched by a pattern.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n    /// split.\n    ///\n    /// # Iterator behavior\n    ///\n    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n    /// allows a reverse search and forward/reverse search yields the same\n    /// elements. This is true for, eg, [`char`] but not for `&str`.\n    ///\n    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n    ///\n    /// If the pattern allows a reverse search but its results might differ\n    /// from a forward search, the [`rsplit`] method can be used.\n    ///\n    /// [`char`]: primitive.char.html\n    /// [`rsplit`]: #method.rsplit\n    ///\n    /// # Examples\n    ///\n    /// Simple patterns:\n    ///\n    /// ```\n    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n    ///\n    /// let v: Vec<&str> = \"\".split('X').collect();\n    /// assert_eq!(v, [\"\"]);\n    ///\n    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n    ///\n    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n    ///\n    /// let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\n    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n    ///\n    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n    /// ```\n    ///\n    /// A more complex pattern, using a closure:\n    ///\n    /// ```\n    /// let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\n    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n    /// ```\n    ///\n    /// If a string contains multiple contiguous separators, you will end up\n    /// with empty strings in the output:\n    ///\n    /// ```\n    /// let x = \"||||a||b|c\".to_string();\n    /// let d: Vec<_> = x.split('|').collect();\n    ///\n    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n    /// ```\n    ///\n    /// Contiguous separators are separated by the empty string.\n    ///\n    /// ```\n    /// let x = \"(///)\".to_string();\n    /// let d: Vec<_> = x.split('/').collect();\n    ///\n    /// assert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n    /// ```\n    ///\n    /// Separators at the start or end of a string are neighbored\n    /// by empty strings.\n    ///\n    /// ```\n    /// let d: Vec<_> = \"010\".split(\"0\").collect();\n    /// assert_eq!(d, &[\"\", \"1\", \"\"]);\n    /// ```\n    ///\n    /// When the empty string is used as a separator, it separates\n    /// every character in the string, along with the beginning\n    /// and end of the string.\n    ///\n    /// ```\n    /// let f: Vec<_> = \"rust\".split(\"\").collect();\n    /// assert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n    /// ```\n    ///\n    /// Contiguous separators can lead to possibly surprising behavior\n    /// when whitespace is used as the separator. This code is correct:\n    ///\n    /// ```\n    /// let x = \"    a  b c\".to_string();\n    /// let d: Vec<_> = x.split(' ').collect();\n    ///\n    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n    /// ```\n    ///\n    /// It does _not_ give you:\n    ///\n    /// ```,ignore\n    /// assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n    /// ```\n    ///\n    /// Use [`split_whitespace`] for this behavior.\n    ///\n    /// [`split_whitespace`]: #method.split_whitespace\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n        core_str::StrExt::split(self, pat)\n    }\n\n    /// An iterator over substrings of the given string slice, separated by\n    /// characters matched by a pattern and yielded in reverse order.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n    /// split.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Iterator behavior\n    ///\n    /// The returned iterator requires that the pattern supports a reverse\n    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n    /// search yields the same elements.\n    ///\n    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n    ///\n    /// For iterating from the front, the [`split`] method can be used.\n    ///\n    /// [`split`]: #method.split\n    ///\n    /// # Examples\n    ///\n    /// Simple patterns:\n    ///\n    /// ```\n    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n    ///\n    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n    /// assert_eq!(v, [\"\"]);\n    ///\n    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n    ///\n    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n    /// ```\n    ///\n    /// A more complex pattern, using a closure:\n    ///\n    /// ```\n    /// let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\n    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        core_str::StrExt::rsplit(self, pat)\n    }\n\n    /// An iterator over substrings of the given string slice, separated by\n    /// characters matched by a pattern.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n    /// split.\n    ///\n    /// Equivalent to [`split`], except that the trailing substring\n    /// is skipped if empty.\n    ///\n    /// [`split`]: #method.split\n    ///\n    /// This method can be used for string data that is _terminated_,\n    /// rather than _separated_ by a pattern.\n    ///\n    /// # Iterator behavior\n    ///\n    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n    /// allows a reverse search and forward/reverse search yields the same\n    /// elements. This is true for, eg, [`char`] but not for `&str`.\n    ///\n    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n    /// [`char`]: primitive.char.html\n    ///\n    /// If the pattern allows a reverse search but its results might differ\n    /// from a forward search, the [`rsplit_terminator`] method can be used.\n    ///\n    /// [`rsplit_terminator`]: #method.rsplit_terminator\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n    /// assert_eq!(v, [\"A\", \"B\"]);\n    ///\n    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n        core_str::StrExt::split_terminator(self, pat)\n    }\n\n    /// An iterator over substrings of `self`, separated by characters\n    /// matched by a pattern and yielded in reverse order.\n    ///\n    /// The pattern can be a simple `&str`, [`char`], or a closure that\n    /// determines the split.\n    /// Additional libraries might provide more complex patterns like\n    /// regular expressions.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// Equivalent to [`split`], except that the trailing substring is\n    /// skipped if empty.\n    ///\n    /// [`split`]: #method.split\n    ///\n    /// This method can be used for string data that is _terminated_,\n    /// rather than _separated_ by a pattern.\n    ///\n    /// # Iterator behavior\n    ///\n    /// The returned iterator requires that the pattern supports a\n    /// reverse search, and it will be double ended if a forward/reverse\n    /// search yields the same elements.\n    ///\n    /// For iterating from the front, the [`split_terminator`] method can be\n    /// used.\n    ///\n    /// [`split_terminator`]: #method.split_terminator\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n    /// assert_eq!(v, [\"B\", \"A\"]);\n    ///\n    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        core_str::StrExt::rsplit_terminator(self, pat)\n    }\n\n    /// An iterator over substrings of the given string slice, separated by a\n    /// pattern, restricted to returning at most `n` items.\n    ///\n    /// If `n` substrings are returned, the last substring (the `n`th substring)\n    /// will contain the remainder of the string.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n    /// split.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Iterator behavior\n    ///\n    /// The returned iterator will not be double ended, because it is\n    /// not efficient to support.\n    ///\n    /// If the pattern allows a reverse search, the [`rsplitn`] method can be\n    /// used.\n    ///\n    /// [`rsplitn`]: #method.rsplitn\n    ///\n    /// # Examples\n    ///\n    /// Simple patterns:\n    ///\n    /// ```\n    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n    ///\n    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n    ///\n    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n    /// assert_eq!(v, [\"abcXdef\"]);\n    ///\n    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n    /// assert_eq!(v, [\"\"]);\n    /// ```\n    ///\n    /// A more complex pattern, using a closure:\n    ///\n    /// ```\n    /// let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\n    /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n        core_str::StrExt::splitn(self, n, pat)\n    }\n\n    /// An iterator over substrings of this string slice, separated by a\n    /// pattern, starting from the end of the string, restricted to returning\n    /// at most `n` items.\n    ///\n    /// If `n` substrings are returned, the last substring (the `n`th substring)\n    /// will contain the remainder of the string.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that\n    /// determines the split.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Iterator behavior\n    ///\n    /// The returned iterator will not be double ended, because it is not\n    /// efficient to support.\n    ///\n    /// For splitting from the front, the [`splitn`] method can be used.\n    ///\n    /// [`splitn`]: #method.splitn\n    ///\n    /// # Examples\n    ///\n    /// Simple patterns:\n    ///\n    /// ```\n    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n    ///\n    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n    ///\n    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n    /// ```\n    ///\n    /// A more complex pattern, using a closure:\n    ///\n    /// ```\n    /// let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\n    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        core_str::StrExt::rsplitn(self, n, pat)\n    }\n\n    /// An iterator over the disjoint matches of a pattern within the given string\n    /// slice.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that\n    /// determines if a character matches.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Iterator behavior\n    ///\n    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n    /// allows a reverse search and forward/reverse search yields the same\n    /// elements. This is true for, eg, [`char`] but not for `&str`.\n    ///\n    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n    /// [`char`]: primitive.char.html\n    ///\n    /// If the pattern allows a reverse search but its results might differ\n    /// from a forward search, the [`rmatches`] method can be used.\n    ///\n    /// [`rmatches`]: #method.rmatches\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n    ///\n    /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n    /// ```\n    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n    #[inline]\n    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n        core_str::StrExt::matches(self, pat)\n    }\n\n    /// An iterator over the disjoint matches of a pattern within this string slice,\n    /// yielded in reverse order.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n    /// a character matches.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Iterator behavior\n    ///\n    /// The returned iterator requires that the pattern supports a reverse\n    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n    /// search yields the same elements.\n    ///\n    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n    ///\n    /// For iterating from the front, the [`matches`] method can be used.\n    ///\n    /// [`matches`]: #method.matches\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n    ///\n    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n    /// ```\n    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n    #[inline]\n    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        core_str::StrExt::rmatches(self, pat)\n    }\n\n    /// An iterator over the disjoint matches of a pattern within this string\n    /// slice as well as the index that the match starts at.\n    ///\n    /// For matches of `pat` within `self` that overlap, only the indices\n    /// corresponding to the first match are returned.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that determines\n    /// if a character matches.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Iterator behavior\n    ///\n    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n    /// allows a reverse search and forward/reverse search yields the same\n    /// elements. This is true for, eg, [`char`] but not for `&str`.\n    ///\n    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n    ///\n    /// If the pattern allows a reverse search but its results might differ\n    /// from a forward search, the [`rmatch_indices`] method can be used.\n    ///\n    /// [`rmatch_indices`]: #method.rmatch_indices\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n    /// assert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n    ///\n    /// let v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\n    /// assert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n    ///\n    /// let v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\n    /// assert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n    /// ```\n    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n    #[inline]\n    pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n        core_str::StrExt::match_indices(self, pat)\n    }\n\n    /// An iterator over the disjoint matches of a pattern within `self`,\n    /// yielded in reverse order along with the index of the match.\n    ///\n    /// For matches of `pat` within `self` that overlap, only the indices\n    /// corresponding to the last match are returned.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that determines if a\n    /// character matches.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Iterator behavior\n    ///\n    /// The returned iterator requires that the pattern supports a reverse\n    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n    /// search yields the same elements.\n    ///\n    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n    ///\n    /// For iterating from the front, the [`match_indices`] method can be used.\n    ///\n    /// [`match_indices`]: #method.match_indices\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n    /// assert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n    ///\n    /// let v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n    /// assert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n    ///\n    /// let v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\n    /// assert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n    /// ```\n    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n    #[inline]\n    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        core_str::StrExt::rmatch_indices(self, pat)\n    }\n\n    /// Returns a string slice with leading and trailing whitespace removed.\n    ///\n    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n    /// Core Property `White_Space`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \" Hello\\tworld\\t\";\n    ///\n    /// assert_eq!(\"Hello\\tworld\", s.trim());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn trim(&self) -> &str {\n        UnicodeStr::trim(self)\n    }\n\n    /// Returns a string slice with leading whitespace removed.\n    ///\n    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n    /// Core Property `White_Space`.\n    ///\n    /// # Text directionality\n    ///\n    /// A string is a sequence of bytes. 'Left' in this context means the first\n    /// position of that byte string; for a language like Arabic or Hebrew\n    /// which are 'right to left' rather than 'left to right', this will be\n    /// the _right_ side, not the left.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \" Hello\\tworld\\t\";\n    ///\n    /// assert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n    /// ```\n    ///\n    /// Directionality:\n    ///\n    /// ```\n    /// let s = \"  English\";\n    /// assert!(Some('E') == s.trim_left().chars().next());\n    ///\n    /// let s = \"  \";\n    /// assert!(Some('') == s.trim_left().chars().next());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn trim_left(&self) -> &str {\n        UnicodeStr::trim_left(self)\n    }\n\n    /// Returns a string slice with trailing whitespace removed.\n    ///\n    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n    /// Core Property `White_Space`.\n    ///\n    /// # Text directionality\n    ///\n    /// A string is a sequence of bytes. 'Right' in this context means the last\n    /// position of that byte string; for a language like Arabic or Hebrew\n    /// which are 'right to left' rather than 'left to right', this will be\n    /// the _left_ side, not the right.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \" Hello\\tworld\\t\";\n    ///\n    /// assert_eq!(\" Hello\\tworld\", s.trim_right());\n    /// ```\n    ///\n    /// Directionality:\n    ///\n    /// ```\n    /// let s = \"English  \";\n    /// assert!(Some('h') == s.trim_right().chars().rev().next());\n    ///\n    /// let s = \"  \";\n    /// assert!(Some('') == s.trim_right().chars().rev().next());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn trim_right(&self) -> &str {\n        UnicodeStr::trim_right(self)\n    }\n\n    /// Returns a string slice with all prefixes and suffixes that match a\n    /// pattern repeatedly removed.\n    ///\n    /// The pattern can be a [`char`] or a closure that determines if a\n    /// character matches.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Simple patterns:\n    ///\n    /// ```\n    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n    /// assert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n    ///\n    /// let x: &[_] = &['1', '2'];\n    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n    /// ```\n    ///\n    /// A more complex pattern, using a closure:\n    ///\n    /// ```\n    /// assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n        where P::Searcher: DoubleEndedSearcher<'a>\n    {\n        core_str::StrExt::trim_matches(self, pat)\n    }\n\n    /// Returns a string slice with all prefixes that match a pattern\n    /// repeatedly removed.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n    /// a character matches.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Text directionality\n    ///\n    /// A string is a sequence of bytes. 'Left' in this context means the first\n    /// position of that byte string; for a language like Arabic or Hebrew\n    /// which are 'right to left' rather than 'left to right', this will be\n    /// the _right_ side, not the left.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n    ///\n    /// let x: &[_] = &['1', '2'];\n    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n        core_str::StrExt::trim_left_matches(self, pat)\n    }\n\n    /// Returns a string slice with all suffixes that match a pattern\n    /// repeatedly removed.\n    ///\n    /// The pattern can be a `&str`, [`char`], or a closure that\n    /// determines if a character matches.\n    ///\n    /// [`char`]: primitive.char.html\n    ///\n    /// # Text directionality\n    ///\n    /// A string is a sequence of bytes. 'Right' in this context means the last\n    /// position of that byte string; for a language like Arabic or Hebrew\n    /// which are 'right to left' rather than 'left to right', this will be\n    /// the _left_ side, not the right.\n    ///\n    /// # Examples\n    ///\n    /// Simple patterns:\n    ///\n    /// ```\n    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n    ///\n    /// let x: &[_] = &['1', '2'];\n    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n    /// ```\n    ///\n    /// A more complex pattern, using a closure:\n    ///\n    /// ```\n    /// assert_eq!(\"1fooX\".trim_left_matches(|c| c == '1' || c == 'X'), \"fooX\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n        where P::Searcher: ReverseSearcher<'a>\n    {\n        core_str::StrExt::trim_right_matches(self, pat)\n    }\n\n    /// Parses this string slice into another type.\n    ///\n    /// Because `parse` is so general, it can cause problems with type\n    /// inference. As such, `parse` is one of the few times you'll see\n    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n    /// helps the inference algorithm understand specifically which type\n    /// you're trying to parse into.\n    ///\n    /// `parse` can parse any type that implements the [`FromStr`] trait.\n    ///\n    /// [`FromStr`]: str/trait.FromStr.html\n    ///\n    /// # Errors\n    ///\n    /// Will return [`Err`] if it's not possible to parse this string slice into\n    /// the desired type.\n    ///\n    /// [`Err`]: str/trait.FromStr.html#associatedtype.Err\n    ///\n    /// # Example\n    ///\n    /// Basic usage\n    ///\n    /// ```\n    /// let four: u32 = \"4\".parse().unwrap();\n    ///\n    /// assert_eq!(4, four);\n    /// ```\n    ///\n    /// Using the 'turbofish' instead of annotating `four`:\n    ///\n    /// ```\n    /// let four = \"4\".parse::<u32>();\n    ///\n    /// assert_eq!(Ok(4), four);\n    /// ```\n    ///\n    /// Failing to parse:\n    ///\n    /// ```\n    /// let nope = \"j\".parse::<u32>();\n    ///\n    /// assert!(nope.is_err());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n        core_str::StrExt::parse(self)\n    }\n\n    /// Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n    #[unstable(feature = \"str_box_extras\", issue = \"41119\")]\n    pub fn into_boxed_bytes(self: Box<str>) -> Box<[u8]> {\n        self.into()\n    }\n\n    /// Replaces all matches of a pattern with another string.\n    ///\n    /// `replace` creates a new [`String`], and copies the data from this string slice into it.\n    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n    /// replaces them with the replacement string slice.\n    ///\n    /// [`String`]: string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"this is old\";\n    ///\n    /// assert_eq!(\"this is new\", s.replace(\"old\", \"new\"));\n    /// ```\n    ///\n    /// When the pattern doesn't match:\n    ///\n    /// ```\n    /// let s = \"this is old\";\n    /// assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n        let mut result = String::new();\n        let mut last_end = 0;\n        for (start, part) in self.match_indices(from) {\n            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n            result.push_str(to);\n            last_end = start + part.len();\n        }\n        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n        result\n    }\n\n    /// Replaces first N matches of a pattern with another string.\n    ///\n    /// `replacen` creates a new [`String`], and copies the data from this string slice into it.\n    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n    /// replaces them with the replacement string slice at most `count` times.\n    ///\n    /// [`String`]: string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"foo foo 123 foo\";\n    /// assert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\n    /// assert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\n    /// assert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));\n    /// ```\n    ///\n    /// When the pattern doesn't match:\n    ///\n    /// ```\n    /// let s = \"this is old\";\n    /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n    /// ```\n    #[stable(feature = \"str_replacen\", since = \"1.16.0\")]\n    pub fn replacen<'a, P: Pattern<'a>>(&'a self, pat: P, to: &str, count: usize) -> String {\n        // Hope to reduce the times of re-allocation\n        let mut result = String::with_capacity(32);\n        let mut last_end = 0;\n        for (start, part) in self.match_indices(pat).take(count) {\n            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n            result.push_str(to);\n            last_end = start + part.len();\n        }\n        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n        result\n    }\n\n    /// Returns the lowercase equivalent of this string slice, as a new [`String`].\n    ///\n    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core Property\n    /// `Lowercase`.\n    ///\n    /// Since some characters can expand into multiple characters when changing\n    /// the case, this function returns a [`String`] instead of modifying the\n    /// parameter in-place.\n    ///\n    /// [`String`]: string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"HELLO\";\n    ///\n    /// assert_eq!(\"hello\", s.to_lowercase());\n    /// ```\n    ///\n    /// A tricky example, with sigma:\n    ///\n    /// ```\n    /// let sigma = \"\";\n    ///\n    /// assert_eq!(\"\", sigma.to_lowercase());\n    ///\n    /// // but at the end of a word, it's , not :\n    /// let odysseus = \"\";\n    ///\n    /// assert_eq!(\"\", odysseus.to_lowercase());\n    /// ```\n    ///\n    /// Languages without case are not changed:\n    ///\n    /// ```\n    /// let new_year = \"\";\n    ///\n    /// assert_eq!(new_year, new_year.to_lowercase());\n    /// ```\n    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n    pub fn to_lowercase(&self) -> String {\n        let mut s = String::with_capacity(self.len());\n        for (i, c) in self[..].char_indices() {\n            if c == '' {\n                //  maps to , except at the end of a word where it maps to .\n                // This is the only conditional (contextual) but language-independent mapping\n                // in `SpecialCasing.txt`,\n                // so hard-code it rather than have a generic \"condition\" mechanism.\n                // See https://github.com/rust-lang/rust/issues/26035\n                map_uppercase_sigma(self, i, &mut s)\n            } else {\n                s.extend(c.to_lowercase());\n            }\n        }\n        return s;\n\n        fn map_uppercase_sigma(from: &str, i: usize, to: &mut String) {\n            // See http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n            // for the definition of `Final_Sigma`.\n            debug_assert!(''.len_utf8() == 2);\n            let is_word_final = case_ignoreable_then_cased(from[..i].chars().rev()) &&\n                                !case_ignoreable_then_cased(from[i + 2..].chars());\n            to.push_str(if is_word_final { \"\" } else { \"\" });\n        }\n\n        fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n            use std_unicode::derived_property::{Cased, Case_Ignorable};\n            match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n                Some(c) => Cased(c),\n                None => false,\n            }\n        }\n    }\n\n    /// Returns the uppercase equivalent of this string slice, as a new [`String`].\n    ///\n    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core Property\n    /// `Uppercase`.\n    ///\n    /// Since some characters can expand into multiple characters when changing\n    /// the case, this function returns a [`String`] instead of modifying the\n    /// parameter in-place.\n    ///\n    /// [`String`]: string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"hello\";\n    ///\n    /// assert_eq!(\"HELLO\", s.to_uppercase());\n    /// ```\n    ///\n    /// Scripts without case are not changed:\n    ///\n    /// ```\n    /// let new_year = \"\";\n    ///\n    /// assert_eq!(new_year, new_year.to_uppercase());\n    /// ```\n    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n    pub fn to_uppercase(&self) -> String {\n        let mut s = String::with_capacity(self.len());\n        s.extend(self.chars().flat_map(|c| c.to_uppercase()));\n        return s;\n    }\n\n    /// Escapes each char in `s` with [`char::escape_debug`].\n    ///\n    /// [`char::escape_debug`]: primitive.char.html#method.escape_debug\n    #[unstable(feature = \"str_escape\",\n               reason = \"return type may change to be an iterator\",\n               issue = \"27791\")]\n    pub fn escape_debug(&self) -> String {\n        self.chars().flat_map(|c| c.escape_debug()).collect()\n    }\n\n    /// Escapes each char in `s` with [`char::escape_default`].\n    ///\n    /// [`char::escape_default`]: primitive.char.html#method.escape_default\n    #[unstable(feature = \"str_escape\",\n               reason = \"return type may change to be an iterator\",\n               issue = \"27791\")]\n    pub fn escape_default(&self) -> String {\n        self.chars().flat_map(|c| c.escape_default()).collect()\n    }\n\n    /// Escapes each char in `s` with [`char::escape_unicode`].\n    ///\n    /// [`char::escape_unicode`]: primitive.char.html#method.escape_unicode\n    #[unstable(feature = \"str_escape\",\n               reason = \"return type may change to be an iterator\",\n               issue = \"27791\")]\n    pub fn escape_unicode(&self) -> String {\n        self.chars().flat_map(|c| c.escape_unicode()).collect()\n    }\n\n    /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n    ///\n    /// [`String`]: string/struct.String.html\n    /// [`Box<str>`]: boxed/struct.Box.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let string = String::from(\"birthday gift\");\n    /// let boxed_str = string.clone().into_boxed_str();\n    ///\n    /// assert_eq!(boxed_str.into_string(), string);\n    /// ```\n    #[stable(feature = \"box_str\", since = \"1.4.0\")]\n    pub fn into_string(self: Box<str>) -> String {\n        unsafe {\n            let slice = mem::transmute::<Box<str>, Box<[u8]>>(self);\n            String::from_utf8_unchecked(slice.into_vec())\n        }\n    }\n\n    /// Create a [`String`] by repeating a string `n` times.\n    ///\n    /// [`String`]: string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n    /// ```\n    #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n    pub fn repeat(&self, n: usize) -> String {\n        let mut s = String::with_capacity(self.len() * n);\n        s.extend((0..n).map(|_| self));\n        s\n    }\n}\n\n/// Converts a boxed slice of bytes to a boxed string slice without checking\n/// that the string contains valid UTF-8.\n#[unstable(feature = \"str_box_extras\", issue = \"41119\")]\npub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {\n    mem::transmute(v)\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![crate_name = \"alloc_system\"]\n#![crate_type = \"rlib\"]\n#![no_std]\n#![allocator]\n#![deny(warnings)]\n#![unstable(feature = \"alloc_system\",\n            reason = \"this library is unlikely to be stabilized in its current \\\n                      form or name\",\n            issue = \"27783\")]\n#![feature(allocator)]\n#![feature(staged_api)]\n#![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n\n// The minimum alignment guaranteed by the architecture. This value is used to\n// add fast paths for low alignment values. In practice, the alignment is a\n// constant at the call site and the branch will be optimized out.\n#[cfg(all(any(target_arch = \"x86\",\n              target_arch = \"arm\",\n              target_arch = \"mips\",\n              target_arch = \"powerpc\",\n              target_arch = \"powerpc64\",\n              target_arch = \"asmjs\",\n              target_arch = \"wasm32\")))]\nconst MIN_ALIGN: usize = 8;\n#[cfg(all(any(target_arch = \"x86_64\",\n              target_arch = \"aarch64\",\n              target_arch = \"mips64\",\n              target_arch = \"s390x\",\n              target_arch = \"sparc64\")))]\nconst MIN_ALIGN: usize = 16;\n\n#[no_mangle]\npub extern \"C\" fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n    unsafe { imp::allocate(size, align) }\n}\n\n#[no_mangle]\npub extern \"C\" fn __rust_allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n    unsafe { imp::allocate_zeroed(size, align) }\n}\n\n#[no_mangle]\npub extern \"C\" fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n    unsafe { imp::deallocate(ptr, old_size, align) }\n}\n\n#[no_mangle]\npub extern \"C\" fn __rust_reallocate(ptr: *mut u8,\n                                    old_size: usize,\n                                    size: usize,\n                                    align: usize)\n                                    -> *mut u8 {\n    unsafe { imp::reallocate(ptr, old_size, size, align) }\n}\n\n#[no_mangle]\npub extern \"C\" fn __rust_reallocate_inplace(ptr: *mut u8,\n                                            old_size: usize,\n                                            size: usize,\n                                            align: usize)\n                                            -> usize {\n    unsafe { imp::reallocate_inplace(ptr, old_size, size, align) }\n}\n\n#[no_mangle]\npub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n    imp::usable_size(size, align)\n}\n\n#[cfg(any(unix, target_os = \"redox\"))]\nmod imp {\n    extern crate libc;\n\n    use core::cmp;\n    use core::ptr;\n    use MIN_ALIGN;\n\n    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n        if align <= MIN_ALIGN {\n            libc::malloc(size as libc::size_t) as *mut u8\n        } else {\n            aligned_malloc(size, align)\n        }\n    }\n\n    #[cfg(any(target_os = \"android\", target_os = \"redox\"))]\n    unsafe fn aligned_malloc(size: usize, align: usize) -> *mut u8 {\n        // On android we currently target API level 9 which unfortunately\n        // doesn't have the `posix_memalign` API used below. Instead we use\n        // `memalign`, but this unfortunately has the property on some systems\n        // where the memory returned cannot be deallocated by `free`!\n        //\n        // Upon closer inspection, however, this appears to work just fine with\n        // Android, so for this platform we should be fine to call `memalign`\n        // (which is present in API level 9). Some helpful references could\n        // possibly be chromium using memalign [1], attempts at documenting that\n        // memalign + free is ok [2] [3], or the current source of chromium\n        // which still uses memalign on android [4].\n        //\n        // [1]: https://codereview.chromium.org/10796020/\n        // [2]: https://code.google.com/p/android/issues/detail?id=35391\n        // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n        // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n        //                                       /memory/aligned_memory.cc\n        libc::memalign(align as libc::size_t, size as libc::size_t) as *mut u8\n    }\n\n    #[cfg(not(any(target_os = \"android\", target_os = \"redox\")))]\n    unsafe fn aligned_malloc(size: usize, align: usize) -> *mut u8 {\n        let mut out = ptr::null_mut();\n        let ret = libc::posix_memalign(&mut out, align as libc::size_t, size as libc::size_t);\n        if ret != 0 {\n            ptr::null_mut()\n        } else {\n            out as *mut u8\n        }\n    }\n\n    pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n        if align <= MIN_ALIGN {\n            libc::calloc(size as libc::size_t, 1) as *mut u8\n        } else {\n            let ptr = aligned_malloc(size, align);\n            if !ptr.is_null() {\n                ptr::write_bytes(ptr, 0, size);\n            }\n            ptr\n        }\n    }\n\n    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n        if align <= MIN_ALIGN {\n            libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n        } else {\n            let new_ptr = allocate(size, align);\n            if !new_ptr.is_null() {\n                ptr::copy(ptr, new_ptr, cmp::min(size, old_size));\n                deallocate(ptr, old_size, align);\n            }\n            new_ptr\n        }\n    }\n\n    pub unsafe fn reallocate_inplace(_ptr: *mut u8,\n                                     old_size: usize,\n                                     _size: usize,\n                                     _align: usize)\n                                     -> usize {\n        old_size\n    }\n\n    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {\n        libc::free(ptr as *mut libc::c_void)\n    }\n\n    pub fn usable_size(size: usize, _align: usize) -> usize {\n        size\n    }\n}\n\n#[cfg(windows)]\n#[allow(bad_style)]\nmod imp {\n    use core::cmp::min;\n    use core::ptr::copy_nonoverlapping;\n    use MIN_ALIGN;\n\n    type LPVOID = *mut u8;\n    type HANDLE = LPVOID;\n    type SIZE_T = usize;\n    type DWORD = u32;\n    type BOOL = i32;\n\n    extern \"system\" {\n        fn GetProcessHeap() -> HANDLE;\n        fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n        fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n        fn GetLastError() -> DWORD;\n    }\n\n    #[repr(C)]\n    struct Header(*mut u8);\n\n\n    const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n    const HEAP_REALLOC_IN_PLACE_ONLY: DWORD = 0x00000010;\n\n    unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n        &mut *(ptr as *mut Header).offset(-1)\n    }\n\n    unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n        let aligned = ptr.offset((align - (ptr as usize & (align - 1))) as isize);\n        *get_header(aligned) = Header(ptr);\n        aligned\n    }\n\n    #[inline]\n    unsafe fn allocate_with_flags(size: usize, align: usize, flags: DWORD) -> *mut u8 {\n        if align <= MIN_ALIGN {\n            HeapAlloc(GetProcessHeap(), flags, size as SIZE_T) as *mut u8\n        } else {\n            let ptr = HeapAlloc(GetProcessHeap(), flags, (size + align) as SIZE_T) as *mut u8;\n            if ptr.is_null() {\n                return ptr;\n            }\n            align_ptr(ptr, align)\n        }\n    }\n\n    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n        allocate_with_flags(size, align, 0)\n    }\n\n    pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n        allocate_with_flags(size, align, HEAP_ZERO_MEMORY)\n    }\n\n    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n        if align <= MIN_ALIGN {\n            HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, size as SIZE_T) as *mut u8\n        } else {\n            let new = allocate(size, align);\n            if !new.is_null() {\n                copy_nonoverlapping(ptr, new, min(size, old_size));\n                deallocate(ptr, old_size, align);\n            }\n            new\n        }\n    }\n\n    pub unsafe fn reallocate_inplace(ptr: *mut u8,\n                                     old_size: usize,\n                                     size: usize,\n                                     align: usize)\n                                     -> usize {\n        let new = if align <= MIN_ALIGN {\n            HeapReAlloc(GetProcessHeap(),\n                        HEAP_REALLOC_IN_PLACE_ONLY,\n                        ptr as LPVOID,\n                        size as SIZE_T) as *mut u8\n        } else {\n            let header = get_header(ptr);\n            HeapReAlloc(GetProcessHeap(),\n                        HEAP_REALLOC_IN_PLACE_ONLY,\n                        header.0 as LPVOID,\n                        size + align as SIZE_T) as *mut u8\n        };\n        if new.is_null() { old_size } else { size }\n    }\n\n    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, align: usize) {\n        if align <= MIN_ALIGN {\n            let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n            debug_assert!(err != 0, \"Failed to free heap memory: {}\", GetLastError());\n        } else {\n            let header = get_header(ptr);\n            let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n            debug_assert!(err != 0, \"Failed to free heap memory: {}\", GetLastError());\n        }\n    }\n\n    pub fn usable_size(size: usize, _align: usize) -> usize {\n        size\n    }\n}\n","// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n// NOTE: The following code was generated by \"./unicode.py\", do not edit directly\n\n#![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n\n/// The version of [Unicode](http://www.unicode.org/)\n/// that the unicode parts of `CharExt` and `UnicodeStrPrelude` traits are based on.\npub const UNICODE_VERSION: (u64, u64, u64) = (10, 0, 0);\n\n\n// BoolTrie is a trie for representing a set of Unicode codepoints. It is\n// implemented with postfix compression (sharing of identical child nodes),\n// which gives both compact size and fast lookup.\n//\n// The space of Unicode codepoints is divided into 3 subareas, each\n// represented by a trie with different depth. In the first (0..0x800), there\n// is no trie structure at all; each u64 entry corresponds to a bitvector\n// effectively holding 64 bool values.\n//\n// In the second (0x800..0x10000), each child of the root node represents a\n// 64-wide subrange, but instead of storing the full 64-bit value of the leaf,\n// the trie stores an 8-bit index into a shared table of leaf values. This\n// exploits the fact that in reasonable sets, many such leaves can be shared.\n//\n// In the third (0x10000..0x110000), each child of the root node represents a\n// 4096-wide subrange, and the trie stores an 8-bit index into a 64-byte slice\n// of a child tree. Each of these 64 bytes represents an index into the table\n// of shared 64-bit leaf values. This exploits the sparse structure in the\n// non-BMP range of most Unicode sets.\npub struct BoolTrie {\n    // 0..0x800 (corresponding to 1 and 2 byte utf-8 sequences)\n    r1: [u64; 32],   // leaves\n\n    // 0x800..0x10000 (corresponding to 3 byte utf-8 sequences)\n    r2: [u8; 992],      // first level\n    r3: &'static [u64],  // leaves\n\n    // 0x10000..0x110000 (corresponding to 4 byte utf-8 sequences)\n    r4: [u8; 256],       // first level\n    r5: &'static [u8],   // second level\n    r6: &'static [u64],  // leaves\n}\n\nfn trie_range_leaf(c: usize, bitmap_chunk: u64) -> bool {\n    ((bitmap_chunk >> (c & 63)) & 1) != 0\n}\n\nfn trie_lookup_range_table(c: char, r: &'static BoolTrie) -> bool {\n    let c = c as usize;\n    if c < 0x800 {\n        trie_range_leaf(c, r.r1[c >> 6])\n    } else if c < 0x10000 {\n        let child = r.r2[(c >> 6) - 0x20];\n        trie_range_leaf(c, r.r3[child as usize])\n    } else {\n        let child = r.r4[(c >> 12) - 0x10];\n        let leaf = r.r5[((child as usize) << 6) + ((c >> 6) & 0x3f)];\n        trie_range_leaf(c, r.r6[leaf as usize])\n    }\n}\n\npub struct SmallBoolTrie {\n    r1: &'static [u8],  // first level\n    r2: &'static [u64],  // leaves\n}\n\nimpl SmallBoolTrie {\n    fn lookup(&self, c: char) -> bool {\n        let c = c as usize;\n        match self.r1.get(c >> 6) {\n            Some(&child) => trie_range_leaf(c, self.r2[child as usize]),\n            None => false,\n        }\n    }\n}\n\npub mod general_category {\n    pub const Cc_table: &'static super::SmallBoolTrie = &super::SmallBoolTrie {\n        r1: &[\n            0, 1, 0\n        ],\n        r2: &[\n            0x00000000ffffffff, 0x8000000000000000\n        ],\n    };\n\n    pub fn Cc(c: char) -> bool {\n        Cc_table.lookup(c)\n    }\n\n    pub const N_table: &'static super::BoolTrie = &super::BoolTrie {\n        r1: [\n            0x03ff000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n            0x0000000000000000, 0x000003ff00000000, 0x0000000000000000, 0x03ff000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x00000000000003ff\n        ],\n        r2: [\n            0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 2, 3,\n            0, 0, 0, 0, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 5, 0, 0, 0, 3, 2, 0, 0, 0, 0, 6, 0, 2, 0, 0, 7, 0, 0, 2, 8, 0, 0, 7, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0,\n            0, 0, 0, 0, 0, 2, 4, 0, 0, 12, 0, 2, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0\n        ],\n        r3: &[\n            0x0000000000000000, 0x0000ffc000000000, 0x0000000003ff0000, 0x000003ff00000000,\n            0x00000000000003ff, 0x0001c00000000000, 0x000000000000ffc0, 0x0000000003ff03ff,\n            0x03ff000000000000, 0xffffffff00000000, 0x00000000000001e7, 0x070003fe00000080,\n            0x03ff000003ff0000\n        ],\n        r4: [\n            0, 1, 2, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 5, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3\n        ],\n        r5: &[\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 7, 0, 0, 8, 0, 0, 0, 6, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0,\n            0, 0, 8, 0, 9, 6, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0,\n            0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10,\n            11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ],\n        r6: &[\n            0x0000000000000000, 0x001fffffffffffff, 0x0000000000000402, 0x00000000003e0000,\n            0x000003ff00000000, 0x0000ffc000000000, 0x03ff000000000000, 0xffc0000000000000,\n            0x0000000003ff0000, 0x00000000000003ff, 0xffffffffffffffff, 0x00007fffffffffff,\n            0xffffffffffffc000\n        ],\n    };\n\n    pub fn N(c: char) -> bool {\n        super::trie_lookup_range_table(c, N_table)\n    }\n\n}\n\npub mod derived_property {\n    pub const Alphabetic_table: &'static super::BoolTrie = &super::BoolTrie {\n        r1: [\n            0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x0000501f0003ffc3,\n            0x0000000000000000, 0xbcdf000000000020, 0xfffffffbffffd740, 0xffbfffffffffffff,\n            0xffffffffffffffff, 0xffffffffffffffff, 0xfffffffffffffc03, 0xffffffffffffffff,\n            0xfffeffffffffffff, 0xfffffffe027fffff, 0xbfff0000000000ff, 0x000707ffffff00b6,\n            0xffffffff07ff0000, 0xffffc000feffffff, 0xffffffffffffffff, 0x9c00e1fe1fefffff,\n            0xffffffffffff0000, 0xffffffffffffe000, 0x0003ffffffffffff, 0x043007fffffffc00\n        ],\n        r2: [\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36, 36, 36, 37, 38, 39, 40, 41,\n            42, 43, 44, 36, 36, 36, 36, 36, 36, 36, 36, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,\n            56, 57, 58, 59, 60, 61, 62, 31, 63, 64, 65, 66, 55, 67, 68, 69, 36, 36, 36, 70, 36, 36,\n            36, 36, 71, 72, 73, 74, 31, 75, 76, 31, 77, 78, 68, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n            31, 31, 79, 80, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n            31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 81, 82, 36, 83, 84, 85, 86, 87, 88, 31, 31, 31,\n            31, 31, 31, 31, 89, 44, 90, 91, 92, 36, 93, 94, 31, 31, 31, 31, 31, 31, 31, 31, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 55, 31, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 95, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 96, 97, 36, 36, 36, 36, 98, 99, 36, 100, 101, 36, 102,\n            103, 104, 105, 36, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 36, 95, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n            36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 117, 118,\n            31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n            31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n            31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n            31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n            31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n            31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n            36, 36, 36, 36, 36, 119, 36, 120, 121, 122, 123, 124, 36, 36, 36, 36, 125, 126, 127,\n            128, 31, 129, 36, 130, 131, 132, 113, 133\n        ],\n        r3: &[\n            0x00001ffffcffffff, 0x000007ff01ffffff, 0x3fdfffff00000000, 0xffff03f8fff00000,\n            0xefffffffffffffff, 0xfffe000fffe1dfff, 0xe3c5fdfffff99fef, 0x1003000fb080599f,\n            0xc36dfdfffff987ee, 0x003f00005e021987, 0xe3edfdfffffbbfee, 0x1e00000f00011bbf,\n            0xe3edfdfffff99fee, 0x0002000fb0c0199f, 0xc3ffc718d63dc7ec, 0x0000000000811dc7,\n            0xe3fffdfffffddfef, 0x0000000f07601ddf, 0xe3effdfffffddfef, 0x0006000f40601ddf,\n            0xe7fffffffffddfef, 0xfc00000f80f05ddf, 0x2ffbfffffc7fffec, 0x000c0000ff5f807f,\n            0x07fffffffffffffe, 0x000000000000207f, 0x3bffecaefef02596, 0x00000000f000205f,\n            0x0000000000000001, 0xfffe1ffffffffeff, 0x1ffffffffeffff03, 0x0000000000000000,\n            0xf97fffffffffffff, 0xffffc1e7ffff0000, 0xffffffff3000407f, 0xf7ffffffffff20bf,\n            0xffffffffffffffff, 0xffffffff3d7f3dff, 0x7f3dffffffff3dff, 0xffffffffff7fff3d,\n            0xffffffffff3dffff, 0x0000000087ffffff, 0xffffffff0000ffff, 0x3f3fffffffffffff,\n            0xfffffffffffffffe, 0xffff9fffffffffff, 0xffffffff07fffffe, 0x01ffc7ffffffffff,\n            0x000fffff000fdfff, 0x000ddfff000fffff, 0xffcfffffffffffff, 0x00000000108001ff,\n            0xffffffff00000000, 0x00ffffffffffffff, 0xffff07ffffffffff, 0x003fffffffffffff,\n            0x01ff0fff7fffffff, 0x001f3fffffff0000, 0xffff0fffffffffff, 0x00000000000003ff,\n            0xffffffff0fffffff, 0x001ffffe7fffffff, 0x0000008000000000, 0xffefffffffffffff,\n            0x0000000000000fef, 0xfc00f3ffffffffff, 0x0003ffbfffffffff, 0x3ffffffffc00e000,\n            0x00000000000001ff, 0x006fde0000000000, 0x001fff8000000000, 0xffffffff3f3fffff,\n            0x3fffffffaaff3f3f, 0x5fdfffffffffffff, 0x1fdc1fff0fcf1fdc, 0x8002000000000000,\n            0x000000001fff0000, 0xf3ffbd503e2ffc84, 0xffffffff000043e0, 0xffc0000000000000,\n            0x000003ffffffffff, 0xffff7fffffffffff, 0xffffffff7fffffff, 0x000c781fffffffff,\n            0xffff20bfffffffff, 0x000080ffffffffff, 0x7f7f7f7f007fffff, 0xffffffff7f7f7f7f,\n            0x0000800000000000, 0x1f3e03fe000000e0, 0xfffffffee07fffff, 0xf7ffffffffffffff,\n            0xfffe7fffffffffe0, 0x07ffffff00007fff, 0xffff000000000000, 0x000007ffffffffff,\n            0x0000000000001fff, 0x3fffffffffff0000, 0x00000c00ffff1fff, 0x8ff07fffffffffff,\n            0x0000ffffffffffff, 0xfffffffcff800000, 0x00ff7ffffffff9ff, 0xff80000000000000,\n            0x000000fffffff7bb, 0x000fffffffffffff, 0x28fc00000000002f, 0xffff07fffffffc00,\n            0x1fffffff0007ffff, 0xfff7ffffffffffff, 0x7c00ffdf00008000, 0x007fffffffffffff,\n            0xc47fffff00003fff, 0x7fffffffffffffff, 0x003cffff38000005, 0xffff7f7f007e7e7e,\n            0xffff003ff7ffffff, 0xffff000fffffffff, 0x0ffffffffffff87f, 0xffff3fffffffffff,\n            0x0000000003ffffff, 0x5f7ffdffe0f8007f, 0xffffffffffffffdb, 0x0003ffffffffffff,\n            0xfffffffffff80000, 0x3fffffffffffffff, 0xffffffffffff0000, 0xfffffffffffcffff,\n            0x0fff0000000000ff, 0xffdf000000000000, 0x1fffffffffffffff, 0x07fffffe00000000,\n            0xffffffc007fffffe, 0x000000001cfcfcfc\n        ],\n        r4: [\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 5, 9, 5, 10, 11, 12, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 13, 14,\n            15, 7, 16, 17, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n        ],\n        r5: &[\n            0, 1, 2, 3, 4, 5, 4, 4, 4, 4, 6, 7, 8, 9, 10, 11, 2, 2, 12, 13, 14, 15, 4, 4, 2, 2, 2,\n            2, 16, 17, 4, 4, 18, 19, 20, 21, 22, 4, 23, 4, 24, 25, 26, 27, 28, 29, 30, 4, 2, 31, 32,\n            32, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 33, 34, 35, 32, 36, 2, 37, 38, 4, 39, 40, 41,\n            42, 4, 4, 2, 43, 2, 44, 4, 4, 45, 46, 47, 48, 28, 4, 49, 4, 4, 4, 4, 4, 50, 51, 4, 4, 4,\n            4, 52, 53, 54, 55, 4, 4, 4, 4, 56, 57, 58, 4, 59, 60, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 61, 4, 2, 62, 2, 2, 2, 63, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 62, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 64, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2,\n            2, 2, 2, 2, 2, 2, 55, 20, 4, 65, 16, 66, 67, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n            68, 69, 70, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 71, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 20, 72, 2, 2, 2, 2, 2, 73,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 2, 74, 75, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 76, 77, 78, 79, 80, 2, 2, 2, 2, 81, 82, 83, 84, 85, 86,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 87, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 2, 2, 2, 88, 2, 89, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 90, 91, 92, 4, 4, 4, 4, 4, 4, 4, 4, 4, 72, 93, 94, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 95, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 10, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            96, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 97, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 98, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4\n        ],\n        r6: &[\n            0xb7ffff7fffffefff, 0x000000003fff3fff, 0xffffffffffffffff, 0x07ffffffffffffff,\n            0x0000000000000000, 0x001fffffffffffff, 0xffffffff1fffffff, 0x000000000001ffff,\n            0xffffe000ffffffff, 0x07ffffffffff07ff, 0xffffffff3fffffff, 0x00000000003eff0f,\n            0xffff00003fffffff, 0x0fffffffff0fffff, 0xffff00ffffffffff, 0x0000000fffffffff,\n            0x007fffffffffffff, 0x000000ff003fffff, 0x91bffffffffffd3f, 0x007fffff003fffff,\n            0x000000007fffffff, 0x0037ffff00000000, 0x03ffffff003fffff, 0xc0ffffffffffffff,\n            0x000ffffffeeff06f, 0x1fffffff00000000, 0x000000001fffffff, 0x0000001ffffffeff,\n            0x003fffffffffffff, 0x0007ffff003fffff, 0x000000000003ffff, 0x00000000000001ff,\n            0x0007ffffffffffff, 0x000000000000003f, 0x01fffffffffffffc, 0x000001ffffff0000,\n            0x0047ffffffff0000, 0x000000001400001e, 0x409ffffffffbffff, 0xffff01ffbfffbd7f,\n            0x000001ffffffffff, 0xe3edfdfffff99fef, 0x0000000fe081199f, 0x00000000000007bb,\n            0x00000000000000b3, 0x7f3fffffffffffff, 0x000000003f000000, 0x7fffffffffffffff,\n            0x0000000000000011, 0x000007ffe3ffffff, 0xffffffff00000000, 0x80000000ffffffff,\n            0x7fe7ffffffffffff, 0xffffffffffff0000, 0x0000000000ffffcf, 0x01ffffffffffffff,\n            0x7f7ffffffffffdff, 0xfffc000000000001, 0x007ffefffffcffff, 0xb47ffffffffffb7f,\n            0x00000000000000cb, 0x0000000003ffffff, 0x00007fffffffffff, 0x000000000000000f,\n            0x000000000000007f, 0x00003fffffff0000, 0xe0fffff80000000f, 0x000000000000ffff,\n            0x7fffffffffff001f, 0x00000000fff80000, 0x0000000300000000, 0x00001fffffffffff,\n            0xffff000000000000, 0x0fffffffffffffff, 0x1fff07ffffffffff, 0x0000000043ff01ff,\n            0xffffffffffdfffff, 0xebffde64dfffffff, 0xffffffffffffffef, 0x7bffffffdfdfe7bf,\n            0xfffffffffffdfc5f, 0xffffff3fffffffff, 0xf7fffffff7fffffd, 0xffdfffffffdfffff,\n            0xffff7fffffff7fff, 0xfffffdfffffffdff, 0x0000000000000ff7, 0x000007dbf9ffff7f,\n            0x000000000000001f, 0x000000000000008f, 0x0af7fe96ffffffef, 0x5ef7f796aa96ea84,\n            0x0ffffbee0ffffbff, 0xffff03ffffff03ff, 0x00000000000003ff, 0x00000000007fffff,\n            0xffff0003ffffffff, 0x00000001ffffffff, 0x000000003fffffff\n        ],\n    };\n\n    pub fn Alphabetic(c: char) -> bool {\n        super::trie_lookup_range_table(c, Alphabetic_table)\n    }\n\n    pub const Case_Ignorable_table: &'static super::BoolTrie = &super::BoolTrie {\n        r1: [\n            0x0400408000000000, 0x0000000140000000, 0x0190a10000000000, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0xffff000000000000, 0xffffffffffffffff,\n            0xffffffffffffffff, 0x0430ffffffffffff, 0x00000000000000b0, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x00000000000003f8, 0x0000000000000000,\n            0x0000000000000000, 0x0000000002000000, 0xbffffffffffe0000, 0x00100000000000b6,\n            0x0000000017ff003f, 0x00010000fffff801, 0x0000000000000000, 0x00003dffbfc00000,\n            0xffff000000028000, 0x00000000000007ff, 0x0001ffc000000000, 0x043ff80000000000\n        ],\n        r2: [\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 10, 11, 12, 13, 14, 15, 16, 11, 17, 18, 7, 2, 19, 20,\n            21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 33, 34, 35, 36, 37, 38, 39, 2, 40, 2, 2, 2, 41, 42, 43, 2,\n            44, 45, 46, 47, 48, 49, 2, 50, 51, 52, 53, 54, 2, 2, 2, 2, 2, 2, 55, 56, 57, 58, 59, 60,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 61, 2, 62, 2, 63, 2, 64, 65, 2, 2, 2, 2,\n            2, 2, 2, 66, 2, 67, 68, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 69, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 49, 2, 2, 2, 2, 70, 71, 72, 73, 74, 75, 76, 77, 78, 2, 2, 79, 80,\n            81, 82, 83, 84, 85, 86, 87, 2, 88, 2, 89, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 90, 2, 91, 92, 2, 2, 2, 2, 2, 2, 2, 2, 93, 94, 2, 95,\n            96, 97, 98, 99\n        ],\n        r3: &[\n            0x00003fffffc00000, 0x000000000e000000, 0x0000000000000000, 0xfffffffffff00000,\n            0x1400000000000007, 0x0002000c00fe21fe, 0x1000000000000002, 0x0000000c0000201e,\n            0x1000000000000006, 0x0023000000023986, 0xfc00000c000021be, 0x9000000000000002,\n            0x0000000c0040201e, 0x0000000000000004, 0x0000000000002001, 0xc000000000000001,\n            0x0000000c00603dc1, 0x0000000c00003040, 0x1800000000000003, 0x00000000005c0400,\n            0x07f2000000000000, 0x0000000000007fc0, 0x1bf2000000000000, 0x0000000000003f40,\n            0x02a0000003000000, 0x7ffe000000000000, 0x1ffffffffeffe0df, 0x0000000000000040,\n            0x66fde00000000000, 0x001e0001c3000000, 0x0000000020002064, 0x1000000000000000,\n            0x00000000e0000000, 0x001c0000001c0000, 0x000c0000000c0000, 0x3fb0000000000000,\n            0x00000000208ffe40, 0x0000000000007800, 0x0000000000000008, 0x0000020000000060,\n            0x0e04018700000000, 0x0000000009800000, 0x9ff81fe57f400000, 0x7fff008000000000,\n            0x17d000000000000f, 0x000ff80000000004, 0x00003b3c00000003, 0x0003a34000000000,\n            0x00cff00000000000, 0x3f00000000000000, 0x031021fdfff70000, 0xfffff00000000000,\n            0x010007ffffffffff, 0xfffffffff8000000, 0xfbffffffffffffff, 0xa000000000000000,\n            0x6000e000e000e003, 0x00007c900300f800, 0x8002ffdf00000000, 0x000000001fff0000,\n            0x0001ffffffff0000, 0x3000000000000000, 0x0003800000000000, 0x8000800000000000,\n            0xffffffff00000000, 0x0000800000000000, 0x083e3c0000000020, 0x000000007e000000,\n            0x7000000000000000, 0x0000000000200000, 0x0000000000001000, 0xbff7800000000000,\n            0x00000000f0000000, 0x0003000000000000, 0x00000003ffffffff, 0x0001000000000000,\n            0x0000000000000700, 0x0300000000000000, 0x0000006000000844, 0x0003ffff00000030,\n            0x00003fc000000000, 0x000000000003ff80, 0x13c8000000000007, 0x0000006000008000,\n            0x00667e0000000000, 0x1001000000001008, 0xc19d000000000000, 0x0058300020000002,\n            0x00000000f8000000, 0x0000212000000000, 0x0000000040000000, 0xfffc000000000000,\n            0x0000000000000003, 0x0000ffff0008ffff, 0x0000000000240000, 0x8000000000000000,\n            0x4000000004004080, 0x0001000000000001, 0x00000000c0000000, 0x0e00000800000000\n        ],\n        r4: [\n            0, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 4, 2, 5, 6, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2\n        ],\n        r5: &[\n            0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 6, 7, 8, 0, 9, 10, 11, 12, 13, 0, 0, 14, 15, 16, 0, 0, 17, 18, 19, 20,\n            0, 0, 21, 22, 23, 24, 25, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 28, 29, 0, 0, 0,\n            0, 0, 30, 0, 31, 0, 32, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 35, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 37, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 39, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 41, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 0, 48, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            50, 51, 0, 0, 51, 51, 51, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0\n        ],\n        r6: &[\n            0x0000000000000000, 0x2000000000000000, 0x0000000100000000, 0x07c0000000000000,\n            0x870000000000f06e, 0x0000006000000000, 0xff00000000000002, 0x800000000000007f,\n            0x2678000000000003, 0x001fef8000000007, 0x0008000000000000, 0x7fc0000000000003,\n            0x0000000000001c00, 0x40d3800000000000, 0x000007f880000000, 0x1000000000000003,\n            0x001f1fc000000001, 0xff00000000000000, 0x000000000000005c, 0x85f8000000000000,\n            0x000000000000000d, 0xb03c000000000000, 0x0000000030000001, 0xa7f8000000000000,\n            0x0000000000000001, 0x00bf280000000000, 0x00000fbce0000000, 0x79f800000000067e,\n            0x000000000e7e0080, 0x00000000037ffc00, 0xbf7f000000000000, 0x006dfcfffffc0000,\n            0xb47e000000000000, 0x00000000000000bf, 0x001f000000000000, 0x007f000000000000,\n            0x000000000000000f, 0x00000000ffff8000, 0x0000000300000000, 0x0000000f60000000,\n            0xfff8038000000000, 0x00003c0000000fe7, 0x000000000000001c, 0xf87fffffffffffff,\n            0x00201fffffffffff, 0x0000fffef8000010, 0x000007dbf9ffff7f, 0x00000000007f0000,\n            0x00000000000007f0, 0xf800000000000000, 0xffffffff00000002, 0xffffffffffffffff,\n            0x0000ffffffffffff\n        ],\n    };\n\n    pub fn Case_Ignorable(c: char) -> bool {\n        super::trie_lookup_range_table(c, Case_Ignorable_table)\n    }\n\n    pub const Cased_table: &'static super::BoolTrie = &super::BoolTrie {\n        r1: [\n            0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n            0xffffffffffffffff, 0xffffffffffffffff, 0xf7ffffffffffffff, 0xfffffffffffffff0,\n            0xffffffffffffffff, 0xffffffffffffffff, 0x01ffffffffefffff, 0x0000001f00000003,\n            0x0000000000000000, 0xbccf000000000020, 0xfffffffbffffd740, 0xffbfffffffffffff,\n            0xffffffffffffffff, 0xffffffffffffffff, 0xfffffffffffffc03, 0xffffffffffffffff,\n            0xfffeffffffffffff, 0xfffffffe007fffff, 0x00000000000000ff, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000\n        ],\n        r2: [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 5, 5,\n            0, 5, 5, 5, 5, 6, 7, 8, 9, 0, 10, 11, 0, 12, 13, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            15, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 17, 18, 5, 19, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 22,\n            0, 23, 5, 24, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 27, 5, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 29, 30, 0, 0\n        ],\n        r3: &[\n            0x0000000000000000, 0xffffffff00000000, 0x00000000000020bf, 0x3f3fffffffffffff,\n            0x00000000000001ff, 0xffffffffffffffff, 0xffffffff3f3fffff, 0x3fffffffaaff3f3f,\n            0x5fdfffffffffffff, 0x1fdc1fff0fcf1fdc, 0x8002000000000000, 0x000000001fff0000,\n            0xf21fbd503e2ffc84, 0xffffffff000043e0, 0x0000000000000018, 0xffc0000000000000,\n            0x000003ffffffffff, 0xffff7fffffffffff, 0xffffffff7fffffff, 0x000c781fffffffff,\n            0x000020bfffffffff, 0x00003fffffffffff, 0x000000003fffffff, 0xfffffffc00000000,\n            0x00ff7fffffff78ff, 0x0700000000000000, 0xffff000000000000, 0xffff003ff7ffffff,\n            0x0000000000f8007f, 0x07fffffe00000000, 0x0000000007fffffe\n        ],\n        r4: [\n            0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2\n        ],\n        r5: &[\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 8, 9, 10, 11, 12, 1, 1, 1, 1, 13, 14, 15, 16, 17, 18, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 3, 20, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ],\n        r6: &[\n            0x0000000000000000, 0xffffffffffffffff, 0x000000000000ffff, 0xffff000000000000,\n            0x0fffffffff0fffff, 0x0007ffffffffffff, 0xffffffff00000000, 0x00000000ffffffff,\n            0xffffffffffdfffff, 0xebffde64dfffffff, 0xffffffffffffffef, 0x7bffffffdfdfe7bf,\n            0xfffffffffffdfc5f, 0xffffff3fffffffff, 0xf7fffffff7fffffd, 0xffdfffffffdfffff,\n            0xffff7fffffff7fff, 0xfffffdfffffffdff, 0x0000000000000ff7, 0x000000000000000f,\n            0xffff03ffffff03ff, 0x00000000000003ff\n        ],\n    };\n\n    pub fn Cased(c: char) -> bool {\n        super::trie_lookup_range_table(c, Cased_table)\n    }\n\n    pub const Lowercase_table: &'static super::BoolTrie = &super::BoolTrie {\n        r1: [\n            0x0000000000000000, 0x07fffffe00000000, 0x0420040000000000, 0xff7fffff80000000,\n            0x55aaaaaaaaaaaaaa, 0xd4aaaaaaaaaaab55, 0xe6512d2a4e243129, 0xaa29aaaab5555240,\n            0x93faaaaaaaaaaaaa, 0xffffffffffffaa85, 0x01ffffffffefffff, 0x0000001f00000003,\n            0x0000000000000000, 0x3c8a000000000020, 0xfffff00000010000, 0x192faaaaaae37fff,\n            0xffff000000000000, 0xaaaaaaaaffffffff, 0xaaaaaaaaaaaaa802, 0xaaaaaaaaaaaad554,\n            0x0000aaaaaaaaaaaa, 0xfffffffe00000000, 0x00000000000000ff, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000\n        ],\n        r2: [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 3, 3,\n            0, 4, 4, 5, 4, 6, 7, 8, 9, 0, 10, 11, 0, 12, 13, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            16, 17, 4, 18, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 21, 0,\n            22, 23, 24, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 26, 3, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 28, 0, 0\n        ],\n        r3: &[\n            0x0000000000000000, 0x3f00000000000000, 0x00000000000001ff, 0xffffffffffffffff,\n            0xaaaaaaaaaaaaaaaa, 0xaaaaaaaabfeaaaaa, 0x00ff00ff003f00ff, 0x3fff00ff00ff003f,\n            0x40df00ff00ff00ff, 0x00dc00ff00cf00dc, 0x8002000000000000, 0x000000001fff0000,\n            0x321080000008c400, 0xffff0000000043c0, 0x0000000000000010, 0x000003ffffff0000,\n            0xffff000000000000, 0x3fda15627fffffff, 0x0008501aaaaaaaaa, 0x000020bfffffffff,\n            0x00002aaaaaaaaaaa, 0x000000003aaaaaaa, 0xaaabaaa800000000, 0x95ffaaaaaaaaaaaa,\n            0x00a002aaaaba50aa, 0x0700000000000000, 0xffff003ff7ffffff, 0x0000000000f8007f,\n            0x0000000007fffffe\n        ],\n        r4: [\n            0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2\n        ],\n        r5: &[\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 22, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0\n        ],\n        r6: &[\n            0x0000000000000000, 0xffffff0000000000, 0x000000000000ffff, 0x0fffffffff000000,\n            0x0007ffffffffffff, 0x00000000ffffffff, 0x000ffffffc000000, 0x000000ffffdfc000,\n            0xebc000000ffffffc, 0xfffffc000000ffef, 0x00ffffffc000000f, 0x00000ffffffc0000,\n            0xfc000000ffffffc0, 0xffffc000000fffff, 0x0ffffffc000000ff, 0x0000ffffffc00000,\n            0x0000003ffffffc00, 0xf0000003f7fffffc, 0xffc000000fdfffff, 0xffff0000003f7fff,\n            0xfffffc000000fdff, 0x0000000000000bf7, 0xfffffffc00000000, 0x000000000000000f\n        ],\n    };\n\n    pub fn Lowercase(c: char) -> bool {\n        super::trie_lookup_range_table(c, Lowercase_table)\n    }\n\n    pub const Uppercase_table: &'static super::BoolTrie = &super::BoolTrie {\n        r1: [\n            0x0000000000000000, 0x0000000007fffffe, 0x0000000000000000, 0x000000007f7fffff,\n            0xaa55555555555555, 0x2b555555555554aa, 0x11aed2d5b1dbced6, 0x55d255554aaaa490,\n            0x6c05555555555555, 0x000000000000557a, 0x0000000000000000, 0x0000000000000000,\n            0x0000000000000000, 0x8045000000000000, 0x00000ffbfffed740, 0xe6905555551c8000,\n            0x0000ffffffffffff, 0x5555555500000000, 0x5555555555555401, 0x5555555555552aab,\n            0xfffe555555555555, 0x00000000007fffff, 0x0000000000000000, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n            0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000\n        ],\n        r2: [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 4, 4, 5, 4, 6, 7, 8, 9, 0, 0, 0, 0, 10, 11, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13,\n            14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            15, 16, 4, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 19, 0,\n            20, 21, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 23, 0, 0, 0\n        ],\n        r3: &[\n            0x0000000000000000, 0xffffffff00000000, 0x00000000000020bf, 0x003fffffffffffff,\n            0x5555555555555555, 0x5555555540155555, 0xff00ff003f00ff00, 0x0000ff00aa003f00,\n            0x0f00000000000000, 0x0f001f000f000f00, 0xc00f3d503e273884, 0x0000ffff00000020,\n            0x0000000000000008, 0xffc0000000000000, 0x000000000000ffff, 0x00007fffffffffff,\n            0xc025ea9d00000000, 0x0004280555555555, 0x0000155555555555, 0x0000000005555555,\n            0x5554555400000000, 0x6a00555555555555, 0x005f7d5555452855, 0x07fffffe00000000\n        ],\n        r4: [\n            0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2\n        ],\n        r5: &[\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 23, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ],\n        r6: &[\n            0x0000000000000000, 0x000000ffffffffff, 0xffff000000000000, 0x00000000000fffff,\n            0x0007ffffffffffff, 0xffffffff00000000, 0xfff0000003ffffff, 0xffffff0000003fff,\n            0x003fde64d0000003, 0x000003ffffff0000, 0x7b0000001fdfe7b0, 0xfffff0000001fc5f,\n            0x03ffffff0000003f, 0x00003ffffff00000, 0xf0000003ffffff00, 0xffff0000003fffff,\n            0xffffff00000003ff, 0x07fffffc00000001, 0x001ffffff0000000, 0x00007fffffc00000,\n            0x000001ffffff0000, 0x0000000000000400, 0x00000003ffffffff, 0xffff03ffffff03ff,\n            0x00000000000003ff\n        ],\n    };\n\n    pub fn Uppercase(c: char) -> bool {\n        super::trie_lookup_range_table(c, Uppercase_table)\n    }\n\n    pub const XID_Continue_table: &'static super::BoolTrie = &super::BoolTrie {\n        r1: [\n            0x03ff000000000000, 0x07fffffe87fffffe, 0x04a0040000000000, 0xff7fffffff7fffff,\n            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x0000501f0003ffc3,\n            0xffffffffffffffff, 0xb8dfffffffffffff, 0xfffffffbffffd7c0, 0xffbfffffffffffff,\n            0xffffffffffffffff, 0xffffffffffffffff, 0xfffffffffffffcfb, 0xffffffffffffffff,\n            0xfffeffffffffffff, 0xfffffffe027fffff, 0xbffffffffffe00ff, 0x000707ffffff00b6,\n            0xffffffff07ff0000, 0xffffc3ffffffffff, 0xffffffffffffffff, 0x9ffffdff9fefffff,\n            0xffffffffffff0000, 0xffffffffffffe7ff, 0x0003ffffffffffff, 0x043fffffffffffff\n        ],\n        r2: [\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 25, 26, 27, 28, 29, 30, 31, 4, 32, 33, 34, 4, 4, 4, 4, 4, 35, 36, 37, 38, 39, 40,\n            41, 42, 4, 4, 4, 4, 4, 4, 4, 4, 43, 44, 45, 46, 47, 4, 48, 49, 50, 51, 52, 53, 54, 55,\n            56, 57, 58, 59, 60, 4, 61, 4, 62, 50, 63, 64, 65, 4, 4, 4, 66, 4, 4, 4, 4, 67, 68, 69,\n            70, 71, 72, 73, 74, 75, 76, 64, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n            60, 60, 60, 60, 60, 77, 78, 4, 79, 80, 81, 82, 83, 60, 60, 60, 60, 60, 60, 60, 60, 84,\n            42, 85, 86, 87, 4, 88, 89, 60, 60, 60, 60, 60, 60, 60, 60, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 52, 60, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 90, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 91, 92, 4, 4, 4, 4, 93, 94, 4, 95, 96, 4, 97, 98, 99, 62, 4, 100, 101,\n            102, 4, 103, 104, 105, 4, 106, 107, 108, 4, 109, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 110, 111, 60, 60, 60, 60, 60, 60, 60,\n            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 4, 4, 4, 4, 4, 101, 4, 112,\n            113, 114, 95, 115, 4, 116, 4, 4, 117, 118, 119, 120, 121, 122, 4, 123, 124, 125, 126,\n            127\n        ],\n        r3: &[\n            0x00003fffffffffff, 0x000007ff0fffffff, 0x3fdfffff00000000, 0xfffffffbfff00000,\n            0xffffffffffffffff, 0xfffeffcfffffffff, 0xf3c5fdfffff99fef, 0x1003ffcfb080799f,\n            0xd36dfdfffff987ee, 0x003fffc05e023987, 0xf3edfdfffffbbfee, 0xfe00ffcf00013bbf,\n            0xf3edfdfffff99fee, 0x0002ffcfb0c0399f, 0xc3ffc718d63dc7ec, 0x0000ffc000813dc7,\n            0xe3fffdfffffddfef, 0x0000ffcf07603ddf, 0xf3effdfffffddfef, 0x0006ffcf40603ddf,\n            0xfffffffffffddfef, 0xfc00ffcf80f07ddf, 0x2ffbfffffc7fffec, 0x000cffc0ff5f847f,\n            0x07fffffffffffffe, 0x0000000003ff7fff, 0x3bffecaefef02596, 0x00000000f3ff3f5f,\n            0xc2a003ff03000001, 0xfffe1ffffffffeff, 0x1ffffffffeffffdf, 0x0000000000000040,\n            0xffffffffffff03ff, 0xffffffff3fffffff, 0xf7ffffffffff20bf, 0xffffffff3d7f3dff,\n            0x7f3dffffffff3dff, 0xffffffffff7fff3d, 0xffffffffff3dffff, 0x0003fe00e7ffffff,\n            0xffffffff0000ffff, 0x3f3fffffffffffff, 0xfffffffffffffffe, 0xffff9fffffffffff,\n            0xffffffff07fffffe, 0x01ffc7ffffffffff, 0x001fffff001fdfff, 0x000ddfff000fffff,\n            0x000003ff308fffff, 0xffffffff03ff3800, 0x00ffffffffffffff, 0xffff07ffffffffff,\n            0x003fffffffffffff, 0x0fff0fff7fffffff, 0x001f3fffffffffc0, 0xffff0fffffffffff,\n            0x0000000007ff03ff, 0xffffffff0fffffff, 0x9fffffff7fffffff, 0x3fff008003ff03ff,\n            0x0000000000000000, 0x000ff80003ff0fff, 0x000fffffffffffff, 0x3fffffffffffe3ff,\n            0x00000000000001ff, 0x03fffffffff70000, 0xfbffffffffffffff, 0xffffffff3f3fffff,\n            0x3fffffffaaff3f3f, 0x5fdfffffffffffff, 0x1fdc1fff0fcf1fdc, 0x8000000000000000,\n            0x8002000000100001, 0x000000001fff0000, 0x0001ffe21fff0000, 0xf3fffd503f2ffc84,\n            0xffffffff000043e0, 0xffff7fffffffffff, 0xffffffff7fffffff, 0x000ff81fffffffff,\n            0xffff20bfffffffff, 0x800080ffffffffff, 0x7f7f7f7f007fffff, 0xffffffff7f7f7f7f,\n            0x1f3efffe000000e0, 0xfffffffee67fffff, 0xf7ffffffffffffff, 0xfffe7fffffffffe0,\n            0x07ffffff00007fff, 0xffff000000000000, 0x000007ffffffffff, 0x0000000000001fff,\n            0x3fffffffffff0000, 0x00000fffffff1fff, 0xbff0ffffffffffff, 0x0003ffffffffffff,\n            0xfffffffcff800000, 0x00ff7ffffffff9ff, 0xff80000000000000, 0x000000ffffffffff,\n            0x28ffffff03ff003f, 0xffff3fffffffffff, 0x1fffffff000fffff, 0x7fffffff03ff8001,\n            0x007fffffffffffff, 0xfc7fffff03ff3fff, 0x007cffff38000007, 0xffff7f7f007e7e7e,\n            0xffff003ff7ffffff, 0x03ff37ffffffffff, 0xffff000fffffffff, 0x0ffffffffffff87f,\n            0x0000000003ffffff, 0x5f7ffdffe0f8007f, 0xffffffffffffffdb, 0xfffffffffff80000,\n            0xfffffff03fffffff, 0x3fffffffffffffff, 0xffffffffffff0000, 0xfffffffffffcffff,\n            0x03ff0000000000ff, 0x0018ffff0000ffff, 0xaa8a00000000e000, 0x1fffffffffffffff,\n            0x87fffffe03ff0000, 0xffffffc007fffffe, 0x7fffffffffffffff, 0x000000001cfcfcfc\n        ],\n        r4: [\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 5, 9, 5, 10, 11, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 13,\n            14, 7, 15, 16, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 17, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n        ],\n        r5: &[\n            0, 1, 2, 3, 4, 5, 4, 6, 4, 4, 7, 8, 9, 10, 11, 12, 2, 2, 13, 14, 15, 16, 4, 4, 2, 2, 2,\n            2, 17, 18, 4, 4, 19, 20, 21, 22, 23, 4, 24, 4, 25, 26, 27, 28, 29, 30, 31, 4, 2, 32, 33,\n            33, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 34, 3, 35, 36, 37, 2, 38, 39, 4, 40, 41, 42,\n            43, 4, 4, 2, 44, 2, 45, 4, 4, 46, 47, 2, 48, 49, 50, 51, 4, 4, 4, 4, 4, 52, 53, 4, 4, 4,\n            4, 54, 55, 56, 57, 4, 4, 4, 4, 58, 59, 60, 4, 61, 62, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 63, 4, 2, 64, 2, 2, 2, 65, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 64, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 66, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2,\n            2, 2, 2, 2, 2, 2, 57, 67, 4, 68, 17, 69, 70, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n            71, 72, 73, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 74, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 33, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 21, 75, 2, 2, 2, 2, 2, 76,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 2, 77, 78, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            79, 80, 4, 4, 81, 4, 4, 4, 4, 4, 4, 2, 82, 83, 84, 85, 86, 2, 2, 2, 2, 87, 88, 89, 90,\n            91, 92, 4, 4, 4, 4, 4, 4, 4, 4, 93, 94, 95, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 96, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 97, 2, 44, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 98, 99, 100, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 101, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 11, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 102, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 103, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 104, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 105, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4\n        ],\n        r6: &[\n            0xb7ffff7fffffefff, 0x000000003fff3fff, 0xffffffffffffffff, 0x07ffffffffffffff,\n            0x0000000000000000, 0x001fffffffffffff, 0x2000000000000000, 0xffffffff1fffffff,\n            0x000000010001ffff, 0xffffe000ffffffff, 0x07ffffffffff07ff, 0xffffffff3fffffff,\n            0x00000000003eff0f, 0xffff03ff3fffffff, 0x0fffffffff0fffff, 0xffff00ffffffffff,\n            0x0000000fffffffff, 0x007fffffffffffff, 0x000000ff003fffff, 0x91bffffffffffd3f,\n            0x007fffff003fffff, 0x000000007fffffff, 0x0037ffff00000000, 0x03ffffff003fffff,\n            0xc0ffffffffffffff, 0x870ffffffeeff06f, 0x1fffffff00000000, 0x000000001fffffff,\n            0x0000007ffffffeff, 0x003fffffffffffff, 0x0007ffff003fffff, 0x000000000003ffff,\n            0x00000000000001ff, 0x0007ffffffffffff, 0x8000ffc00000007f, 0x03ff01ffffff0000,\n            0xffdfffffffffffff, 0x004fffffffff0000, 0x0000000017ff1c1f, 0x40fffffffffbffff,\n            0xffff01ffbfffbd7f, 0x03ff07ffffffffff, 0xf3edfdfffff99fef, 0x001f1fcfe081399f,\n            0x0000000003ff07ff, 0x0000000003ff00bf, 0xff3fffffffffffff, 0x000000003f000001,\n            0x0000000003ff0011, 0x00ffffffffffffff, 0x00000000000003ff, 0x03ff0fffe3ffffff,\n            0xffffffff00000000, 0x800003ffffffffff, 0x7fffffffffffffff, 0xffffffffffff0080,\n            0x0000000003ffffcf, 0x01ffffffffffffff, 0xff7ffffffffffdff, 0xfffc000003ff0001,\n            0x007ffefffffcffff, 0xb47ffffffffffb7f, 0x0000000003ff00ff, 0x0000000003ffffff,\n            0x00007fffffffffff, 0x000000000000000f, 0x000000000000007f, 0x000003ff7fffffff,\n            0x001f3fffffff0000, 0xe0fffff803ff000f, 0x000000000000ffff, 0x7fffffffffff001f,\n            0x00000000ffff8000, 0x0000000300000000, 0x00001fffffffffff, 0xffff000000000000,\n            0x0fffffffffffffff, 0x1fff07ffffffffff, 0x0000000063ff01ff, 0xf807e3e000000000,\n            0x00003c0000000fe7, 0x000000000000001c, 0xffffffffffdfffff, 0xebffde64dfffffff,\n            0xffffffffffffffef, 0x7bffffffdfdfe7bf, 0xfffffffffffdfc5f, 0xffffff3fffffffff,\n            0xf7fffffff7fffffd, 0xffdfffffffdfffff, 0xffff7fffffff7fff, 0xfffffdfffffffdff,\n            0xffffffffffffcff7, 0xf87fffffffffffff, 0x00201fffffffffff, 0x0000fffef8000010,\n            0x000007dbf9ffff7f, 0x00000000007f001f, 0x0af7fe96ffffffef, 0x5ef7f796aa96ea84,\n            0x0ffffbee0ffffbff, 0x00000000007fffff, 0xffff0003ffffffff, 0x00000001ffffffff,\n            0x000000003fffffff, 0x0000ffffffffffff\n        ],\n    };\n\n    pub fn XID_Continue(c: char) -> bool {\n        super::trie_lookup_range_table(c, XID_Continue_table)\n    }\n\n    pub const XID_Start_table: &'static super::BoolTrie = &super::BoolTrie {\n        r1: [\n            0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x0000501f0003ffc3,\n            0x0000000000000000, 0xb8df000000000000, 0xfffffffbffffd740, 0xffbfffffffffffff,\n            0xffffffffffffffff, 0xffffffffffffffff, 0xfffffffffffffc03, 0xffffffffffffffff,\n            0xfffeffffffffffff, 0xfffffffe027fffff, 0x00000000000000ff, 0x000707ffffff0000,\n            0xffffffff00000000, 0xfffec000000007ff, 0xffffffffffffffff, 0x9c00c060002fffff,\n            0x0000fffffffd0000, 0xffffffffffffe000, 0x0002003fffffffff, 0x043007fffffffc00\n        ],\n        r2: [\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n            24, 23, 25, 26, 27, 28, 29, 3, 30, 31, 32, 33, 34, 34, 34, 34, 34, 35, 36, 37, 38, 39,\n            40, 41, 42, 34, 34, 34, 34, 34, 34, 34, 34, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\n            54, 55, 56, 57, 58, 59, 60, 3, 61, 62, 63, 64, 65, 66, 67, 68, 34, 34, 34, 3, 34, 34,\n            34, 34, 69, 70, 71, 72, 3, 73, 74, 3, 75, 76, 67, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 77,\n            78, 34, 79, 80, 81, 82, 83, 3, 3, 3, 3, 3, 3, 3, 3, 84, 42, 85, 86, 87, 34, 88, 89, 3,\n            3, 3, 3, 3, 3, 3, 3, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 53, 3, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 90, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 91, 92, 34, 34, 34, 34, 93,\n            94, 95, 96, 97, 34, 98, 99, 100, 48, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,\n            111, 112, 34, 113, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n            34, 34, 34, 114, 115, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 34, 34, 34, 34, 34,\n            116, 34, 117, 118, 119, 120, 121, 34, 122, 34, 34, 123, 124, 125, 126, 3, 127, 34, 128,\n            129, 130, 131, 132\n        ],\n        r3: &[\n            0x00000110043fffff, 0x000007ff01ffffff, 0x3fdfffff00000000, 0x0000000000000000,\n            0x23fffffffffffff0, 0xfffe0003ff010000, 0x23c5fdfffff99fe1, 0x10030003b0004000,\n            0x036dfdfffff987e0, 0x001c00005e000000, 0x23edfdfffffbbfe0, 0x0200000300010000,\n            0x23edfdfffff99fe0, 0x00020003b0000000, 0x03ffc718d63dc7e8, 0x0000000000010000,\n            0x23fffdfffffddfe0, 0x0000000307000000, 0x23effdfffffddfe1, 0x0006000340000000,\n            0x27fffffffffddfe0, 0xfc00000380704000, 0x2ffbfffffc7fffe0, 0x000000000000007f,\n            0x0005fffffffffffe, 0x2005ecaefef02596, 0x00000000f000005f, 0x0000000000000001,\n            0x00001ffffffffeff, 0x0000000000001f00, 0x800007ffffffffff, 0xffe1c0623c3f0000,\n            0xffffffff00004003, 0xf7ffffffffff20bf, 0xffffffffffffffff, 0xffffffff3d7f3dff,\n            0x7f3dffffffff3dff, 0xffffffffff7fff3d, 0xffffffffff3dffff, 0x0000000007ffffff,\n            0xffffffff0000ffff, 0x3f3fffffffffffff, 0xfffffffffffffffe, 0xffff9fffffffffff,\n            0xffffffff07fffffe, 0x01ffc7ffffffffff, 0x0003ffff0003dfff, 0x0001dfff0003ffff,\n            0x000fffffffffffff, 0x0000000010800000, 0xffffffff00000000, 0x00ffffffffffffff,\n            0xffff05ffffffffff, 0x003fffffffffffff, 0x000000007fffffff, 0x001f3fffffff0000,\n            0xffff0fffffffffff, 0x00000000000003ff, 0xffffffff007fffff, 0x00000000001fffff,\n            0x0000008000000000, 0x000fffffffffffe0, 0x0000000000000fe0, 0xfc00c001fffffff8,\n            0x0000003fffffffff, 0x0000000fffffffff, 0x3ffffffffc00e000, 0x00000000000001ff,\n            0x0063de0000000000, 0xffffffff3f3fffff, 0x3fffffffaaff3f3f, 0x5fdfffffffffffff,\n            0x1fdc1fff0fcf1fdc, 0x8002000000000000, 0x000000001fff0000, 0xf3fffd503f2ffc84,\n            0xffffffff000043e0, 0xffff7fffffffffff, 0xffffffff7fffffff, 0x000c781fffffffff,\n            0xffff20bfffffffff, 0x000080ffffffffff, 0x7f7f7f7f007fffff, 0x000000007f7f7f7f,\n            0x1f3e03fe000000e0, 0xfffffffee07fffff, 0xf7ffffffffffffff, 0xfffe7fffffffffe0,\n            0x07ffffff00007fff, 0xffff000000000000, 0x000007ffffffffff, 0x0000000000001fff,\n            0x3fffffffffff0000, 0x00000c00ffff1fff, 0x80007fffffffffff, 0xffffffff3fffffff,\n            0x0000ffffffffffff, 0xfffffffcff800000, 0x00ff7ffffffff9ff, 0xff80000000000000,\n            0x00000007fffff7bb, 0x000ffffffffffffc, 0x28fc000000000000, 0xffff003ffffffc00,\n            0x1fffffff0000007f, 0x0007fffffffffff0, 0x7c00ffdf00008000, 0x000001ffffffffff,\n            0xc47fffff00000ff7, 0x3e62ffffffffffff, 0x001c07ff38000005, 0xffff7f7f007e7e7e,\n            0xffff003ff7ffffff, 0x00000007ffffffff, 0xffff000fffffffff, 0x0ffffffffffff87f,\n            0xffff3fffffffffff, 0x0000000003ffffff, 0x5f7ffdffa0f8007f, 0xffffffffffffffdb,\n            0x0003ffffffffffff, 0xfffffffffff80000, 0xfffffff03fffffff, 0x3fffffffffffffff,\n            0xffffffffffff0000, 0xfffffffffffcffff, 0x03ff0000000000ff, 0xaa8a000000000000,\n            0x1fffffffffffffff, 0x07fffffe00000000, 0xffffffc007fffffe, 0x7fffffff3fffffff,\n            0x000000001cfcfcfc\n        ],\n        r4: [\n            0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 5, 9, 5, 10, 11, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 13,\n            14, 7, 15, 16, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n        ],\n        r5: &[\n            0, 1, 2, 3, 4, 5, 4, 4, 4, 4, 6, 7, 8, 9, 10, 11, 2, 2, 12, 13, 14, 15, 4, 4, 2, 2, 2,\n            2, 16, 17, 4, 4, 18, 19, 20, 21, 22, 4, 23, 4, 24, 25, 26, 27, 28, 29, 30, 4, 2, 31, 32,\n            32, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 33, 4, 34, 35, 36, 37, 38, 39, 40, 4, 41, 20,\n            42, 43, 4, 4, 5, 44, 45, 46, 4, 4, 47, 48, 45, 49, 50, 4, 51, 4, 4, 4, 4, 4, 52, 53, 4,\n            4, 4, 4, 54, 55, 56, 57, 4, 4, 4, 4, 58, 59, 60, 4, 61, 62, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 51, 4, 2, 47, 2, 2, 2, 63, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 47, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 64, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            2, 2, 2, 2, 2, 2, 2, 2, 57, 20, 4, 65, 45, 66, 60, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 2, 67, 68, 69, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 70, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 20, 71, 2, 2, 2, 2, 2,\n            72, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 2, 73, 74, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 75, 76, 77, 78, 79, 2, 2, 2, 2, 80, 81, 82, 83, 84,\n            85, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 86, 2, 63, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 87, 88, 89, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 90, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 10, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 91, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 92, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 93, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4\n        ],\n        r6: &[\n            0xb7ffff7fffffefff, 0x000000003fff3fff, 0xffffffffffffffff, 0x07ffffffffffffff,\n            0x0000000000000000, 0x001fffffffffffff, 0xffffffff1fffffff, 0x000000000001ffff,\n            0xffffe000ffffffff, 0x003fffffffff07ff, 0xffffffff3fffffff, 0x00000000003eff0f,\n            0xffff00003fffffff, 0x0fffffffff0fffff, 0xffff00ffffffffff, 0x0000000fffffffff,\n            0x007fffffffffffff, 0x000000ff003fffff, 0x91bffffffffffd3f, 0x007fffff003fffff,\n            0x000000007fffffff, 0x0037ffff00000000, 0x03ffffff003fffff, 0xc0ffffffffffffff,\n            0x000ffffffeef0001, 0x1fffffff00000000, 0x000000001fffffff, 0x0000001ffffffeff,\n            0x003fffffffffffff, 0x0007ffff003fffff, 0x000000000003ffff, 0x00000000000001ff,\n            0x0007ffffffffffff, 0x00fffffffffffff8, 0x0000fffffffffff8, 0x000001ffffff0000,\n            0x0000007ffffffff8, 0x0047ffffffff0000, 0x0007fffffffffff8, 0x000000001400001e,\n            0x00000ffffffbffff, 0xffff01ffbfffbd7f, 0x23edfdfffff99fe0, 0x00000003e0010000,\n            0x0000000000000780, 0x0000ffffffffffff, 0x00000000000000b0, 0x00007fffffffffff,\n            0x000000000f000000, 0x0000000000000010, 0x000007ffffffffff, 0x0000000003ffffff,\n            0xffffffff00000000, 0x80000000ffffffff, 0x0407fffffffff801, 0xfffffffff0010000,\n            0x00000000000003cf, 0x01ffffffffffffff, 0x00007ffffffffdff, 0xfffc000000000001,\n            0x000000000000ffff, 0x0001fffffffffb7f, 0x0000000000000040, 0x000000000000000f,\n            0x000000000000007f, 0x00003fffffff0000, 0xe0fffff80000000f, 0x000000000001001f,\n            0x00000000fff80000, 0x0000000300000000, 0x00001fffffffffff, 0xffff000000000000,\n            0x0fffffffffffffff, 0x1fff07ffffffffff, 0x0000000003ff01ff, 0xffffffffffdfffff,\n            0xebffde64dfffffff, 0xffffffffffffffef, 0x7bffffffdfdfe7bf, 0xfffffffffffdfc5f,\n            0xffffff3fffffffff, 0xf7fffffff7fffffd, 0xffdfffffffdfffff, 0xffff7fffffff7fff,\n            0xfffffdfffffffdff, 0x0000000000000ff7, 0x000000000000001f, 0x0af7fe96ffffffef,\n            0x5ef7f796aa96ea84, 0x0ffffbee0ffffbff, 0x00000000007fffff, 0xffff0003ffffffff,\n            0x00000001ffffffff, 0x000000003fffffff\n        ],\n    };\n\n    pub fn XID_Start(c: char) -> bool {\n        super::trie_lookup_range_table(c, XID_Start_table)\n    }\n\n}\n\npub mod property {\n    pub const Pattern_White_Space_table: &'static super::SmallBoolTrie = &super::SmallBoolTrie {\n        r1: &[\n            0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3\n        ],\n        r2: &[\n            0x0000000100003e00, 0x0000000000000000, 0x0000000000000020, 0x000003000000c000\n        ],\n    };\n\n    pub fn Pattern_White_Space(c: char) -> bool {\n        Pattern_White_Space_table.lookup(c)\n    }\n\n    pub const White_Space_table: &'static super::SmallBoolTrie = &super::SmallBoolTrie {\n        r1: &[\n            0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3\n        ],\n        r2: &[\n            0x0000000100003e00, 0x0000000000000000, 0x0000000100000020, 0x0000000000000001,\n            0x00008300000007ff, 0x0000000080000000\n        ],\n    };\n\n    pub fn White_Space(c: char) -> bool {\n        White_Space_table.lookup(c)\n    }\n\n}\n\npub mod conversions {\n    use core::option::Option;\n    use core::option::Option::{Some, None};\n\n    pub fn to_lower(c: char) -> [char; 3] {\n        match bsearch_case_table(c, to_lowercase_table) {\n            None        => [c, '\\0', '\\0'],\n            Some(index) => to_lowercase_table[index].1,\n        }\n    }\n\n    pub fn to_upper(c: char) -> [char; 3] {\n        match bsearch_case_table(c, to_uppercase_table) {\n            None        => [c, '\\0', '\\0'],\n            Some(index) => to_uppercase_table[index].1,\n        }\n    }\n\n    fn bsearch_case_table(c: char, table: &'static [(char, [char; 3])]) -> Option<usize> {\n        table.binary_search_by(|&(key, _)| key.cmp(&c)).ok()\n    }\n\n    const to_lowercase_table: &'static [(char, [char; 3])] = &[\n        ('\\u{41}', ['\\u{61}', '\\0', '\\0']), ('\\u{42}', ['\\u{62}', '\\0', '\\0']), ('\\u{43}',\n        ['\\u{63}', '\\0', '\\0']), ('\\u{44}', ['\\u{64}', '\\0', '\\0']), ('\\u{45}', ['\\u{65}', '\\0',\n        '\\0']), ('\\u{46}', ['\\u{66}', '\\0', '\\0']), ('\\u{47}', ['\\u{67}', '\\0', '\\0']), ('\\u{48}',\n        ['\\u{68}', '\\0', '\\0']), ('\\u{49}', ['\\u{69}', '\\0', '\\0']), ('\\u{4a}', ['\\u{6a}', '\\0',\n        '\\0']), ('\\u{4b}', ['\\u{6b}', '\\0', '\\0']), ('\\u{4c}', ['\\u{6c}', '\\0', '\\0']), ('\\u{4d}',\n        ['\\u{6d}', '\\0', '\\0']), ('\\u{4e}', ['\\u{6e}', '\\0', '\\0']), ('\\u{4f}', ['\\u{6f}', '\\0',\n        '\\0']), ('\\u{50}', ['\\u{70}', '\\0', '\\0']), ('\\u{51}', ['\\u{71}', '\\0', '\\0']), ('\\u{52}',\n        ['\\u{72}', '\\0', '\\0']), ('\\u{53}', ['\\u{73}', '\\0', '\\0']), ('\\u{54}', ['\\u{74}', '\\0',\n        '\\0']), ('\\u{55}', ['\\u{75}', '\\0', '\\0']), ('\\u{56}', ['\\u{76}', '\\0', '\\0']), ('\\u{57}',\n        ['\\u{77}', '\\0', '\\0']), ('\\u{58}', ['\\u{78}', '\\0', '\\0']), ('\\u{59}', ['\\u{79}', '\\0',\n        '\\0']), ('\\u{5a}', ['\\u{7a}', '\\0', '\\0']), ('\\u{c0}', ['\\u{e0}', '\\0', '\\0']), ('\\u{c1}',\n        ['\\u{e1}', '\\0', '\\0']), ('\\u{c2}', ['\\u{e2}', '\\0', '\\0']), ('\\u{c3}', ['\\u{e3}', '\\0',\n        '\\0']), ('\\u{c4}', ['\\u{e4}', '\\0', '\\0']), ('\\u{c5}', ['\\u{e5}', '\\0', '\\0']), ('\\u{c6}',\n        ['\\u{e6}', '\\0', '\\0']), ('\\u{c7}', ['\\u{e7}', '\\0', '\\0']), ('\\u{c8}', ['\\u{e8}', '\\0',\n        '\\0']), ('\\u{c9}', ['\\u{e9}', '\\0', '\\0']), ('\\u{ca}', ['\\u{ea}', '\\0', '\\0']), ('\\u{cb}',\n        ['\\u{eb}', '\\0', '\\0']), ('\\u{cc}', ['\\u{ec}', '\\0', '\\0']), ('\\u{cd}', ['\\u{ed}', '\\0',\n        '\\0']), ('\\u{ce}', ['\\u{ee}', '\\0', '\\0']), ('\\u{cf}', ['\\u{ef}', '\\0', '\\0']), ('\\u{d0}',\n        ['\\u{f0}', '\\0', '\\0']), ('\\u{d1}', ['\\u{f1}', '\\0', '\\0']), ('\\u{d2}', ['\\u{f2}', '\\0',\n        '\\0']), ('\\u{d3}', ['\\u{f3}', '\\0', '\\0']), ('\\u{d4}', ['\\u{f4}', '\\0', '\\0']), ('\\u{d5}',\n        ['\\u{f5}', '\\0', '\\0']), ('\\u{d6}', ['\\u{f6}', '\\0', '\\0']), ('\\u{d8}', ['\\u{f8}', '\\0',\n        '\\0']), ('\\u{d9}', ['\\u{f9}', '\\0', '\\0']), ('\\u{da}', ['\\u{fa}', '\\0', '\\0']), ('\\u{db}',\n        ['\\u{fb}', '\\0', '\\0']), ('\\u{dc}', ['\\u{fc}', '\\0', '\\0']), ('\\u{dd}', ['\\u{fd}', '\\0',\n        '\\0']), ('\\u{de}', ['\\u{fe}', '\\0', '\\0']), ('\\u{100}', ['\\u{101}', '\\0', '\\0']),\n        ('\\u{102}', ['\\u{103}', '\\0', '\\0']), ('\\u{104}', ['\\u{105}', '\\0', '\\0']), ('\\u{106}',\n        ['\\u{107}', '\\0', '\\0']), ('\\u{108}', ['\\u{109}', '\\0', '\\0']), ('\\u{10a}', ['\\u{10b}',\n        '\\0', '\\0']), ('\\u{10c}', ['\\u{10d}', '\\0', '\\0']), ('\\u{10e}', ['\\u{10f}', '\\0', '\\0']),\n        ('\\u{110}', ['\\u{111}', '\\0', '\\0']), ('\\u{112}', ['\\u{113}', '\\0', '\\0']), ('\\u{114}',\n        ['\\u{115}', '\\0', '\\0']), ('\\u{116}', ['\\u{117}', '\\0', '\\0']), ('\\u{118}', ['\\u{119}',\n        '\\0', '\\0']), ('\\u{11a}', ['\\u{11b}', '\\0', '\\0']), ('\\u{11c}', ['\\u{11d}', '\\0', '\\0']),\n        ('\\u{11e}', ['\\u{11f}', '\\0', '\\0']), ('\\u{120}', ['\\u{121}', '\\0', '\\0']), ('\\u{122}',\n        ['\\u{123}', '\\0', '\\0']), ('\\u{124}', ['\\u{125}', '\\0', '\\0']), ('\\u{126}', ['\\u{127}',\n        '\\0', '\\0']), ('\\u{128}', ['\\u{129}', '\\0', '\\0']), ('\\u{12a}', ['\\u{12b}', '\\0', '\\0']),\n        ('\\u{12c}', ['\\u{12d}', '\\0', '\\0']), ('\\u{12e}', ['\\u{12f}', '\\0', '\\0']), ('\\u{130}',\n        ['\\u{69}', '\\u{307}', '\\0']), ('\\u{132}', ['\\u{133}', '\\0', '\\0']), ('\\u{134}', ['\\u{135}',\n        '\\0', '\\0']), ('\\u{136}', ['\\u{137}', '\\0', '\\0']), ('\\u{139}', ['\\u{13a}', '\\0', '\\0']),\n        ('\\u{13b}', ['\\u{13c}', '\\0', '\\0']), ('\\u{13d}', ['\\u{13e}', '\\0', '\\0']), ('\\u{13f}',\n        ['\\u{140}', '\\0', '\\0']), ('\\u{141}', ['\\u{142}', '\\0', '\\0']), ('\\u{143}', ['\\u{144}',\n        '\\0', '\\0']), ('\\u{145}', ['\\u{146}', '\\0', '\\0']), ('\\u{147}', ['\\u{148}', '\\0', '\\0']),\n        ('\\u{14a}', ['\\u{14b}', '\\0', '\\0']), ('\\u{14c}', ['\\u{14d}', '\\0', '\\0']), ('\\u{14e}',\n        ['\\u{14f}', '\\0', '\\0']), ('\\u{150}', ['\\u{151}', '\\0', '\\0']), ('\\u{152}', ['\\u{153}',\n        '\\0', '\\0']), ('\\u{154}', ['\\u{155}', '\\0', '\\0']), ('\\u{156}', ['\\u{157}', '\\0', '\\0']),\n        ('\\u{158}', ['\\u{159}', '\\0', '\\0']), ('\\u{15a}', ['\\u{15b}', '\\0', '\\0']), ('\\u{15c}',\n        ['\\u{15d}', '\\0', '\\0']), ('\\u{15e}', ['\\u{15f}', '\\0', '\\0']), ('\\u{160}', ['\\u{161}',\n        '\\0', '\\0']), ('\\u{162}', ['\\u{163}', '\\0', '\\0']), ('\\u{164}', ['\\u{165}', '\\0', '\\0']),\n        ('\\u{166}', ['\\u{167}', '\\0', '\\0']), ('\\u{168}', ['\\u{169}', '\\0', '\\0']), ('\\u{16a}',\n        ['\\u{16b}', '\\0', '\\0']), ('\\u{16c}', ['\\u{16d}', '\\0', '\\0']), ('\\u{16e}', ['\\u{16f}',\n        '\\0', '\\0']), ('\\u{170}', ['\\u{171}', '\\0', '\\0']), ('\\u{172}', ['\\u{173}', '\\0', '\\0']),\n        ('\\u{174}', ['\\u{175}', '\\0', '\\0']), ('\\u{176}', ['\\u{177}', '\\0', '\\0']), ('\\u{178}',\n        ['\\u{ff}', '\\0', '\\0']), ('\\u{179}', ['\\u{17a}', '\\0', '\\0']), ('\\u{17b}', ['\\u{17c}', '\\0',\n        '\\0']), ('\\u{17d}', ['\\u{17e}', '\\0', '\\0']), ('\\u{181}', ['\\u{253}', '\\0', '\\0']),\n        ('\\u{182}', ['\\u{183}', '\\0', '\\0']), ('\\u{184}', ['\\u{185}', '\\0', '\\0']), ('\\u{186}',\n        ['\\u{254}', '\\0', '\\0']), ('\\u{187}', ['\\u{188}', '\\0', '\\0']), ('\\u{189}', ['\\u{256}',\n        '\\0', '\\0']), ('\\u{18a}', ['\\u{257}', '\\0', '\\0']), ('\\u{18b}', ['\\u{18c}', '\\0', '\\0']),\n        ('\\u{18e}', ['\\u{1dd}', '\\0', '\\0']), ('\\u{18f}', ['\\u{259}', '\\0', '\\0']), ('\\u{190}',\n        ['\\u{25b}', '\\0', '\\0']), ('\\u{191}', ['\\u{192}', '\\0', '\\0']), ('\\u{193}', ['\\u{260}',\n        '\\0', '\\0']), ('\\u{194}', ['\\u{263}', '\\0', '\\0']), ('\\u{196}', ['\\u{269}', '\\0', '\\0']),\n        ('\\u{197}', ['\\u{268}', '\\0', '\\0']), ('\\u{198}', ['\\u{199}', '\\0', '\\0']), ('\\u{19c}',\n        ['\\u{26f}', '\\0', '\\0']), ('\\u{19d}', ['\\u{272}', '\\0', '\\0']), ('\\u{19f}', ['\\u{275}',\n        '\\0', '\\0']), ('\\u{1a0}', ['\\u{1a1}', '\\0', '\\0']), ('\\u{1a2}', ['\\u{1a3}', '\\0', '\\0']),\n        ('\\u{1a4}', ['\\u{1a5}', '\\0', '\\0']), ('\\u{1a6}', ['\\u{280}', '\\0', '\\0']), ('\\u{1a7}',\n        ['\\u{1a8}', '\\0', '\\0']), ('\\u{1a9}', ['\\u{283}', '\\0', '\\0']), ('\\u{1ac}', ['\\u{1ad}',\n        '\\0', '\\0']), ('\\u{1ae}', ['\\u{288}', '\\0', '\\0']), ('\\u{1af}', ['\\u{1b0}', '\\0', '\\0']),\n        ('\\u{1b1}', ['\\u{28a}', '\\0', '\\0']), ('\\u{1b2}', ['\\u{28b}', '\\0', '\\0']), ('\\u{1b3}',\n        ['\\u{1b4}', '\\0', '\\0']), ('\\u{1b5}', ['\\u{1b6}', '\\0', '\\0']), ('\\u{1b7}', ['\\u{292}',\n        '\\0', '\\0']), ('\\u{1b8}', ['\\u{1b9}', '\\0', '\\0']), ('\\u{1bc}', ['\\u{1bd}', '\\0', '\\0']),\n        ('\\u{1c4}', ['\\u{1c6}', '\\0', '\\0']), ('\\u{1c5}', ['\\u{1c6}', '\\0', '\\0']), ('\\u{1c7}',\n        ['\\u{1c9}', '\\0', '\\0']), ('\\u{1c8}', ['\\u{1c9}', '\\0', '\\0']), ('\\u{1ca}', ['\\u{1cc}',\n        '\\0', '\\0']), ('\\u{1cb}', ['\\u{1cc}', '\\0', '\\0']), ('\\u{1cd}', ['\\u{1ce}', '\\0', '\\0']),\n        ('\\u{1cf}', ['\\u{1d0}', '\\0', '\\0']), ('\\u{1d1}', ['\\u{1d2}', '\\0', '\\0']), ('\\u{1d3}',\n        ['\\u{1d4}', '\\0', '\\0']), ('\\u{1d5}', ['\\u{1d6}', '\\0', '\\0']), ('\\u{1d7}', ['\\u{1d8}',\n        '\\0', '\\0']), ('\\u{1d9}', ['\\u{1da}', '\\0', '\\0']), ('\\u{1db}', ['\\u{1dc}', '\\0', '\\0']),\n        ('\\u{1de}', ['\\u{1df}', '\\0', '\\0']), ('\\u{1e0}', ['\\u{1e1}', '\\0', '\\0']), ('\\u{1e2}',\n        ['\\u{1e3}', '\\0', '\\0']), ('\\u{1e4}', ['\\u{1e5}', '\\0', '\\0']), ('\\u{1e6}', ['\\u{1e7}',\n        '\\0', '\\0']), ('\\u{1e8}', ['\\u{1e9}', '\\0', '\\0']), ('\\u{1ea}', ['\\u{1eb}', '\\0', '\\0']),\n        ('\\u{1ec}', ['\\u{1ed}', '\\0', '\\0']), ('\\u{1ee}', ['\\u{1ef}', '\\0', '\\0']), ('\\u{1f1}',\n        ['\\u{1f3}', '\\0', '\\0']), ('\\u{1f2}', ['\\u{1f3}', '\\0', '\\0']), ('\\u{1f4}', ['\\u{1f5}',\n        '\\0', '\\0']), ('\\u{1f6}', ['\\u{195}', '\\0', '\\0']), ('\\u{1f7}', ['\\u{1bf}', '\\0', '\\0']),\n        ('\\u{1f8}', ['\\u{1f9}', '\\0', '\\0']), ('\\u{1fa}', ['\\u{1fb}', '\\0', '\\0']), ('\\u{1fc}',\n        ['\\u{1fd}', '\\0', '\\0']), ('\\u{1fe}', ['\\u{1ff}', '\\0', '\\0']), ('\\u{200}', ['\\u{201}',\n        '\\0', '\\0']), ('\\u{202}', ['\\u{203}', '\\0', '\\0']), ('\\u{204}', ['\\u{205}', '\\0', '\\0']),\n        ('\\u{206}', ['\\u{207}', '\\0', '\\0']), ('\\u{208}', ['\\u{209}', '\\0', '\\0']), ('\\u{20a}',\n        ['\\u{20b}', '\\0', '\\0']), ('\\u{20c}', ['\\u{20d}', '\\0', '\\0']), ('\\u{20e}', ['\\u{20f}',\n        '\\0', '\\0']), ('\\u{210}', ['\\u{211}', '\\0', '\\0']), ('\\u{212}', ['\\u{213}', '\\0', '\\0']),\n        ('\\u{214}', ['\\u{215}', '\\0', '\\0']), ('\\u{216}', ['\\u{217}', '\\0', '\\0']), ('\\u{218}',\n        ['\\u{219}', '\\0', '\\0']), ('\\u{21a}', ['\\u{21b}', '\\0', '\\0']), ('\\u{21c}', ['\\u{21d}',\n        '\\0', '\\0']), ('\\u{21e}', ['\\u{21f}', '\\0', '\\0']), ('\\u{220}', ['\\u{19e}', '\\0', '\\0']),\n        ('\\u{222}', ['\\u{223}', '\\0', '\\0']), ('\\u{224}', ['\\u{225}', '\\0', '\\0']), ('\\u{226}',\n        ['\\u{227}', '\\0', '\\0']), ('\\u{228}', ['\\u{229}', '\\0', '\\0']), ('\\u{22a}', ['\\u{22b}',\n        '\\0', '\\0']), ('\\u{22c}', ['\\u{22d}', '\\0', '\\0']), ('\\u{22e}', ['\\u{22f}', '\\0', '\\0']),\n        ('\\u{230}', ['\\u{231}', '\\0', '\\0']), ('\\u{232}', ['\\u{233}', '\\0', '\\0']), ('\\u{23a}',\n        ['\\u{2c65}', '\\0', '\\0']), ('\\u{23b}', ['\\u{23c}', '\\0', '\\0']), ('\\u{23d}', ['\\u{19a}',\n        '\\0', '\\0']), ('\\u{23e}', ['\\u{2c66}', '\\0', '\\0']), ('\\u{241}', ['\\u{242}', '\\0', '\\0']),\n        ('\\u{243}', ['\\u{180}', '\\0', '\\0']), ('\\u{244}', ['\\u{289}', '\\0', '\\0']), ('\\u{245}',\n        ['\\u{28c}', '\\0', '\\0']), ('\\u{246}', ['\\u{247}', '\\0', '\\0']), ('\\u{248}', ['\\u{249}',\n        '\\0', '\\0']), ('\\u{24a}', ['\\u{24b}', '\\0', '\\0']), ('\\u{24c}', ['\\u{24d}', '\\0', '\\0']),\n        ('\\u{24e}', ['\\u{24f}', '\\0', '\\0']), ('\\u{370}', ['\\u{371}', '\\0', '\\0']), ('\\u{372}',\n        ['\\u{373}', '\\0', '\\0']), ('\\u{376}', ['\\u{377}', '\\0', '\\0']), ('\\u{37f}', ['\\u{3f3}',\n        '\\0', '\\0']), ('\\u{386}', ['\\u{3ac}', '\\0', '\\0']), ('\\u{388}', ['\\u{3ad}', '\\0', '\\0']),\n        ('\\u{389}', ['\\u{3ae}', '\\0', '\\0']), ('\\u{38a}', ['\\u{3af}', '\\0', '\\0']), ('\\u{38c}',\n        ['\\u{3cc}', '\\0', '\\0']), ('\\u{38e}', ['\\u{3cd}', '\\0', '\\0']), ('\\u{38f}', ['\\u{3ce}',\n        '\\0', '\\0']), ('\\u{391}', ['\\u{3b1}', '\\0', '\\0']), ('\\u{392}', ['\\u{3b2}', '\\0', '\\0']),\n        ('\\u{393}', ['\\u{3b3}', '\\0', '\\0']), ('\\u{394}', ['\\u{3b4}', '\\0', '\\0']), ('\\u{395}',\n        ['\\u{3b5}', '\\0', '\\0']), ('\\u{396}', ['\\u{3b6}', '\\0', '\\0']), ('\\u{397}', ['\\u{3b7}',\n        '\\0', '\\0']), ('\\u{398}', ['\\u{3b8}', '\\0', '\\0']), ('\\u{399}', ['\\u{3b9}', '\\0', '\\0']),\n        ('\\u{39a}', ['\\u{3ba}', '\\0', '\\0']), ('\\u{39b}', ['\\u{3bb}', '\\0', '\\0']), ('\\u{39c}',\n        ['\\u{3bc}', '\\0', '\\0']), ('\\u{39d}', ['\\u{3bd}', '\\0', '\\0']), ('\\u{39e}', ['\\u{3be}',\n        '\\0', '\\0']), ('\\u{39f}', ['\\u{3bf}', '\\0', '\\0']), ('\\u{3a0}', ['\\u{3c0}', '\\0', '\\0']),\n        ('\\u{3a1}', ['\\u{3c1}', '\\0', '\\0']), ('\\u{3a3}', ['\\u{3c3}', '\\0', '\\0']), ('\\u{3a4}',\n        ['\\u{3c4}', '\\0', '\\0']), ('\\u{3a5}', ['\\u{3c5}', '\\0', '\\0']), ('\\u{3a6}', ['\\u{3c6}',\n        '\\0', '\\0']), ('\\u{3a7}', ['\\u{3c7}', '\\0', '\\0']), ('\\u{3a8}', ['\\u{3c8}', '\\0', '\\0']),\n        ('\\u{3a9}', ['\\u{3c9}', '\\0', '\\0']), ('\\u{3aa}', ['\\u{3ca}', '\\0', '\\0']), ('\\u{3ab}',\n        ['\\u{3cb}', '\\0', '\\0']), ('\\u{3cf}', ['\\u{3d7}', '\\0', '\\0']), ('\\u{3d8}', ['\\u{3d9}',\n        '\\0', '\\0']), ('\\u{3da}', ['\\u{3db}', '\\0', '\\0']), ('\\u{3dc}', ['\\u{3dd}', '\\0', '\\0']),\n        ('\\u{3de}', ['\\u{3df}', '\\0', '\\0']), ('\\u{3e0}', ['\\u{3e1}', '\\0', '\\0']), ('\\u{3e2}',\n        ['\\u{3e3}', '\\0', '\\0']), ('\\u{3e4}', ['\\u{3e5}', '\\0', '\\0']), ('\\u{3e6}', ['\\u{3e7}',\n        '\\0', '\\0']), ('\\u{3e8}', ['\\u{3e9}', '\\0', '\\0']), ('\\u{3ea}', ['\\u{3eb}', '\\0', '\\0']),\n        ('\\u{3ec}', ['\\u{3ed}', '\\0', '\\0']), ('\\u{3ee}', ['\\u{3ef}', '\\0', '\\0']), ('\\u{3f4}',\n        ['\\u{3b8}', '\\0', '\\0']), ('\\u{3f7}', ['\\u{3f8}', '\\0', '\\0']), ('\\u{3f9}', ['\\u{3f2}',\n        '\\0', '\\0']), ('\\u{3fa}', ['\\u{3fb}', '\\0', '\\0']), ('\\u{3fd}', ['\\u{37b}', '\\0', '\\0']),\n        ('\\u{3fe}', ['\\u{37c}', '\\0', '\\0']), ('\\u{3ff}', ['\\u{37d}', '\\0', '\\0']), ('\\u{400}',\n        ['\\u{450}', '\\0', '\\0']), ('\\u{401}', ['\\u{451}', '\\0', '\\0']), ('\\u{402}', ['\\u{452}',\n        '\\0', '\\0']), ('\\u{403}', ['\\u{453}', '\\0', '\\0']), ('\\u{404}', ['\\u{454}', '\\0', '\\0']),\n        ('\\u{405}', ['\\u{455}', '\\0', '\\0']), ('\\u{406}', ['\\u{456}', '\\0', '\\0']), ('\\u{407}',\n        ['\\u{457}', '\\0', '\\0']), ('\\u{408}', ['\\u{458}', '\\0', '\\0']), ('\\u{409}', ['\\u{459}',\n        '\\0', '\\0']), ('\\u{40a}', ['\\u{45a}', '\\0', '\\0']), ('\\u{40b}', ['\\u{45b}', '\\0', '\\0']),\n        ('\\u{40c}', ['\\u{45c}', '\\0', '\\0']), ('\\u{40d}', ['\\u{45d}', '\\0', '\\0']), ('\\u{40e}',\n        ['\\u{45e}', '\\0', '\\0']), ('\\u{40f}', ['\\u{45f}', '\\0', '\\0']), ('\\u{410}', ['\\u{430}',\n        '\\0', '\\0']), ('\\u{411}', ['\\u{431}', '\\0', '\\0']), ('\\u{412}', ['\\u{432}', '\\0', '\\0']),\n        ('\\u{413}', ['\\u{433}', '\\0', '\\0']), ('\\u{414}', ['\\u{434}', '\\0', '\\0']), ('\\u{415}',\n        ['\\u{435}', '\\0', '\\0']), ('\\u{416}', ['\\u{436}', '\\0', '\\0']), ('\\u{417}', ['\\u{437}',\n        '\\0', '\\0']), ('\\u{418}', ['\\u{438}', '\\0', '\\0']), ('\\u{419}', ['\\u{439}', '\\0', '\\0']),\n        ('\\u{41a}', ['\\u{43a}', '\\0', '\\0']), ('\\u{41b}', ['\\u{43b}', '\\0', '\\0']), ('\\u{41c}',\n        ['\\u{43c}', '\\0', '\\0']), ('\\u{41d}', ['\\u{43d}', '\\0', '\\0']), ('\\u{41e}', ['\\u{43e}',\n        '\\0', '\\0']), ('\\u{41f}', ['\\u{43f}', '\\0', '\\0']), ('\\u{420}', ['\\u{440}', '\\0', '\\0']),\n        ('\\u{421}', ['\\u{441}', '\\0', '\\0']), ('\\u{422}', ['\\u{442}', '\\0', '\\0']), ('\\u{423}',\n        ['\\u{443}', '\\0', '\\0']), ('\\u{424}', ['\\u{444}', '\\0', '\\0']), ('\\u{425}', ['\\u{445}',\n        '\\0', '\\0']), ('\\u{426}', ['\\u{446}', '\\0', '\\0']), ('\\u{427}', ['\\u{447}', '\\0', '\\0']),\n        ('\\u{428}', ['\\u{448}', '\\0', '\\0']), ('\\u{429}', ['\\u{449}', '\\0', '\\0']), ('\\u{42a}',\n        ['\\u{44a}', '\\0', '\\0']), ('\\u{42b}', ['\\u{44b}', '\\0', '\\0']), ('\\u{42c}', ['\\u{44c}',\n        '\\0', '\\0']), ('\\u{42d}', ['\\u{44d}', '\\0', '\\0']), ('\\u{42e}', ['\\u{44e}', '\\0', '\\0']),\n        ('\\u{42f}', ['\\u{44f}', '\\0', '\\0']), ('\\u{460}', ['\\u{461}', '\\0', '\\0']), ('\\u{462}',\n        ['\\u{463}', '\\0', '\\0']), ('\\u{464}', ['\\u{465}', '\\0', '\\0']), ('\\u{466}', ['\\u{467}',\n        '\\0', '\\0']), ('\\u{468}', ['\\u{469}', '\\0', '\\0']), ('\\u{46a}', ['\\u{46b}', '\\0', '\\0']),\n        ('\\u{46c}', ['\\u{46d}', '\\0', '\\0']), ('\\u{46e}', ['\\u{46f}', '\\0', '\\0']), ('\\u{470}',\n        ['\\u{471}', '\\0', '\\0']), ('\\u{472}', ['\\u{473}', '\\0', '\\0']), ('\\u{474}', ['\\u{475}',\n        '\\0', '\\0']), ('\\u{476}', ['\\u{477}', '\\0', '\\0']), ('\\u{478}', ['\\u{479}', '\\0', '\\0']),\n        ('\\u{47a}', ['\\u{47b}', '\\0', '\\0']), ('\\u{47c}', ['\\u{47d}', '\\0', '\\0']), ('\\u{47e}',\n        ['\\u{47f}', '\\0', '\\0']), ('\\u{480}', ['\\u{481}', '\\0', '\\0']), ('\\u{48a}', ['\\u{48b}',\n        '\\0', '\\0']), ('\\u{48c}', ['\\u{48d}', '\\0', '\\0']), ('\\u{48e}', ['\\u{48f}', '\\0', '\\0']),\n        ('\\u{490}', ['\\u{491}', '\\0', '\\0']), ('\\u{492}', ['\\u{493}', '\\0', '\\0']), ('\\u{494}',\n        ['\\u{495}', '\\0', '\\0']), ('\\u{496}', ['\\u{497}', '\\0', '\\0']), ('\\u{498}', ['\\u{499}',\n        '\\0', '\\0']), ('\\u{49a}', ['\\u{49b}', '\\0', '\\0']), ('\\u{49c}', ['\\u{49d}', '\\0', '\\0']),\n        ('\\u{49e}', ['\\u{49f}', '\\0', '\\0']), ('\\u{4a0}', ['\\u{4a1}', '\\0', '\\0']), ('\\u{4a2}',\n        ['\\u{4a3}', '\\0', '\\0']), ('\\u{4a4}', ['\\u{4a5}', '\\0', '\\0']), ('\\u{4a6}', ['\\u{4a7}',\n        '\\0', '\\0']), ('\\u{4a8}', ['\\u{4a9}', '\\0', '\\0']), ('\\u{4aa}', ['\\u{4ab}', '\\0', '\\0']),\n        ('\\u{4ac}', ['\\u{4ad}', '\\0', '\\0']), ('\\u{4ae}', ['\\u{4af}', '\\0', '\\0']), ('\\u{4b0}',\n        ['\\u{4b1}', '\\0', '\\0']), ('\\u{4b2}', ['\\u{4b3}', '\\0', '\\0']), ('\\u{4b4}', ['\\u{4b5}',\n        '\\0', '\\0']), ('\\u{4b6}', ['\\u{4b7}', '\\0', '\\0']), ('\\u{4b8}', ['\\u{4b9}', '\\0', '\\0']),\n        ('\\u{4ba}', ['\\u{4bb}', '\\0', '\\0']), ('\\u{4bc}', ['\\u{4bd}', '\\0', '\\0']), ('\\u{4be}',\n        ['\\u{4bf}', '\\0', '\\0']), ('\\u{4c0}', ['\\u{4cf}', '\\0', '\\0']), ('\\u{4c1}', ['\\u{4c2}',\n        '\\0', '\\0']), ('\\u{4c3}', ['\\u{4c4}', '\\0', '\\0']), ('\\u{4c5}', ['\\u{4c6}', '\\0', '\\0']),\n        ('\\u{4c7}', ['\\u{4c8}', '\\0', '\\0']), ('\\u{4c9}', ['\\u{4ca}', '\\0', '\\0']), ('\\u{4cb}',\n        ['\\u{4cc}', '\\0', '\\0']), ('\\u{4cd}', ['\\u{4ce}', '\\0', '\\0']), ('\\u{4d0}', ['\\u{4d1}',\n        '\\0', '\\0']), ('\\u{4d2}', ['\\u{4d3}', '\\0', '\\0']), ('\\u{4d4}', ['\\u{4d5}', '\\0', '\\0']),\n        ('\\u{4d6}', ['\\u{4d7}', '\\0', '\\0']), ('\\u{4d8}', ['\\u{4d9}', '\\0', '\\0']), ('\\u{4da}',\n        ['\\u{4db}', '\\0', '\\0']), ('\\u{4dc}', ['\\u{4dd}', '\\0', '\\0']), ('\\u{4de}', ['\\u{4df}',\n        '\\0', '\\0']), ('\\u{4e0}', ['\\u{4e1}', '\\0', '\\0']), ('\\u{4e2}', ['\\u{4e3}', '\\0', '\\0']),\n        ('\\u{4e4}', ['\\u{4e5}', '\\0', '\\0']), ('\\u{4e6}', ['\\u{4e7}', '\\0', '\\0']), ('\\u{4e8}',\n        ['\\u{4e9}', '\\0', '\\0']), ('\\u{4ea}', ['\\u{4eb}', '\\0', '\\0']), ('\\u{4ec}', ['\\u{4ed}',\n        '\\0', '\\0']), ('\\u{4ee}', ['\\u{4ef}', '\\0', '\\0']), ('\\u{4f0}', ['\\u{4f1}', '\\0', '\\0']),\n        ('\\u{4f2}', ['\\u{4f3}', '\\0', '\\0']), ('\\u{4f4}', ['\\u{4f5}', '\\0', '\\0']), ('\\u{4f6}',\n        ['\\u{4f7}', '\\0', '\\0']), ('\\u{4f8}', ['\\u{4f9}', '\\0', '\\0']), ('\\u{4fa}', ['\\u{4fb}',\n        '\\0', '\\0']), ('\\u{4fc}', ['\\u{4fd}', '\\0', '\\0']), ('\\u{4fe}', ['\\u{4ff}', '\\0', '\\0']),\n        ('\\u{500}', ['\\u{501}', '\\0', '\\0']), ('\\u{502}', ['\\u{503}', '\\0', '\\0']), ('\\u{504}',\n        ['\\u{505}', '\\0', '\\0']), ('\\u{506}', ['\\u{507}', '\\0', '\\0']), ('\\u{508}', ['\\u{509}',\n        '\\0', '\\0']), ('\\u{50a}', ['\\u{50b}', '\\0', '\\0']), ('\\u{50c}', ['\\u{50d}', '\\0', '\\0']),\n        ('\\u{50e}', ['\\u{50f}', '\\0', '\\0']), ('\\u{510}', ['\\u{511}', '\\0', '\\0']), ('\\u{512}',\n        ['\\u{513}', '\\0', '\\0']), ('\\u{514}', ['\\u{515}', '\\0', '\\0']), ('\\u{516}', ['\\u{517}',\n        '\\0', '\\0']), ('\\u{518}', ['\\u{519}', '\\0', '\\0']), ('\\u{51a}', ['\\u{51b}', '\\0', '\\0']),\n        ('\\u{51c}', ['\\u{51d}', '\\0', '\\0']), ('\\u{51e}', ['\\u{51f}', '\\0', '\\0']), ('\\u{520}',\n        ['\\u{521}', '\\0', '\\0']), ('\\u{522}', ['\\u{523}', '\\0', '\\0']), ('\\u{524}', ['\\u{525}',\n        '\\0', '\\0']), ('\\u{526}', ['\\u{527}', '\\0', '\\0']), ('\\u{528}', ['\\u{529}', '\\0', '\\0']),\n        ('\\u{52a}', ['\\u{52b}', '\\0', '\\0']), ('\\u{52c}', ['\\u{52d}', '\\0', '\\0']), ('\\u{52e}',\n        ['\\u{52f}', '\\0', '\\0']), ('\\u{531}', ['\\u{561}', '\\0', '\\0']), ('\\u{532}', ['\\u{562}',\n        '\\0', '\\0']), ('\\u{533}', ['\\u{563}', '\\0', '\\0']), ('\\u{534}', ['\\u{564}', '\\0', '\\0']),\n        ('\\u{535}', ['\\u{565}', '\\0', '\\0']), ('\\u{536}', ['\\u{566}', '\\0', '\\0']), ('\\u{537}',\n        ['\\u{567}', '\\0', '\\0']), ('\\u{538}', ['\\u{568}', '\\0', '\\0']), ('\\u{539}', ['\\u{569}',\n        '\\0', '\\0']), ('\\u{53a}', ['\\u{56a}', '\\0', '\\0']), ('\\u{53b}', ['\\u{56b}', '\\0', '\\0']),\n        ('\\u{53c}', ['\\u{56c}', '\\0', '\\0']), ('\\u{53d}', ['\\u{56d}', '\\0', '\\0']), ('\\u{53e}',\n        ['\\u{56e}', '\\0', '\\0']), ('\\u{53f}', ['\\u{56f}', '\\0', '\\0']), ('\\u{540}', ['\\u{570}',\n        '\\0', '\\0']), ('\\u{541}', ['\\u{571}', '\\0', '\\0']), ('\\u{542}', ['\\u{572}', '\\0', '\\0']),\n        ('\\u{543}', ['\\u{573}', '\\0', '\\0']), ('\\u{544}', ['\\u{574}', '\\0', '\\0']), ('\\u{545}',\n        ['\\u{575}', '\\0', '\\0']), ('\\u{546}', ['\\u{576}', '\\0', '\\0']), ('\\u{547}', ['\\u{577}',\n        '\\0', '\\0']), ('\\u{548}', ['\\u{578}', '\\0', '\\0']), ('\\u{549}', ['\\u{579}', '\\0', '\\0']),\n        ('\\u{54a}', ['\\u{57a}', '\\0', '\\0']), ('\\u{54b}', ['\\u{57b}', '\\0', '\\0']), ('\\u{54c}',\n        ['\\u{57c}', '\\0', '\\0']), ('\\u{54d}', ['\\u{57d}', '\\0', '\\0']), ('\\u{54e}', ['\\u{57e}',\n        '\\0', '\\0']), ('\\u{54f}', ['\\u{57f}', '\\0', '\\0']), ('\\u{550}', ['\\u{580}', '\\0', '\\0']),\n        ('\\u{551}', ['\\u{581}', '\\0', '\\0']), ('\\u{552}', ['\\u{582}', '\\0', '\\0']), ('\\u{553}',\n        ['\\u{583}', '\\0', '\\0']), ('\\u{554}', ['\\u{584}', '\\0', '\\0']), ('\\u{555}', ['\\u{585}',\n        '\\0', '\\0']), ('\\u{556}', ['\\u{586}', '\\0', '\\0']), ('\\u{10a0}', ['\\u{2d00}', '\\0', '\\0']),\n        ('\\u{10a1}', ['\\u{2d01}', '\\0', '\\0']), ('\\u{10a2}', ['\\u{2d02}', '\\0', '\\0']), ('\\u{10a3}',\n        ['\\u{2d03}', '\\0', '\\0']), ('\\u{10a4}', ['\\u{2d04}', '\\0', '\\0']), ('\\u{10a5}', ['\\u{2d05}',\n        '\\0', '\\0']), ('\\u{10a6}', ['\\u{2d06}', '\\0', '\\0']), ('\\u{10a7}', ['\\u{2d07}', '\\0',\n        '\\0']), ('\\u{10a8}', ['\\u{2d08}', '\\0', '\\0']), ('\\u{10a9}', ['\\u{2d09}', '\\0', '\\0']),\n        ('\\u{10aa}', ['\\u{2d0a}', '\\0', '\\0']), ('\\u{10ab}', ['\\u{2d0b}', '\\0', '\\0']), ('\\u{10ac}',\n        ['\\u{2d0c}', '\\0', '\\0']), ('\\u{10ad}', ['\\u{2d0d}', '\\0', '\\0']), ('\\u{10ae}', ['\\u{2d0e}',\n        '\\0', '\\0']), ('\\u{10af}', ['\\u{2d0f}', '\\0', '\\0']), ('\\u{10b0}', ['\\u{2d10}', '\\0',\n        '\\0']), ('\\u{10b1}', ['\\u{2d11}', '\\0', '\\0']), ('\\u{10b2}', ['\\u{2d12}', '\\0', '\\0']),\n        ('\\u{10b3}', ['\\u{2d13}', '\\0', '\\0']), ('\\u{10b4}', ['\\u{2d14}', '\\0', '\\0']), ('\\u{10b5}',\n        ['\\u{2d15}', '\\0', '\\0']), ('\\u{10b6}', ['\\u{2d16}', '\\0', '\\0']), ('\\u{10b7}', ['\\u{2d17}',\n        '\\0', '\\0']), ('\\u{10b8}', ['\\u{2d18}', '\\0', '\\0']), ('\\u{10b9}', ['\\u{2d19}', '\\0',\n        '\\0']), ('\\u{10ba}', ['\\u{2d1a}', '\\0', '\\0']), ('\\u{10bb}', ['\\u{2d1b}', '\\0', '\\0']),\n        ('\\u{10bc}', ['\\u{2d1c}', '\\0', '\\0']), ('\\u{10bd}', ['\\u{2d1d}', '\\0', '\\0']), ('\\u{10be}',\n        ['\\u{2d1e}', '\\0', '\\0']), ('\\u{10bf}', ['\\u{2d1f}', '\\0', '\\0']), ('\\u{10c0}', ['\\u{2d20}',\n        '\\0', '\\0']), ('\\u{10c1}', ['\\u{2d21}', '\\0', '\\0']), ('\\u{10c2}', ['\\u{2d22}', '\\0',\n        '\\0']), ('\\u{10c3}', ['\\u{2d23}', '\\0', '\\0']), ('\\u{10c4}', ['\\u{2d24}', '\\0', '\\0']),\n        ('\\u{10c5}', ['\\u{2d25}', '\\0', '\\0']), ('\\u{10c7}', ['\\u{2d27}', '\\0', '\\0']), ('\\u{10cd}',\n        ['\\u{2d2d}', '\\0', '\\0']), ('\\u{13a0}', ['\\u{ab70}', '\\0', '\\0']), ('\\u{13a1}', ['\\u{ab71}',\n        '\\0', '\\0']), ('\\u{13a2}', ['\\u{ab72}', '\\0', '\\0']), ('\\u{13a3}', ['\\u{ab73}', '\\0',\n        '\\0']), ('\\u{13a4}', ['\\u{ab74}', '\\0', '\\0']), ('\\u{13a5}', ['\\u{ab75}', '\\0', '\\0']),\n        ('\\u{13a6}', ['\\u{ab76}', '\\0', '\\0']), ('\\u{13a7}', ['\\u{ab77}', '\\0', '\\0']), ('\\u{13a8}',\n        ['\\u{ab78}', '\\0', '\\0']), ('\\u{13a9}', ['\\u{ab79}', '\\0', '\\0']), ('\\u{13aa}', ['\\u{ab7a}',\n        '\\0', '\\0']), ('\\u{13ab}', ['\\u{ab7b}', '\\0', '\\0']), ('\\u{13ac}', ['\\u{ab7c}', '\\0',\n        '\\0']), ('\\u{13ad}', ['\\u{ab7d}', '\\0', '\\0']), ('\\u{13ae}', ['\\u{ab7e}', '\\0', '\\0']),\n        ('\\u{13af}', ['\\u{ab7f}', '\\0', '\\0']), ('\\u{13b0}', ['\\u{ab80}', '\\0', '\\0']), ('\\u{13b1}',\n        ['\\u{ab81}', '\\0', '\\0']), ('\\u{13b2}', ['\\u{ab82}', '\\0', '\\0']), ('\\u{13b3}', ['\\u{ab83}',\n        '\\0', '\\0']), ('\\u{13b4}', ['\\u{ab84}', '\\0', '\\0']), ('\\u{13b5}', ['\\u{ab85}', '\\0',\n        '\\0']), ('\\u{13b6}', ['\\u{ab86}', '\\0', '\\0']), ('\\u{13b7}', ['\\u{ab87}', '\\0', '\\0']),\n        ('\\u{13b8}', ['\\u{ab88}', '\\0', '\\0']), ('\\u{13b9}', ['\\u{ab89}', '\\0', '\\0']), ('\\u{13ba}',\n        ['\\u{ab8a}', '\\0', '\\0']), ('\\u{13bb}', ['\\u{ab8b}', '\\0', '\\0']), ('\\u{13bc}', ['\\u{ab8c}',\n        '\\0', '\\0']), ('\\u{13bd}', ['\\u{ab8d}', '\\0', '\\0']), ('\\u{13be}', ['\\u{ab8e}', '\\0',\n        '\\0']), ('\\u{13bf}', ['\\u{ab8f}', '\\0', '\\0']), ('\\u{13c0}', ['\\u{ab90}', '\\0', '\\0']),\n        ('\\u{13c1}', ['\\u{ab91}', '\\0', '\\0']), ('\\u{13c2}', ['\\u{ab92}', '\\0', '\\0']), ('\\u{13c3}',\n        ['\\u{ab93}', '\\0', '\\0']), ('\\u{13c4}', ['\\u{ab94}', '\\0', '\\0']), ('\\u{13c5}', ['\\u{ab95}',\n        '\\0', '\\0']), ('\\u{13c6}', ['\\u{ab96}', '\\0', '\\0']), ('\\u{13c7}', ['\\u{ab97}', '\\0',\n        '\\0']), ('\\u{13c8}', ['\\u{ab98}', '\\0', '\\0']), ('\\u{13c9}', ['\\u{ab99}', '\\0', '\\0']),\n        ('\\u{13ca}', ['\\u{ab9a}', '\\0', '\\0']), ('\\u{13cb}', ['\\u{ab9b}', '\\0', '\\0']), ('\\u{13cc}',\n        ['\\u{ab9c}', '\\0', '\\0']), ('\\u{13cd}', ['\\u{ab9d}', '\\0', '\\0']), ('\\u{13ce}', ['\\u{ab9e}',\n        '\\0', '\\0']), ('\\u{13cf}', ['\\u{ab9f}', '\\0', '\\0']), ('\\u{13d0}', ['\\u{aba0}', '\\0',\n        '\\0']), ('\\u{13d1}', ['\\u{aba1}', '\\0', '\\0']), ('\\u{13d2}', ['\\u{aba2}', '\\0', '\\0']),\n        ('\\u{13d3}', ['\\u{aba3}', '\\0', '\\0']), ('\\u{13d4}', ['\\u{aba4}', '\\0', '\\0']), ('\\u{13d5}',\n        ['\\u{aba5}', '\\0', '\\0']), ('\\u{13d6}', ['\\u{aba6}', '\\0', '\\0']), ('\\u{13d7}', ['\\u{aba7}',\n        '\\0', '\\0']), ('\\u{13d8}', ['\\u{aba8}', '\\0', '\\0']), ('\\u{13d9}', ['\\u{aba9}', '\\0',\n        '\\0']), ('\\u{13da}', ['\\u{abaa}', '\\0', '\\0']), ('\\u{13db}', ['\\u{abab}', '\\0', '\\0']),\n        ('\\u{13dc}', ['\\u{abac}', '\\0', '\\0']), ('\\u{13dd}', ['\\u{abad}', '\\0', '\\0']), ('\\u{13de}',\n        ['\\u{abae}', '\\0', '\\0']), ('\\u{13df}', ['\\u{abaf}', '\\0', '\\0']), ('\\u{13e0}', ['\\u{abb0}',\n        '\\0', '\\0']), ('\\u{13e1}', ['\\u{abb1}', '\\0', '\\0']), ('\\u{13e2}', ['\\u{abb2}', '\\0',\n        '\\0']), ('\\u{13e3}', ['\\u{abb3}', '\\0', '\\0']), ('\\u{13e4}', ['\\u{abb4}', '\\0', '\\0']),\n        ('\\u{13e5}', ['\\u{abb5}', '\\0', '\\0']), ('\\u{13e6}', ['\\u{abb6}', '\\0', '\\0']), ('\\u{13e7}',\n        ['\\u{abb7}', '\\0', '\\0']), ('\\u{13e8}', ['\\u{abb8}', '\\0', '\\0']), ('\\u{13e9}', ['\\u{abb9}',\n        '\\0', '\\0']), ('\\u{13ea}', ['\\u{abba}', '\\0', '\\0']), ('\\u{13eb}', ['\\u{abbb}', '\\0',\n        '\\0']), ('\\u{13ec}', ['\\u{abbc}', '\\0', '\\0']), ('\\u{13ed}', ['\\u{abbd}', '\\0', '\\0']),\n        ('\\u{13ee}', ['\\u{abbe}', '\\0', '\\0']), ('\\u{13ef}', ['\\u{abbf}', '\\0', '\\0']), ('\\u{13f0}',\n        ['\\u{13f8}', '\\0', '\\0']), ('\\u{13f1}', ['\\u{13f9}', '\\0', '\\0']), ('\\u{13f2}', ['\\u{13fa}',\n        '\\0', '\\0']), ('\\u{13f3}', ['\\u{13fb}', '\\0', '\\0']), ('\\u{13f4}', ['\\u{13fc}', '\\0',\n        '\\0']), ('\\u{13f5}', ['\\u{13fd}', '\\0', '\\0']), ('\\u{1e00}', ['\\u{1e01}', '\\0', '\\0']),\n        ('\\u{1e02}', ['\\u{1e03}', '\\0', '\\0']), ('\\u{1e04}', ['\\u{1e05}', '\\0', '\\0']), ('\\u{1e06}',\n        ['\\u{1e07}', '\\0', '\\0']), ('\\u{1e08}', ['\\u{1e09}', '\\0', '\\0']), ('\\u{1e0a}', ['\\u{1e0b}',\n        '\\0', '\\0']), ('\\u{1e0c}', ['\\u{1e0d}', '\\0', '\\0']), ('\\u{1e0e}', ['\\u{1e0f}', '\\0',\n        '\\0']), ('\\u{1e10}', ['\\u{1e11}', '\\0', '\\0']), ('\\u{1e12}', ['\\u{1e13}', '\\0', '\\0']),\n        ('\\u{1e14}', ['\\u{1e15}', '\\0', '\\0']), ('\\u{1e16}', ['\\u{1e17}', '\\0', '\\0']), ('\\u{1e18}',\n        ['\\u{1e19}', '\\0', '\\0']), ('\\u{1e1a}', ['\\u{1e1b}', '\\0', '\\0']), ('\\u{1e1c}', ['\\u{1e1d}',\n        '\\0', '\\0']), ('\\u{1e1e}', ['\\u{1e1f}', '\\0', '\\0']), ('\\u{1e20}', ['\\u{1e21}', '\\0',\n        '\\0']), ('\\u{1e22}', ['\\u{1e23}', '\\0', '\\0']), ('\\u{1e24}', ['\\u{1e25}', '\\0', '\\0']),\n        ('\\u{1e26}', ['\\u{1e27}', '\\0', '\\0']), ('\\u{1e28}', ['\\u{1e29}', '\\0', '\\0']), ('\\u{1e2a}',\n        ['\\u{1e2b}', '\\0', '\\0']), ('\\u{1e2c}', ['\\u{1e2d}', '\\0', '\\0']), ('\\u{1e2e}', ['\\u{1e2f}',\n        '\\0', '\\0']), ('\\u{1e30}', ['\\u{1e31}', '\\0', '\\0']), ('\\u{1e32}', ['\\u{1e33}', '\\0',\n        '\\0']), ('\\u{1e34}', ['\\u{1e35}', '\\0', '\\0']), ('\\u{1e36}', ['\\u{1e37}', '\\0', '\\0']),\n        ('\\u{1e38}', ['\\u{1e39}', '\\0', '\\0']), ('\\u{1e3a}', ['\\u{1e3b}', '\\0', '\\0']), ('\\u{1e3c}',\n        ['\\u{1e3d}', '\\0', '\\0']), ('\\u{1e3e}', ['\\u{1e3f}', '\\0', '\\0']), ('\\u{1e40}', ['\\u{1e41}',\n        '\\0', '\\0']), ('\\u{1e42}', ['\\u{1e43}', '\\0', '\\0']), ('\\u{1e44}', ['\\u{1e45}', '\\0',\n        '\\0']), ('\\u{1e46}', ['\\u{1e47}', '\\0', '\\0']), ('\\u{1e48}', ['\\u{1e49}', '\\0', '\\0']),\n        ('\\u{1e4a}', ['\\u{1e4b}', '\\0', '\\0']), ('\\u{1e4c}', ['\\u{1e4d}', '\\0', '\\0']), ('\\u{1e4e}',\n        ['\\u{1e4f}', '\\0', '\\0']), ('\\u{1e50}', ['\\u{1e51}', '\\0', '\\0']), ('\\u{1e52}', ['\\u{1e53}',\n        '\\0', '\\0']), ('\\u{1e54}', ['\\u{1e55}', '\\0', '\\0']), ('\\u{1e56}', ['\\u{1e57}', '\\0',\n        '\\0']), ('\\u{1e58}', ['\\u{1e59}', '\\0', '\\0']), ('\\u{1e5a}', ['\\u{1e5b}', '\\0', '\\0']),\n        ('\\u{1e5c}', ['\\u{1e5d}', '\\0', '\\0']), ('\\u{1e5e}', ['\\u{1e5f}', '\\0', '\\0']), ('\\u{1e60}',\n        ['\\u{1e61}', '\\0', '\\0']), ('\\u{1e62}', ['\\u{1e63}', '\\0', '\\0']), ('\\u{1e64}', ['\\u{1e65}',\n        '\\0', '\\0']), ('\\u{1e66}', ['\\u{1e67}', '\\0', '\\0']), ('\\u{1e68}', ['\\u{1e69}', '\\0',\n        '\\0']), ('\\u{1e6a}', ['\\u{1e6b}', '\\0', '\\0']), ('\\u{1e6c}', ['\\u{1e6d}', '\\0', '\\0']),\n        ('\\u{1e6e}', ['\\u{1e6f}', '\\0', '\\0']), ('\\u{1e70}', ['\\u{1e71}', '\\0', '\\0']), ('\\u{1e72}',\n        ['\\u{1e73}', '\\0', '\\0']), ('\\u{1e74}', ['\\u{1e75}', '\\0', '\\0']), ('\\u{1e76}', ['\\u{1e77}',\n        '\\0', '\\0']), ('\\u{1e78}', ['\\u{1e79}', '\\0', '\\0']), ('\\u{1e7a}', ['\\u{1e7b}', '\\0',\n        '\\0']), ('\\u{1e7c}', ['\\u{1e7d}', '\\0', '\\0']), ('\\u{1e7e}', ['\\u{1e7f}', '\\0', '\\0']),\n        ('\\u{1e80}', ['\\u{1e81}', '\\0', '\\0']), ('\\u{1e82}', ['\\u{1e83}', '\\0', '\\0']), ('\\u{1e84}',\n        ['\\u{1e85}', '\\0', '\\0']), ('\\u{1e86}', ['\\u{1e87}', '\\0', '\\0']), ('\\u{1e88}', ['\\u{1e89}',\n        '\\0', '\\0']), ('\\u{1e8a}', ['\\u{1e8b}', '\\0', '\\0']), ('\\u{1e8c}', ['\\u{1e8d}', '\\0',\n        '\\0']), ('\\u{1e8e}', ['\\u{1e8f}', '\\0', '\\0']), ('\\u{1e90}', ['\\u{1e91}', '\\0', '\\0']),\n        ('\\u{1e92}', ['\\u{1e93}', '\\0', '\\0']), ('\\u{1e94}', ['\\u{1e95}', '\\0', '\\0']), ('\\u{1e9e}',\n        ['\\u{df}', '\\0', '\\0']), ('\\u{1ea0}', ['\\u{1ea1}', '\\0', '\\0']), ('\\u{1ea2}', ['\\u{1ea3}',\n        '\\0', '\\0']), ('\\u{1ea4}', ['\\u{1ea5}', '\\0', '\\0']), ('\\u{1ea6}', ['\\u{1ea7}', '\\0',\n        '\\0']), ('\\u{1ea8}', ['\\u{1ea9}', '\\0', '\\0']), ('\\u{1eaa}', ['\\u{1eab}', '\\0', '\\0']),\n        ('\\u{1eac}', ['\\u{1ead}', '\\0', '\\0']), ('\\u{1eae}', ['\\u{1eaf}', '\\0', '\\0']), ('\\u{1eb0}',\n        ['\\u{1eb1}', '\\0', '\\0']), ('\\u{1eb2}', ['\\u{1eb3}', '\\0', '\\0']), ('\\u{1eb4}', ['\\u{1eb5}',\n        '\\0', '\\0']), ('\\u{1eb6}', ['\\u{1eb7}', '\\0', '\\0']), ('\\u{1eb8}', ['\\u{1eb9}', '\\0',\n        '\\0']), ('\\u{1eba}', ['\\u{1ebb}', '\\0', '\\0']), ('\\u{1ebc}', ['\\u{1ebd}', '\\0', '\\0']),\n        ('\\u{1ebe}', ['\\u{1ebf}', '\\0', '\\0']), ('\\u{1ec0}', ['\\u{1ec1}', '\\0', '\\0']), ('\\u{1ec2}',\n        ['\\u{1ec3}', '\\0', '\\0']), ('\\u{1ec4}', ['\\u{1ec5}', '\\0', '\\0']), ('\\u{1ec6}', ['\\u{1ec7}',\n        '\\0', '\\0']), ('\\u{1ec8}', ['\\u{1ec9}', '\\0', '\\0']), ('\\u{1eca}', ['\\u{1ecb}', '\\0',\n        '\\0']), ('\\u{1ecc}', ['\\u{1ecd}', '\\0', '\\0']), ('\\u{1ece}', ['\\u{1ecf}', '\\0', '\\0']),\n        ('\\u{1ed0}', ['\\u{1ed1}', '\\0', '\\0']), ('\\u{1ed2}', ['\\u{1ed3}', '\\0', '\\0']), ('\\u{1ed4}',\n        ['\\u{1ed5}', '\\0', '\\0']), ('\\u{1ed6}', ['\\u{1ed7}', '\\0', '\\0']), ('\\u{1ed8}', ['\\u{1ed9}',\n        '\\0', '\\0']), ('\\u{1eda}', ['\\u{1edb}', '\\0', '\\0']), ('\\u{1edc}', ['\\u{1edd}', '\\0',\n        '\\0']), ('\\u{1ede}', ['\\u{1edf}', '\\0', '\\0']), ('\\u{1ee0}', ['\\u{1ee1}', '\\0', '\\0']),\n        ('\\u{1ee2}', ['\\u{1ee3}', '\\0', '\\0']), ('\\u{1ee4}', ['\\u{1ee5}', '\\0', '\\0']), ('\\u{1ee6}',\n        ['\\u{1ee7}', '\\0', '\\0']), ('\\u{1ee8}', ['\\u{1ee9}', '\\0', '\\0']), ('\\u{1eea}', ['\\u{1eeb}',\n        '\\0', '\\0']), ('\\u{1eec}', ['\\u{1eed}', '\\0', '\\0']), ('\\u{1eee}', ['\\u{1eef}', '\\0',\n        '\\0']), ('\\u{1ef0}', ['\\u{1ef1}', '\\0', '\\0']), ('\\u{1ef2}', ['\\u{1ef3}', '\\0', '\\0']),\n        ('\\u{1ef4}', ['\\u{1ef5}', '\\0', '\\0']), ('\\u{1ef6}', ['\\u{1ef7}', '\\0', '\\0']), ('\\u{1ef8}',\n        ['\\u{1ef9}', '\\0', '\\0']), ('\\u{1efa}', ['\\u{1efb}', '\\0', '\\0']), ('\\u{1efc}', ['\\u{1efd}',\n        '\\0', '\\0']), ('\\u{1efe}', ['\\u{1eff}', '\\0', '\\0']), ('\\u{1f08}', ['\\u{1f00}', '\\0',\n        '\\0']), ('\\u{1f09}', ['\\u{1f01}', '\\0', '\\0']), ('\\u{1f0a}', ['\\u{1f02}', '\\0', '\\0']),\n        ('\\u{1f0b}', ['\\u{1f03}', '\\0', '\\0']), ('\\u{1f0c}', ['\\u{1f04}', '\\0', '\\0']), ('\\u{1f0d}',\n        ['\\u{1f05}', '\\0', '\\0']), ('\\u{1f0e}', ['\\u{1f06}', '\\0', '\\0']), ('\\u{1f0f}', ['\\u{1f07}',\n        '\\0', '\\0']), ('\\u{1f18}', ['\\u{1f10}', '\\0', '\\0']), ('\\u{1f19}', ['\\u{1f11}', '\\0',\n        '\\0']), ('\\u{1f1a}', ['\\u{1f12}', '\\0', '\\0']), ('\\u{1f1b}', ['\\u{1f13}', '\\0', '\\0']),\n        ('\\u{1f1c}', ['\\u{1f14}', '\\0', '\\0']), ('\\u{1f1d}', ['\\u{1f15}', '\\0', '\\0']), ('\\u{1f28}',\n        ['\\u{1f20}', '\\0', '\\0']), ('\\u{1f29}', ['\\u{1f21}', '\\0', '\\0']), ('\\u{1f2a}', ['\\u{1f22}',\n        '\\0', '\\0']), ('\\u{1f2b}', ['\\u{1f23}', '\\0', '\\0']), ('\\u{1f2c}', ['\\u{1f24}', '\\0',\n        '\\0']), ('\\u{1f2d}', ['\\u{1f25}', '\\0', '\\0']), ('\\u{1f2e}', ['\\u{1f26}', '\\0', '\\0']),\n        ('\\u{1f2f}', ['\\u{1f27}', '\\0', '\\0']), ('\\u{1f38}', ['\\u{1f30}', '\\0', '\\0']), ('\\u{1f39}',\n        ['\\u{1f31}', '\\0', '\\0']), ('\\u{1f3a}', ['\\u{1f32}', '\\0', '\\0']), ('\\u{1f3b}', ['\\u{1f33}',\n        '\\0', '\\0']), ('\\u{1f3c}', ['\\u{1f34}', '\\0', '\\0']), ('\\u{1f3d}', ['\\u{1f35}', '\\0',\n        '\\0']), ('\\u{1f3e}', ['\\u{1f36}', '\\0', '\\0']), ('\\u{1f3f}', ['\\u{1f37}', '\\0', '\\0']),\n        ('\\u{1f48}', ['\\u{1f40}', '\\0', '\\0']), ('\\u{1f49}', ['\\u{1f41}', '\\0', '\\0']), ('\\u{1f4a}',\n        ['\\u{1f42}', '\\0', '\\0']), ('\\u{1f4b}', ['\\u{1f43}', '\\0', '\\0']), ('\\u{1f4c}', ['\\u{1f44}',\n        '\\0', '\\0']), ('\\u{1f4d}', ['\\u{1f45}', '\\0', '\\0']), ('\\u{1f59}', ['\\u{1f51}', '\\0',\n        '\\0']), ('\\u{1f5b}', ['\\u{1f53}', '\\0', '\\0']), ('\\u{1f5d}', ['\\u{1f55}', '\\0', '\\0']),\n        ('\\u{1f5f}', ['\\u{1f57}', '\\0', '\\0']), ('\\u{1f68}', ['\\u{1f60}', '\\0', '\\0']), ('\\u{1f69}',\n        ['\\u{1f61}', '\\0', '\\0']), ('\\u{1f6a}', ['\\u{1f62}', '\\0', '\\0']), ('\\u{1f6b}', ['\\u{1f63}',\n        '\\0', '\\0']), ('\\u{1f6c}', ['\\u{1f64}', '\\0', '\\0']), ('\\u{1f6d}', ['\\u{1f65}', '\\0',\n        '\\0']), ('\\u{1f6e}', ['\\u{1f66}', '\\0', '\\0']), ('\\u{1f6f}', ['\\u{1f67}', '\\0', '\\0']),\n        ('\\u{1f88}', ['\\u{1f80}', '\\0', '\\0']), ('\\u{1f89}', ['\\u{1f81}', '\\0', '\\0']), ('\\u{1f8a}',\n        ['\\u{1f82}', '\\0', '\\0']), ('\\u{1f8b}', ['\\u{1f83}', '\\0', '\\0']), ('\\u{1f8c}', ['\\u{1f84}',\n        '\\0', '\\0']), ('\\u{1f8d}', ['\\u{1f85}', '\\0', '\\0']), ('\\u{1f8e}', ['\\u{1f86}', '\\0',\n        '\\0']), ('\\u{1f8f}', ['\\u{1f87}', '\\0', '\\0']), ('\\u{1f98}', ['\\u{1f90}', '\\0', '\\0']),\n        ('\\u{1f99}', ['\\u{1f91}', '\\0', '\\0']), ('\\u{1f9a}', ['\\u{1f92}', '\\0', '\\0']), ('\\u{1f9b}',\n        ['\\u{1f93}', '\\0', '\\0']), ('\\u{1f9c}', ['\\u{1f94}', '\\0', '\\0']), ('\\u{1f9d}', ['\\u{1f95}',\n        '\\0', '\\0']), ('\\u{1f9e}', ['\\u{1f96}', '\\0', '\\0']), ('\\u{1f9f}', ['\\u{1f97}', '\\0',\n        '\\0']), ('\\u{1fa8}', ['\\u{1fa0}', '\\0', '\\0']), ('\\u{1fa9}', ['\\u{1fa1}', '\\0', '\\0']),\n        ('\\u{1faa}', ['\\u{1fa2}', '\\0', '\\0']), ('\\u{1fab}', ['\\u{1fa3}', '\\0', '\\0']), ('\\u{1fac}',\n        ['\\u{1fa4}', '\\0', '\\0']), ('\\u{1fad}', ['\\u{1fa5}', '\\0', '\\0']), ('\\u{1fae}', ['\\u{1fa6}',\n        '\\0', '\\0']), ('\\u{1faf}', ['\\u{1fa7}', '\\0', '\\0']), ('\\u{1fb8}', ['\\u{1fb0}', '\\0',\n        '\\0']), ('\\u{1fb9}', ['\\u{1fb1}', '\\0', '\\0']), ('\\u{1fba}', ['\\u{1f70}', '\\0', '\\0']),\n        ('\\u{1fbb}', ['\\u{1f71}', '\\0', '\\0']), ('\\u{1fbc}', ['\\u{1fb3}', '\\0', '\\0']), ('\\u{1fc8}',\n        ['\\u{1f72}', '\\0', '\\0']), ('\\u{1fc9}', ['\\u{1f73}', '\\0', '\\0']), ('\\u{1fca}', ['\\u{1f74}',\n        '\\0', '\\0']), ('\\u{1fcb}', ['\\u{1f75}', '\\0', '\\0']), ('\\u{1fcc}', ['\\u{1fc3}', '\\0',\n        '\\0']), ('\\u{1fd8}', ['\\u{1fd0}', '\\0', '\\0']), ('\\u{1fd9}', ['\\u{1fd1}', '\\0', '\\0']),\n        ('\\u{1fda}', ['\\u{1f76}', '\\0', '\\0']), ('\\u{1fdb}', ['\\u{1f77}', '\\0', '\\0']), ('\\u{1fe8}',\n        ['\\u{1fe0}', '\\0', '\\0']), ('\\u{1fe9}', ['\\u{1fe1}', '\\0', '\\0']), ('\\u{1fea}', ['\\u{1f7a}',\n        '\\0', '\\0']), ('\\u{1feb}', ['\\u{1f7b}', '\\0', '\\0']), ('\\u{1fec}', ['\\u{1fe5}', '\\0',\n        '\\0']), ('\\u{1ff8}', ['\\u{1f78}', '\\0', '\\0']), ('\\u{1ff9}', ['\\u{1f79}', '\\0', '\\0']),\n        ('\\u{1ffa}', ['\\u{1f7c}', '\\0', '\\0']), ('\\u{1ffb}', ['\\u{1f7d}', '\\0', '\\0']), ('\\u{1ffc}',\n        ['\\u{1ff3}', '\\0', '\\0']), ('\\u{2126}', ['\\u{3c9}', '\\0', '\\0']), ('\\u{212a}', ['\\u{6b}',\n        '\\0', '\\0']), ('\\u{212b}', ['\\u{e5}', '\\0', '\\0']), ('\\u{2132}', ['\\u{214e}', '\\0', '\\0']),\n        ('\\u{2160}', ['\\u{2170}', '\\0', '\\0']), ('\\u{2161}', ['\\u{2171}', '\\0', '\\0']), ('\\u{2162}',\n        ['\\u{2172}', '\\0', '\\0']), ('\\u{2163}', ['\\u{2173}', '\\0', '\\0']), ('\\u{2164}', ['\\u{2174}',\n        '\\0', '\\0']), ('\\u{2165}', ['\\u{2175}', '\\0', '\\0']), ('\\u{2166}', ['\\u{2176}', '\\0',\n        '\\0']), ('\\u{2167}', ['\\u{2177}', '\\0', '\\0']), ('\\u{2168}', ['\\u{2178}', '\\0', '\\0']),\n        ('\\u{2169}', ['\\u{2179}', '\\0', '\\0']), ('\\u{216a}', ['\\u{217a}', '\\0', '\\0']), ('\\u{216b}',\n        ['\\u{217b}', '\\0', '\\0']), ('\\u{216c}', ['\\u{217c}', '\\0', '\\0']), ('\\u{216d}', ['\\u{217d}',\n        '\\0', '\\0']), ('\\u{216e}', ['\\u{217e}', '\\0', '\\0']), ('\\u{216f}', ['\\u{217f}', '\\0',\n        '\\0']), ('\\u{2183}', ['\\u{2184}', '\\0', '\\0']), ('\\u{24b6}', ['\\u{24d0}', '\\0', '\\0']),\n        ('\\u{24b7}', ['\\u{24d1}', '\\0', '\\0']), ('\\u{24b8}', ['\\u{24d2}', '\\0', '\\0']), ('\\u{24b9}',\n        ['\\u{24d3}', '\\0', '\\0']), ('\\u{24ba}', ['\\u{24d4}', '\\0', '\\0']), ('\\u{24bb}', ['\\u{24d5}',\n        '\\0', '\\0']), ('\\u{24bc}', ['\\u{24d6}', '\\0', '\\0']), ('\\u{24bd}', ['\\u{24d7}', '\\0',\n        '\\0']), ('\\u{24be}', ['\\u{24d8}', '\\0', '\\0']), ('\\u{24bf}', ['\\u{24d9}', '\\0', '\\0']),\n        ('\\u{24c0}', ['\\u{24da}', '\\0', '\\0']), ('\\u{24c1}', ['\\u{24db}', '\\0', '\\0']), ('\\u{24c2}',\n        ['\\u{24dc}', '\\0', '\\0']), ('\\u{24c3}', ['\\u{24dd}', '\\0', '\\0']), ('\\u{24c4}', ['\\u{24de}',\n        '\\0', '\\0']), ('\\u{24c5}', ['\\u{24df}', '\\0', '\\0']), ('\\u{24c6}', ['\\u{24e0}', '\\0',\n        '\\0']), ('\\u{24c7}', ['\\u{24e1}', '\\0', '\\0']), ('\\u{24c8}', ['\\u{24e2}', '\\0', '\\0']),\n        ('\\u{24c9}', ['\\u{24e3}', '\\0', '\\0']), ('\\u{24ca}', ['\\u{24e4}', '\\0', '\\0']), ('\\u{24cb}',\n        ['\\u{24e5}', '\\0', '\\0']), ('\\u{24cc}', ['\\u{24e6}', '\\0', '\\0']), ('\\u{24cd}', ['\\u{24e7}',\n        '\\0', '\\0']), ('\\u{24ce}', ['\\u{24e8}', '\\0', '\\0']), ('\\u{24cf}', ['\\u{24e9}', '\\0',\n        '\\0']), ('\\u{2c00}', ['\\u{2c30}', '\\0', '\\0']), ('\\u{2c01}', ['\\u{2c31}', '\\0', '\\0']),\n        ('\\u{2c02}', ['\\u{2c32}', '\\0', '\\0']), ('\\u{2c03}', ['\\u{2c33}', '\\0', '\\0']), ('\\u{2c04}',\n        ['\\u{2c34}', '\\0', '\\0']), ('\\u{2c05}', ['\\u{2c35}', '\\0', '\\0']), ('\\u{2c06}', ['\\u{2c36}',\n        '\\0', '\\0']), ('\\u{2c07}', ['\\u{2c37}', '\\0', '\\0']), ('\\u{2c08}', ['\\u{2c38}', '\\0',\n        '\\0']), ('\\u{2c09}', ['\\u{2c39}', '\\0', '\\0']), ('\\u{2c0a}', ['\\u{2c3a}', '\\0', '\\0']),\n        ('\\u{2c0b}', ['\\u{2c3b}', '\\0', '\\0']), ('\\u{2c0c}', ['\\u{2c3c}', '\\0', '\\0']), ('\\u{2c0d}',\n        ['\\u{2c3d}', '\\0', '\\0']), ('\\u{2c0e}', ['\\u{2c3e}', '\\0', '\\0']), ('\\u{2c0f}', ['\\u{2c3f}',\n        '\\0', '\\0']), ('\\u{2c10}', ['\\u{2c40}', '\\0', '\\0']), ('\\u{2c11}', ['\\u{2c41}', '\\0',\n        '\\0']), ('\\u{2c12}', ['\\u{2c42}', '\\0', '\\0']), ('\\u{2c13}', ['\\u{2c43}', '\\0', '\\0']),\n        ('\\u{2c14}', ['\\u{2c44}', '\\0', '\\0']), ('\\u{2c15}', ['\\u{2c45}', '\\0', '\\0']), ('\\u{2c16}',\n        ['\\u{2c46}', '\\0', '\\0']), ('\\u{2c17}', ['\\u{2c47}', '\\0', '\\0']), ('\\u{2c18}', ['\\u{2c48}',\n        '\\0', '\\0']), ('\\u{2c19}', ['\\u{2c49}', '\\0', '\\0']), ('\\u{2c1a}', ['\\u{2c4a}', '\\0',\n        '\\0']), ('\\u{2c1b}', ['\\u{2c4b}', '\\0', '\\0']), ('\\u{2c1c}', ['\\u{2c4c}', '\\0', '\\0']),\n        ('\\u{2c1d}', ['\\u{2c4d}', '\\0', '\\0']), ('\\u{2c1e}', ['\\u{2c4e}', '\\0', '\\0']), ('\\u{2c1f}',\n        ['\\u{2c4f}', '\\0', '\\0']), ('\\u{2c20}', ['\\u{2c50}', '\\0', '\\0']), ('\\u{2c21}', ['\\u{2c51}',\n        '\\0', '\\0']), ('\\u{2c22}', ['\\u{2c52}', '\\0', '\\0']), ('\\u{2c23}', ['\\u{2c53}', '\\0',\n        '\\0']), ('\\u{2c24}', ['\\u{2c54}', '\\0', '\\0']), ('\\u{2c25}', ['\\u{2c55}', '\\0', '\\0']),\n        ('\\u{2c26}', ['\\u{2c56}', '\\0', '\\0']), ('\\u{2c27}', ['\\u{2c57}', '\\0', '\\0']), ('\\u{2c28}',\n        ['\\u{2c58}', '\\0', '\\0']), ('\\u{2c29}', ['\\u{2c59}', '\\0', '\\0']), ('\\u{2c2a}', ['\\u{2c5a}',\n        '\\0', '\\0']), ('\\u{2c2b}', ['\\u{2c5b}', '\\0', '\\0']), ('\\u{2c2c}', ['\\u{2c5c}', '\\0',\n        '\\0']), ('\\u{2c2d}', ['\\u{2c5d}', '\\0', '\\0']), ('\\u{2c2e}', ['\\u{2c5e}', '\\0', '\\0']),\n        ('\\u{2c60}', ['\\u{2c61}', '\\0', '\\0']), ('\\u{2c62}', ['\\u{26b}', '\\0', '\\0']), ('\\u{2c63}',\n        ['\\u{1d7d}', '\\0', '\\0']), ('\\u{2c64}', ['\\u{27d}', '\\0', '\\0']), ('\\u{2c67}', ['\\u{2c68}',\n        '\\0', '\\0']), ('\\u{2c69}', ['\\u{2c6a}', '\\0', '\\0']), ('\\u{2c6b}', ['\\u{2c6c}', '\\0',\n        '\\0']), ('\\u{2c6d}', ['\\u{251}', '\\0', '\\0']), ('\\u{2c6e}', ['\\u{271}', '\\0', '\\0']),\n        ('\\u{2c6f}', ['\\u{250}', '\\0', '\\0']), ('\\u{2c70}', ['\\u{252}', '\\0', '\\0']), ('\\u{2c72}',\n        ['\\u{2c73}', '\\0', '\\0']), ('\\u{2c75}', ['\\u{2c76}', '\\0', '\\0']), ('\\u{2c7e}', ['\\u{23f}',\n        '\\0', '\\0']), ('\\u{2c7f}', ['\\u{240}', '\\0', '\\0']), ('\\u{2c80}', ['\\u{2c81}', '\\0', '\\0']),\n        ('\\u{2c82}', ['\\u{2c83}', '\\0', '\\0']), ('\\u{2c84}', ['\\u{2c85}', '\\0', '\\0']), ('\\u{2c86}',\n        ['\\u{2c87}', '\\0', '\\0']), ('\\u{2c88}', ['\\u{2c89}', '\\0', '\\0']), ('\\u{2c8a}', ['\\u{2c8b}',\n        '\\0', '\\0']), ('\\u{2c8c}', ['\\u{2c8d}', '\\0', '\\0']), ('\\u{2c8e}', ['\\u{2c8f}', '\\0',\n        '\\0']), ('\\u{2c90}', ['\\u{2c91}', '\\0', '\\0']), ('\\u{2c92}', ['\\u{2c93}', '\\0', '\\0']),\n        ('\\u{2c94}', ['\\u{2c95}', '\\0', '\\0']), ('\\u{2c96}', ['\\u{2c97}', '\\0', '\\0']), ('\\u{2c98}',\n        ['\\u{2c99}', '\\0', '\\0']), ('\\u{2c9a}', ['\\u{2c9b}', '\\0', '\\0']), ('\\u{2c9c}', ['\\u{2c9d}',\n        '\\0', '\\0']), ('\\u{2c9e}', ['\\u{2c9f}', '\\0', '\\0']), ('\\u{2ca0}', ['\\u{2ca1}', '\\0',\n        '\\0']), ('\\u{2ca2}', ['\\u{2ca3}', '\\0', '\\0']), ('\\u{2ca4}', ['\\u{2ca5}', '\\0', '\\0']),\n        ('\\u{2ca6}', ['\\u{2ca7}', '\\0', '\\0']), ('\\u{2ca8}', ['\\u{2ca9}', '\\0', '\\0']), ('\\u{2caa}',\n        ['\\u{2cab}', '\\0', '\\0']), ('\\u{2cac}', ['\\u{2cad}', '\\0', '\\0']), ('\\u{2cae}', ['\\u{2caf}',\n        '\\0', '\\0']), ('\\u{2cb0}', ['\\u{2cb1}', '\\0', '\\0']), ('\\u{2cb2}', ['\\u{2cb3}', '\\0',\n        '\\0']), ('\\u{2cb4}', ['\\u{2cb5}', '\\0', '\\0']), ('\\u{2cb6}', ['\\u{2cb7}', '\\0', '\\0']),\n        ('\\u{2cb8}', ['\\u{2cb9}', '\\0', '\\0']), ('\\u{2cba}', ['\\u{2cbb}', '\\0', '\\0']), ('\\u{2cbc}',\n        ['\\u{2cbd}', '\\0', '\\0']), ('\\u{2cbe}', ['\\u{2cbf}', '\\0', '\\0']), ('\\u{2cc0}', ['\\u{2cc1}',\n        '\\0', '\\0']), ('\\u{2cc2}', ['\\u{2cc3}', '\\0', '\\0']), ('\\u{2cc4}', ['\\u{2cc5}', '\\0',\n        '\\0']), ('\\u{2cc6}', ['\\u{2cc7}', '\\0', '\\0']), ('\\u{2cc8}', ['\\u{2cc9}', '\\0', '\\0']),\n        ('\\u{2cca}', ['\\u{2ccb}', '\\0', '\\0']), ('\\u{2ccc}', ['\\u{2ccd}', '\\0', '\\0']), ('\\u{2cce}',\n        ['\\u{2ccf}', '\\0', '\\0']), ('\\u{2cd0}', ['\\u{2cd1}', '\\0', '\\0']), ('\\u{2cd2}', ['\\u{2cd3}',\n        '\\0', '\\0']), ('\\u{2cd4}', ['\\u{2cd5}', '\\0', '\\0']), ('\\u{2cd6}', ['\\u{2cd7}', '\\0',\n        '\\0']), ('\\u{2cd8}', ['\\u{2cd9}', '\\0', '\\0']), ('\\u{2cda}', ['\\u{2cdb}', '\\0', '\\0']),\n        ('\\u{2cdc}', ['\\u{2cdd}', '\\0', '\\0']), ('\\u{2cde}', ['\\u{2cdf}', '\\0', '\\0']), ('\\u{2ce0}',\n        ['\\u{2ce1}', '\\0', '\\0']), ('\\u{2ce2}', ['\\u{2ce3}', '\\0', '\\0']), ('\\u{2ceb}', ['\\u{2cec}',\n        '\\0', '\\0']), ('\\u{2ced}', ['\\u{2cee}', '\\0', '\\0']), ('\\u{2cf2}', ['\\u{2cf3}', '\\0',\n        '\\0']), ('\\u{a640}', ['\\u{a641}', '\\0', '\\0']), ('\\u{a642}', ['\\u{a643}', '\\0', '\\0']),\n        ('\\u{a644}', ['\\u{a645}', '\\0', '\\0']), ('\\u{a646}', ['\\u{a647}', '\\0', '\\0']), ('\\u{a648}',\n        ['\\u{a649}', '\\0', '\\0']), ('\\u{a64a}', ['\\u{a64b}', '\\0', '\\0']), ('\\u{a64c}', ['\\u{a64d}',\n        '\\0', '\\0']), ('\\u{a64e}', ['\\u{a64f}', '\\0', '\\0']), ('\\u{a650}', ['\\u{a651}', '\\0',\n        '\\0']), ('\\u{a652}', ['\\u{a653}', '\\0', '\\0']), ('\\u{a654}', ['\\u{a655}', '\\0', '\\0']),\n        ('\\u{a656}', ['\\u{a657}', '\\0', '\\0']), ('\\u{a658}', ['\\u{a659}', '\\0', '\\0']), ('\\u{a65a}',\n        ['\\u{a65b}', '\\0', '\\0']), ('\\u{a65c}', ['\\u{a65d}', '\\0', '\\0']), ('\\u{a65e}', ['\\u{a65f}',\n        '\\0', '\\0']), ('\\u{a660}', ['\\u{a661}', '\\0', '\\0']), ('\\u{a662}', ['\\u{a663}', '\\0',\n        '\\0']), ('\\u{a664}', ['\\u{a665}', '\\0', '\\0']), ('\\u{a666}', ['\\u{a667}', '\\0', '\\0']),\n        ('\\u{a668}', ['\\u{a669}', '\\0', '\\0']), ('\\u{a66a}', ['\\u{a66b}', '\\0', '\\0']), ('\\u{a66c}',\n        ['\\u{a66d}', '\\0', '\\0']), ('\\u{a680}', ['\\u{a681}', '\\0', '\\0']), ('\\u{a682}', ['\\u{a683}',\n        '\\0', '\\0']), ('\\u{a684}', ['\\u{a685}', '\\0', '\\0']), ('\\u{a686}', ['\\u{a687}', '\\0',\n        '\\0']), ('\\u{a688}', ['\\u{a689}', '\\0', '\\0']), ('\\u{a68a}', ['\\u{a68b}', '\\0', '\\0']),\n        ('\\u{a68c}', ['\\u{a68d}', '\\0', '\\0']), ('\\u{a68e}', ['\\u{a68f}', '\\0', '\\0']), ('\\u{a690}',\n        ['\\u{a691}', '\\0', '\\0']), ('\\u{a692}', ['\\u{a693}', '\\0', '\\0']), ('\\u{a694}', ['\\u{a695}',\n        '\\0', '\\0']), ('\\u{a696}', ['\\u{a697}', '\\0', '\\0']), ('\\u{a698}', ['\\u{a699}', '\\0',\n        '\\0']), ('\\u{a69a}', ['\\u{a69b}', '\\0', '\\0']), ('\\u{a722}', ['\\u{a723}', '\\0', '\\0']),\n        ('\\u{a724}', ['\\u{a725}', '\\0', '\\0']), ('\\u{a726}', ['\\u{a727}', '\\0', '\\0']), ('\\u{a728}',\n        ['\\u{a729}', '\\0', '\\0']), ('\\u{a72a}', ['\\u{a72b}', '\\0', '\\0']), ('\\u{a72c}', ['\\u{a72d}',\n        '\\0', '\\0']), ('\\u{a72e}', ['\\u{a72f}', '\\0', '\\0']), ('\\u{a732}', ['\\u{a733}', '\\0',\n        '\\0']), ('\\u{a734}', ['\\u{a735}', '\\0', '\\0']), ('\\u{a736}', ['\\u{a737}', '\\0', '\\0']),\n        ('\\u{a738}', ['\\u{a739}', '\\0', '\\0']), ('\\u{a73a}', ['\\u{a73b}', '\\0', '\\0']), ('\\u{a73c}',\n        ['\\u{a73d}', '\\0', '\\0']), ('\\u{a73e}', ['\\u{a73f}', '\\0', '\\0']), ('\\u{a740}', ['\\u{a741}',\n        '\\0', '\\0']), ('\\u{a742}', ['\\u{a743}', '\\0', '\\0']), ('\\u{a744}', ['\\u{a745}', '\\0',\n        '\\0']), ('\\u{a746}', ['\\u{a747}', '\\0', '\\0']), ('\\u{a748}', ['\\u{a749}', '\\0', '\\0']),\n        ('\\u{a74a}', ['\\u{a74b}', '\\0', '\\0']), ('\\u{a74c}', ['\\u{a74d}', '\\0', '\\0']), ('\\u{a74e}',\n        ['\\u{a74f}', '\\0', '\\0']), ('\\u{a750}', ['\\u{a751}', '\\0', '\\0']), ('\\u{a752}', ['\\u{a753}',\n        '\\0', '\\0']), ('\\u{a754}', ['\\u{a755}', '\\0', '\\0']), ('\\u{a756}', ['\\u{a757}', '\\0',\n        '\\0']), ('\\u{a758}', ['\\u{a759}', '\\0', '\\0']), ('\\u{a75a}', ['\\u{a75b}', '\\0', '\\0']),\n        ('\\u{a75c}', ['\\u{a75d}', '\\0', '\\0']), ('\\u{a75e}', ['\\u{a75f}', '\\0', '\\0']), ('\\u{a760}',\n        ['\\u{a761}', '\\0', '\\0']), ('\\u{a762}', ['\\u{a763}', '\\0', '\\0']), ('\\u{a764}', ['\\u{a765}',\n        '\\0', '\\0']), ('\\u{a766}', ['\\u{a767}', '\\0', '\\0']), ('\\u{a768}', ['\\u{a769}', '\\0',\n        '\\0']), ('\\u{a76a}', ['\\u{a76b}', '\\0', '\\0']), ('\\u{a76c}', ['\\u{a76d}', '\\0', '\\0']),\n        ('\\u{a76e}', ['\\u{a76f}', '\\0', '\\0']), ('\\u{a779}', ['\\u{a77a}', '\\0', '\\0']), ('\\u{a77b}',\n        ['\\u{a77c}', '\\0', '\\0']), ('\\u{a77d}', ['\\u{1d79}', '\\0', '\\0']), ('\\u{a77e}', ['\\u{a77f}',\n        '\\0', '\\0']), ('\\u{a780}', ['\\u{a781}', '\\0', '\\0']), ('\\u{a782}', ['\\u{a783}', '\\0',\n        '\\0']), ('\\u{a784}', ['\\u{a785}', '\\0', '\\0']), ('\\u{a786}', ['\\u{a787}', '\\0', '\\0']),\n        ('\\u{a78b}', ['\\u{a78c}', '\\0', '\\0']), ('\\u{a78d}', ['\\u{265}', '\\0', '\\0']), ('\\u{a790}',\n        ['\\u{a791}', '\\0', '\\0']), ('\\u{a792}', ['\\u{a793}', '\\0', '\\0']), ('\\u{a796}', ['\\u{a797}',\n        '\\0', '\\0']), ('\\u{a798}', ['\\u{a799}', '\\0', '\\0']), ('\\u{a79a}', ['\\u{a79b}', '\\0',\n        '\\0']), ('\\u{a79c}', ['\\u{a79d}', '\\0', '\\0']), ('\\u{a79e}', ['\\u{a79f}', '\\0', '\\0']),\n        ('\\u{a7a0}', ['\\u{a7a1}', '\\0', '\\0']), ('\\u{a7a2}', ['\\u{a7a3}', '\\0', '\\0']), ('\\u{a7a4}',\n        ['\\u{a7a5}', '\\0', '\\0']), ('\\u{a7a6}', ['\\u{a7a7}', '\\0', '\\0']), ('\\u{a7a8}', ['\\u{a7a9}',\n        '\\0', '\\0']), ('\\u{a7aa}', ['\\u{266}', '\\0', '\\0']), ('\\u{a7ab}', ['\\u{25c}', '\\0', '\\0']),\n        ('\\u{a7ac}', ['\\u{261}', '\\0', '\\0']), ('\\u{a7ad}', ['\\u{26c}', '\\0', '\\0']), ('\\u{a7ae}',\n        ['\\u{26a}', '\\0', '\\0']), ('\\u{a7b0}', ['\\u{29e}', '\\0', '\\0']), ('\\u{a7b1}', ['\\u{287}',\n        '\\0', '\\0']), ('\\u{a7b2}', ['\\u{29d}', '\\0', '\\0']), ('\\u{a7b3}', ['\\u{ab53}', '\\0', '\\0']),\n        ('\\u{a7b4}', ['\\u{a7b5}', '\\0', '\\0']), ('\\u{a7b6}', ['\\u{a7b7}', '\\0', '\\0']), ('\\u{ff21}',\n        ['\\u{ff41}', '\\0', '\\0']), ('\\u{ff22}', ['\\u{ff42}', '\\0', '\\0']), ('\\u{ff23}', ['\\u{ff43}',\n        '\\0', '\\0']), ('\\u{ff24}', ['\\u{ff44}', '\\0', '\\0']), ('\\u{ff25}', ['\\u{ff45}', '\\0',\n        '\\0']), ('\\u{ff26}', ['\\u{ff46}', '\\0', '\\0']), ('\\u{ff27}', ['\\u{ff47}', '\\0', '\\0']),\n        ('\\u{ff28}', ['\\u{ff48}', '\\0', '\\0']), ('\\u{ff29}', ['\\u{ff49}', '\\0', '\\0']), ('\\u{ff2a}',\n        ['\\u{ff4a}', '\\0', '\\0']), ('\\u{ff2b}', ['\\u{ff4b}', '\\0', '\\0']), ('\\u{ff2c}', ['\\u{ff4c}',\n        '\\0', '\\0']), ('\\u{ff2d}', ['\\u{ff4d}', '\\0', '\\0']), ('\\u{ff2e}', ['\\u{ff4e}', '\\0',\n        '\\0']), ('\\u{ff2f}', ['\\u{ff4f}', '\\0', '\\0']), ('\\u{ff30}', ['\\u{ff50}', '\\0', '\\0']),\n        ('\\u{ff31}', ['\\u{ff51}', '\\0', '\\0']), ('\\u{ff32}', ['\\u{ff52}', '\\0', '\\0']), ('\\u{ff33}',\n        ['\\u{ff53}', '\\0', '\\0']), ('\\u{ff34}', ['\\u{ff54}', '\\0', '\\0']), ('\\u{ff35}', ['\\u{ff55}',\n        '\\0', '\\0']), ('\\u{ff36}', ['\\u{ff56}', '\\0', '\\0']), ('\\u{ff37}', ['\\u{ff57}', '\\0',\n        '\\0']), ('\\u{ff38}', ['\\u{ff58}', '\\0', '\\0']), ('\\u{ff39}', ['\\u{ff59}', '\\0', '\\0']),\n        ('\\u{ff3a}', ['\\u{ff5a}', '\\0', '\\0']), ('\\u{10400}', ['\\u{10428}', '\\0', '\\0']),\n        ('\\u{10401}', ['\\u{10429}', '\\0', '\\0']), ('\\u{10402}', ['\\u{1042a}', '\\0', '\\0']),\n        ('\\u{10403}', ['\\u{1042b}', '\\0', '\\0']), ('\\u{10404}', ['\\u{1042c}', '\\0', '\\0']),\n        ('\\u{10405}', ['\\u{1042d}', '\\0', '\\0']), ('\\u{10406}', ['\\u{1042e}', '\\0', '\\0']),\n        ('\\u{10407}', ['\\u{1042f}', '\\0', '\\0']), ('\\u{10408}', ['\\u{10430}', '\\0', '\\0']),\n        ('\\u{10409}', ['\\u{10431}', '\\0', '\\0']), ('\\u{1040a}', ['\\u{10432}', '\\0', '\\0']),\n        ('\\u{1040b}', ['\\u{10433}', '\\0', '\\0']), ('\\u{1040c}', ['\\u{10434}', '\\0', '\\0']),\n        ('\\u{1040d}', ['\\u{10435}', '\\0', '\\0']), ('\\u{1040e}', ['\\u{10436}', '\\0', '\\0']),\n        ('\\u{1040f}', ['\\u{10437}', '\\0', '\\0']), ('\\u{10410}', ['\\u{10438}', '\\0', '\\0']),\n        ('\\u{10411}', ['\\u{10439}', '\\0', '\\0']), ('\\u{10412}', ['\\u{1043a}', '\\0', '\\0']),\n        ('\\u{10413}', ['\\u{1043b}', '\\0', '\\0']), ('\\u{10414}', ['\\u{1043c}', '\\0', '\\0']),\n        ('\\u{10415}', ['\\u{1043d}', '\\0', '\\0']), ('\\u{10416}', ['\\u{1043e}', '\\0', '\\0']),\n        ('\\u{10417}', ['\\u{1043f}', '\\0', '\\0']), ('\\u{10418}', ['\\u{10440}', '\\0', '\\0']),\n        ('\\u{10419}', ['\\u{10441}', '\\0', '\\0']), ('\\u{1041a}', ['\\u{10442}', '\\0', '\\0']),\n        ('\\u{1041b}', ['\\u{10443}', '\\0', '\\0']), ('\\u{1041c}', ['\\u{10444}', '\\0', '\\0']),\n        ('\\u{1041d}', ['\\u{10445}', '\\0', '\\0']), ('\\u{1041e}', ['\\u{10446}', '\\0', '\\0']),\n        ('\\u{1041f}', ['\\u{10447}', '\\0', '\\0']), ('\\u{10420}', ['\\u{10448}', '\\0', '\\0']),\n        ('\\u{10421}', ['\\u{10449}', '\\0', '\\0']), ('\\u{10422}', ['\\u{1044a}', '\\0', '\\0']),\n        ('\\u{10423}', ['\\u{1044b}', '\\0', '\\0']), ('\\u{10424}', ['\\u{1044c}', '\\0', '\\0']),\n        ('\\u{10425}', ['\\u{1044d}', '\\0', '\\0']), ('\\u{10426}', ['\\u{1044e}', '\\0', '\\0']),\n        ('\\u{10427}', ['\\u{1044f}', '\\0', '\\0']), ('\\u{104b0}', ['\\u{104d8}', '\\0', '\\0']),\n        ('\\u{104b1}', ['\\u{104d9}', '\\0', '\\0']), ('\\u{104b2}', ['\\u{104da}', '\\0', '\\0']),\n        ('\\u{104b3}', ['\\u{104db}', '\\0', '\\0']), ('\\u{104b4}', ['\\u{104dc}', '\\0', '\\0']),\n        ('\\u{104b5}', ['\\u{104dd}', '\\0', '\\0']), ('\\u{104b6}', ['\\u{104de}', '\\0', '\\0']),\n        ('\\u{104b7}', ['\\u{104df}', '\\0', '\\0']), ('\\u{104b8}', ['\\u{104e0}', '\\0', '\\0']),\n        ('\\u{104b9}', ['\\u{104e1}', '\\0', '\\0']), ('\\u{104ba}', ['\\u{104e2}', '\\0', '\\0']),\n        ('\\u{104bb}', ['\\u{104e3}', '\\0', '\\0']), ('\\u{104bc}', ['\\u{104e4}', '\\0', '\\0']),\n        ('\\u{104bd}', ['\\u{104e5}', '\\0', '\\0']), ('\\u{104be}', ['\\u{104e6}', '\\0', '\\0']),\n        ('\\u{104bf}', ['\\u{104e7}', '\\0', '\\0']), ('\\u{104c0}', ['\\u{104e8}', '\\0', '\\0']),\n        ('\\u{104c1}', ['\\u{104e9}', '\\0', '\\0']), ('\\u{104c2}', ['\\u{104ea}', '\\0', '\\0']),\n        ('\\u{104c3}', ['\\u{104eb}', '\\0', '\\0']), ('\\u{104c4}', ['\\u{104ec}', '\\0', '\\0']),\n        ('\\u{104c5}', ['\\u{104ed}', '\\0', '\\0']), ('\\u{104c6}', ['\\u{104ee}', '\\0', '\\0']),\n        ('\\u{104c7}', ['\\u{104ef}', '\\0', '\\0']), ('\\u{104c8}', ['\\u{104f0}', '\\0', '\\0']),\n        ('\\u{104c9}', ['\\u{104f1}', '\\0', '\\0']), ('\\u{104ca}', ['\\u{104f2}', '\\0', '\\0']),\n        ('\\u{104cb}', ['\\u{104f3}', '\\0', '\\0']), ('\\u{104cc}', ['\\u{104f4}', '\\0', '\\0']),\n        ('\\u{104cd}', ['\\u{104f5}', '\\0', '\\0']), ('\\u{104ce}', ['\\u{104f6}', '\\0', '\\0']),\n        ('\\u{104cf}', ['\\u{104f7}', '\\0', '\\0']), ('\\u{104d0}', ['\\u{104f8}', '\\0', '\\0']),\n        ('\\u{104d1}', ['\\u{104f9}', '\\0', '\\0']), ('\\u{104d2}', ['\\u{104fa}', '\\0', '\\0']),\n        ('\\u{104d3}', ['\\u{104fb}', '\\0', '\\0']), ('\\u{10c80}', ['\\u{10cc0}', '\\0', '\\0']),\n        ('\\u{10c81}', ['\\u{10cc1}', '\\0', '\\0']), ('\\u{10c82}', ['\\u{10cc2}', '\\0', '\\0']),\n        ('\\u{10c83}', ['\\u{10cc3}', '\\0', '\\0']), ('\\u{10c84}', ['\\u{10cc4}', '\\0', '\\0']),\n        ('\\u{10c85}', ['\\u{10cc5}', '\\0', '\\0']), ('\\u{10c86}', ['\\u{10cc6}', '\\0', '\\0']),\n        ('\\u{10c87}', ['\\u{10cc7}', '\\0', '\\0']), ('\\u{10c88}', ['\\u{10cc8}', '\\0', '\\0']),\n        ('\\u{10c89}', ['\\u{10cc9}', '\\0', '\\0']), ('\\u{10c8a}', ['\\u{10cca}', '\\0', '\\0']),\n        ('\\u{10c8b}', ['\\u{10ccb}', '\\0', '\\0']), ('\\u{10c8c}', ['\\u{10ccc}', '\\0', '\\0']),\n        ('\\u{10c8d}', ['\\u{10ccd}', '\\0', '\\0']), ('\\u{10c8e}', ['\\u{10cce}', '\\0', '\\0']),\n        ('\\u{10c8f}', ['\\u{10ccf}', '\\0', '\\0']), ('\\u{10c90}', ['\\u{10cd0}', '\\0', '\\0']),\n        ('\\u{10c91}', ['\\u{10cd1}', '\\0', '\\0']), ('\\u{10c92}', ['\\u{10cd2}', '\\0', '\\0']),\n        ('\\u{10c93}', ['\\u{10cd3}', '\\0', '\\0']), ('\\u{10c94}', ['\\u{10cd4}', '\\0', '\\0']),\n        ('\\u{10c95}', ['\\u{10cd5}', '\\0', '\\0']), ('\\u{10c96}', ['\\u{10cd6}', '\\0', '\\0']),\n        ('\\u{10c97}', ['\\u{10cd7}', '\\0', '\\0']), ('\\u{10c98}', ['\\u{10cd8}', '\\0', '\\0']),\n        ('\\u{10c99}', ['\\u{10cd9}', '\\0', '\\0']), ('\\u{10c9a}', ['\\u{10cda}', '\\0', '\\0']),\n        ('\\u{10c9b}', ['\\u{10cdb}', '\\0', '\\0']), ('\\u{10c9c}', ['\\u{10cdc}', '\\0', '\\0']),\n        ('\\u{10c9d}', ['\\u{10cdd}', '\\0', '\\0']), ('\\u{10c9e}', ['\\u{10cde}', '\\0', '\\0']),\n        ('\\u{10c9f}', ['\\u{10cdf}', '\\0', '\\0']), ('\\u{10ca0}', ['\\u{10ce0}', '\\0', '\\0']),\n        ('\\u{10ca1}', ['\\u{10ce1}', '\\0', '\\0']), ('\\u{10ca2}', ['\\u{10ce2}', '\\0', '\\0']),\n        ('\\u{10ca3}', ['\\u{10ce3}', '\\0', '\\0']), ('\\u{10ca4}', ['\\u{10ce4}', '\\0', '\\0']),\n        ('\\u{10ca5}', ['\\u{10ce5}', '\\0', '\\0']), ('\\u{10ca6}', ['\\u{10ce6}', '\\0', '\\0']),\n        ('\\u{10ca7}', ['\\u{10ce7}', '\\0', '\\0']), ('\\u{10ca8}', ['\\u{10ce8}', '\\0', '\\0']),\n        ('\\u{10ca9}', ['\\u{10ce9}', '\\0', '\\0']), ('\\u{10caa}', ['\\u{10cea}', '\\0', '\\0']),\n        ('\\u{10cab}', ['\\u{10ceb}', '\\0', '\\0']), ('\\u{10cac}', ['\\u{10cec}', '\\0', '\\0']),\n        ('\\u{10cad}', ['\\u{10ced}', '\\0', '\\0']), ('\\u{10cae}', ['\\u{10cee}', '\\0', '\\0']),\n        ('\\u{10caf}', ['\\u{10cef}', '\\0', '\\0']), ('\\u{10cb0}', ['\\u{10cf0}', '\\0', '\\0']),\n        ('\\u{10cb1}', ['\\u{10cf1}', '\\0', '\\0']), ('\\u{10cb2}', ['\\u{10cf2}', '\\0', '\\0']),\n        ('\\u{118a0}', ['\\u{118c0}', '\\0', '\\0']), ('\\u{118a1}', ['\\u{118c1}', '\\0', '\\0']),\n        ('\\u{118a2}', ['\\u{118c2}', '\\0', '\\0']), ('\\u{118a3}', ['\\u{118c3}', '\\0', '\\0']),\n        ('\\u{118a4}', ['\\u{118c4}', '\\0', '\\0']), ('\\u{118a5}', ['\\u{118c5}', '\\0', '\\0']),\n        ('\\u{118a6}', ['\\u{118c6}', '\\0', '\\0']), ('\\u{118a7}', ['\\u{118c7}', '\\0', '\\0']),\n        ('\\u{118a8}', ['\\u{118c8}', '\\0', '\\0']), ('\\u{118a9}', ['\\u{118c9}', '\\0', '\\0']),\n        ('\\u{118aa}', ['\\u{118ca}', '\\0', '\\0']), ('\\u{118ab}', ['\\u{118cb}', '\\0', '\\0']),\n        ('\\u{118ac}', ['\\u{118cc}', '\\0', '\\0']), ('\\u{118ad}', ['\\u{118cd}', '\\0', '\\0']),\n        ('\\u{118ae}', ['\\u{118ce}', '\\0', '\\0']), ('\\u{118af}', ['\\u{118cf}', '\\0', '\\0']),\n        ('\\u{118b0}', ['\\u{118d0}', '\\0', '\\0']), ('\\u{118b1}', ['\\u{118d1}', '\\0', '\\0']),\n        ('\\u{118b2}', ['\\u{118d2}', '\\0', '\\0']), ('\\u{118b3}', ['\\u{118d3}', '\\0', '\\0']),\n        ('\\u{118b4}', ['\\u{118d4}', '\\0', '\\0']), ('\\u{118b5}', ['\\u{118d5}', '\\0', '\\0']),\n        ('\\u{118b6}', ['\\u{118d6}', '\\0', '\\0']), ('\\u{118b7}', ['\\u{118d7}', '\\0', '\\0']),\n        ('\\u{118b8}', ['\\u{118d8}', '\\0', '\\0']), ('\\u{118b9}', ['\\u{118d9}', '\\0', '\\0']),\n        ('\\u{118ba}', ['\\u{118da}', '\\0', '\\0']), ('\\u{118bb}', ['\\u{118db}', '\\0', '\\0']),\n        ('\\u{118bc}', ['\\u{118dc}', '\\0', '\\0']), ('\\u{118bd}', ['\\u{118dd}', '\\0', '\\0']),\n        ('\\u{118be}', ['\\u{118de}', '\\0', '\\0']), ('\\u{118bf}', ['\\u{118df}', '\\0', '\\0']),\n        ('\\u{1e900}', ['\\u{1e922}', '\\0', '\\0']), ('\\u{1e901}', ['\\u{1e923}', '\\0', '\\0']),\n        ('\\u{1e902}', ['\\u{1e924}', '\\0', '\\0']), ('\\u{1e903}', ['\\u{1e925}', '\\0', '\\0']),\n        ('\\u{1e904}', ['\\u{1e926}', '\\0', '\\0']), ('\\u{1e905}', ['\\u{1e927}', '\\0', '\\0']),\n        ('\\u{1e906}', ['\\u{1e928}', '\\0', '\\0']), ('\\u{1e907}', ['\\u{1e929}', '\\0', '\\0']),\n        ('\\u{1e908}', ['\\u{1e92a}', '\\0', '\\0']), ('\\u{1e909}', ['\\u{1e92b}', '\\0', '\\0']),\n        ('\\u{1e90a}', ['\\u{1e92c}', '\\0', '\\0']), ('\\u{1e90b}', ['\\u{1e92d}', '\\0', '\\0']),\n        ('\\u{1e90c}', ['\\u{1e92e}', '\\0', '\\0']), ('\\u{1e90d}', ['\\u{1e92f}', '\\0', '\\0']),\n        ('\\u{1e90e}', ['\\u{1e930}', '\\0', '\\0']), ('\\u{1e90f}', ['\\u{1e931}', '\\0', '\\0']),\n        ('\\u{1e910}', ['\\u{1e932}', '\\0', '\\0']), ('\\u{1e911}', ['\\u{1e933}', '\\0', '\\0']),\n        ('\\u{1e912}', ['\\u{1e934}', '\\0', '\\0']), ('\\u{1e913}', ['\\u{1e935}', '\\0', '\\0']),\n        ('\\u{1e914}', ['\\u{1e936}', '\\0', '\\0']), ('\\u{1e915}', ['\\u{1e937}', '\\0', '\\0']),\n        ('\\u{1e916}', ['\\u{1e938}', '\\0', '\\0']), ('\\u{1e917}', ['\\u{1e939}', '\\0', '\\0']),\n        ('\\u{1e918}', ['\\u{1e93a}', '\\0', '\\0']), ('\\u{1e919}', ['\\u{1e93b}', '\\0', '\\0']),\n        ('\\u{1e91a}', ['\\u{1e93c}', '\\0', '\\0']), ('\\u{1e91b}', ['\\u{1e93d}', '\\0', '\\0']),\n        ('\\u{1e91c}', ['\\u{1e93e}', '\\0', '\\0']), ('\\u{1e91d}', ['\\u{1e93f}', '\\0', '\\0']),\n        ('\\u{1e91e}', ['\\u{1e940}', '\\0', '\\0']), ('\\u{1e91f}', ['\\u{1e941}', '\\0', '\\0']),\n        ('\\u{1e920}', ['\\u{1e942}', '\\0', '\\0']), ('\\u{1e921}', ['\\u{1e943}', '\\0', '\\0'])\n    ];\n\n    const to_uppercase_table: &'static [(char, [char; 3])] = &[\n        ('\\u{61}', ['\\u{41}', '\\0', '\\0']), ('\\u{62}', ['\\u{42}', '\\0', '\\0']), ('\\u{63}',\n        ['\\u{43}', '\\0', '\\0']), ('\\u{64}', ['\\u{44}', '\\0', '\\0']), ('\\u{65}', ['\\u{45}', '\\0',\n        '\\0']), ('\\u{66}', ['\\u{46}', '\\0', '\\0']), ('\\u{67}', ['\\u{47}', '\\0', '\\0']), ('\\u{68}',\n        ['\\u{48}', '\\0', '\\0']), ('\\u{69}', ['\\u{49}', '\\0', '\\0']), ('\\u{6a}', ['\\u{4a}', '\\0',\n        '\\0']), ('\\u{6b}', ['\\u{4b}', '\\0', '\\0']), ('\\u{6c}', ['\\u{4c}', '\\0', '\\0']), ('\\u{6d}',\n        ['\\u{4d}', '\\0', '\\0']), ('\\u{6e}', ['\\u{4e}', '\\0', '\\0']), ('\\u{6f}', ['\\u{4f}', '\\0',\n        '\\0']), ('\\u{70}', ['\\u{50}', '\\0', '\\0']), ('\\u{71}', ['\\u{51}', '\\0', '\\0']), ('\\u{72}',\n        ['\\u{52}', '\\0', '\\0']), ('\\u{73}', ['\\u{53}', '\\0', '\\0']), ('\\u{74}', ['\\u{54}', '\\0',\n        '\\0']), ('\\u{75}', ['\\u{55}', '\\0', '\\0']), ('\\u{76}', ['\\u{56}', '\\0', '\\0']), ('\\u{77}',\n        ['\\u{57}', '\\0', '\\0']), ('\\u{78}', ['\\u{58}', '\\0', '\\0']), ('\\u{79}', ['\\u{59}', '\\0',\n        '\\0']), ('\\u{7a}', ['\\u{5a}', '\\0', '\\0']), ('\\u{b5}', ['\\u{39c}', '\\0', '\\0']), ('\\u{df}',\n        ['\\u{53}', '\\u{53}', '\\0']), ('\\u{e0}', ['\\u{c0}', '\\0', '\\0']), ('\\u{e1}', ['\\u{c1}', '\\0',\n        '\\0']), ('\\u{e2}', ['\\u{c2}', '\\0', '\\0']), ('\\u{e3}', ['\\u{c3}', '\\0', '\\0']), ('\\u{e4}',\n        ['\\u{c4}', '\\0', '\\0']), ('\\u{e5}', ['\\u{c5}', '\\0', '\\0']), ('\\u{e6}', ['\\u{c6}', '\\0',\n        '\\0']), ('\\u{e7}', ['\\u{c7}', '\\0', '\\0']), ('\\u{e8}', ['\\u{c8}', '\\0', '\\0']), ('\\u{e9}',\n        ['\\u{c9}', '\\0', '\\0']), ('\\u{ea}', ['\\u{ca}', '\\0', '\\0']), ('\\u{eb}', ['\\u{cb}', '\\0',\n        '\\0']), ('\\u{ec}', ['\\u{cc}', '\\0', '\\0']), ('\\u{ed}', ['\\u{cd}', '\\0', '\\0']), ('\\u{ee}',\n        ['\\u{ce}', '\\0', '\\0']), ('\\u{ef}', ['\\u{cf}', '\\0', '\\0']), ('\\u{f0}', ['\\u{d0}', '\\0',\n        '\\0']), ('\\u{f1}', ['\\u{d1}', '\\0', '\\0']), ('\\u{f2}', ['\\u{d2}', '\\0', '\\0']), ('\\u{f3}',\n        ['\\u{d3}', '\\0', '\\0']), ('\\u{f4}', ['\\u{d4}', '\\0', '\\0']), ('\\u{f5}', ['\\u{d5}', '\\0',\n        '\\0']), ('\\u{f6}', ['\\u{d6}', '\\0', '\\0']), ('\\u{f8}', ['\\u{d8}', '\\0', '\\0']), ('\\u{f9}',\n        ['\\u{d9}', '\\0', '\\0']), ('\\u{fa}', ['\\u{da}', '\\0', '\\0']), ('\\u{fb}', ['\\u{db}', '\\0',\n        '\\0']), ('\\u{fc}', ['\\u{dc}', '\\0', '\\0']), ('\\u{fd}', ['\\u{dd}', '\\0', '\\0']), ('\\u{fe}',\n        ['\\u{de}', '\\0', '\\0']), ('\\u{ff}', ['\\u{178}', '\\0', '\\0']), ('\\u{101}', ['\\u{100}', '\\0',\n        '\\0']), ('\\u{103}', ['\\u{102}', '\\0', '\\0']), ('\\u{105}', ['\\u{104}', '\\0', '\\0']),\n        ('\\u{107}', ['\\u{106}', '\\0', '\\0']), ('\\u{109}', ['\\u{108}', '\\0', '\\0']), ('\\u{10b}',\n        ['\\u{10a}', '\\0', '\\0']), ('\\u{10d}', ['\\u{10c}', '\\0', '\\0']), ('\\u{10f}', ['\\u{10e}',\n        '\\0', '\\0']), ('\\u{111}', ['\\u{110}', '\\0', '\\0']), ('\\u{113}', ['\\u{112}', '\\0', '\\0']),\n        ('\\u{115}', ['\\u{114}', '\\0', '\\0']), ('\\u{117}', ['\\u{116}', '\\0', '\\0']), ('\\u{119}',\n        ['\\u{118}', '\\0', '\\0']), ('\\u{11b}', ['\\u{11a}', '\\0', '\\0']), ('\\u{11d}', ['\\u{11c}',\n        '\\0', '\\0']), ('\\u{11f}', ['\\u{11e}', '\\0', '\\0']), ('\\u{121}', ['\\u{120}', '\\0', '\\0']),\n        ('\\u{123}', ['\\u{122}', '\\0', '\\0']), ('\\u{125}', ['\\u{124}', '\\0', '\\0']), ('\\u{127}',\n        ['\\u{126}', '\\0', '\\0']), ('\\u{129}', ['\\u{128}', '\\0', '\\0']), ('\\u{12b}', ['\\u{12a}',\n        '\\0', '\\0']), ('\\u{12d}', ['\\u{12c}', '\\0', '\\0']), ('\\u{12f}', ['\\u{12e}', '\\0', '\\0']),\n        ('\\u{131}', ['\\u{49}', '\\0', '\\0']), ('\\u{133}', ['\\u{132}', '\\0', '\\0']), ('\\u{135}',\n        ['\\u{134}', '\\0', '\\0']), ('\\u{137}', ['\\u{136}', '\\0', '\\0']), ('\\u{13a}', ['\\u{139}',\n        '\\0', '\\0']), ('\\u{13c}', ['\\u{13b}', '\\0', '\\0']), ('\\u{13e}', ['\\u{13d}', '\\0', '\\0']),\n        ('\\u{140}', ['\\u{13f}', '\\0', '\\0']), ('\\u{142}', ['\\u{141}', '\\0', '\\0']), ('\\u{144}',\n        ['\\u{143}', '\\0', '\\0']), ('\\u{146}', ['\\u{145}', '\\0', '\\0']), ('\\u{148}', ['\\u{147}',\n        '\\0', '\\0']), ('\\u{149}', ['\\u{2bc}', '\\u{4e}', '\\0']), ('\\u{14b}', ['\\u{14a}', '\\0',\n        '\\0']), ('\\u{14d}', ['\\u{14c}', '\\0', '\\0']), ('\\u{14f}', ['\\u{14e}', '\\0', '\\0']),\n        ('\\u{151}', ['\\u{150}', '\\0', '\\0']), ('\\u{153}', ['\\u{152}', '\\0', '\\0']), ('\\u{155}',\n        ['\\u{154}', '\\0', '\\0']), ('\\u{157}', ['\\u{156}', '\\0', '\\0']), ('\\u{159}', ['\\u{158}',\n        '\\0', '\\0']), ('\\u{15b}', ['\\u{15a}', '\\0', '\\0']), ('\\u{15d}', ['\\u{15c}', '\\0', '\\0']),\n        ('\\u{15f}', ['\\u{15e}', '\\0', '\\0']), ('\\u{161}', ['\\u{160}', '\\0', '\\0']), ('\\u{163}',\n        ['\\u{162}', '\\0', '\\0']), ('\\u{165}', ['\\u{164}', '\\0', '\\0']), ('\\u{167}', ['\\u{166}',\n        '\\0', '\\0']), ('\\u{169}', ['\\u{168}', '\\0', '\\0']), ('\\u{16b}', ['\\u{16a}', '\\0', '\\0']),\n        ('\\u{16d}', ['\\u{16c}', '\\0', '\\0']), ('\\u{16f}', ['\\u{16e}', '\\0', '\\0']), ('\\u{171}',\n        ['\\u{170}', '\\0', '\\0']), ('\\u{173}', ['\\u{172}', '\\0', '\\0']), ('\\u{175}', ['\\u{174}',\n        '\\0', '\\0']), ('\\u{177}', ['\\u{176}', '\\0', '\\0']), ('\\u{17a}', ['\\u{179}', '\\0', '\\0']),\n        ('\\u{17c}', ['\\u{17b}', '\\0', '\\0']), ('\\u{17e}', ['\\u{17d}', '\\0', '\\0']), ('\\u{17f}',\n        ['\\u{53}', '\\0', '\\0']), ('\\u{180}', ['\\u{243}', '\\0', '\\0']), ('\\u{183}', ['\\u{182}', '\\0',\n        '\\0']), ('\\u{185}', ['\\u{184}', '\\0', '\\0']), ('\\u{188}', ['\\u{187}', '\\0', '\\0']),\n        ('\\u{18c}', ['\\u{18b}', '\\0', '\\0']), ('\\u{192}', ['\\u{191}', '\\0', '\\0']), ('\\u{195}',\n        ['\\u{1f6}', '\\0', '\\0']), ('\\u{199}', ['\\u{198}', '\\0', '\\0']), ('\\u{19a}', ['\\u{23d}',\n        '\\0', '\\0']), ('\\u{19e}', ['\\u{220}', '\\0', '\\0']), ('\\u{1a1}', ['\\u{1a0}', '\\0', '\\0']),\n        ('\\u{1a3}', ['\\u{1a2}', '\\0', '\\0']), ('\\u{1a5}', ['\\u{1a4}', '\\0', '\\0']), ('\\u{1a8}',\n        ['\\u{1a7}', '\\0', '\\0']), ('\\u{1ad}', ['\\u{1ac}', '\\0', '\\0']), ('\\u{1b0}', ['\\u{1af}',\n        '\\0', '\\0']), ('\\u{1b4}', ['\\u{1b3}', '\\0', '\\0']), ('\\u{1b6}', ['\\u{1b5}', '\\0', '\\0']),\n        ('\\u{1b9}', ['\\u{1b8}', '\\0', '\\0']), ('\\u{1bd}', ['\\u{1bc}', '\\0', '\\0']), ('\\u{1bf}',\n        ['\\u{1f7}', '\\0', '\\0']), ('\\u{1c5}', ['\\u{1c4}', '\\0', '\\0']), ('\\u{1c6}', ['\\u{1c4}',\n        '\\0', '\\0']), ('\\u{1c8}', ['\\u{1c7}', '\\0', '\\0']), ('\\u{1c9}', ['\\u{1c7}', '\\0', '\\0']),\n        ('\\u{1cb}', ['\\u{1ca}', '\\0', '\\0']), ('\\u{1cc}', ['\\u{1ca}', '\\0', '\\0']), ('\\u{1ce}',\n        ['\\u{1cd}', '\\0', '\\0']), ('\\u{1d0}', ['\\u{1cf}', '\\0', '\\0']), ('\\u{1d2}', ['\\u{1d1}',\n        '\\0', '\\0']), ('\\u{1d4}', ['\\u{1d3}', '\\0', '\\0']), ('\\u{1d6}', ['\\u{1d5}', '\\0', '\\0']),\n        ('\\u{1d8}', ['\\u{1d7}', '\\0', '\\0']), ('\\u{1da}', ['\\u{1d9}', '\\0', '\\0']), ('\\u{1dc}',\n        ['\\u{1db}', '\\0', '\\0']), ('\\u{1dd}', ['\\u{18e}', '\\0', '\\0']), ('\\u{1df}', ['\\u{1de}',\n        '\\0', '\\0']), ('\\u{1e1}', ['\\u{1e0}', '\\0', '\\0']), ('\\u{1e3}', ['\\u{1e2}', '\\0', '\\0']),\n        ('\\u{1e5}', ['\\u{1e4}', '\\0', '\\0']), ('\\u{1e7}', ['\\u{1e6}', '\\0', '\\0']), ('\\u{1e9}',\n        ['\\u{1e8}', '\\0', '\\0']), ('\\u{1eb}', ['\\u{1ea}', '\\0', '\\0']), ('\\u{1ed}', ['\\u{1ec}',\n        '\\0', '\\0']), ('\\u{1ef}', ['\\u{1ee}', '\\0', '\\0']), ('\\u{1f0}', ['\\u{4a}', '\\u{30c}',\n        '\\0']), ('\\u{1f2}', ['\\u{1f1}', '\\0', '\\0']), ('\\u{1f3}', ['\\u{1f1}', '\\0', '\\0']),\n        ('\\u{1f5}', ['\\u{1f4}', '\\0', '\\0']), ('\\u{1f9}', ['\\u{1f8}', '\\0', '\\0']), ('\\u{1fb}',\n        ['\\u{1fa}', '\\0', '\\0']), ('\\u{1fd}', ['\\u{1fc}', '\\0', '\\0']), ('\\u{1ff}', ['\\u{1fe}',\n        '\\0', '\\0']), ('\\u{201}', ['\\u{200}', '\\0', '\\0']), ('\\u{203}', ['\\u{202}', '\\0', '\\0']),\n        ('\\u{205}', ['\\u{204}', '\\0', '\\0']), ('\\u{207}', ['\\u{206}', '\\0', '\\0']), ('\\u{209}',\n        ['\\u{208}', '\\0', '\\0']), ('\\u{20b}', ['\\u{20a}', '\\0', '\\0']), ('\\u{20d}', ['\\u{20c}',\n        '\\0', '\\0']), ('\\u{20f}', ['\\u{20e}', '\\0', '\\0']), ('\\u{211}', ['\\u{210}', '\\0', '\\0']),\n        ('\\u{213}', ['\\u{212}', '\\0', '\\0']), ('\\u{215}', ['\\u{214}', '\\0', '\\0']), ('\\u{217}',\n        ['\\u{216}', '\\0', '\\0']), ('\\u{219}', ['\\u{218}', '\\0', '\\0']), ('\\u{21b}', ['\\u{21a}',\n        '\\0', '\\0']), ('\\u{21d}', ['\\u{21c}', '\\0', '\\0']), ('\\u{21f}', ['\\u{21e}', '\\0', '\\0']),\n        ('\\u{223}', ['\\u{222}', '\\0', '\\0']), ('\\u{225}', ['\\u{224}', '\\0', '\\0']), ('\\u{227}',\n        ['\\u{226}', '\\0', '\\0']), ('\\u{229}', ['\\u{228}', '\\0', '\\0']), ('\\u{22b}', ['\\u{22a}',\n        '\\0', '\\0']), ('\\u{22d}', ['\\u{22c}', '\\0', '\\0']), ('\\u{22f}', ['\\u{22e}', '\\0', '\\0']),\n        ('\\u{231}', ['\\u{230}', '\\0', '\\0']), ('\\u{233}', ['\\u{232}', '\\0', '\\0']), ('\\u{23c}',\n        ['\\u{23b}', '\\0', '\\0']), ('\\u{23f}', ['\\u{2c7e}', '\\0', '\\0']), ('\\u{240}', ['\\u{2c7f}',\n        '\\0', '\\0']), ('\\u{242}', ['\\u{241}', '\\0', '\\0']), ('\\u{247}', ['\\u{246}', '\\0', '\\0']),\n        ('\\u{249}', ['\\u{248}', '\\0', '\\0']), ('\\u{24b}', ['\\u{24a}', '\\0', '\\0']), ('\\u{24d}',\n        ['\\u{24c}', '\\0', '\\0']), ('\\u{24f}', ['\\u{24e}', '\\0', '\\0']), ('\\u{250}', ['\\u{2c6f}',\n        '\\0', '\\0']), ('\\u{251}', ['\\u{2c6d}', '\\0', '\\0']), ('\\u{252}', ['\\u{2c70}', '\\0', '\\0']),\n        ('\\u{253}', ['\\u{181}', '\\0', '\\0']), ('\\u{254}', ['\\u{186}', '\\0', '\\0']), ('\\u{256}',\n        ['\\u{189}', '\\0', '\\0']), ('\\u{257}', ['\\u{18a}', '\\0', '\\0']), ('\\u{259}', ['\\u{18f}',\n        '\\0', '\\0']), ('\\u{25b}', ['\\u{190}', '\\0', '\\0']), ('\\u{25c}', ['\\u{a7ab}', '\\0', '\\0']),\n        ('\\u{260}', ['\\u{193}', '\\0', '\\0']), ('\\u{261}', ['\\u{a7ac}', '\\0', '\\0']), ('\\u{263}',\n        ['\\u{194}', '\\0', '\\0']), ('\\u{265}', ['\\u{a78d}', '\\0', '\\0']), ('\\u{266}', ['\\u{a7aa}',\n        '\\0', '\\0']), ('\\u{268}', ['\\u{197}', '\\0', '\\0']), ('\\u{269}', ['\\u{196}', '\\0', '\\0']),\n        ('\\u{26a}', ['\\u{a7ae}', '\\0', '\\0']), ('\\u{26b}', ['\\u{2c62}', '\\0', '\\0']), ('\\u{26c}',\n        ['\\u{a7ad}', '\\0', '\\0']), ('\\u{26f}', ['\\u{19c}', '\\0', '\\0']), ('\\u{271}', ['\\u{2c6e}',\n        '\\0', '\\0']), ('\\u{272}', ['\\u{19d}', '\\0', '\\0']), ('\\u{275}', ['\\u{19f}', '\\0', '\\0']),\n        ('\\u{27d}', ['\\u{2c64}', '\\0', '\\0']), ('\\u{280}', ['\\u{1a6}', '\\0', '\\0']), ('\\u{283}',\n        ['\\u{1a9}', '\\0', '\\0']), ('\\u{287}', ['\\u{a7b1}', '\\0', '\\0']), ('\\u{288}', ['\\u{1ae}',\n        '\\0', '\\0']), ('\\u{289}', ['\\u{244}', '\\0', '\\0']), ('\\u{28a}', ['\\u{1b1}', '\\0', '\\0']),\n        ('\\u{28b}', ['\\u{1b2}', '\\0', '\\0']), ('\\u{28c}', ['\\u{245}', '\\0', '\\0']), ('\\u{292}',\n        ['\\u{1b7}', '\\0', '\\0']), ('\\u{29d}', ['\\u{a7b2}', '\\0', '\\0']), ('\\u{29e}', ['\\u{a7b0}',\n        '\\0', '\\0']), ('\\u{345}', ['\\u{399}', '\\0', '\\0']), ('\\u{371}', ['\\u{370}', '\\0', '\\0']),\n        ('\\u{373}', ['\\u{372}', '\\0', '\\0']), ('\\u{377}', ['\\u{376}', '\\0', '\\0']), ('\\u{37b}',\n        ['\\u{3fd}', '\\0', '\\0']), ('\\u{37c}', ['\\u{3fe}', '\\0', '\\0']), ('\\u{37d}', ['\\u{3ff}',\n        '\\0', '\\0']), ('\\u{390}', ['\\u{399}', '\\u{308}', '\\u{301}']), ('\\u{3ac}', ['\\u{386}', '\\0',\n        '\\0']), ('\\u{3ad}', ['\\u{388}', '\\0', '\\0']), ('\\u{3ae}', ['\\u{389}', '\\0', '\\0']),\n        ('\\u{3af}', ['\\u{38a}', '\\0', '\\0']), ('\\u{3b0}', ['\\u{3a5}', '\\u{308}', '\\u{301}']),\n        ('\\u{3b1}', ['\\u{391}', '\\0', '\\0']), ('\\u{3b2}', ['\\u{392}', '\\0', '\\0']), ('\\u{3b3}',\n        ['\\u{393}', '\\0', '\\0']), ('\\u{3b4}', ['\\u{394}', '\\0', '\\0']), ('\\u{3b5}', ['\\u{395}',\n        '\\0', '\\0']), ('\\u{3b6}', ['\\u{396}', '\\0', '\\0']), ('\\u{3b7}', ['\\u{397}', '\\0', '\\0']),\n        ('\\u{3b8}', ['\\u{398}', '\\0', '\\0']), ('\\u{3b9}', ['\\u{399}', '\\0', '\\0']), ('\\u{3ba}',\n        ['\\u{39a}', '\\0', '\\0']), ('\\u{3bb}', ['\\u{39b}', '\\0', '\\0']), ('\\u{3bc}', ['\\u{39c}',\n        '\\0', '\\0']), ('\\u{3bd}', ['\\u{39d}', '\\0', '\\0']), ('\\u{3be}', ['\\u{39e}', '\\0', '\\0']),\n        ('\\u{3bf}', ['\\u{39f}', '\\0', '\\0']), ('\\u{3c0}', ['\\u{3a0}', '\\0', '\\0']), ('\\u{3c1}',\n        ['\\u{3a1}', '\\0', '\\0']), ('\\u{3c2}', ['\\u{3a3}', '\\0', '\\0']), ('\\u{3c3}', ['\\u{3a3}',\n        '\\0', '\\0']), ('\\u{3c4}', ['\\u{3a4}', '\\0', '\\0']), ('\\u{3c5}', ['\\u{3a5}', '\\0', '\\0']),\n        ('\\u{3c6}', ['\\u{3a6}', '\\0', '\\0']), ('\\u{3c7}', ['\\u{3a7}', '\\0', '\\0']), ('\\u{3c8}',\n        ['\\u{3a8}', '\\0', '\\0']), ('\\u{3c9}', ['\\u{3a9}', '\\0', '\\0']), ('\\u{3ca}', ['\\u{3aa}',\n        '\\0', '\\0']), ('\\u{3cb}', ['\\u{3ab}', '\\0', '\\0']), ('\\u{3cc}', ['\\u{38c}', '\\0', '\\0']),\n        ('\\u{3cd}', ['\\u{38e}', '\\0', '\\0']), ('\\u{3ce}', ['\\u{38f}', '\\0', '\\0']), ('\\u{3d0}',\n        ['\\u{392}', '\\0', '\\0']), ('\\u{3d1}', ['\\u{398}', '\\0', '\\0']), ('\\u{3d5}', ['\\u{3a6}',\n        '\\0', '\\0']), ('\\u{3d6}', ['\\u{3a0}', '\\0', '\\0']), ('\\u{3d7}', ['\\u{3cf}', '\\0', '\\0']),\n        ('\\u{3d9}', ['\\u{3d8}', '\\0', '\\0']), ('\\u{3db}', ['\\u{3da}', '\\0', '\\0']), ('\\u{3dd}',\n        ['\\u{3dc}', '\\0', '\\0']), ('\\u{3df}', ['\\u{3de}', '\\0', '\\0']), ('\\u{3e1}', ['\\u{3e0}',\n        '\\0', '\\0']), ('\\u{3e3}', ['\\u{3e2}', '\\0', '\\0']), ('\\u{3e5}', ['\\u{3e4}', '\\0', '\\0']),\n        ('\\u{3e7}', ['\\u{3e6}', '\\0', '\\0']), ('\\u{3e9}', ['\\u{3e8}', '\\0', '\\0']), ('\\u{3eb}',\n        ['\\u{3ea}', '\\0', '\\0']), ('\\u{3ed}', ['\\u{3ec}', '\\0', '\\0']), ('\\u{3ef}', ['\\u{3ee}',\n        '\\0', '\\0']), ('\\u{3f0}', ['\\u{39a}', '\\0', '\\0']), ('\\u{3f1}', ['\\u{3a1}', '\\0', '\\0']),\n        ('\\u{3f2}', ['\\u{3f9}', '\\0', '\\0']), ('\\u{3f3}', ['\\u{37f}', '\\0', '\\0']), ('\\u{3f5}',\n        ['\\u{395}', '\\0', '\\0']), ('\\u{3f8}', ['\\u{3f7}', '\\0', '\\0']), ('\\u{3fb}', ['\\u{3fa}',\n        '\\0', '\\0']), ('\\u{430}', ['\\u{410}', '\\0', '\\0']), ('\\u{431}', ['\\u{411}', '\\0', '\\0']),\n        ('\\u{432}', ['\\u{412}', '\\0', '\\0']), ('\\u{433}', ['\\u{413}', '\\0', '\\0']), ('\\u{434}',\n        ['\\u{414}', '\\0', '\\0']), ('\\u{435}', ['\\u{415}', '\\0', '\\0']), ('\\u{436}', ['\\u{416}',\n        '\\0', '\\0']), ('\\u{437}', ['\\u{417}', '\\0', '\\0']), ('\\u{438}', ['\\u{418}', '\\0', '\\0']),\n        ('\\u{439}', ['\\u{419}', '\\0', '\\0']), ('\\u{43a}', ['\\u{41a}', '\\0', '\\0']), ('\\u{43b}',\n        ['\\u{41b}', '\\0', '\\0']), ('\\u{43c}', ['\\u{41c}', '\\0', '\\0']), ('\\u{43d}', ['\\u{41d}',\n        '\\0', '\\0']), ('\\u{43e}', ['\\u{41e}', '\\0', '\\0']), ('\\u{43f}', ['\\u{41f}', '\\0', '\\0']),\n        ('\\u{440}', ['\\u{420}', '\\0', '\\0']), ('\\u{441}', ['\\u{421}', '\\0', '\\0']), ('\\u{442}',\n        ['\\u{422}', '\\0', '\\0']), ('\\u{443}', ['\\u{423}', '\\0', '\\0']), ('\\u{444}', ['\\u{424}',\n        '\\0', '\\0']), ('\\u{445}', ['\\u{425}', '\\0', '\\0']), ('\\u{446}', ['\\u{426}', '\\0', '\\0']),\n        ('\\u{447}', ['\\u{427}', '\\0', '\\0']), ('\\u{448}', ['\\u{428}', '\\0', '\\0']), ('\\u{449}',\n        ['\\u{429}', '\\0', '\\0']), ('\\u{44a}', ['\\u{42a}', '\\0', '\\0']), ('\\u{44b}', ['\\u{42b}',\n        '\\0', '\\0']), ('\\u{44c}', ['\\u{42c}', '\\0', '\\0']), ('\\u{44d}', ['\\u{42d}', '\\0', '\\0']),\n        ('\\u{44e}', ['\\u{42e}', '\\0', '\\0']), ('\\u{44f}', ['\\u{42f}', '\\0', '\\0']), ('\\u{450}',\n        ['\\u{400}', '\\0', '\\0']), ('\\u{451}', ['\\u{401}', '\\0', '\\0']), ('\\u{452}', ['\\u{402}',\n        '\\0', '\\0']), ('\\u{453}', ['\\u{403}', '\\0', '\\0']), ('\\u{454}', ['\\u{404}', '\\0', '\\0']),\n        ('\\u{455}', ['\\u{405}', '\\0', '\\0']), ('\\u{456}', ['\\u{406}', '\\0', '\\0']), ('\\u{457}',\n        ['\\u{407}', '\\0', '\\0']), ('\\u{458}', ['\\u{408}', '\\0', '\\0']), ('\\u{459}', ['\\u{409}',\n        '\\0', '\\0']), ('\\u{45a}', ['\\u{40a}', '\\0', '\\0']), ('\\u{45b}', ['\\u{40b}', '\\0', '\\0']),\n        ('\\u{45c}', ['\\u{40c}', '\\0', '\\0']), ('\\u{45d}', ['\\u{40d}', '\\0', '\\0']), ('\\u{45e}',\n        ['\\u{40e}', '\\0', '\\0']), ('\\u{45f}', ['\\u{40f}', '\\0', '\\0']), ('\\u{461}', ['\\u{460}',\n        '\\0', '\\0']), ('\\u{463}', ['\\u{462}', '\\0', '\\0']), ('\\u{465}', ['\\u{464}', '\\0', '\\0']),\n        ('\\u{467}', ['\\u{466}', '\\0', '\\0']), ('\\u{469}', ['\\u{468}', '\\0', '\\0']), ('\\u{46b}',\n        ['\\u{46a}', '\\0', '\\0']), ('\\u{46d}', ['\\u{46c}', '\\0', '\\0']), ('\\u{46f}', ['\\u{46e}',\n        '\\0', '\\0']), ('\\u{471}', ['\\u{470}', '\\0', '\\0']), ('\\u{473}', ['\\u{472}', '\\0', '\\0']),\n        ('\\u{475}', ['\\u{474}', '\\0', '\\0']), ('\\u{477}', ['\\u{476}', '\\0', '\\0']), ('\\u{479}',\n        ['\\u{478}', '\\0', '\\0']), ('\\u{47b}', ['\\u{47a}', '\\0', '\\0']), ('\\u{47d}', ['\\u{47c}',\n        '\\0', '\\0']), ('\\u{47f}', ['\\u{47e}', '\\0', '\\0']), ('\\u{481}', ['\\u{480}', '\\0', '\\0']),\n        ('\\u{48b}', ['\\u{48a}', '\\0', '\\0']), ('\\u{48d}', ['\\u{48c}', '\\0', '\\0']), ('\\u{48f}',\n        ['\\u{48e}', '\\0', '\\0']), ('\\u{491}', ['\\u{490}', '\\0', '\\0']), ('\\u{493}', ['\\u{492}',\n        '\\0', '\\0']), ('\\u{495}', ['\\u{494}', '\\0', '\\0']), ('\\u{497}', ['\\u{496}', '\\0', '\\0']),\n        ('\\u{499}', ['\\u{498}', '\\0', '\\0']), ('\\u{49b}', ['\\u{49a}', '\\0', '\\0']), ('\\u{49d}',\n        ['\\u{49c}', '\\0', '\\0']), ('\\u{49f}', ['\\u{49e}', '\\0', '\\0']), ('\\u{4a1}', ['\\u{4a0}',\n        '\\0', '\\0']), ('\\u{4a3}', ['\\u{4a2}', '\\0', '\\0']), ('\\u{4a5}', ['\\u{4a4}', '\\0', '\\0']),\n        ('\\u{4a7}', ['\\u{4a6}', '\\0', '\\0']), ('\\u{4a9}', ['\\u{4a8}', '\\0', '\\0']), ('\\u{4ab}',\n        ['\\u{4aa}', '\\0', '\\0']), ('\\u{4ad}', ['\\u{4ac}', '\\0', '\\0']), ('\\u{4af}', ['\\u{4ae}',\n        '\\0', '\\0']), ('\\u{4b1}', ['\\u{4b0}', '\\0', '\\0']), ('\\u{4b3}', ['\\u{4b2}', '\\0', '\\0']),\n        ('\\u{4b5}', ['\\u{4b4}', '\\0', '\\0']), ('\\u{4b7}', ['\\u{4b6}', '\\0', '\\0']), ('\\u{4b9}',\n        ['\\u{4b8}', '\\0', '\\0']), ('\\u{4bb}', ['\\u{4ba}', '\\0', '\\0']), ('\\u{4bd}', ['\\u{4bc}',\n        '\\0', '\\0']), ('\\u{4bf}', ['\\u{4be}', '\\0', '\\0']), ('\\u{4c2}', ['\\u{4c1}', '\\0', '\\0']),\n        ('\\u{4c4}', ['\\u{4c3}', '\\0', '\\0']), ('\\u{4c6}', ['\\u{4c5}', '\\0', '\\0']), ('\\u{4c8}',\n        ['\\u{4c7}', '\\0', '\\0']), ('\\u{4ca}', ['\\u{4c9}', '\\0', '\\0']), ('\\u{4cc}', ['\\u{4cb}',\n        '\\0', '\\0']), ('\\u{4ce}', ['\\u{4cd}', '\\0', '\\0']), ('\\u{4cf}', ['\\u{4c0}', '\\0', '\\0']),\n        ('\\u{4d1}', ['\\u{4d0}', '\\0', '\\0']), ('\\u{4d3}', ['\\u{4d2}', '\\0', '\\0']), ('\\u{4d5}',\n        ['\\u{4d4}', '\\0', '\\0']), ('\\u{4d7}', ['\\u{4d6}', '\\0', '\\0']), ('\\u{4d9}', ['\\u{4d8}',\n        '\\0', '\\0']), ('\\u{4db}', ['\\u{4da}', '\\0', '\\0']), ('\\u{4dd}', ['\\u{4dc}', '\\0', '\\0']),\n        ('\\u{4df}', ['\\u{4de}', '\\0', '\\0']), ('\\u{4e1}', ['\\u{4e0}', '\\0', '\\0']), ('\\u{4e3}',\n        ['\\u{4e2}', '\\0', '\\0']), ('\\u{4e5}', ['\\u{4e4}', '\\0', '\\0']), ('\\u{4e7}', ['\\u{4e6}',\n        '\\0', '\\0']), ('\\u{4e9}', ['\\u{4e8}', '\\0', '\\0']), ('\\u{4eb}', ['\\u{4ea}', '\\0', '\\0']),\n        ('\\u{4ed}', ['\\u{4ec}', '\\0', '\\0']), ('\\u{4ef}', ['\\u{4ee}', '\\0', '\\0']), ('\\u{4f1}',\n        ['\\u{4f0}', '\\0', '\\0']), ('\\u{4f3}', ['\\u{4f2}', '\\0', '\\0']), ('\\u{4f5}', ['\\u{4f4}',\n        '\\0', '\\0']), ('\\u{4f7}', ['\\u{4f6}', '\\0', '\\0']), ('\\u{4f9}', ['\\u{4f8}', '\\0', '\\0']),\n        ('\\u{4fb}', ['\\u{4fa}', '\\0', '\\0']), ('\\u{4fd}', ['\\u{4fc}', '\\0', '\\0']), ('\\u{4ff}',\n        ['\\u{4fe}', '\\0', '\\0']), ('\\u{501}', ['\\u{500}', '\\0', '\\0']), ('\\u{503}', ['\\u{502}',\n        '\\0', '\\0']), ('\\u{505}', ['\\u{504}', '\\0', '\\0']), ('\\u{507}', ['\\u{506}', '\\0', '\\0']),\n        ('\\u{509}', ['\\u{508}', '\\0', '\\0']), ('\\u{50b}', ['\\u{50a}', '\\0', '\\0']), ('\\u{50d}',\n        ['\\u{50c}', '\\0', '\\0']), ('\\u{50f}', ['\\u{50e}', '\\0', '\\0']), ('\\u{511}', ['\\u{510}',\n        '\\0', '\\0']), ('\\u{513}', ['\\u{512}', '\\0', '\\0']), ('\\u{515}', ['\\u{514}', '\\0', '\\0']),\n        ('\\u{517}', ['\\u{516}', '\\0', '\\0']), ('\\u{519}', ['\\u{518}', '\\0', '\\0']), ('\\u{51b}',\n        ['\\u{51a}', '\\0', '\\0']), ('\\u{51d}', ['\\u{51c}', '\\0', '\\0']), ('\\u{51f}', ['\\u{51e}',\n        '\\0', '\\0']), ('\\u{521}', ['\\u{520}', '\\0', '\\0']), ('\\u{523}', ['\\u{522}', '\\0', '\\0']),\n        ('\\u{525}', ['\\u{524}', '\\0', '\\0']), ('\\u{527}', ['\\u{526}', '\\0', '\\0']), ('\\u{529}',\n        ['\\u{528}', '\\0', '\\0']), ('\\u{52b}', ['\\u{52a}', '\\0', '\\0']), ('\\u{52d}', ['\\u{52c}',\n        '\\0', '\\0']), ('\\u{52f}', ['\\u{52e}', '\\0', '\\0']), ('\\u{561}', ['\\u{531}', '\\0', '\\0']),\n        ('\\u{562}', ['\\u{532}', '\\0', '\\0']), ('\\u{563}', ['\\u{533}', '\\0', '\\0']), ('\\u{564}',\n        ['\\u{534}', '\\0', '\\0']), ('\\u{565}', ['\\u{535}', '\\0', '\\0']), ('\\u{566}', ['\\u{536}',\n        '\\0', '\\0']), ('\\u{567}', ['\\u{537}', '\\0', '\\0']), ('\\u{568}', ['\\u{538}', '\\0', '\\0']),\n        ('\\u{569}', ['\\u{539}', '\\0', '\\0']), ('\\u{56a}', ['\\u{53a}', '\\0', '\\0']), ('\\u{56b}',\n        ['\\u{53b}', '\\0', '\\0']), ('\\u{56c}', ['\\u{53c}', '\\0', '\\0']), ('\\u{56d}', ['\\u{53d}',\n        '\\0', '\\0']), ('\\u{56e}', ['\\u{53e}', '\\0', '\\0']), ('\\u{56f}', ['\\u{53f}', '\\0', '\\0']),\n        ('\\u{570}', ['\\u{540}', '\\0', '\\0']), ('\\u{571}', ['\\u{541}', '\\0', '\\0']), ('\\u{572}',\n        ['\\u{542}', '\\0', '\\0']), ('\\u{573}', ['\\u{543}', '\\0', '\\0']), ('\\u{574}', ['\\u{544}',\n        '\\0', '\\0']), ('\\u{575}', ['\\u{545}', '\\0', '\\0']), ('\\u{576}', ['\\u{546}', '\\0', '\\0']),\n        ('\\u{577}', ['\\u{547}', '\\0', '\\0']), ('\\u{578}', ['\\u{548}', '\\0', '\\0']), ('\\u{579}',\n        ['\\u{549}', '\\0', '\\0']), ('\\u{57a}', ['\\u{54a}', '\\0', '\\0']), ('\\u{57b}', ['\\u{54b}',\n        '\\0', '\\0']), ('\\u{57c}', ['\\u{54c}', '\\0', '\\0']), ('\\u{57d}', ['\\u{54d}', '\\0', '\\0']),\n        ('\\u{57e}', ['\\u{54e}', '\\0', '\\0']), ('\\u{57f}', ['\\u{54f}', '\\0', '\\0']), ('\\u{580}',\n        ['\\u{550}', '\\0', '\\0']), ('\\u{581}', ['\\u{551}', '\\0', '\\0']), ('\\u{582}', ['\\u{552}',\n        '\\0', '\\0']), ('\\u{583}', ['\\u{553}', '\\0', '\\0']), ('\\u{584}', ['\\u{554}', '\\0', '\\0']),\n        ('\\u{585}', ['\\u{555}', '\\0', '\\0']), ('\\u{586}', ['\\u{556}', '\\0', '\\0']), ('\\u{587}',\n        ['\\u{535}', '\\u{552}', '\\0']), ('\\u{13f8}', ['\\u{13f0}', '\\0', '\\0']), ('\\u{13f9}',\n        ['\\u{13f1}', '\\0', '\\0']), ('\\u{13fa}', ['\\u{13f2}', '\\0', '\\0']), ('\\u{13fb}', ['\\u{13f3}',\n        '\\0', '\\0']), ('\\u{13fc}', ['\\u{13f4}', '\\0', '\\0']), ('\\u{13fd}', ['\\u{13f5}', '\\0',\n        '\\0']), ('\\u{1c80}', ['\\u{412}', '\\0', '\\0']), ('\\u{1c81}', ['\\u{414}', '\\0', '\\0']),\n        ('\\u{1c82}', ['\\u{41e}', '\\0', '\\0']), ('\\u{1c83}', ['\\u{421}', '\\0', '\\0']), ('\\u{1c84}',\n        ['\\u{422}', '\\0', '\\0']), ('\\u{1c85}', ['\\u{422}', '\\0', '\\0']), ('\\u{1c86}', ['\\u{42a}',\n        '\\0', '\\0']), ('\\u{1c87}', ['\\u{462}', '\\0', '\\0']), ('\\u{1c88}', ['\\u{a64a}', '\\0', '\\0']),\n        ('\\u{1d79}', ['\\u{a77d}', '\\0', '\\0']), ('\\u{1d7d}', ['\\u{2c63}', '\\0', '\\0']), ('\\u{1e01}',\n        ['\\u{1e00}', '\\0', '\\0']), ('\\u{1e03}', ['\\u{1e02}', '\\0', '\\0']), ('\\u{1e05}', ['\\u{1e04}',\n        '\\0', '\\0']), ('\\u{1e07}', ['\\u{1e06}', '\\0', '\\0']), ('\\u{1e09}', ['\\u{1e08}', '\\0',\n        '\\0']), ('\\u{1e0b}', ['\\u{1e0a}', '\\0', '\\0']), ('\\u{1e0d}', ['\\u{1e0c}', '\\0', '\\0']),\n        ('\\u{1e0f}', ['\\u{1e0e}', '\\0', '\\0']), ('\\u{1e11}', ['\\u{1e10}', '\\0', '\\0']), ('\\u{1e13}',\n        ['\\u{1e12}', '\\0', '\\0']), ('\\u{1e15}', ['\\u{1e14}', '\\0', '\\0']), ('\\u{1e17}', ['\\u{1e16}',\n        '\\0', '\\0']), ('\\u{1e19}', ['\\u{1e18}', '\\0', '\\0']), ('\\u{1e1b}', ['\\u{1e1a}', '\\0',\n        '\\0']), ('\\u{1e1d}', ['\\u{1e1c}', '\\0', '\\0']), ('\\u{1e1f}', ['\\u{1e1e}', '\\0', '\\0']),\n        ('\\u{1e21}', ['\\u{1e20}', '\\0', '\\0']), ('\\u{1e23}', ['\\u{1e22}', '\\0', '\\0']), ('\\u{1e25}',\n        ['\\u{1e24}', '\\0', '\\0']), ('\\u{1e27}', ['\\u{1e26}', '\\0', '\\0']), ('\\u{1e29}', ['\\u{1e28}',\n        '\\0', '\\0']), ('\\u{1e2b}', ['\\u{1e2a}', '\\0', '\\0']), ('\\u{1e2d}', ['\\u{1e2c}', '\\0',\n        '\\0']), ('\\u{1e2f}', ['\\u{1e2e}', '\\0', '\\0']), ('\\u{1e31}', ['\\u{1e30}', '\\0', '\\0']),\n        ('\\u{1e33}', ['\\u{1e32}', '\\0', '\\0']), ('\\u{1e35}', ['\\u{1e34}', '\\0', '\\0']), ('\\u{1e37}',\n        ['\\u{1e36}', '\\0', '\\0']), ('\\u{1e39}', ['\\u{1e38}', '\\0', '\\0']), ('\\u{1e3b}', ['\\u{1e3a}',\n        '\\0', '\\0']), ('\\u{1e3d}', ['\\u{1e3c}', '\\0', '\\0']), ('\\u{1e3f}', ['\\u{1e3e}', '\\0',\n        '\\0']), ('\\u{1e41}', ['\\u{1e40}', '\\0', '\\0']), ('\\u{1e43}', ['\\u{1e42}', '\\0', '\\0']),\n        ('\\u{1e45}', ['\\u{1e44}', '\\0', '\\0']), ('\\u{1e47}', ['\\u{1e46}', '\\0', '\\0']), ('\\u{1e49}',\n        ['\\u{1e48}', '\\0', '\\0']), ('\\u{1e4b}', ['\\u{1e4a}', '\\0', '\\0']), ('\\u{1e4d}', ['\\u{1e4c}',\n        '\\0', '\\0']), ('\\u{1e4f}', ['\\u{1e4e}', '\\0', '\\0']), ('\\u{1e51}', ['\\u{1e50}', '\\0',\n        '\\0']), ('\\u{1e53}', ['\\u{1e52}', '\\0', '\\0']), ('\\u{1e55}', ['\\u{1e54}', '\\0', '\\0']),\n        ('\\u{1e57}', ['\\u{1e56}', '\\0', '\\0']), ('\\u{1e59}', ['\\u{1e58}', '\\0', '\\0']), ('\\u{1e5b}',\n        ['\\u{1e5a}', '\\0', '\\0']), ('\\u{1e5d}', ['\\u{1e5c}', '\\0', '\\0']), ('\\u{1e5f}', ['\\u{1e5e}',\n        '\\0', '\\0']), ('\\u{1e61}', ['\\u{1e60}', '\\0', '\\0']), ('\\u{1e63}', ['\\u{1e62}', '\\0',\n        '\\0']), ('\\u{1e65}', ['\\u{1e64}', '\\0', '\\0']), ('\\u{1e67}', ['\\u{1e66}', '\\0', '\\0']),\n        ('\\u{1e69}', ['\\u{1e68}', '\\0', '\\0']), ('\\u{1e6b}', ['\\u{1e6a}', '\\0', '\\0']), ('\\u{1e6d}',\n        ['\\u{1e6c}', '\\0', '\\0']), ('\\u{1e6f}', ['\\u{1e6e}', '\\0', '\\0']), ('\\u{1e71}', ['\\u{1e70}',\n        '\\0', '\\0']), ('\\u{1e73}', ['\\u{1e72}', '\\0', '\\0']), ('\\u{1e75}', ['\\u{1e74}', '\\0',\n        '\\0']), ('\\u{1e77}', ['\\u{1e76}', '\\0', '\\0']), ('\\u{1e79}', ['\\u{1e78}', '\\0', '\\0']),\n        ('\\u{1e7b}', ['\\u{1e7a}', '\\0', '\\0']), ('\\u{1e7d}', ['\\u{1e7c}', '\\0', '\\0']), ('\\u{1e7f}',\n        ['\\u{1e7e}', '\\0', '\\0']), ('\\u{1e81}', ['\\u{1e80}', '\\0', '\\0']), ('\\u{1e83}', ['\\u{1e82}',\n        '\\0', '\\0']), ('\\u{1e85}', ['\\u{1e84}', '\\0', '\\0']), ('\\u{1e87}', ['\\u{1e86}', '\\0',\n        '\\0']), ('\\u{1e89}', ['\\u{1e88}', '\\0', '\\0']), ('\\u{1e8b}', ['\\u{1e8a}', '\\0', '\\0']),\n        ('\\u{1e8d}', ['\\u{1e8c}', '\\0', '\\0']), ('\\u{1e8f}', ['\\u{1e8e}', '\\0', '\\0']), ('\\u{1e91}',\n        ['\\u{1e90}', '\\0', '\\0']), ('\\u{1e93}', ['\\u{1e92}', '\\0', '\\0']), ('\\u{1e95}', ['\\u{1e94}',\n        '\\0', '\\0']), ('\\u{1e96}', ['\\u{48}', '\\u{331}', '\\0']), ('\\u{1e97}', ['\\u{54}', '\\u{308}',\n        '\\0']), ('\\u{1e98}', ['\\u{57}', '\\u{30a}', '\\0']), ('\\u{1e99}', ['\\u{59}', '\\u{30a}',\n        '\\0']), ('\\u{1e9a}', ['\\u{41}', '\\u{2be}', '\\0']), ('\\u{1e9b}', ['\\u{1e60}', '\\0', '\\0']),\n        ('\\u{1ea1}', ['\\u{1ea0}', '\\0', '\\0']), ('\\u{1ea3}', ['\\u{1ea2}', '\\0', '\\0']), ('\\u{1ea5}',\n        ['\\u{1ea4}', '\\0', '\\0']), ('\\u{1ea7}', ['\\u{1ea6}', '\\0', '\\0']), ('\\u{1ea9}', ['\\u{1ea8}',\n        '\\0', '\\0']), ('\\u{1eab}', ['\\u{1eaa}', '\\0', '\\0']), ('\\u{1ead}', ['\\u{1eac}', '\\0',\n        '\\0']), ('\\u{1eaf}', ['\\u{1eae}', '\\0', '\\0']), ('\\u{1eb1}', ['\\u{1eb0}', '\\0', '\\0']),\n        ('\\u{1eb3}', ['\\u{1eb2}', '\\0', '\\0']), ('\\u{1eb5}', ['\\u{1eb4}', '\\0', '\\0']), ('\\u{1eb7}',\n        ['\\u{1eb6}', '\\0', '\\0']), ('\\u{1eb9}', ['\\u{1eb8}', '\\0', '\\0']), ('\\u{1ebb}', ['\\u{1eba}',\n        '\\0', '\\0']), ('\\u{1ebd}', ['\\u{1ebc}', '\\0', '\\0']), ('\\u{1ebf}', ['\\u{1ebe}', '\\0',\n        '\\0']), ('\\u{1ec1}', ['\\u{1ec0}', '\\0', '\\0']), ('\\u{1ec3}', ['\\u{1ec2}', '\\0', '\\0']),\n        ('\\u{1ec5}', ['\\u{1ec4}', '\\0', '\\0']), ('\\u{1ec7}', ['\\u{1ec6}', '\\0', '\\0']), ('\\u{1ec9}',\n        ['\\u{1ec8}', '\\0', '\\0']), ('\\u{1ecb}', ['\\u{1eca}', '\\0', '\\0']), ('\\u{1ecd}', ['\\u{1ecc}',\n        '\\0', '\\0']), ('\\u{1ecf}', ['\\u{1ece}', '\\0', '\\0']), ('\\u{1ed1}', ['\\u{1ed0}', '\\0',\n        '\\0']), ('\\u{1ed3}', ['\\u{1ed2}', '\\0', '\\0']), ('\\u{1ed5}', ['\\u{1ed4}', '\\0', '\\0']),\n        ('\\u{1ed7}', ['\\u{1ed6}', '\\0', '\\0']), ('\\u{1ed9}', ['\\u{1ed8}', '\\0', '\\0']), ('\\u{1edb}',\n        ['\\u{1eda}', '\\0', '\\0']), ('\\u{1edd}', ['\\u{1edc}', '\\0', '\\0']), ('\\u{1edf}', ['\\u{1ede}',\n        '\\0', '\\0']), ('\\u{1ee1}', ['\\u{1ee0}', '\\0', '\\0']), ('\\u{1ee3}', ['\\u{1ee2}', '\\0',\n        '\\0']), ('\\u{1ee5}', ['\\u{1ee4}', '\\0', '\\0']), ('\\u{1ee7}', ['\\u{1ee6}', '\\0', '\\0']),\n        ('\\u{1ee9}', ['\\u{1ee8}', '\\0', '\\0']), ('\\u{1eeb}', ['\\u{1eea}', '\\0', '\\0']), ('\\u{1eed}',\n        ['\\u{1eec}', '\\0', '\\0']), ('\\u{1eef}', ['\\u{1eee}', '\\0', '\\0']), ('\\u{1ef1}', ['\\u{1ef0}',\n        '\\0', '\\0']), ('\\u{1ef3}', ['\\u{1ef2}', '\\0', '\\0']), ('\\u{1ef5}', ['\\u{1ef4}', '\\0',\n        '\\0']), ('\\u{1ef7}', ['\\u{1ef6}', '\\0', '\\0']), ('\\u{1ef9}', ['\\u{1ef8}', '\\0', '\\0']),\n        ('\\u{1efb}', ['\\u{1efa}', '\\0', '\\0']), ('\\u{1efd}', ['\\u{1efc}', '\\0', '\\0']), ('\\u{1eff}',\n        ['\\u{1efe}', '\\0', '\\0']), ('\\u{1f00}', ['\\u{1f08}', '\\0', '\\0']), ('\\u{1f01}', ['\\u{1f09}',\n        '\\0', '\\0']), ('\\u{1f02}', ['\\u{1f0a}', '\\0', '\\0']), ('\\u{1f03}', ['\\u{1f0b}', '\\0',\n        '\\0']), ('\\u{1f04}', ['\\u{1f0c}', '\\0', '\\0']), ('\\u{1f05}', ['\\u{1f0d}', '\\0', '\\0']),\n        ('\\u{1f06}', ['\\u{1f0e}', '\\0', '\\0']), ('\\u{1f07}', ['\\u{1f0f}', '\\0', '\\0']), ('\\u{1f10}',\n        ['\\u{1f18}', '\\0', '\\0']), ('\\u{1f11}', ['\\u{1f19}', '\\0', '\\0']), ('\\u{1f12}', ['\\u{1f1a}',\n        '\\0', '\\0']), ('\\u{1f13}', ['\\u{1f1b}', '\\0', '\\0']), ('\\u{1f14}', ['\\u{1f1c}', '\\0',\n        '\\0']), ('\\u{1f15}', ['\\u{1f1d}', '\\0', '\\0']), ('\\u{1f20}', ['\\u{1f28}', '\\0', '\\0']),\n        ('\\u{1f21}', ['\\u{1f29}', '\\0', '\\0']), ('\\u{1f22}', ['\\u{1f2a}', '\\0', '\\0']), ('\\u{1f23}',\n        ['\\u{1f2b}', '\\0', '\\0']), ('\\u{1f24}', ['\\u{1f2c}', '\\0', '\\0']), ('\\u{1f25}', ['\\u{1f2d}',\n        '\\0', '\\0']), ('\\u{1f26}', ['\\u{1f2e}', '\\0', '\\0']), ('\\u{1f27}', ['\\u{1f2f}', '\\0',\n        '\\0']), ('\\u{1f30}', ['\\u{1f38}', '\\0', '\\0']), ('\\u{1f31}', ['\\u{1f39}', '\\0', '\\0']),\n        ('\\u{1f32}', ['\\u{1f3a}', '\\0', '\\0']), ('\\u{1f33}', ['\\u{1f3b}', '\\0', '\\0']), ('\\u{1f34}',\n        ['\\u{1f3c}', '\\0', '\\0']), ('\\u{1f35}', ['\\u{1f3d}', '\\0', '\\0']), ('\\u{1f36}', ['\\u{1f3e}',\n        '\\0', '\\0']), ('\\u{1f37}', ['\\u{1f3f}', '\\0', '\\0']), ('\\u{1f40}', ['\\u{1f48}', '\\0',\n        '\\0']), ('\\u{1f41}', ['\\u{1f49}', '\\0', '\\0']), ('\\u{1f42}', ['\\u{1f4a}', '\\0', '\\0']),\n        ('\\u{1f43}', ['\\u{1f4b}', '\\0', '\\0']), ('\\u{1f44}', ['\\u{1f4c}', '\\0', '\\0']), ('\\u{1f45}',\n        ['\\u{1f4d}', '\\0', '\\0']), ('\\u{1f50}', ['\\u{3a5}', '\\u{313}', '\\0']), ('\\u{1f51}',\n        ['\\u{1f59}', '\\0', '\\0']), ('\\u{1f52}', ['\\u{3a5}', '\\u{313}', '\\u{300}']), ('\\u{1f53}',\n        ['\\u{1f5b}', '\\0', '\\0']), ('\\u{1f54}', ['\\u{3a5}', '\\u{313}', '\\u{301}']), ('\\u{1f55}',\n        ['\\u{1f5d}', '\\0', '\\0']), ('\\u{1f56}', ['\\u{3a5}', '\\u{313}', '\\u{342}']), ('\\u{1f57}',\n        ['\\u{1f5f}', '\\0', '\\0']), ('\\u{1f60}', ['\\u{1f68}', '\\0', '\\0']), ('\\u{1f61}', ['\\u{1f69}',\n        '\\0', '\\0']), ('\\u{1f62}', ['\\u{1f6a}', '\\0', '\\0']), ('\\u{1f63}', ['\\u{1f6b}', '\\0',\n        '\\0']), ('\\u{1f64}', ['\\u{1f6c}', '\\0', '\\0']), ('\\u{1f65}', ['\\u{1f6d}', '\\0', '\\0']),\n        ('\\u{1f66}', ['\\u{1f6e}', '\\0', '\\0']), ('\\u{1f67}', ['\\u{1f6f}', '\\0', '\\0']), ('\\u{1f70}',\n        ['\\u{1fba}', '\\0', '\\0']), ('\\u{1f71}', ['\\u{1fbb}', '\\0', '\\0']), ('\\u{1f72}', ['\\u{1fc8}',\n        '\\0', '\\0']), ('\\u{1f73}', ['\\u{1fc9}', '\\0', '\\0']), ('\\u{1f74}', ['\\u{1fca}', '\\0',\n        '\\0']), ('\\u{1f75}', ['\\u{1fcb}', '\\0', '\\0']), ('\\u{1f76}', ['\\u{1fda}', '\\0', '\\0']),\n        ('\\u{1f77}', ['\\u{1fdb}', '\\0', '\\0']), ('\\u{1f78}', ['\\u{1ff8}', '\\0', '\\0']), ('\\u{1f79}',\n        ['\\u{1ff9}', '\\0', '\\0']), ('\\u{1f7a}', ['\\u{1fea}', '\\0', '\\0']), ('\\u{1f7b}', ['\\u{1feb}',\n        '\\0', '\\0']), ('\\u{1f7c}', ['\\u{1ffa}', '\\0', '\\0']), ('\\u{1f7d}', ['\\u{1ffb}', '\\0',\n        '\\0']), ('\\u{1f80}', ['\\u{1f08}', '\\u{399}', '\\0']), ('\\u{1f81}', ['\\u{1f09}', '\\u{399}',\n        '\\0']), ('\\u{1f82}', ['\\u{1f0a}', '\\u{399}', '\\0']), ('\\u{1f83}', ['\\u{1f0b}', '\\u{399}',\n        '\\0']), ('\\u{1f84}', ['\\u{1f0c}', '\\u{399}', '\\0']), ('\\u{1f85}', ['\\u{1f0d}', '\\u{399}',\n        '\\0']), ('\\u{1f86}', ['\\u{1f0e}', '\\u{399}', '\\0']), ('\\u{1f87}', ['\\u{1f0f}', '\\u{399}',\n        '\\0']), ('\\u{1f88}', ['\\u{1f08}', '\\u{399}', '\\0']), ('\\u{1f89}', ['\\u{1f09}', '\\u{399}',\n        '\\0']), ('\\u{1f8a}', ['\\u{1f0a}', '\\u{399}', '\\0']), ('\\u{1f8b}', ['\\u{1f0b}', '\\u{399}',\n        '\\0']), ('\\u{1f8c}', ['\\u{1f0c}', '\\u{399}', '\\0']), ('\\u{1f8d}', ['\\u{1f0d}', '\\u{399}',\n        '\\0']), ('\\u{1f8e}', ['\\u{1f0e}', '\\u{399}', '\\0']), ('\\u{1f8f}', ['\\u{1f0f}', '\\u{399}',\n        '\\0']), ('\\u{1f90}', ['\\u{1f28}', '\\u{399}', '\\0']), ('\\u{1f91}', ['\\u{1f29}', '\\u{399}',\n        '\\0']), ('\\u{1f92}', ['\\u{1f2a}', '\\u{399}', '\\0']), ('\\u{1f93}', ['\\u{1f2b}', '\\u{399}',\n        '\\0']), ('\\u{1f94}', ['\\u{1f2c}', '\\u{399}', '\\0']), ('\\u{1f95}', ['\\u{1f2d}', '\\u{399}',\n        '\\0']), ('\\u{1f96}', ['\\u{1f2e}', '\\u{399}', '\\0']), ('\\u{1f97}', ['\\u{1f2f}', '\\u{399}',\n        '\\0']), ('\\u{1f98}', ['\\u{1f28}', '\\u{399}', '\\0']), ('\\u{1f99}', ['\\u{1f29}', '\\u{399}',\n        '\\0']), ('\\u{1f9a}', ['\\u{1f2a}', '\\u{399}', '\\0']), ('\\u{1f9b}', ['\\u{1f2b}', '\\u{399}',\n        '\\0']), ('\\u{1f9c}', ['\\u{1f2c}', '\\u{399}', '\\0']), ('\\u{1f9d}', ['\\u{1f2d}', '\\u{399}',\n        '\\0']), ('\\u{1f9e}', ['\\u{1f2e}', '\\u{399}', '\\0']), ('\\u{1f9f}', ['\\u{1f2f}', '\\u{399}',\n        '\\0']), ('\\u{1fa0}', ['\\u{1f68}', '\\u{399}', '\\0']), ('\\u{1fa1}', ['\\u{1f69}', '\\u{399}',\n        '\\0']), ('\\u{1fa2}', ['\\u{1f6a}', '\\u{399}', '\\0']), ('\\u{1fa3}', ['\\u{1f6b}', '\\u{399}',\n        '\\0']), ('\\u{1fa4}', ['\\u{1f6c}', '\\u{399}', '\\0']), ('\\u{1fa5}', ['\\u{1f6d}', '\\u{399}',\n        '\\0']), ('\\u{1fa6}', ['\\u{1f6e}', '\\u{399}', '\\0']), ('\\u{1fa7}', ['\\u{1f6f}', '\\u{399}',\n        '\\0']), ('\\u{1fa8}', ['\\u{1f68}', '\\u{399}', '\\0']), ('\\u{1fa9}', ['\\u{1f69}', '\\u{399}',\n        '\\0']), ('\\u{1faa}', ['\\u{1f6a}', '\\u{399}', '\\0']), ('\\u{1fab}', ['\\u{1f6b}', '\\u{399}',\n        '\\0']), ('\\u{1fac}', ['\\u{1f6c}', '\\u{399}', '\\0']), ('\\u{1fad}', ['\\u{1f6d}', '\\u{399}',\n        '\\0']), ('\\u{1fae}', ['\\u{1f6e}', '\\u{399}', '\\0']), ('\\u{1faf}', ['\\u{1f6f}', '\\u{399}',\n        '\\0']), ('\\u{1fb0}', ['\\u{1fb8}', '\\0', '\\0']), ('\\u{1fb1}', ['\\u{1fb9}', '\\0', '\\0']),\n        ('\\u{1fb2}', ['\\u{1fba}', '\\u{399}', '\\0']), ('\\u{1fb3}', ['\\u{391}', '\\u{399}', '\\0']),\n        ('\\u{1fb4}', ['\\u{386}', '\\u{399}', '\\0']), ('\\u{1fb6}', ['\\u{391}', '\\u{342}', '\\0']),\n        ('\\u{1fb7}', ['\\u{391}', '\\u{342}', '\\u{399}']), ('\\u{1fbc}', ['\\u{391}', '\\u{399}', '\\0']),\n        ('\\u{1fbe}', ['\\u{399}', '\\0', '\\0']), ('\\u{1fc2}', ['\\u{1fca}', '\\u{399}', '\\0']),\n        ('\\u{1fc3}', ['\\u{397}', '\\u{399}', '\\0']), ('\\u{1fc4}', ['\\u{389}', '\\u{399}', '\\0']),\n        ('\\u{1fc6}', ['\\u{397}', '\\u{342}', '\\0']), ('\\u{1fc7}', ['\\u{397}', '\\u{342}', '\\u{399}']),\n        ('\\u{1fcc}', ['\\u{397}', '\\u{399}', '\\0']), ('\\u{1fd0}', ['\\u{1fd8}', '\\0', '\\0']),\n        ('\\u{1fd1}', ['\\u{1fd9}', '\\0', '\\0']), ('\\u{1fd2}', ['\\u{399}', '\\u{308}', '\\u{300}']),\n        ('\\u{1fd3}', ['\\u{399}', '\\u{308}', '\\u{301}']), ('\\u{1fd6}', ['\\u{399}', '\\u{342}', '\\0']),\n        ('\\u{1fd7}', ['\\u{399}', '\\u{308}', '\\u{342}']), ('\\u{1fe0}', ['\\u{1fe8}', '\\0', '\\0']),\n        ('\\u{1fe1}', ['\\u{1fe9}', '\\0', '\\0']), ('\\u{1fe2}', ['\\u{3a5}', '\\u{308}', '\\u{300}']),\n        ('\\u{1fe3}', ['\\u{3a5}', '\\u{308}', '\\u{301}']), ('\\u{1fe4}', ['\\u{3a1}', '\\u{313}', '\\0']),\n        ('\\u{1fe5}', ['\\u{1fec}', '\\0', '\\0']), ('\\u{1fe6}', ['\\u{3a5}', '\\u{342}', '\\0']),\n        ('\\u{1fe7}', ['\\u{3a5}', '\\u{308}', '\\u{342}']), ('\\u{1ff2}', ['\\u{1ffa}', '\\u{399}',\n        '\\0']), ('\\u{1ff3}', ['\\u{3a9}', '\\u{399}', '\\0']), ('\\u{1ff4}', ['\\u{38f}', '\\u{399}',\n        '\\0']), ('\\u{1ff6}', ['\\u{3a9}', '\\u{342}', '\\0']), ('\\u{1ff7}', ['\\u{3a9}', '\\u{342}',\n        '\\u{399}']), ('\\u{1ffc}', ['\\u{3a9}', '\\u{399}', '\\0']), ('\\u{214e}', ['\\u{2132}', '\\0',\n        '\\0']), ('\\u{2170}', ['\\u{2160}', '\\0', '\\0']), ('\\u{2171}', ['\\u{2161}', '\\0', '\\0']),\n        ('\\u{2172}', ['\\u{2162}', '\\0', '\\0']), ('\\u{2173}', ['\\u{2163}', '\\0', '\\0']), ('\\u{2174}',\n        ['\\u{2164}', '\\0', '\\0']), ('\\u{2175}', ['\\u{2165}', '\\0', '\\0']), ('\\u{2176}', ['\\u{2166}',\n        '\\0', '\\0']), ('\\u{2177}', ['\\u{2167}', '\\0', '\\0']), ('\\u{2178}', ['\\u{2168}', '\\0',\n        '\\0']), ('\\u{2179}', ['\\u{2169}', '\\0', '\\0']), ('\\u{217a}', ['\\u{216a}', '\\0', '\\0']),\n        ('\\u{217b}', ['\\u{216b}', '\\0', '\\0']), ('\\u{217c}', ['\\u{216c}', '\\0', '\\0']), ('\\u{217d}',\n        ['\\u{216d}', '\\0', '\\0']), ('\\u{217e}', ['\\u{216e}', '\\0', '\\0']), ('\\u{217f}', ['\\u{216f}',\n        '\\0', '\\0']), ('\\u{2184}', ['\\u{2183}', '\\0', '\\0']), ('\\u{24d0}', ['\\u{24b6}', '\\0',\n        '\\0']), ('\\u{24d1}', ['\\u{24b7}', '\\0', '\\0']), ('\\u{24d2}', ['\\u{24b8}', '\\0', '\\0']),\n        ('\\u{24d3}', ['\\u{24b9}', '\\0', '\\0']), ('\\u{24d4}', ['\\u{24ba}', '\\0', '\\0']), ('\\u{24d5}',\n        ['\\u{24bb}', '\\0', '\\0']), ('\\u{24d6}', ['\\u{24bc}', '\\0', '\\0']), ('\\u{24d7}', ['\\u{24bd}',\n        '\\0', '\\0']), ('\\u{24d8}', ['\\u{24be}', '\\0', '\\0']), ('\\u{24d9}', ['\\u{24bf}', '\\0',\n        '\\0']), ('\\u{24da}', ['\\u{24c0}', '\\0', '\\0']), ('\\u{24db}', ['\\u{24c1}', '\\0', '\\0']),\n        ('\\u{24dc}', ['\\u{24c2}', '\\0', '\\0']), ('\\u{24dd}', ['\\u{24c3}', '\\0', '\\0']), ('\\u{24de}',\n        ['\\u{24c4}', '\\0', '\\0']), ('\\u{24df}', ['\\u{24c5}', '\\0', '\\0']), ('\\u{24e0}', ['\\u{24c6}',\n        '\\0', '\\0']), ('\\u{24e1}', ['\\u{24c7}', '\\0', '\\0']), ('\\u{24e2}', ['\\u{24c8}', '\\0',\n        '\\0']), ('\\u{24e3}', ['\\u{24c9}', '\\0', '\\0']), ('\\u{24e4}', ['\\u{24ca}', '\\0', '\\0']),\n        ('\\u{24e5}', ['\\u{24cb}', '\\0', '\\0']), ('\\u{24e6}', ['\\u{24cc}', '\\0', '\\0']), ('\\u{24e7}',\n        ['\\u{24cd}', '\\0', '\\0']), ('\\u{24e8}', ['\\u{24ce}', '\\0', '\\0']), ('\\u{24e9}', ['\\u{24cf}',\n        '\\0', '\\0']), ('\\u{2c30}', ['\\u{2c00}', '\\0', '\\0']), ('\\u{2c31}', ['\\u{2c01}', '\\0',\n        '\\0']), ('\\u{2c32}', ['\\u{2c02}', '\\0', '\\0']), ('\\u{2c33}', ['\\u{2c03}', '\\0', '\\0']),\n        ('\\u{2c34}', ['\\u{2c04}', '\\0', '\\0']), ('\\u{2c35}', ['\\u{2c05}', '\\0', '\\0']), ('\\u{2c36}',\n        ['\\u{2c06}', '\\0', '\\0']), ('\\u{2c37}', ['\\u{2c07}', '\\0', '\\0']), ('\\u{2c38}', ['\\u{2c08}',\n        '\\0', '\\0']), ('\\u{2c39}', ['\\u{2c09}', '\\0', '\\0']), ('\\u{2c3a}', ['\\u{2c0a}', '\\0',\n        '\\0']), ('\\u{2c3b}', ['\\u{2c0b}', '\\0', '\\0']), ('\\u{2c3c}', ['\\u{2c0c}', '\\0', '\\0']),\n        ('\\u{2c3d}', ['\\u{2c0d}', '\\0', '\\0']), ('\\u{2c3e}', ['\\u{2c0e}', '\\0', '\\0']), ('\\u{2c3f}',\n        ['\\u{2c0f}', '\\0', '\\0']), ('\\u{2c40}', ['\\u{2c10}', '\\0', '\\0']), ('\\u{2c41}', ['\\u{2c11}',\n        '\\0', '\\0']), ('\\u{2c42}', ['\\u{2c12}', '\\0', '\\0']), ('\\u{2c43}', ['\\u{2c13}', '\\0',\n        '\\0']), ('\\u{2c44}', ['\\u{2c14}', '\\0', '\\0']), ('\\u{2c45}', ['\\u{2c15}', '\\0', '\\0']),\n        ('\\u{2c46}', ['\\u{2c16}', '\\0', '\\0']), ('\\u{2c47}', ['\\u{2c17}', '\\0', '\\0']), ('\\u{2c48}',\n        ['\\u{2c18}', '\\0', '\\0']), ('\\u{2c49}', ['\\u{2c19}', '\\0', '\\0']), ('\\u{2c4a}', ['\\u{2c1a}',\n        '\\0', '\\0']), ('\\u{2c4b}', ['\\u{2c1b}', '\\0', '\\0']), ('\\u{2c4c}', ['\\u{2c1c}', '\\0',\n        '\\0']), ('\\u{2c4d}', ['\\u{2c1d}', '\\0', '\\0']), ('\\u{2c4e}', ['\\u{2c1e}', '\\0', '\\0']),\n        ('\\u{2c4f}', ['\\u{2c1f}', '\\0', '\\0']), ('\\u{2c50}', ['\\u{2c20}', '\\0', '\\0']), ('\\u{2c51}',\n        ['\\u{2c21}', '\\0', '\\0']), ('\\u{2c52}', ['\\u{2c22}', '\\0', '\\0']), ('\\u{2c53}', ['\\u{2c23}',\n        '\\0', '\\0']), ('\\u{2c54}', ['\\u{2c24}', '\\0', '\\0']), ('\\u{2c55}', ['\\u{2c25}', '\\0',\n        '\\0']), ('\\u{2c56}', ['\\u{2c26}', '\\0', '\\0']), ('\\u{2c57}', ['\\u{2c27}', '\\0', '\\0']),\n        ('\\u{2c58}', ['\\u{2c28}', '\\0', '\\0']), ('\\u{2c59}', ['\\u{2c29}', '\\0', '\\0']), ('\\u{2c5a}',\n        ['\\u{2c2a}', '\\0', '\\0']), ('\\u{2c5b}', ['\\u{2c2b}', '\\0', '\\0']), ('\\u{2c5c}', ['\\u{2c2c}',\n        '\\0', '\\0']), ('\\u{2c5d}', ['\\u{2c2d}', '\\0', '\\0']), ('\\u{2c5e}', ['\\u{2c2e}', '\\0',\n        '\\0']), ('\\u{2c61}', ['\\u{2c60}', '\\0', '\\0']), ('\\u{2c65}', ['\\u{23a}', '\\0', '\\0']),\n        ('\\u{2c66}', ['\\u{23e}', '\\0', '\\0']), ('\\u{2c68}', ['\\u{2c67}', '\\0', '\\0']), ('\\u{2c6a}',\n        ['\\u{2c69}', '\\0', '\\0']), ('\\u{2c6c}', ['\\u{2c6b}', '\\0', '\\0']), ('\\u{2c73}', ['\\u{2c72}',\n        '\\0', '\\0']), ('\\u{2c76}', ['\\u{2c75}', '\\0', '\\0']), ('\\u{2c81}', ['\\u{2c80}', '\\0',\n        '\\0']), ('\\u{2c83}', ['\\u{2c82}', '\\0', '\\0']), ('\\u{2c85}', ['\\u{2c84}', '\\0', '\\0']),\n        ('\\u{2c87}', ['\\u{2c86}', '\\0', '\\0']), ('\\u{2c89}', ['\\u{2c88}', '\\0', '\\0']), ('\\u{2c8b}',\n        ['\\u{2c8a}', '\\0', '\\0']), ('\\u{2c8d}', ['\\u{2c8c}', '\\0', '\\0']), ('\\u{2c8f}', ['\\u{2c8e}',\n        '\\0', '\\0']), ('\\u{2c91}', ['\\u{2c90}', '\\0', '\\0']), ('\\u{2c93}', ['\\u{2c92}', '\\0',\n        '\\0']), ('\\u{2c95}', ['\\u{2c94}', '\\0', '\\0']), ('\\u{2c97}', ['\\u{2c96}', '\\0', '\\0']),\n        ('\\u{2c99}', ['\\u{2c98}', '\\0', '\\0']), ('\\u{2c9b}', ['\\u{2c9a}', '\\0', '\\0']), ('\\u{2c9d}',\n        ['\\u{2c9c}', '\\0', '\\0']), ('\\u{2c9f}', ['\\u{2c9e}', '\\0', '\\0']), ('\\u{2ca1}', ['\\u{2ca0}',\n        '\\0', '\\0']), ('\\u{2ca3}', ['\\u{2ca2}', '\\0', '\\0']), ('\\u{2ca5}', ['\\u{2ca4}', '\\0',\n        '\\0']), ('\\u{2ca7}', ['\\u{2ca6}', '\\0', '\\0']), ('\\u{2ca9}', ['\\u{2ca8}', '\\0', '\\0']),\n        ('\\u{2cab}', ['\\u{2caa}', '\\0', '\\0']), ('\\u{2cad}', ['\\u{2cac}', '\\0', '\\0']), ('\\u{2caf}',\n        ['\\u{2cae}', '\\0', '\\0']), ('\\u{2cb1}', ['\\u{2cb0}', '\\0', '\\0']), ('\\u{2cb3}', ['\\u{2cb2}',\n        '\\0', '\\0']), ('\\u{2cb5}', ['\\u{2cb4}', '\\0', '\\0']), ('\\u{2cb7}', ['\\u{2cb6}', '\\0',\n        '\\0']), ('\\u{2cb9}', ['\\u{2cb8}', '\\0', '\\0']), ('\\u{2cbb}', ['\\u{2cba}', '\\0', '\\0']),\n        ('\\u{2cbd}', ['\\u{2cbc}', '\\0', '\\0']), ('\\u{2cbf}', ['\\u{2cbe}', '\\0', '\\0']), ('\\u{2cc1}',\n        ['\\u{2cc0}', '\\0', '\\0']), ('\\u{2cc3}', ['\\u{2cc2}', '\\0', '\\0']), ('\\u{2cc5}', ['\\u{2cc4}',\n        '\\0', '\\0']), ('\\u{2cc7}', ['\\u{2cc6}', '\\0', '\\0']), ('\\u{2cc9}', ['\\u{2cc8}', '\\0',\n        '\\0']), ('\\u{2ccb}', ['\\u{2cca}', '\\0', '\\0']), ('\\u{2ccd}', ['\\u{2ccc}', '\\0', '\\0']),\n        ('\\u{2ccf}', ['\\u{2cce}', '\\0', '\\0']), ('\\u{2cd1}', ['\\u{2cd0}', '\\0', '\\0']), ('\\u{2cd3}',\n        ['\\u{2cd2}', '\\0', '\\0']), ('\\u{2cd5}', ['\\u{2cd4}', '\\0', '\\0']), ('\\u{2cd7}', ['\\u{2cd6}',\n        '\\0', '\\0']), ('\\u{2cd9}', ['\\u{2cd8}', '\\0', '\\0']), ('\\u{2cdb}', ['\\u{2cda}', '\\0',\n        '\\0']), ('\\u{2cdd}', ['\\u{2cdc}', '\\0', '\\0']), ('\\u{2cdf}', ['\\u{2cde}', '\\0', '\\0']),\n        ('\\u{2ce1}', ['\\u{2ce0}', '\\0', '\\0']), ('\\u{2ce3}', ['\\u{2ce2}', '\\0', '\\0']), ('\\u{2cec}',\n        ['\\u{2ceb}', '\\0', '\\0']), ('\\u{2cee}', ['\\u{2ced}', '\\0', '\\0']), ('\\u{2cf3}', ['\\u{2cf2}',\n        '\\0', '\\0']), ('\\u{2d00}', ['\\u{10a0}', '\\0', '\\0']), ('\\u{2d01}', ['\\u{10a1}', '\\0',\n        '\\0']), ('\\u{2d02}', ['\\u{10a2}', '\\0', '\\0']), ('\\u{2d03}', ['\\u{10a3}', '\\0', '\\0']),\n        ('\\u{2d04}', ['\\u{10a4}', '\\0', '\\0']), ('\\u{2d05}', ['\\u{10a5}', '\\0', '\\0']), ('\\u{2d06}',\n        ['\\u{10a6}', '\\0', '\\0']), ('\\u{2d07}', ['\\u{10a7}', '\\0', '\\0']), ('\\u{2d08}', ['\\u{10a8}',\n        '\\0', '\\0']), ('\\u{2d09}', ['\\u{10a9}', '\\0', '\\0']), ('\\u{2d0a}', ['\\u{10aa}', '\\0',\n        '\\0']), ('\\u{2d0b}', ['\\u{10ab}', '\\0', '\\0']), ('\\u{2d0c}', ['\\u{10ac}', '\\0', '\\0']),\n        ('\\u{2d0d}', ['\\u{10ad}', '\\0', '\\0']), ('\\u{2d0e}', ['\\u{10ae}', '\\0', '\\0']), ('\\u{2d0f}',\n        ['\\u{10af}', '\\0', '\\0']), ('\\u{2d10}', ['\\u{10b0}', '\\0', '\\0']), ('\\u{2d11}', ['\\u{10b1}',\n        '\\0', '\\0']), ('\\u{2d12}', ['\\u{10b2}', '\\0', '\\0']), ('\\u{2d13}', ['\\u{10b3}', '\\0',\n        '\\0']), ('\\u{2d14}', ['\\u{10b4}', '\\0', '\\0']), ('\\u{2d15}', ['\\u{10b5}', '\\0', '\\0']),\n        ('\\u{2d16}', ['\\u{10b6}', '\\0', '\\0']), ('\\u{2d17}', ['\\u{10b7}', '\\0', '\\0']), ('\\u{2d18}',\n        ['\\u{10b8}', '\\0', '\\0']), ('\\u{2d19}', ['\\u{10b9}', '\\0', '\\0']), ('\\u{2d1a}', ['\\u{10ba}',\n        '\\0', '\\0']), ('\\u{2d1b}', ['\\u{10bb}', '\\0', '\\0']), ('\\u{2d1c}', ['\\u{10bc}', '\\0',\n        '\\0']), ('\\u{2d1d}', ['\\u{10bd}', '\\0', '\\0']), ('\\u{2d1e}', ['\\u{10be}', '\\0', '\\0']),\n        ('\\u{2d1f}', ['\\u{10bf}', '\\0', '\\0']), ('\\u{2d20}', ['\\u{10c0}', '\\0', '\\0']), ('\\u{2d21}',\n        ['\\u{10c1}', '\\0', '\\0']), ('\\u{2d22}', ['\\u{10c2}', '\\0', '\\0']), ('\\u{2d23}', ['\\u{10c3}',\n        '\\0', '\\0']), ('\\u{2d24}', ['\\u{10c4}', '\\0', '\\0']), ('\\u{2d25}', ['\\u{10c5}', '\\0',\n        '\\0']), ('\\u{2d27}', ['\\u{10c7}', '\\0', '\\0']), ('\\u{2d2d}', ['\\u{10cd}', '\\0', '\\0']),\n        ('\\u{a641}', ['\\u{a640}', '\\0', '\\0']), ('\\u{a643}', ['\\u{a642}', '\\0', '\\0']), ('\\u{a645}',\n        ['\\u{a644}', '\\0', '\\0']), ('\\u{a647}', ['\\u{a646}', '\\0', '\\0']), ('\\u{a649}', ['\\u{a648}',\n        '\\0', '\\0']), ('\\u{a64b}', ['\\u{a64a}', '\\0', '\\0']), ('\\u{a64d}', ['\\u{a64c}', '\\0',\n        '\\0']), ('\\u{a64f}', ['\\u{a64e}', '\\0', '\\0']), ('\\u{a651}', ['\\u{a650}', '\\0', '\\0']),\n        ('\\u{a653}', ['\\u{a652}', '\\0', '\\0']), ('\\u{a655}', ['\\u{a654}', '\\0', '\\0']), ('\\u{a657}',\n        ['\\u{a656}', '\\0', '\\0']), ('\\u{a659}', ['\\u{a658}', '\\0', '\\0']), ('\\u{a65b}', ['\\u{a65a}',\n        '\\0', '\\0']), ('\\u{a65d}', ['\\u{a65c}', '\\0', '\\0']), ('\\u{a65f}', ['\\u{a65e}', '\\0',\n        '\\0']), ('\\u{a661}', ['\\u{a660}', '\\0', '\\0']), ('\\u{a663}', ['\\u{a662}', '\\0', '\\0']),\n        ('\\u{a665}', ['\\u{a664}', '\\0', '\\0']), ('\\u{a667}', ['\\u{a666}', '\\0', '\\0']), ('\\u{a669}',\n        ['\\u{a668}', '\\0', '\\0']), ('\\u{a66b}', ['\\u{a66a}', '\\0', '\\0']), ('\\u{a66d}', ['\\u{a66c}',\n        '\\0', '\\0']), ('\\u{a681}', ['\\u{a680}', '\\0', '\\0']), ('\\u{a683}', ['\\u{a682}', '\\0',\n        '\\0']), ('\\u{a685}', ['\\u{a684}', '\\0', '\\0']), ('\\u{a687}', ['\\u{a686}', '\\0', '\\0']),\n        ('\\u{a689}', ['\\u{a688}', '\\0', '\\0']), ('\\u{a68b}', ['\\u{a68a}', '\\0', '\\0']), ('\\u{a68d}',\n        ['\\u{a68c}', '\\0', '\\0']), ('\\u{a68f}', ['\\u{a68e}', '\\0', '\\0']), ('\\u{a691}', ['\\u{a690}',\n        '\\0', '\\0']), ('\\u{a693}', ['\\u{a692}', '\\0', '\\0']), ('\\u{a695}', ['\\u{a694}', '\\0',\n        '\\0']), ('\\u{a697}', ['\\u{a696}', '\\0', '\\0']), ('\\u{a699}', ['\\u{a698}', '\\0', '\\0']),\n        ('\\u{a69b}', ['\\u{a69a}', '\\0', '\\0']), ('\\u{a723}', ['\\u{a722}', '\\0', '\\0']), ('\\u{a725}',\n        ['\\u{a724}', '\\0', '\\0']), ('\\u{a727}', ['\\u{a726}', '\\0', '\\0']), ('\\u{a729}', ['\\u{a728}',\n        '\\0', '\\0']), ('\\u{a72b}', ['\\u{a72a}', '\\0', '\\0']), ('\\u{a72d}', ['\\u{a72c}', '\\0',\n        '\\0']), ('\\u{a72f}', ['\\u{a72e}', '\\0', '\\0']), ('\\u{a733}', ['\\u{a732}', '\\0', '\\0']),\n        ('\\u{a735}', ['\\u{a734}', '\\0', '\\0']), ('\\u{a737}', ['\\u{a736}', '\\0', '\\0']), ('\\u{a739}',\n        ['\\u{a738}', '\\0', '\\0']), ('\\u{a73b}', ['\\u{a73a}', '\\0', '\\0']), ('\\u{a73d}', ['\\u{a73c}',\n        '\\0', '\\0']), ('\\u{a73f}', ['\\u{a73e}', '\\0', '\\0']), ('\\u{a741}', ['\\u{a740}', '\\0',\n        '\\0']), ('\\u{a743}', ['\\u{a742}', '\\0', '\\0']), ('\\u{a745}', ['\\u{a744}', '\\0', '\\0']),\n        ('\\u{a747}', ['\\u{a746}', '\\0', '\\0']), ('\\u{a749}', ['\\u{a748}', '\\0', '\\0']), ('\\u{a74b}',\n        ['\\u{a74a}', '\\0', '\\0']), ('\\u{a74d}', ['\\u{a74c}', '\\0', '\\0']), ('\\u{a74f}', ['\\u{a74e}',\n        '\\0', '\\0']), ('\\u{a751}', ['\\u{a750}', '\\0', '\\0']), ('\\u{a753}', ['\\u{a752}', '\\0',\n        '\\0']), ('\\u{a755}', ['\\u{a754}', '\\0', '\\0']), ('\\u{a757}', ['\\u{a756}', '\\0', '\\0']),\n        ('\\u{a759}', ['\\u{a758}', '\\0', '\\0']), ('\\u{a75b}', ['\\u{a75a}', '\\0', '\\0']), ('\\u{a75d}',\n        ['\\u{a75c}', '\\0', '\\0']), ('\\u{a75f}', ['\\u{a75e}', '\\0', '\\0']), ('\\u{a761}', ['\\u{a760}',\n        '\\0', '\\0']), ('\\u{a763}', ['\\u{a762}', '\\0', '\\0']), ('\\u{a765}', ['\\u{a764}', '\\0',\n        '\\0']), ('\\u{a767}', ['\\u{a766}', '\\0', '\\0']), ('\\u{a769}', ['\\u{a768}', '\\0', '\\0']),\n        ('\\u{a76b}', ['\\u{a76a}', '\\0', '\\0']), ('\\u{a76d}', ['\\u{a76c}', '\\0', '\\0']), ('\\u{a76f}',\n        ['\\u{a76e}', '\\0', '\\0']), ('\\u{a77a}', ['\\u{a779}', '\\0', '\\0']), ('\\u{a77c}', ['\\u{a77b}',\n        '\\0', '\\0']), ('\\u{a77f}', ['\\u{a77e}', '\\0', '\\0']), ('\\u{a781}', ['\\u{a780}', '\\0',\n        '\\0']), ('\\u{a783}', ['\\u{a782}', '\\0', '\\0']), ('\\u{a785}', ['\\u{a784}', '\\0', '\\0']),\n        ('\\u{a787}', ['\\u{a786}', '\\0', '\\0']), ('\\u{a78c}', ['\\u{a78b}', '\\0', '\\0']), ('\\u{a791}',\n        ['\\u{a790}', '\\0', '\\0']), ('\\u{a793}', ['\\u{a792}', '\\0', '\\0']), ('\\u{a797}', ['\\u{a796}',\n        '\\0', '\\0']), ('\\u{a799}', ['\\u{a798}', '\\0', '\\0']), ('\\u{a79b}', ['\\u{a79a}', '\\0',\n        '\\0']), ('\\u{a79d}', ['\\u{a79c}', '\\0', '\\0']), ('\\u{a79f}', ['\\u{a79e}', '\\0', '\\0']),\n        ('\\u{a7a1}', ['\\u{a7a0}', '\\0', '\\0']), ('\\u{a7a3}', ['\\u{a7a2}', '\\0', '\\0']), ('\\u{a7a5}',\n        ['\\u{a7a4}', '\\0', '\\0']), ('\\u{a7a7}', ['\\u{a7a6}', '\\0', '\\0']), ('\\u{a7a9}', ['\\u{a7a8}',\n        '\\0', '\\0']), ('\\u{a7b5}', ['\\u{a7b4}', '\\0', '\\0']), ('\\u{a7b7}', ['\\u{a7b6}', '\\0',\n        '\\0']), ('\\u{ab53}', ['\\u{a7b3}', '\\0', '\\0']), ('\\u{ab70}', ['\\u{13a0}', '\\0', '\\0']),\n        ('\\u{ab71}', ['\\u{13a1}', '\\0', '\\0']), ('\\u{ab72}', ['\\u{13a2}', '\\0', '\\0']), ('\\u{ab73}',\n        ['\\u{13a3}', '\\0', '\\0']), ('\\u{ab74}', ['\\u{13a4}', '\\0', '\\0']), ('\\u{ab75}', ['\\u{13a5}',\n        '\\0', '\\0']), ('\\u{ab76}', ['\\u{13a6}', '\\0', '\\0']), ('\\u{ab77}', ['\\u{13a7}', '\\0',\n        '\\0']), ('\\u{ab78}', ['\\u{13a8}', '\\0', '\\0']), ('\\u{ab79}', ['\\u{13a9}', '\\0', '\\0']),\n        ('\\u{ab7a}', ['\\u{13aa}', '\\0', '\\0']), ('\\u{ab7b}', ['\\u{13ab}', '\\0', '\\0']), ('\\u{ab7c}',\n        ['\\u{13ac}', '\\0', '\\0']), ('\\u{ab7d}', ['\\u{13ad}', '\\0', '\\0']), ('\\u{ab7e}', ['\\u{13ae}',\n        '\\0', '\\0']), ('\\u{ab7f}', ['\\u{13af}', '\\0', '\\0']), ('\\u{ab80}', ['\\u{13b0}', '\\0',\n        '\\0']), ('\\u{ab81}', ['\\u{13b1}', '\\0', '\\0']), ('\\u{ab82}', ['\\u{13b2}', '\\0', '\\0']),\n        ('\\u{ab83}', ['\\u{13b3}', '\\0', '\\0']), ('\\u{ab84}', ['\\u{13b4}', '\\0', '\\0']), ('\\u{ab85}',\n        ['\\u{13b5}', '\\0', '\\0']), ('\\u{ab86}', ['\\u{13b6}', '\\0', '\\0']), ('\\u{ab87}', ['\\u{13b7}',\n        '\\0', '\\0']), ('\\u{ab88}', ['\\u{13b8}', '\\0', '\\0']), ('\\u{ab89}', ['\\u{13b9}', '\\0',\n        '\\0']), ('\\u{ab8a}', ['\\u{13ba}', '\\0', '\\0']), ('\\u{ab8b}', ['\\u{13bb}', '\\0', '\\0']),\n        ('\\u{ab8c}', ['\\u{13bc}', '\\0', '\\0']), ('\\u{ab8d}', ['\\u{13bd}', '\\0', '\\0']), ('\\u{ab8e}',\n        ['\\u{13be}', '\\0', '\\0']), ('\\u{ab8f}', ['\\u{13bf}', '\\0', '\\0']), ('\\u{ab90}', ['\\u{13c0}',\n        '\\0', '\\0']), ('\\u{ab91}', ['\\u{13c1}', '\\0', '\\0']), ('\\u{ab92}', ['\\u{13c2}', '\\0',\n        '\\0']), ('\\u{ab93}', ['\\u{13c3}', '\\0', '\\0']), ('\\u{ab94}', ['\\u{13c4}', '\\0', '\\0']),\n        ('\\u{ab95}', ['\\u{13c5}', '\\0', '\\0']), ('\\u{ab96}', ['\\u{13c6}', '\\0', '\\0']), ('\\u{ab97}',\n        ['\\u{13c7}', '\\0', '\\0']), ('\\u{ab98}', ['\\u{13c8}', '\\0', '\\0']), ('\\u{ab99}', ['\\u{13c9}',\n        '\\0', '\\0']), ('\\u{ab9a}', ['\\u{13ca}', '\\0', '\\0']), ('\\u{ab9b}', ['\\u{13cb}', '\\0',\n        '\\0']), ('\\u{ab9c}', ['\\u{13cc}', '\\0', '\\0']), ('\\u{ab9d}', ['\\u{13cd}', '\\0', '\\0']),\n        ('\\u{ab9e}', ['\\u{13ce}', '\\0', '\\0']), ('\\u{ab9f}', ['\\u{13cf}', '\\0', '\\0']), ('\\u{aba0}',\n        ['\\u{13d0}', '\\0', '\\0']), ('\\u{aba1}', ['\\u{13d1}', '\\0', '\\0']), ('\\u{aba2}', ['\\u{13d2}',\n        '\\0', '\\0']), ('\\u{aba3}', ['\\u{13d3}', '\\0', '\\0']), ('\\u{aba4}', ['\\u{13d4}', '\\0',\n        '\\0']), ('\\u{aba5}', ['\\u{13d5}', '\\0', '\\0']), ('\\u{aba6}', ['\\u{13d6}', '\\0', '\\0']),\n        ('\\u{aba7}', ['\\u{13d7}', '\\0', '\\0']), ('\\u{aba8}', ['\\u{13d8}', '\\0', '\\0']), ('\\u{aba9}',\n        ['\\u{13d9}', '\\0', '\\0']), ('\\u{abaa}', ['\\u{13da}', '\\0', '\\0']), ('\\u{abab}', ['\\u{13db}',\n        '\\0', '\\0']), ('\\u{abac}', ['\\u{13dc}', '\\0', '\\0']), ('\\u{abad}', ['\\u{13dd}', '\\0',\n        '\\0']), ('\\u{abae}', ['\\u{13de}', '\\0', '\\0']), ('\\u{abaf}', ['\\u{13df}', '\\0', '\\0']),\n        ('\\u{abb0}', ['\\u{13e0}', '\\0', '\\0']), ('\\u{abb1}', ['\\u{13e1}', '\\0', '\\0']), ('\\u{abb2}',\n        ['\\u{13e2}', '\\0', '\\0']), ('\\u{abb3}', ['\\u{13e3}', '\\0', '\\0']), ('\\u{abb4}', ['\\u{13e4}',\n        '\\0', '\\0']), ('\\u{abb5}', ['\\u{13e5}', '\\0', '\\0']), ('\\u{abb6}', ['\\u{13e6}', '\\0',\n        '\\0']), ('\\u{abb7}', ['\\u{13e7}', '\\0', '\\0']), ('\\u{abb8}', ['\\u{13e8}', '\\0', '\\0']),\n        ('\\u{abb9}', ['\\u{13e9}', '\\0', '\\0']), ('\\u{abba}', ['\\u{13ea}', '\\0', '\\0']), ('\\u{abbb}',\n        ['\\u{13eb}', '\\0', '\\0']), ('\\u{abbc}', ['\\u{13ec}', '\\0', '\\0']), ('\\u{abbd}', ['\\u{13ed}',\n        '\\0', '\\0']), ('\\u{abbe}', ['\\u{13ee}', '\\0', '\\0']), ('\\u{abbf}', ['\\u{13ef}', '\\0',\n        '\\0']), ('\\u{fb00}', ['\\u{46}', '\\u{46}', '\\0']), ('\\u{fb01}', ['\\u{46}', '\\u{49}', '\\0']),\n        ('\\u{fb02}', ['\\u{46}', '\\u{4c}', '\\0']), ('\\u{fb03}', ['\\u{46}', '\\u{46}', '\\u{49}']),\n        ('\\u{fb04}', ['\\u{46}', '\\u{46}', '\\u{4c}']), ('\\u{fb05}', ['\\u{53}', '\\u{54}', '\\0']),\n        ('\\u{fb06}', ['\\u{53}', '\\u{54}', '\\0']), ('\\u{fb13}', ['\\u{544}', '\\u{546}', '\\0']),\n        ('\\u{fb14}', ['\\u{544}', '\\u{535}', '\\0']), ('\\u{fb15}', ['\\u{544}', '\\u{53b}', '\\0']),\n        ('\\u{fb16}', ['\\u{54e}', '\\u{546}', '\\0']), ('\\u{fb17}', ['\\u{544}', '\\u{53d}', '\\0']),\n        ('\\u{ff41}', ['\\u{ff21}', '\\0', '\\0']), ('\\u{ff42}', ['\\u{ff22}', '\\0', '\\0']), ('\\u{ff43}',\n        ['\\u{ff23}', '\\0', '\\0']), ('\\u{ff44}', ['\\u{ff24}', '\\0', '\\0']), ('\\u{ff45}', ['\\u{ff25}',\n        '\\0', '\\0']), ('\\u{ff46}', ['\\u{ff26}', '\\0', '\\0']), ('\\u{ff47}', ['\\u{ff27}', '\\0',\n        '\\0']), ('\\u{ff48}', ['\\u{ff28}', '\\0', '\\0']), ('\\u{ff49}', ['\\u{ff29}', '\\0', '\\0']),\n        ('\\u{ff4a}', ['\\u{ff2a}', '\\0', '\\0']), ('\\u{ff4b}', ['\\u{ff2b}', '\\0', '\\0']), ('\\u{ff4c}',\n        ['\\u{ff2c}', '\\0', '\\0']), ('\\u{ff4d}', ['\\u{ff2d}', '\\0', '\\0']), ('\\u{ff4e}', ['\\u{ff2e}',\n        '\\0', '\\0']), ('\\u{ff4f}', ['\\u{ff2f}', '\\0', '\\0']), ('\\u{ff50}', ['\\u{ff30}', '\\0',\n        '\\0']), ('\\u{ff51}', ['\\u{ff31}', '\\0', '\\0']), ('\\u{ff52}', ['\\u{ff32}', '\\0', '\\0']),\n        ('\\u{ff53}', ['\\u{ff33}', '\\0', '\\0']), ('\\u{ff54}', ['\\u{ff34}', '\\0', '\\0']), ('\\u{ff55}',\n        ['\\u{ff35}', '\\0', '\\0']), ('\\u{ff56}', ['\\u{ff36}', '\\0', '\\0']), ('\\u{ff57}', ['\\u{ff37}',\n        '\\0', '\\0']), ('\\u{ff58}', ['\\u{ff38}', '\\0', '\\0']), ('\\u{ff59}', ['\\u{ff39}', '\\0',\n        '\\0']), ('\\u{ff5a}', ['\\u{ff3a}', '\\0', '\\0']), ('\\u{10428}', ['\\u{10400}', '\\0', '\\0']),\n        ('\\u{10429}', ['\\u{10401}', '\\0', '\\0']), ('\\u{1042a}', ['\\u{10402}', '\\0', '\\0']),\n        ('\\u{1042b}', ['\\u{10403}', '\\0', '\\0']), ('\\u{1042c}', ['\\u{10404}', '\\0', '\\0']),\n        ('\\u{1042d}', ['\\u{10405}', '\\0', '\\0']), ('\\u{1042e}', ['\\u{10406}', '\\0', '\\0']),\n        ('\\u{1042f}', ['\\u{10407}', '\\0', '\\0']), ('\\u{10430}', ['\\u{10408}', '\\0', '\\0']),\n        ('\\u{10431}', ['\\u{10409}', '\\0', '\\0']), ('\\u{10432}', ['\\u{1040a}', '\\0', '\\0']),\n        ('\\u{10433}', ['\\u{1040b}', '\\0', '\\0']), ('\\u{10434}', ['\\u{1040c}', '\\0', '\\0']),\n        ('\\u{10435}', ['\\u{1040d}', '\\0', '\\0']), ('\\u{10436}', ['\\u{1040e}', '\\0', '\\0']),\n        ('\\u{10437}', ['\\u{1040f}', '\\0', '\\0']), ('\\u{10438}', ['\\u{10410}', '\\0', '\\0']),\n        ('\\u{10439}', ['\\u{10411}', '\\0', '\\0']), ('\\u{1043a}', ['\\u{10412}', '\\0', '\\0']),\n        ('\\u{1043b}', ['\\u{10413}', '\\0', '\\0']), ('\\u{1043c}', ['\\u{10414}', '\\0', '\\0']),\n        ('\\u{1043d}', ['\\u{10415}', '\\0', '\\0']), ('\\u{1043e}', ['\\u{10416}', '\\0', '\\0']),\n        ('\\u{1043f}', ['\\u{10417}', '\\0', '\\0']), ('\\u{10440}', ['\\u{10418}', '\\0', '\\0']),\n        ('\\u{10441}', ['\\u{10419}', '\\0', '\\0']), ('\\u{10442}', ['\\u{1041a}', '\\0', '\\0']),\n        ('\\u{10443}', ['\\u{1041b}', '\\0', '\\0']), ('\\u{10444}', ['\\u{1041c}', '\\0', '\\0']),\n        ('\\u{10445}', ['\\u{1041d}', '\\0', '\\0']), ('\\u{10446}', ['\\u{1041e}', '\\0', '\\0']),\n        ('\\u{10447}', ['\\u{1041f}', '\\0', '\\0']), ('\\u{10448}', ['\\u{10420}', '\\0', '\\0']),\n        ('\\u{10449}', ['\\u{10421}', '\\0', '\\0']), ('\\u{1044a}', ['\\u{10422}', '\\0', '\\0']),\n        ('\\u{1044b}', ['\\u{10423}', '\\0', '\\0']), ('\\u{1044c}', ['\\u{10424}', '\\0', '\\0']),\n        ('\\u{1044d}', ['\\u{10425}', '\\0', '\\0']), ('\\u{1044e}', ['\\u{10426}', '\\0', '\\0']),\n        ('\\u{1044f}', ['\\u{10427}', '\\0', '\\0']), ('\\u{104d8}', ['\\u{104b0}', '\\0', '\\0']),\n        ('\\u{104d9}', ['\\u{104b1}', '\\0', '\\0']), ('\\u{104da}', ['\\u{104b2}', '\\0', '\\0']),\n        ('\\u{104db}', ['\\u{104b3}', '\\0', '\\0']), ('\\u{104dc}', ['\\u{104b4}', '\\0', '\\0']),\n        ('\\u{104dd}', ['\\u{104b5}', '\\0', '\\0']), ('\\u{104de}', ['\\u{104b6}', '\\0', '\\0']),\n        ('\\u{104df}', ['\\u{104b7}', '\\0', '\\0']), ('\\u{104e0}', ['\\u{104b8}', '\\0', '\\0']),\n        ('\\u{104e1}', ['\\u{104b9}', '\\0', '\\0']), ('\\u{104e2}', ['\\u{104ba}', '\\0', '\\0']),\n        ('\\u{104e3}', ['\\u{104bb}', '\\0', '\\0']), ('\\u{104e4}', ['\\u{104bc}', '\\0', '\\0']),\n        ('\\u{104e5}', ['\\u{104bd}', '\\0', '\\0']), ('\\u{104e6}', ['\\u{104be}', '\\0', '\\0']),\n        ('\\u{104e7}', ['\\u{104bf}', '\\0', '\\0']), ('\\u{104e8}', ['\\u{104c0}', '\\0', '\\0']),\n        ('\\u{104e9}', ['\\u{104c1}', '\\0', '\\0']), ('\\u{104ea}', ['\\u{104c2}', '\\0', '\\0']),\n        ('\\u{104eb}', ['\\u{104c3}', '\\0', '\\0']), ('\\u{104ec}', ['\\u{104c4}', '\\0', '\\0']),\n        ('\\u{104ed}', ['\\u{104c5}', '\\0', '\\0']), ('\\u{104ee}', ['\\u{104c6}', '\\0', '\\0']),\n        ('\\u{104ef}', ['\\u{104c7}', '\\0', '\\0']), ('\\u{104f0}', ['\\u{104c8}', '\\0', '\\0']),\n        ('\\u{104f1}', ['\\u{104c9}', '\\0', '\\0']), ('\\u{104f2}', ['\\u{104ca}', '\\0', '\\0']),\n        ('\\u{104f3}', ['\\u{104cb}', '\\0', '\\0']), ('\\u{104f4}', ['\\u{104cc}', '\\0', '\\0']),\n        ('\\u{104f5}', ['\\u{104cd}', '\\0', '\\0']), ('\\u{104f6}', ['\\u{104ce}', '\\0', '\\0']),\n        ('\\u{104f7}', ['\\u{104cf}', '\\0', '\\0']), ('\\u{104f8}', ['\\u{104d0}', '\\0', '\\0']),\n        ('\\u{104f9}', ['\\u{104d1}', '\\0', '\\0']), ('\\u{104fa}', ['\\u{104d2}', '\\0', '\\0']),\n        ('\\u{104fb}', ['\\u{104d3}', '\\0', '\\0']), ('\\u{10cc0}', ['\\u{10c80}', '\\0', '\\0']),\n        ('\\u{10cc1}', ['\\u{10c81}', '\\0', '\\0']), ('\\u{10cc2}', ['\\u{10c82}', '\\0', '\\0']),\n        ('\\u{10cc3}', ['\\u{10c83}', '\\0', '\\0']), ('\\u{10cc4}', ['\\u{10c84}', '\\0', '\\0']),\n        ('\\u{10cc5}', ['\\u{10c85}', '\\0', '\\0']), ('\\u{10cc6}', ['\\u{10c86}', '\\0', '\\0']),\n        ('\\u{10cc7}', ['\\u{10c87}', '\\0', '\\0']), ('\\u{10cc8}', ['\\u{10c88}', '\\0', '\\0']),\n        ('\\u{10cc9}', ['\\u{10c89}', '\\0', '\\0']), ('\\u{10cca}', ['\\u{10c8a}', '\\0', '\\0']),\n        ('\\u{10ccb}', ['\\u{10c8b}', '\\0', '\\0']), ('\\u{10ccc}', ['\\u{10c8c}', '\\0', '\\0']),\n        ('\\u{10ccd}', ['\\u{10c8d}', '\\0', '\\0']), ('\\u{10cce}', ['\\u{10c8e}', '\\0', '\\0']),\n        ('\\u{10ccf}', ['\\u{10c8f}', '\\0', '\\0']), ('\\u{10cd0}', ['\\u{10c90}', '\\0', '\\0']),\n        ('\\u{10cd1}', ['\\u{10c91}', '\\0', '\\0']), ('\\u{10cd2}', ['\\u{10c92}', '\\0', '\\0']),\n        ('\\u{10cd3}', ['\\u{10c93}', '\\0', '\\0']), ('\\u{10cd4}', ['\\u{10c94}', '\\0', '\\0']),\n        ('\\u{10cd5}', ['\\u{10c95}', '\\0', '\\0']), ('\\u{10cd6}', ['\\u{10c96}', '\\0', '\\0']),\n        ('\\u{10cd7}', ['\\u{10c97}', '\\0', '\\0']), ('\\u{10cd8}', ['\\u{10c98}', '\\0', '\\0']),\n        ('\\u{10cd9}', ['\\u{10c99}', '\\0', '\\0']), ('\\u{10cda}', ['\\u{10c9a}', '\\0', '\\0']),\n        ('\\u{10cdb}', ['\\u{10c9b}', '\\0', '\\0']), ('\\u{10cdc}', ['\\u{10c9c}', '\\0', '\\0']),\n        ('\\u{10cdd}', ['\\u{10c9d}', '\\0', '\\0']), ('\\u{10cde}', ['\\u{10c9e}', '\\0', '\\0']),\n        ('\\u{10cdf}', ['\\u{10c9f}', '\\0', '\\0']), ('\\u{10ce0}', ['\\u{10ca0}', '\\0', '\\0']),\n        ('\\u{10ce1}', ['\\u{10ca1}', '\\0', '\\0']), ('\\u{10ce2}', ['\\u{10ca2}', '\\0', '\\0']),\n        ('\\u{10ce3}', ['\\u{10ca3}', '\\0', '\\0']), ('\\u{10ce4}', ['\\u{10ca4}', '\\0', '\\0']),\n        ('\\u{10ce5}', ['\\u{10ca5}', '\\0', '\\0']), ('\\u{10ce6}', ['\\u{10ca6}', '\\0', '\\0']),\n        ('\\u{10ce7}', ['\\u{10ca7}', '\\0', '\\0']), ('\\u{10ce8}', ['\\u{10ca8}', '\\0', '\\0']),\n        ('\\u{10ce9}', ['\\u{10ca9}', '\\0', '\\0']), ('\\u{10cea}', ['\\u{10caa}', '\\0', '\\0']),\n        ('\\u{10ceb}', ['\\u{10cab}', '\\0', '\\0']), ('\\u{10cec}', ['\\u{10cac}', '\\0', '\\0']),\n        ('\\u{10ced}', ['\\u{10cad}', '\\0', '\\0']), ('\\u{10cee}', ['\\u{10cae}', '\\0', '\\0']),\n        ('\\u{10cef}', ['\\u{10caf}', '\\0', '\\0']), ('\\u{10cf0}', ['\\u{10cb0}', '\\0', '\\0']),\n        ('\\u{10cf1}', ['\\u{10cb1}', '\\0', '\\0']), ('\\u{10cf2}', ['\\u{10cb2}', '\\0', '\\0']),\n        ('\\u{118c0}', ['\\u{118a0}', '\\0', '\\0']), ('\\u{118c1}', ['\\u{118a1}', '\\0', '\\0']),\n        ('\\u{118c2}', ['\\u{118a2}', '\\0', '\\0']), ('\\u{118c3}', ['\\u{118a3}', '\\0', '\\0']),\n        ('\\u{118c4}', ['\\u{118a4}', '\\0', '\\0']), ('\\u{118c5}', ['\\u{118a5}', '\\0', '\\0']),\n        ('\\u{118c6}', ['\\u{118a6}', '\\0', '\\0']), ('\\u{118c7}', ['\\u{118a7}', '\\0', '\\0']),\n        ('\\u{118c8}', ['\\u{118a8}', '\\0', '\\0']), ('\\u{118c9}', ['\\u{118a9}', '\\0', '\\0']),\n        ('\\u{118ca}', ['\\u{118aa}', '\\0', '\\0']), ('\\u{118cb}', ['\\u{118ab}', '\\0', '\\0']),\n        ('\\u{118cc}', ['\\u{118ac}', '\\0', '\\0']), ('\\u{118cd}', ['\\u{118ad}', '\\0', '\\0']),\n        ('\\u{118ce}', ['\\u{118ae}', '\\0', '\\0']), ('\\u{118cf}', ['\\u{118af}', '\\0', '\\0']),\n        ('\\u{118d0}', ['\\u{118b0}', '\\0', '\\0']), ('\\u{118d1}', ['\\u{118b1}', '\\0', '\\0']),\n        ('\\u{118d2}', ['\\u{118b2}', '\\0', '\\0']), ('\\u{118d3}', ['\\u{118b3}', '\\0', '\\0']),\n        ('\\u{118d4}', ['\\u{118b4}', '\\0', '\\0']), ('\\u{118d5}', ['\\u{118b5}', '\\0', '\\0']),\n        ('\\u{118d6}', ['\\u{118b6}', '\\0', '\\0']), ('\\u{118d7}', ['\\u{118b7}', '\\0', '\\0']),\n        ('\\u{118d8}', ['\\u{118b8}', '\\0', '\\0']), ('\\u{118d9}', ['\\u{118b9}', '\\0', '\\0']),\n        ('\\u{118da}', ['\\u{118ba}', '\\0', '\\0']), ('\\u{118db}', ['\\u{118bb}', '\\0', '\\0']),\n        ('\\u{118dc}', ['\\u{118bc}', '\\0', '\\0']), ('\\u{118dd}', ['\\u{118bd}', '\\0', '\\0']),\n        ('\\u{118de}', ['\\u{118be}', '\\0', '\\0']), ('\\u{118df}', ['\\u{118bf}', '\\0', '\\0']),\n        ('\\u{1e922}', ['\\u{1e900}', '\\0', '\\0']), ('\\u{1e923}', ['\\u{1e901}', '\\0', '\\0']),\n        ('\\u{1e924}', ['\\u{1e902}', '\\0', '\\0']), ('\\u{1e925}', ['\\u{1e903}', '\\0', '\\0']),\n        ('\\u{1e926}', ['\\u{1e904}', '\\0', '\\0']), ('\\u{1e927}', ['\\u{1e905}', '\\0', '\\0']),\n        ('\\u{1e928}', ['\\u{1e906}', '\\0', '\\0']), ('\\u{1e929}', ['\\u{1e907}', '\\0', '\\0']),\n        ('\\u{1e92a}', ['\\u{1e908}', '\\0', '\\0']), ('\\u{1e92b}', ['\\u{1e909}', '\\0', '\\0']),\n        ('\\u{1e92c}', ['\\u{1e90a}', '\\0', '\\0']), ('\\u{1e92d}', ['\\u{1e90b}', '\\0', '\\0']),\n        ('\\u{1e92e}', ['\\u{1e90c}', '\\0', '\\0']), ('\\u{1e92f}', ['\\u{1e90d}', '\\0', '\\0']),\n        ('\\u{1e930}', ['\\u{1e90e}', '\\0', '\\0']), ('\\u{1e931}', ['\\u{1e90f}', '\\0', '\\0']),\n        ('\\u{1e932}', ['\\u{1e910}', '\\0', '\\0']), ('\\u{1e933}', ['\\u{1e911}', '\\0', '\\0']),\n        ('\\u{1e934}', ['\\u{1e912}', '\\0', '\\0']), ('\\u{1e935}', ['\\u{1e913}', '\\0', '\\0']),\n        ('\\u{1e936}', ['\\u{1e914}', '\\0', '\\0']), ('\\u{1e937}', ['\\u{1e915}', '\\0', '\\0']),\n        ('\\u{1e938}', ['\\u{1e916}', '\\0', '\\0']), ('\\u{1e939}', ['\\u{1e917}', '\\0', '\\0']),\n        ('\\u{1e93a}', ['\\u{1e918}', '\\0', '\\0']), ('\\u{1e93b}', ['\\u{1e919}', '\\0', '\\0']),\n        ('\\u{1e93c}', ['\\u{1e91a}', '\\0', '\\0']), ('\\u{1e93d}', ['\\u{1e91b}', '\\0', '\\0']),\n        ('\\u{1e93e}', ['\\u{1e91c}', '\\0', '\\0']), ('\\u{1e93f}', ['\\u{1e91d}', '\\0', '\\0']),\n        ('\\u{1e940}', ['\\u{1e91e}', '\\0', '\\0']), ('\\u{1e941}', ['\\u{1e91f}', '\\0', '\\0']),\n        ('\\u{1e942}', ['\\u{1e920}', '\\0', '\\0']), ('\\u{1e943}', ['\\u{1e921}', '\\0', '\\0'])\n    ];\n\n}\n\n","// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse core::str as core_str;\nuse core::fmt;\nuse core::fmt::Write;\nuse char;\nuse core::intrinsics;\n\n\n/// Lossy UTF-8 string.\n#[unstable(feature = \"str_internals\", issue = \"0\")]\npub struct Utf8Lossy {\n    bytes: [u8]\n}\n\nimpl Utf8Lossy {\n    pub fn from_str(s: &str) -> &Utf8Lossy {\n        Utf8Lossy::from_bytes(s.as_bytes())\n    }\n\n    pub fn from_bytes(bytes: &[u8]) -> &Utf8Lossy {\n        unsafe { intrinsics::transmute(bytes) }\n    }\n\n    pub fn chunks(&self) -> Utf8LossyChunksIter {\n        Utf8LossyChunksIter { source: &self.bytes }\n    }\n}\n\n\n/// Iterator over lossy UTF-8 string\n#[unstable(feature = \"str_internals\", issue = \"0\")]\npub struct Utf8LossyChunksIter<'a> {\n    source: &'a [u8],\n}\n\n#[unstable(feature = \"str_internals\", issue = \"0\")]\n#[derive(PartialEq, Eq, Debug)]\npub struct Utf8LossyChunk<'a> {\n    /// Sequence of valid chars.\n    /// Can be empty between broken UTF-8 chars.\n    pub valid: &'a str,\n    /// Single broken char, empty if none.\n    /// Empty iff iterator item is last.\n    pub broken: &'a [u8],\n}\n\nimpl<'a> Iterator for Utf8LossyChunksIter<'a> {\n    type Item = Utf8LossyChunk<'a>;\n\n    fn next(&mut self) -> Option<Utf8LossyChunk<'a>> {\n        if self.source.len() == 0 {\n            return None;\n        }\n\n        const TAG_CONT_U8: u8 = 128;\n        fn unsafe_get(xs: &[u8], i: usize) -> u8 {\n            unsafe { *xs.get_unchecked(i) }\n        }\n        fn safe_get(xs: &[u8], i: usize) -> u8 {\n            if i >= xs.len() { 0 } else { unsafe_get(xs, i) }\n        }\n\n        let mut i = 0;\n        while i < self.source.len() {\n            let i_ = i;\n\n            let byte = unsafe_get(self.source, i);\n            i += 1;\n\n            if byte < 128 {\n\n            } else {\n                let w = core_str::utf8_char_width(byte);\n\n                macro_rules! error { () => ({\n                    unsafe {\n                        let r = Utf8LossyChunk {\n                            valid: core_str::from_utf8_unchecked(&self.source[0..i_]),\n                            broken: &self.source[i_..i],\n                        };\n                        self.source = &self.source[i..];\n                        return Some(r);\n                    }\n                })}\n\n                match w {\n                    2 => {\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            error!();\n                        }\n                        i += 1;\n                    }\n                    3 => {\n                        match (byte, safe_get(self.source, i)) {\n                            (0xE0, 0xA0 ... 0xBF) => (),\n                            (0xE1 ... 0xEC, 0x80 ... 0xBF) => (),\n                            (0xED, 0x80 ... 0x9F) => (),\n                            (0xEE ... 0xEF, 0x80 ... 0xBF) => (),\n                            _ => {\n                                error!();\n                            }\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            error!();\n                        }\n                        i += 1;\n                    }\n                    4 => {\n                        match (byte, safe_get(self.source, i)) {\n                            (0xF0, 0x90 ... 0xBF) => (),\n                            (0xF1 ... 0xF3, 0x80 ... 0xBF) => (),\n                            (0xF4, 0x80 ... 0x8F) => (),\n                            _ => {\n                                error!();\n                            }\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            error!();\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            error!();\n                        }\n                        i += 1;\n                    }\n                    _ => {\n                        error!();\n                    }\n                }\n            }\n        }\n\n        let r = Utf8LossyChunk {\n            valid: unsafe { core_str::from_utf8_unchecked(self.source) },\n            broken: &[],\n        };\n        self.source = &[];\n        return Some(r);\n    }\n}\n\n\nimpl fmt::Display for Utf8Lossy {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for Utf8LossyChunk { valid, broken } in self.chunks() {\n            f.write_str(valid)?;\n            if !broken.is_empty() {\n                f.write_char(char::REPLACEMENT_CHARACTER)?;\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Debug for Utf8Lossy {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_char('\"')?;\n\n        for Utf8LossyChunk { valid, broken } in self.chunks() {\n\n            // Valid part.\n            // Here we partially parse UTF-8 again which is suboptimal.\n            {\n                let mut from = 0;\n                for (i, c) in valid.char_indices() {\n                    let esc = c.escape_debug();\n                    // If char needs escaping, flush backlog so far and write, else skip\n                    if esc.len() != 1 {\n                        f.write_str(&valid[from..i])?;\n                        for c in esc {\n                            f.write_char(c)?;\n                        }\n                        from = i + c.len_utf8();\n                    }\n                }\n                f.write_str(&valid[from..])?;\n            }\n\n            // Broken parts of string as hex escape.\n            for &b in broken {\n                write!(f, \"\\\\x{:02x}\", b)?;\n            }\n        }\n\n        f.write_char('\"')\n    }\n}\n","// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\nuse ops::{Mul, Add};\nuse num::Wrapping;\n\n/// Conversion from an `Iterator`.\n///\n/// By implementing `FromIterator` for a type, you define how it will be\n/// created from an iterator. This is common for types which describe a\n/// collection of some kind.\n///\n/// `FromIterator`'s [`from_iter`] is rarely called explicitly, and is instead\n/// used through [`Iterator`]'s [`collect`] method. See [`collect`]'s\n/// documentation for more examples.\n///\n/// [`from_iter`]: #tymethod.from_iter\n/// [`Iterator`]: trait.Iterator.html\n/// [`collect`]: trait.Iterator.html#method.collect\n///\n/// See also: [`IntoIterator`].\n///\n/// [`IntoIterator`]: trait.IntoIterator.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::iter::FromIterator;\n///\n/// let five_fives = std::iter::repeat(5).take(5);\n///\n/// let v = Vec::from_iter(five_fives);\n///\n/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n/// ```\n///\n/// Using [`collect`] to implicitly use `FromIterator`:\n///\n/// ```\n/// let five_fives = std::iter::repeat(5).take(5);\n///\n/// let v: Vec<i32> = five_fives.collect();\n///\n/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n/// ```\n///\n/// Implementing `FromIterator` for your type:\n///\n/// ```\n/// use std::iter::FromIterator;\n///\n/// // A sample collection, that's just a wrapper over Vec<T>\n/// #[derive(Debug)]\n/// struct MyCollection(Vec<i32>);\n///\n/// // Let's give it some methods so we can create one and add things\n/// // to it.\n/// impl MyCollection {\n///     fn new() -> MyCollection {\n///         MyCollection(Vec::new())\n///     }\n///\n///     fn add(&mut self, elem: i32) {\n///         self.0.push(elem);\n///     }\n/// }\n///\n/// // and we'll implement FromIterator\n/// impl FromIterator<i32> for MyCollection {\n///     fn from_iter<I: IntoIterator<Item=i32>>(iter: I) -> Self {\n///         let mut c = MyCollection::new();\n///\n///         for i in iter {\n///             c.add(i);\n///         }\n///\n///         c\n///     }\n/// }\n///\n/// // Now we can make a new iterator...\n/// let iter = (0..5).into_iter();\n///\n/// // ... and make a MyCollection out of it\n/// let c = MyCollection::from_iter(iter);\n///\n/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n///\n/// // collect works too!\n///\n/// let iter = (0..5).into_iter();\n/// let c: MyCollection = iter.collect();\n///\n/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n                          built from an iterator over elements of type `{A}`\"]\npub trait FromIterator<A>: Sized {\n    /// Creates a value from an iterator.\n    ///\n    /// See the [module-level documentation] for more.\n    ///\n    /// [module-level documentation]: index.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::iter::FromIterator;\n    ///\n    /// let five_fives = std::iter::repeat(5).take(5);\n    ///\n    /// let v = Vec::from_iter(five_fives);\n    ///\n    /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> Self;\n}\n\n/// Conversion into an `Iterator`.\n///\n/// By implementing `IntoIterator` for a type, you define how it will be\n/// converted to an iterator. This is common for types which describe a\n/// collection of some kind.\n///\n/// One benefit of implementing `IntoIterator` is that your type will [work\n/// with Rust's `for` loop syntax](index.html#for-loops-and-intoiterator).\n///\n/// See also: [`FromIterator`].\n///\n/// [`FromIterator`]: trait.FromIterator.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let v = vec![1, 2, 3];\n///\n/// let mut iter = v.into_iter();\n///\n/// let n = iter.next();\n/// assert_eq!(Some(1), n);\n///\n/// let n = iter.next();\n/// assert_eq!(Some(2), n);\n///\n/// let n = iter.next();\n/// assert_eq!(Some(3), n);\n///\n/// let n = iter.next();\n/// assert_eq!(None, n);\n/// ```\n///\n/// Implementing `IntoIterator` for your type:\n///\n/// ```\n/// // A sample collection, that's just a wrapper over Vec<T>\n/// #[derive(Debug)]\n/// struct MyCollection(Vec<i32>);\n///\n/// // Let's give it some methods so we can create one and add things\n/// // to it.\n/// impl MyCollection {\n///     fn new() -> MyCollection {\n///         MyCollection(Vec::new())\n///     }\n///\n///     fn add(&mut self, elem: i32) {\n///         self.0.push(elem);\n///     }\n/// }\n///\n/// // and we'll implement IntoIterator\n/// impl IntoIterator for MyCollection {\n///     type Item = i32;\n///     type IntoIter = ::std::vec::IntoIter<i32>;\n///\n///     fn into_iter(self) -> Self::IntoIter {\n///         self.0.into_iter()\n///     }\n/// }\n///\n/// // Now we can make a new collection...\n/// let mut c = MyCollection::new();\n///\n/// // ... add some stuff to it ...\n/// c.add(0);\n/// c.add(1);\n/// c.add(2);\n///\n/// // ... and then turn it into an Iterator:\n/// for (i, n) in c.into_iter().enumerate() {\n///     assert_eq!(i as i32, n);\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait IntoIterator {\n    /// The type of the elements being iterated over.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Item;\n\n    /// Which kind of iterator are we turning this into?\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type IntoIter: Iterator<Item=Self::Item>;\n\n    /// Creates an iterator from a value.\n    ///\n    /// See the [module-level documentation] for more.\n    ///\n    /// [module-level documentation]: index.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let v = vec![1, 2, 3];\n    ///\n    /// let mut iter = v.into_iter();\n    ///\n    /// let n = iter.next();\n    /// assert_eq!(Some(1), n);\n    ///\n    /// let n = iter.next();\n    /// assert_eq!(Some(2), n);\n    ///\n    /// let n = iter.next();\n    /// assert_eq!(Some(3), n);\n    ///\n    /// let n = iter.next();\n    /// assert_eq!(None, n);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn into_iter(self) -> Self::IntoIter;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator> IntoIterator for I {\n    type Item = I::Item;\n    type IntoIter = I;\n\n    fn into_iter(self) -> I {\n        self\n    }\n}\n\n/// Extend a collection with the contents of an iterator.\n///\n/// Iterators produce a series of values, and collections can also be thought\n/// of as a series of values. The `Extend` trait bridges this gap, allowing you\n/// to extend a collection by including the contents of that iterator. When\n/// extending a collection with an already existing key, that entry is updated\n/// or, in the case of collections that permit multiple entries with equal\n/// keys, that entry is inserted.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // You can extend a String with some chars:\n/// let mut message = String::from(\"The first three letters are: \");\n///\n/// message.extend(&['a', 'b', 'c']);\n///\n/// assert_eq!(\"abc\", &message[29..32]);\n/// ```\n///\n/// Implementing `Extend`:\n///\n/// ```\n/// // A sample collection, that's just a wrapper over Vec<T>\n/// #[derive(Debug)]\n/// struct MyCollection(Vec<i32>);\n///\n/// // Let's give it some methods so we can create one and add things\n/// // to it.\n/// impl MyCollection {\n///     fn new() -> MyCollection {\n///         MyCollection(Vec::new())\n///     }\n///\n///     fn add(&mut self, elem: i32) {\n///         self.0.push(elem);\n///     }\n/// }\n///\n/// // since MyCollection has a list of i32s, we implement Extend for i32\n/// impl Extend<i32> for MyCollection {\n///\n///     // This is a bit simpler with the concrete type signature: we can call\n///     // extend on anything which can be turned into an Iterator which gives\n///     // us i32s. Because we need i32s to put into MyCollection.\n///     fn extend<T: IntoIterator<Item=i32>>(&mut self, iter: T) {\n///\n///         // The implementation is very straightforward: loop through the\n///         // iterator, and add() each element to ourselves.\n///         for elem in iter {\n///             self.add(elem);\n///         }\n///     }\n/// }\n///\n/// let mut c = MyCollection::new();\n///\n/// c.add(5);\n/// c.add(6);\n/// c.add(7);\n///\n/// // let's extend our collection with three more numbers\n/// c.extend(vec![1, 2, 3]);\n///\n/// // we've added these elements onto the end\n/// assert_eq!(\"MyCollection([5, 6, 7, 1, 2, 3])\", format!(\"{:?}\", c));\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Extend<A> {\n    /// Extends a collection with the contents of an iterator.\n    ///\n    /// As this is the only method for this trait, the [trait-level] docs\n    /// contain more details.\n    ///\n    /// [trait-level]: trait.Extend.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // You can extend a String with some chars:\n    /// let mut message = String::from(\"abc\");\n    ///\n    /// message.extend(['d', 'e', 'f'].iter());\n    ///\n    /// assert_eq!(\"abcdef\", &message);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T);\n}\n\n/// An iterator able to yield elements from both ends.\n///\n/// Something that implements `DoubleEndedIterator` has one extra capability\n/// over something that implements [`Iterator`]: the ability to also take\n/// `Item`s from the back, as well as the front.\n///\n/// It is important to note that both back and forth work on the same range,\n/// and do not cross: iteration is over when they meet in the middle.\n///\n/// In a similar fashion to the [`Iterator`] protocol, once a\n/// `DoubleEndedIterator` returns `None` from a `next_back()`, calling it again\n/// may or may not ever return `Some` again. `next()` and `next_back()` are\n/// interchangable for this purpose.\n///\n/// [`Iterator`]: trait.Iterator.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let numbers = vec![1, 2, 3, 4, 5, 6];\n///\n/// let mut iter = numbers.iter();\n///\n/// assert_eq!(Some(&1), iter.next());\n/// assert_eq!(Some(&6), iter.next_back());\n/// assert_eq!(Some(&5), iter.next_back());\n/// assert_eq!(Some(&2), iter.next());\n/// assert_eq!(Some(&3), iter.next());\n/// assert_eq!(Some(&4), iter.next());\n/// assert_eq!(None, iter.next());\n/// assert_eq!(None, iter.next_back());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait DoubleEndedIterator: Iterator {\n    /// Removes and returns an element from the end of the iterator.\n    ///\n    /// Returns `None` when there are no more elements.\n    ///\n    /// The [trait-level] docs contain more details.\n    ///\n    /// [trait-level]: trait.DoubleEndedIterator.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let numbers = vec![1, 2, 3, 4, 5, 6];\n    ///\n    /// let mut iter = numbers.iter();\n    ///\n    /// assert_eq!(Some(&1), iter.next());\n    /// assert_eq!(Some(&6), iter.next_back());\n    /// assert_eq!(Some(&5), iter.next_back());\n    /// assert_eq!(Some(&2), iter.next());\n    /// assert_eq!(Some(&3), iter.next());\n    /// assert_eq!(Some(&4), iter.next());\n    /// assert_eq!(None, iter.next());\n    /// assert_eq!(None, iter.next_back());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn next_back(&mut self) -> Option<Self::Item>;\n\n    /// Searches for an element of an iterator from the right that satisfies a predicate.\n    ///\n    /// `rfind()` takes a closure that returns `true` or `false`. It applies\n    /// this closure to each element of the iterator, starting at the end, and if any\n    /// of them return `true`, then `rfind()` returns [`Some(element)`]. If they all return\n    /// `false`, it returns [`None`].\n    ///\n    /// `rfind()` is short-circuiting; in other words, it will stop processing\n    /// as soon as the closure returns `true`.\n    ///\n    /// Because `rfind()` takes a reference, and many iterators iterate over\n    /// references, this leads to a possibly confusing situation where the\n    /// argument is a double reference. You can see this effect in the\n    /// examples below, with `&&x`.\n    ///\n    /// [`Some(element)`]: ../../std/option/enum.Option.html#variant.Some\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(iter_rfind)]\n    ///\n    /// let a = [1, 2, 3];\n    ///\n    /// assert_eq!(a.iter().rfind(|&&x| x == 2), Some(&2));\n    ///\n    /// assert_eq!(a.iter().rfind(|&&x| x == 5), None);\n    /// ```\n    ///\n    /// Stopping at the first `true`:\n    ///\n    /// ```\n    /// #![feature(iter_rfind)]\n    ///\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter();\n    ///\n    /// assert_eq!(iter.rfind(|&&x| x == 2), Some(&2));\n    ///\n    /// // we can still use `iter`, as there are more elements.\n    /// assert_eq!(iter.next_back(), Some(&1));\n    /// ```\n    #[inline]\n    #[unstable(feature = \"iter_rfind\", issue = \"39480\")]\n    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n        Self: Sized,\n        P: FnMut(&Self::Item) -> bool\n    {\n        while let Some(x) = self.next_back() {\n            if predicate(&x) { return Some(x) }\n        }\n        None\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n    fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }\n}\n\n/// An iterator that knows its exact length.\n///\n/// Many [`Iterator`]s don't know how many times they will iterate, but some do.\n/// If an iterator knows how many times it can iterate, providing access to\n/// that information can be useful. For example, if you want to iterate\n/// backwards, a good start is to know where the end is.\n///\n/// When implementing an `ExactSizeIterator`, You must also implement\n/// [`Iterator`]. When doing so, the implementation of [`size_hint`] *must*\n/// return the exact size of the iterator.\n///\n/// [`Iterator`]: trait.Iterator.html\n/// [`size_hint`]: trait.Iterator.html#method.size_hint\n///\n/// The [`len`] method has a default implementation, so you usually shouldn't\n/// implement it. However, you may be able to provide a more performant\n/// implementation than the default, so overriding it in this case makes sense.\n///\n/// [`len`]: #method.len\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // a finite range knows exactly how many times it will iterate\n/// let five = 0..5;\n///\n/// assert_eq!(5, five.len());\n/// ```\n///\n/// In the [module level docs][moddocs], we implemented an [`Iterator`],\n/// `Counter`. Let's implement `ExactSizeIterator` for it as well:\n///\n/// [moddocs]: index.html\n///\n/// ```\n/// # struct Counter {\n/// #     count: usize,\n/// # }\n/// # impl Counter {\n/// #     fn new() -> Counter {\n/// #         Counter { count: 0 }\n/// #     }\n/// # }\n/// # impl Iterator for Counter {\n/// #     type Item = usize;\n/// #     fn next(&mut self) -> Option<usize> {\n/// #         self.count += 1;\n/// #         if self.count < 6 {\n/// #             Some(self.count)\n/// #         } else {\n/// #             None\n/// #         }\n/// #     }\n/// # }\n/// impl ExactSizeIterator for Counter {\n///     // We can easily calculate the remaining number of iterations.\n///     fn len(&self) -> usize {\n///         5 - self.count\n///     }\n/// }\n///\n/// // And now we can use it!\n///\n/// let counter = Counter::new();\n///\n/// assert_eq!(5, counter.len());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait ExactSizeIterator: Iterator {\n    /// Returns the exact number of times the iterator will iterate.\n    ///\n    /// This method has a default implementation, so you usually should not\n    /// implement it directly. However, if you can provide a more efficient\n    /// implementation, you can do so. See the [trait-level] docs for an\n    /// example.\n    ///\n    /// This function has the same safety guarantees as the [`size_hint`]\n    /// function.\n    ///\n    /// [trait-level]: trait.ExactSizeIterator.html\n    /// [`size_hint`]: trait.Iterator.html#method.size_hint\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // a finite range knows exactly how many times it will iterate\n    /// let five = 0..5;\n    ///\n    /// assert_eq!(5, five.len());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn len(&self) -> usize {\n        let (lower, upper) = self.size_hint();\n        // Note: This assertion is overly defensive, but it checks the invariant\n        // guaranteed by the trait. If this trait were rust-internal,\n        // we could use debug_assert!; assert_eq! will check all Rust user\n        // implementations too.\n        assert_eq!(upper, Some(lower));\n        lower\n    }\n\n    /// Returns whether the iterator is empty.\n    ///\n    /// This method has a default implementation using `self.len()`, so you\n    /// don't need to implement it yourself.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(exact_size_is_empty)]\n    ///\n    /// let mut one_element = 0..1;\n    /// assert!(!one_element.is_empty());\n    ///\n    /// assert_eq!(one_element.next(), Some(0));\n    /// assert!(one_element.is_empty());\n    ///\n    /// assert_eq!(one_element.next(), None);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"exact_size_is_empty\", issue = \"35428\")]\n    fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, I: ExactSizeIterator + ?Sized> ExactSizeIterator for &'a mut I {\n    fn len(&self) -> usize {\n        (**self).len()\n    }\n    fn is_empty(&self) -> bool {\n        (**self).is_empty()\n    }\n}\n\n/// Trait to represent types that can be created by summing up an iterator.\n///\n/// This trait is used to implement the [`sum`] method on iterators. Types which\n/// implement the trait can be generated by the [`sum`] method. Like\n/// [`FromIterator`] this trait should rarely be called directly and instead\n/// interacted with through [`Iterator::sum`].\n///\n/// [`sum`]: ../../std/iter/trait.Sum.html#tymethod.sum\n/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n/// [`Iterator::sum`]: ../../std/iter/trait.Iterator.html#method.sum\n#[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\npub trait Sum<A = Self>: Sized {\n    /// Method which takes an iterator and generates `Self` from the elements by\n    /// \"summing up\" the items.\n    #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n    fn sum<I: Iterator<Item=A>>(iter: I) -> Self;\n}\n\n/// Trait to represent types that can be created by multiplying elements of an\n/// iterator.\n///\n/// This trait is used to implement the [`product`] method on iterators. Types\n/// which implement the trait can be generated by the [`product`] method. Like\n/// [`FromIterator`] this trait should rarely be called directly and instead\n/// interacted with through [`Iterator::product`].\n///\n/// [`product`]: ../../std/iter/trait.Product.html#tymethod.product\n/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n/// [`Iterator::product`]: ../../std/iter/trait.Iterator.html#method.product\n#[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\npub trait Product<A = Self>: Sized {\n    /// Method which takes an iterator and generates `Self` from the elements by\n    /// multiplying the items.\n    #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n    fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n}\n\n// NB: explicitly use Add and Mul here to inherit overflow checks\nmacro_rules! integer_sum_product {\n    (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n        #[$attr]\n        impl Sum for $a {\n            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n                iter.fold($zero, Add::add)\n            }\n        }\n\n        #[$attr]\n        impl Product for $a {\n            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n                iter.fold($one, Mul::mul)\n            }\n        }\n\n        #[$attr]\n        impl<'a> Sum<&'a $a> for $a {\n            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n                iter.fold($zero, Add::add)\n            }\n        }\n\n        #[$attr]\n        impl<'a> Product<&'a $a> for $a {\n            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n                iter.fold($one, Mul::mul)\n            }\n        }\n    )*);\n    ($($a:ty)*) => (\n        integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)+);\n        integer_sum_product!(@impls Wrapping(0), Wrapping(1),\n                #[stable(feature = \"wrapping_iter_arith\", since = \"1.14.0\")],\n                $(Wrapping<$a>)+);\n    );\n}\n\nmacro_rules! float_sum_product {\n    ($($a:ident)*) => ($(\n        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n        impl Sum for $a {\n            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n                iter.fold(0.0, |a, b| a + b)\n            }\n        }\n\n        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n        impl Product for $a {\n            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n                iter.fold(1.0, |a, b| a * b)\n            }\n        }\n\n        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n        impl<'a> Sum<&'a $a> for $a {\n            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n                iter.fold(0.0, |a, b| a + *b)\n            }\n        }\n\n        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n        impl<'a> Product<&'a $a> for $a {\n            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n                iter.fold(1.0, |a, b| a * *b)\n            }\n        }\n    )*)\n}\n\ninteger_sum_product! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\nfloat_sum_product! { f32 f64 }\n\n/// An iterator adapter that produces output as long as the underlying\n/// iterator produces `Result::Ok` values.\n///\n/// If an error is encountered, the iterator stops and the error is\n/// stored. The error may be recovered later via `reconstruct`.\nstruct ResultShunt<I, E> {\n    iter: I,\n    error: Option<E>,\n}\n\nimpl<I, T, E> ResultShunt<I, E>\n    where I: Iterator<Item = Result<T, E>>\n{\n    /// Process the given iterator as if it yielded a `T` instead of a\n    /// `Result<T, _>`. Any errors will stop the inner iterator and\n    /// the overall result will be an error.\n    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n        where F: FnMut(&mut Self) -> U\n    {\n        let mut shunt = ResultShunt::new(iter);\n        let value = f(shunt.by_ref());\n        shunt.reconstruct(value)\n    }\n\n    fn new(iter: I) -> Self {\n        ResultShunt {\n            iter: iter,\n            error: None,\n        }\n    }\n\n    /// Consume the adapter and rebuild a `Result` value. This should\n    /// *always* be called, otherwise any potential error would be\n    /// lost.\n    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n        match self.error {\n            None => Ok(val),\n            Some(e) => Err(e),\n        }\n    }\n}\n\nimpl<I, T, E> Iterator for ResultShunt<I, E>\n    where I: Iterator<Item = Result<T, E>>\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            Some(Ok(v)) => Some(v),\n            Some(Err(e)) => {\n                self.error = Some(e);\n                None\n            }\n            None => None,\n        }\n    }\n}\n\n#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\nimpl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n    where T: Sum<U>,\n{\n    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n    /// the sum of all elements is returned.\n    ///\n    /// # Examples\n    ///\n    /// This sums up every integer in a vector, rejecting the sum if a negative\n    /// element is encountered:\n    ///\n    /// ```\n    /// let v = vec![1, 2];\n    /// let res: Result<i32, &'static str> = v.iter().map(|&x: &i32|\n    ///     if x < 0 { Err(\"Negative element found\") }\n    ///     else { Ok(x) }\n    /// ).sum();\n    /// assert_eq!(res, Ok(3));\n    /// ```\n    fn sum<I>(iter: I) -> Result<T, E>\n        where I: Iterator<Item = Result<U, E>>,\n    {\n        ResultShunt::process(iter, |i| i.sum())\n    }\n}\n\n#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\nimpl<T, U, E> Product<Result<U, E>> for Result<T, E>\n    where T: Product<U>,\n{\n    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n    /// the product of all elements is returned.\n    fn product<I>(iter: I) -> Result<T, E>\n        where I: Iterator<Item = Result<U, E>>,\n    {\n        ResultShunt::process(iter, |i| i.product())\n    }\n}\n\n/// An iterator that always continues to yield `None` when exhausted.\n///\n/// Calling next on a fused iterator that has returned `None` once is guaranteed\n/// to return [`None`] again. This trait should be implemented by all iterators\n/// that behave this way because it allows for some significant optimizations.\n///\n/// Note: In general, you should not use `FusedIterator` in generic bounds if\n/// you need a fused iterator. Instead, you should just call [`Iterator::fuse`]\n/// on the iterator. If the iterator is already fused, the additional [`Fuse`]\n/// wrapper will be a no-op with no performance penalty.\n///\n/// [`None`]: ../../std/option/enum.Option.html#variant.None\n/// [`Iterator::fuse`]: ../../std/iter/trait.Iterator.html#method.fuse\n/// [`Fuse`]: ../../std/iter/struct.Fuse.html\n#[unstable(feature = \"fused\", issue = \"35602\")]\npub trait FusedIterator: Iterator {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, I: FusedIterator + ?Sized> FusedIterator for &'a mut I {}\n\n/// An iterator that reports an accurate length using size_hint.\n///\n/// The iterator reports a size hint where it is either exact\n/// (lower bound is equal to upper bound), or the upper bound is [`None`].\n/// The upper bound must only be [`None`] if the actual iterator length is\n/// larger than [`usize::MAX`].\n///\n/// The iterator must produce exactly the number of elements it reported.\n///\n/// # Safety\n///\n/// This trait must only be implemented when the contract is upheld.\n/// Consumers of this trait must inspect [`.size_hint`]s upper bound.\n///\n/// [`None`]: ../../std/option/enum.Option.html#variant.None\n/// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n/// [`.size_hint`]: ../../std/iter/trait.Iterator.html#method.size_hint\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\npub unsafe trait TrustedLen : Iterator {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, I: TrustedLen + ?Sized> TrustedLen for &'a mut I {}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Panic support for libcore\n//!\n//! The core library cannot define panicking, but it does *declare* panicking. This\n//! means that the functions inside of libcore are allowed to panic, but to be\n//! useful an upstream crate must define panicking for libcore to use. The current\n//! interface for panicking is:\n//!\n//! ```\n//! # use std::fmt;\n//! fn panic_impl(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> !\n//! # { loop {} }\n//! ```\n//!\n//! This definition allows for panicking with any general message, but it does not\n//! allow for failing with a `Box<Any>` value. The reason for this is that libcore\n//! is not allowed to allocate.\n//!\n//! This module contains a few other panicking functions, but these are just the\n//! necessary lang items for the compiler. All panics are funneled through this\n//! one function. Currently, the actual symbol is declared in the standard\n//! library, but the location of this may change over time.\n\n#![allow(dead_code, missing_docs)]\n#![unstable(feature = \"core_panic\",\n            reason = \"internal details of the implementation of the `panic!` \\\n                      and related macros\",\n            issue = \"0\")]\n\nuse fmt;\n\n#[cold] #[inline(never)] // this is the slow path, always\n#[cfg_attr(not(stage0), lang = \"panic\")]\npub fn panic(expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n    // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n    // reduce size overhead. The format_args! macro uses str's Display trait to\n    // write expr, which calls Formatter::pad, which must accommodate string\n    // truncation and padding (even though none is used here). Using\n    // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n    // output binary, saving up to a few kilobytes.\n    let (expr, file, line, col) = *expr_file_line_col;\n    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), &(file, line, col))\n}\n\n// FIXME: remove when SNAP\n#[cold] #[inline(never)]\n#[cfg(stage0)]\n#[lang = \"panic\"]\npub fn panic_old(expr_file_line: &(&'static str, &'static str, u32)) -> ! {\n    let (expr, file, line) = *expr_file_line;\n    let expr_file_line_col = (expr, file, line, 0);\n    panic(&expr_file_line_col)\n}\n\n#[cold] #[inline(never)]\n#[cfg_attr(not(stage0), lang = \"panic_bounds_check\")]\nfn panic_bounds_check(file_line_col: &(&'static str, u32, u32),\n                     index: usize, len: usize) -> ! {\n    panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\",\n                           len, index), file_line_col)\n}\n\n// FIXME: remove when SNAP\n#[cold] #[inline(never)]\n#[cfg(stage0)]\n#[lang = \"panic_bounds_check\"]\nfn panic_bounds_check_old(file_line: &(&'static str, u32),\n                     index: usize, len: usize) -> ! {\n    let (file, line) = *file_line;\n    panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\",\n                           len, index), &(file, line, 0))\n}\n\n#[cold] #[inline(never)]\npub fn panic_fmt(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> ! {\n    #[allow(improper_ctypes)]\n    extern {\n        #[lang = \"panic_fmt\"]\n        #[unwind]\n        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: u32, col: u32) -> !;\n    }\n    let (file, line, col) = *file_line_col;\n    unsafe { panic_impl(fmt, file, line, col) }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Integer and floating-point number formatting\n\n#![allow(deprecated)]\n\n// FIXME: #6220 Implement floating point formatting\n\nuse fmt;\nuse ops::{Div, Rem, Sub};\nuse str;\nuse slice;\nuse ptr;\nuse mem;\n\n#[doc(hidden)]\ntrait Int: PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n           Sub<Output=Self> + Copy {\n    fn zero() -> Self;\n    fn from_u8(u: u8) -> Self;\n    fn to_u8(&self) -> u8;\n    fn to_u16(&self) -> u16;\n    fn to_u32(&self) -> u32;\n    fn to_u64(&self) -> u64;\n    fn to_u128(&self) -> u128;\n}\n\nmacro_rules! doit {\n    ($($t:ident)*) => ($(impl Int for $t {\n        fn zero() -> $t { 0 }\n        fn from_u8(u: u8) -> $t { u as $t }\n        fn to_u8(&self) -> u8 { *self as u8 }\n        fn to_u16(&self) -> u16 { *self as u16 }\n        fn to_u32(&self) -> u32 { *self as u32 }\n        fn to_u64(&self) -> u64 { *self as u64 }\n        fn to_u128(&self) -> u128 { *self as u128 }\n    })*)\n}\ndoit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n\n/// A type that represents a specific radix\n#[doc(hidden)]\ntrait GenericRadix {\n    /// The number of digits.\n    fn base(&self) -> u8;\n\n    /// A radix-specific prefix string.\n    fn prefix(&self) -> &'static str {\n        \"\"\n    }\n\n    /// Converts an integer to corresponding radix digit.\n    fn digit(&self, x: u8) -> u8;\n\n    /// Format an integer using the radix using a formatter.\n    fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n        // The radix can be as low as 2, so we need a buffer of at least 128\n        // characters for a base 2 number.\n        let zero = T::zero();\n        let is_nonnegative = x >= zero;\n        let mut buf = [0; 128];\n        let mut curr = buf.len();\n        let base = T::from_u8(self.base());\n        if is_nonnegative {\n            // Accumulate each digit of the number from the least significant\n            // to the most significant figure.\n            for byte in buf.iter_mut().rev() {\n                let n = x % base;              // Get the current place value.\n                x = x / base;                  // Deaccumulate the number.\n                *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n                curr -= 1;\n                if x == zero {\n                    // No more digits left to accumulate.\n                    break\n                };\n            }\n        } else {\n            // Do the same as above, but accounting for two's complement.\n            for byte in buf.iter_mut().rev() {\n                let n = zero - (x % base);     // Get the current place value.\n                x = x / base;                  // Deaccumulate the number.\n                *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n                curr -= 1;\n                if x == zero {\n                    // No more digits left to accumulate.\n                    break\n                };\n            }\n        }\n        let buf = unsafe { str::from_utf8_unchecked(&buf[curr..]) };\n        f.pad_integral(is_nonnegative, self.prefix(), buf)\n    }\n}\n\n/// A binary (base 2) radix\n#[derive(Clone, PartialEq)]\nstruct Binary;\n\n/// An octal (base 8) radix\n#[derive(Clone, PartialEq)]\nstruct Octal;\n\n/// A decimal (base 10) radix\n#[derive(Clone, PartialEq)]\nstruct Decimal;\n\n/// A hexadecimal (base 16) radix, formatted with lower-case characters\n#[derive(Clone, PartialEq)]\nstruct LowerHex;\n\n/// A hexadecimal (base 16) radix, formatted with upper-case characters\n#[derive(Clone, PartialEq)]\nstruct UpperHex;\n\nmacro_rules! radix {\n    ($T:ident, $base:expr, $prefix:expr, $($x:pat => $conv:expr),+) => {\n        impl GenericRadix for $T {\n            fn base(&self) -> u8 { $base }\n            fn prefix(&self) -> &'static str { $prefix }\n            fn digit(&self, x: u8) -> u8 {\n                match x {\n                    $($x => $conv,)+\n                    x => panic!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n                }\n            }\n        }\n    }\n}\n\nradix! { Binary,    2, \"0b\", x @  0 ...  2 => b'0' + x }\nradix! { Octal,     8, \"0o\", x @  0 ...  7 => b'0' + x }\nradix! { Decimal,  10, \"\",   x @  0 ...  9 => b'0' + x }\nradix! { LowerHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n                             x @ 10 ... 15 => b'a' + (x - 10) }\nradix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n                             x @ 10 ... 15 => b'A' + (x - 10) }\n\nmacro_rules! int_base {\n    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::$Trait for $T {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                $Radix.fmt_int(*self as $U, f)\n            }\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($T:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::Debug for $T {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                fmt::Display::fmt(self, f)\n            }\n        }\n    }\n}\n\nmacro_rules! integer {\n    ($Int:ident, $Uint:ident) => {\n        int_base! { Binary   for $Int as $Uint  -> Binary }\n        int_base! { Octal    for $Int as $Uint  -> Octal }\n        int_base! { LowerHex for $Int as $Uint  -> LowerHex }\n        int_base! { UpperHex for $Int as $Uint  -> UpperHex }\n        debug! { $Int }\n\n        int_base! { Binary   for $Uint as $Uint -> Binary }\n        int_base! { Octal    for $Uint as $Uint -> Octal }\n        int_base! { LowerHex for $Uint as $Uint -> LowerHex }\n        int_base! { UpperHex for $Uint as $Uint -> UpperHex }\n        debug! { $Uint }\n    }\n}\ninteger! { isize, usize }\ninteger! { i8, u8 }\ninteger! { i16, u16 }\ninteger! { i32, u32 }\ninteger! { i64, u64 }\ninteger! { i128, u128 }\n\nconst DEC_DIGITS_LUT: &'static[u8] =\n    b\"0001020304050607080910111213141516171819\\\n      2021222324252627282930313233343536373839\\\n      4041424344454647484950515253545556575859\\\n      6061626364656667686970717273747576777879\\\n      8081828384858687888990919293949596979899\";\n\nmacro_rules! impl_Display {\n    ($($t:ident),*: $conv_fn:ident) => ($(\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl fmt::Display for $t {\n        #[allow(unused_comparisons)]\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            let is_nonnegative = *self >= 0;\n            let mut n = if is_nonnegative {\n                self.$conv_fn()\n            } else {\n                // convert the negative num to positive by summing 1 to it's 2 complement\n                (!self.$conv_fn()).wrapping_add(1)\n            };\n            let mut buf: [u8; 39] = unsafe { mem::uninitialized() };\n            let mut curr = buf.len() as isize;\n            let buf_ptr = buf.as_mut_ptr();\n            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n            unsafe {\n                // need at least 16 bits for the 4-characters-at-a-time to work.\n                if ::mem::size_of::<$t>() >= 2 {\n                    // eagerly decode 4 characters at a time\n                    while n >= 10000 {\n                        let rem = (n % 10000) as isize;\n                        n /= 10000;\n\n                        let d1 = (rem / 100) << 1;\n                        let d2 = (rem % 100) << 1;\n                        curr -= 4;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                    }\n                }\n\n                // if we reach here numbers are <= 9999, so at most 4 chars long\n                let mut n = n as isize; // possibly reduce 64bit math\n\n                // decode 2 more chars, if > 2 chars\n                if n >= 100 {\n                    let d1 = (n % 100) << 1;\n                    n /= 100;\n                    curr -= 2;\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                }\n\n                // decode last 1 or 2 chars\n                if n < 10 {\n                    curr -= 1;\n                    *buf_ptr.offset(curr) = (n as u8) + 48;\n                } else {\n                    let d1 = n << 1;\n                    curr -= 2;\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                }\n            }\n\n            let buf_slice = unsafe {\n                str::from_utf8_unchecked(\n                    slice::from_raw_parts(buf_ptr.offset(curr), buf.len() - curr as usize))\n            };\n            f.pad_integral(is_nonnegative, \"\", buf_slice)\n        }\n    })*);\n}\n\nimpl_Display!(i8, u8, i16, u16, i32, u32: to_u32);\nimpl_Display!(i64, u64: to_u64);\nimpl_Display!(i128, u128: to_u128);\n#[cfg(target_pointer_width = \"16\")]\nimpl_Display!(isize, usize: to_u16);\n#[cfg(target_pointer_width = \"32\")]\nimpl_Display!(isize, usize: to_u32);\n#[cfg(target_pointer_width = \"64\")]\nimpl_Display!(isize, usize: to_u64);\n","// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n// NOTE: The following code was generated by \"src/etc/char_private.py\",\n//       do not edit directly!\n\nfn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8],\n         normal: &[u8]) -> bool {\n    let xupper = (x >> 8) as u8;\n    let mut lowerstart = 0;\n    for &(upper, lowercount) in singletonuppers {\n        let lowerend = lowerstart + lowercount as usize;\n        if xupper == upper {\n            for &lower in &singletonlowers[lowerstart..lowerend] {\n                if lower == x as u8 {\n                    return false;\n                }\n            }\n        } else if xupper < upper {\n            break;\n        }\n        lowerstart = lowerend;\n    }\n\n    let mut x = x as i32;\n    let mut normal = normal.iter().cloned();\n    let mut current = true;\n    while let Some(v) = normal.next() {\n        let len = if v & 0x80 != 0 {\n            ((v & 0x7f) as i32) << 8 | normal.next().unwrap() as i32\n        } else {\n            v as i32\n        };\n        x -= len;\n        if x < 0 {\n            break;\n        }\n        current = !current;\n    }\n    current\n}\n\npub fn is_printable(x: char) -> bool {\n    let x = x as u32;\n    let lower = x as u16;\n    if x < 0x10000 {\n        check(lower, SINGLETONS0U, SINGLETONS0L, NORMAL0)\n    } else if x < 0x20000 {\n        check(lower, SINGLETONS1U, SINGLETONS1L, NORMAL1)\n    } else {\n        if 0x2a6d7 <= x && x < 0x2a700 {\n            return false;\n        }\n        if 0x2b735 <= x && x < 0x2b740 {\n            return false;\n        }\n        if 0x2b81e <= x && x < 0x2b820 {\n            return false;\n        }\n        if 0x2cea2 <= x && x < 0x2f800 {\n            return false;\n        }\n        if 0x2fa1e <= x && x < 0xe0100 {\n            return false;\n        }\n        if 0xe01f0 <= x && x < 0x110000 {\n            return false;\n        }\n        true\n    }\n}\n\nconst SINGLETONS0U: &'static [(u8, u8)] = &[\n    (0x00, 1),\n    (0x03, 5),\n    (0x05, 8),\n    (0x06, 3),\n    (0x07, 4),\n    (0x08, 7),\n    (0x09, 16),\n    (0x0a, 27),\n    (0x0b, 24),\n    (0x0c, 22),\n    (0x0d, 20),\n    (0x0e, 22),\n    (0x0f, 4),\n    (0x10, 3),\n    (0x12, 18),\n    (0x13, 9),\n    (0x16, 1),\n    (0x17, 5),\n    (0x18, 2),\n    (0x19, 3),\n    (0x1a, 7),\n    (0x1c, 1),\n    (0x1f, 22),\n    (0x20, 3),\n    (0x23, 1),\n    (0x2b, 5),\n    (0x2c, 2),\n    (0x2d, 11),\n    (0x2e, 1),\n    (0x30, 3),\n    (0x31, 1),\n    (0x32, 2),\n    (0xa7, 1),\n    (0xa8, 2),\n    (0xa9, 2),\n    (0xaa, 4),\n    (0xab, 8),\n    (0xfa, 2),\n    (0xfb, 5),\n    (0xfd, 4),\n    (0xfe, 3),\n    (0xff, 9),\n];\nconst SINGLETONS0L: &'static [u8] = &[\n    0xad, 0x78, 0x79, 0x8b, 0x8d, 0xa2, 0x30, 0x57,\n    0x58, 0x60, 0x88, 0x8b, 0x8c, 0x90, 0x1c, 0x1d,\n    0xdd, 0x0e, 0x0f, 0x4b, 0x4c, 0x2e, 0x2f, 0x3f,\n    0x5c, 0x5d, 0xb5, 0xe2, 0x84, 0x8d, 0x8e, 0x91,\n    0x92, 0xa9, 0xb1, 0xba, 0xbb, 0xc5, 0xc6, 0xc9,\n    0xca, 0xde, 0xe4, 0xe5, 0x04, 0x11, 0x12, 0x29,\n    0x31, 0x34, 0x37, 0x3a, 0x3b, 0x3d, 0x49, 0x4a,\n    0x5d, 0x84, 0x8e, 0x92, 0xa9, 0xb1, 0xb4, 0xba,\n    0xbb, 0xc6, 0xca, 0xce, 0xcf, 0xe4, 0xe5, 0x04,\n    0x0d, 0x0e, 0x11, 0x12, 0x29, 0x31, 0x34, 0x3a,\n    0x3b, 0x45, 0x46, 0x49, 0x4a, 0x5e, 0x64, 0x65,\n    0x84, 0x91, 0x9b, 0x9d, 0xc9, 0xce, 0xcf, 0x04,\n    0x0d, 0x11, 0x29, 0x45, 0x49, 0x57, 0x64, 0x65,\n    0x84, 0x8d, 0x91, 0xa9, 0xb4, 0xba, 0xbb, 0xc5,\n    0xc9, 0xdf, 0xe4, 0xe5, 0xf0, 0x04, 0x0d, 0x11,\n    0x3b, 0x3c, 0x45, 0x49, 0x64, 0x65, 0x80, 0x81,\n    0x84, 0xb2, 0xbc, 0xbe, 0xbf, 0xd5, 0xd7, 0xf0,\n    0xf1, 0x83, 0x85, 0x86, 0x89, 0x8b, 0x8c, 0x98,\n    0xa0, 0xa4, 0xa6, 0xa8, 0xa9, 0xac, 0xba, 0xbe,\n    0xbf, 0xc5, 0xc7, 0xce, 0xcf, 0xda, 0xdb, 0x48,\n    0x98, 0xbd, 0xcd, 0xc6, 0xce, 0xcf, 0x49, 0x4e,\n    0x4f, 0x57, 0x59, 0x5e, 0x5f, 0x89, 0x8e, 0x8f,\n    0xb1, 0xb6, 0xb7, 0xbf, 0xc1, 0xc6, 0xc7, 0xd7,\n    0x11, 0x16, 0x17, 0x5b, 0x5c, 0xf6, 0xf7, 0xfe,\n    0xff, 0x80, 0x0d, 0x6d, 0x71, 0xde, 0xdf, 0x0e,\n    0x0f, 0x1f, 0x6e, 0x6f, 0x1c, 0x1d, 0x5f, 0x7d,\n    0x7e, 0xae, 0xaf, 0xf7, 0x16, 0x17, 0x1e, 0x1f,\n    0x46, 0x47, 0x4e, 0x4f, 0x58, 0x5a, 0x5c, 0x5e,\n    0x7e, 0x7f, 0xb5, 0xc5, 0xd4, 0xd5, 0xdc, 0xf0,\n    0xf1, 0xf5, 0x72, 0x73, 0x8f, 0xff, 0x74, 0x75,\n    0x96, 0x97, 0xc9, 0x2f, 0x5f, 0x26, 0x2e, 0x2f,\n    0xa7, 0xaf, 0xb7, 0xbf, 0xc7, 0xcf, 0xd7, 0xdf,\n    0x9a, 0x40, 0x97, 0x98, 0x8f, 0x1f, 0xff, 0xaf,\n    0xfe, 0xff, 0xce, 0xff, 0x4e, 0x4f, 0x5a, 0x5b,\n    0x07, 0x08, 0x0f, 0x10, 0x27, 0x2f, 0xee, 0xef,\n    0x6e, 0x6f, 0x37, 0x3d, 0x3f, 0x42, 0x45, 0x90,\n    0x91, 0xfe, 0xff, 0x53, 0x67, 0x75, 0xc8, 0xc9,\n    0xd0, 0xd1, 0xd8, 0xd9, 0xe7, 0xfe, 0xff,\n];\nconst SINGLETONS1U: &'static [(u8, u8)] = &[\n    (0x00, 6),\n    (0x01, 1),\n    (0x03, 1),\n    (0x04, 2),\n    (0x08, 8),\n    (0x09, 2),\n    (0x0a, 3),\n    (0x0b, 2),\n    (0x10, 1),\n    (0x11, 4),\n    (0x12, 5),\n    (0x13, 18),\n    (0x14, 2),\n    (0x15, 2),\n    (0x1c, 5),\n    (0x24, 1),\n    (0x6a, 3),\n    (0x6b, 2),\n    (0xbc, 2),\n    (0xd1, 2),\n    (0xd4, 12),\n    (0xd5, 9),\n    (0xd6, 2),\n    (0xd7, 2),\n    (0xda, 1),\n    (0xe0, 5),\n    (0xe8, 2),\n    (0xee, 32),\n    (0xf0, 4),\n    (0xf1, 1),\n    (0xf9, 4),\n];\nconst SINGLETONS1L: &'static [u8] = &[\n    0x0c, 0x27, 0x3b, 0x3e, 0x4e, 0x4f, 0x8f, 0x9e,\n    0x9e, 0x9f, 0x06, 0x07, 0x09, 0x36, 0x3d, 0x3e,\n    0x56, 0xf3, 0xd0, 0xd1, 0x04, 0x14, 0x18, 0x56,\n    0x57, 0xbd, 0x35, 0xce, 0xcf, 0xe0, 0x12, 0x87,\n    0x89, 0x8e, 0x9e, 0x04, 0x0d, 0x0e, 0x11, 0x12,\n    0x29, 0x31, 0x34, 0x3a, 0x3b, 0x45, 0x46, 0x49,\n    0x4a, 0x4e, 0x4f, 0x64, 0x65, 0x5a, 0x5c, 0xb6,\n    0xb7, 0x09, 0x37, 0x90, 0x91, 0xa8, 0x6f, 0x5f,\n    0xee, 0xef, 0x5a, 0x62, 0x9a, 0x9b, 0x27, 0x28,\n    0x55, 0x9d, 0xa0, 0xa1, 0xa3, 0xa4, 0xa7, 0xa8,\n    0xad, 0xba, 0xbc, 0xc4, 0x06, 0x0b, 0x0c, 0x15,\n    0x1d, 0x3a, 0x3f, 0x45, 0x51, 0xa6, 0xa7, 0xcc,\n    0xcd, 0xa0, 0x07, 0x19, 0x1a, 0x22, 0x25, 0xc5,\n    0xc6, 0x04, 0x20, 0x23, 0x25, 0x26, 0x28, 0x33,\n    0x38, 0x3a, 0x48, 0x4a, 0x4c, 0x50, 0x53, 0x55,\n    0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x63, 0x65,\n    0x66, 0x6b, 0x73, 0x78, 0x7d, 0x7f, 0x8a, 0xa4,\n    0xaa, 0xaf, 0xb0, 0xc0, 0xd0, 0x2f, 0x1f, 0x31,\n    0x32, 0x3f,\n];\nconst NORMAL0: &'static [u8] = &[\n    0x00, 0x20,\n    0x5f, 0x22,\n    0x82, 0xdf, 0x04,\n    0x82, 0x44, 0x08,\n    0x1b, 0x05,\n    0x05, 0x11,\n    0x81, 0xac, 0x0e,\n    0x3b, 0x05,\n    0x5f, 0x41,\n    0x1e, 0x16,\n    0x80, 0xdf, 0x03,\n    0x19, 0x08,\n    0x01, 0x04,\n    0x20, 0x05,\n    0x0a, 0x04,\n    0x34, 0x04,\n    0x07, 0x03,\n    0x01, 0x07,\n    0x06, 0x07,\n    0x10, 0x0b,\n    0x50, 0x0f,\n    0x12, 0x07,\n    0x01, 0x07,\n    0x4d, 0x08,\n    0x02, 0x04,\n    0x1c, 0x0a,\n    0x09, 0x03,\n    0x08, 0x03,\n    0x07, 0x03,\n    0x02, 0x03,\n    0x03, 0x03,\n    0x0c, 0x04,\n    0x05, 0x03,\n    0x0b, 0x06,\n    0x01, 0x0e,\n    0x15, 0x05,\n    0x3a, 0x03,\n    0x11, 0x07,\n    0x06, 0x05,\n    0x10, 0x08,\n    0x56, 0x07,\n    0x02, 0x07,\n    0x15, 0x0e,\n    0x4f, 0x04,\n    0x43, 0x03,\n    0x2d, 0x03,\n    0x01, 0x04,\n    0x11, 0x06,\n    0x0f, 0x0c,\n    0x3a, 0x04,\n    0x1d, 0x25,\n    0x0d, 0x06,\n    0x4c, 0x20,\n    0x6d, 0x04,\n    0x6a, 0x25,\n    0x80, 0xc8, 0x05,\n    0x82, 0xb0, 0x03,\n    0x1a, 0x06,\n    0x82, 0xfd, 0x03,\n    0x59, 0x07,\n    0x15, 0x0b,\n    0x17, 0x09,\n    0x14, 0x0c,\n    0x14, 0x0c,\n    0x6a, 0x06,\n    0x0a, 0x06,\n    0x1a, 0x06,\n    0x58, 0x08,\n    0x2b, 0x05,\n    0x46, 0x0a,\n    0x2c, 0x04,\n    0x0c, 0x04,\n    0x01, 0x03,\n    0x31, 0x0b,\n    0x2c, 0x04,\n    0x1a, 0x06,\n    0x0b, 0x03,\n    0x80, 0xac, 0x06,\n    0x0a, 0x06,\n    0x1f, 0x41,\n    0x4c, 0x04,\n    0x2d, 0x03,\n    0x74, 0x08,\n    0x3c, 0x03,\n    0x0f, 0x03,\n    0x3c, 0x37,\n    0x08, 0x08,\n    0x2a, 0x06,\n    0x80, 0xf6, 0x05,\n    0x82, 0x04, 0x11,\n    0x18, 0x08,\n    0x2f, 0x11,\n    0x2d, 0x03,\n    0x1f, 0x11,\n    0x21, 0x0f,\n    0x80, 0x8c, 0x04,\n    0x82, 0x97, 0x19,\n    0x0b, 0x15,\n    0x87, 0x5a, 0x03,\n    0x15, 0x1a,\n    0x04, 0x10,\n    0x80, 0xf4, 0x05,\n    0x2f, 0x05,\n    0x3b, 0x07,\n    0x02, 0x0e,\n    0x18, 0x09,\n    0x80, 0xa5, 0x3b,\n    0x74, 0x0c,\n    0x80, 0xd6, 0x1a,\n    0x0c, 0x05,\n    0x80, 0xff, 0x05,\n    0x29, 0x03,\n    0x80, 0x8a, 0x05,\n    0x24, 0x0c,\n    0x9b, 0xc6, 0x0a,\n    0xd2, 0x16, 0x2a,\n    0x84, 0x8d, 0x03,\n    0x37, 0x09,\n    0x81, 0x5c, 0x14,\n    0x80, 0xb8, 0x08,\n    0x80, 0xb8, 0x3f,\n    0x35, 0x04,\n    0x0a, 0x06,\n    0x38, 0x08,\n    0x46, 0x08,\n    0x0c, 0x06,\n    0x74, 0x0b,\n    0x1e, 0x03,\n    0x5a, 0x04,\n    0x59, 0x09,\n    0x80, 0x83, 0x18,\n    0x1c, 0x0a,\n    0x16, 0x09,\n    0x46, 0x0a,\n    0x80, 0x8a, 0x06,\n    0xab, 0xa4, 0x0c,\n    0x17, 0x04,\n    0x31, 0xa1, 0x04,\n    0x81, 0xda, 0x26,\n    0x07, 0x0c,\n    0x05, 0x05,\n    0x80, 0xa5, 0x11,\n    0x81, 0x6d, 0x10,\n    0x78, 0x28,\n    0x2a, 0x06,\n    0x4c, 0x04,\n    0x80, 0x8d, 0x04,\n    0x80, 0xbe, 0x03,\n    0x1b, 0x03,\n    0x0f, 0x0d,\n];\nconst NORMAL1: &'static [u8] = &[\n    0x5e, 0x22,\n    0x7b, 0x05,\n    0x03, 0x04,\n    0x2d, 0x03,\n    0x65, 0x04,\n    0x01, 0x2f,\n    0x2e, 0x80, 0x82,\n    0x1d, 0x03,\n    0x31, 0x0f,\n    0x1c, 0x04,\n    0x24, 0x0c,\n    0x1b, 0x05,\n    0x2b, 0x05,\n    0x44, 0x04,\n    0x0e, 0x2a,\n    0x80, 0xaa, 0x06,\n    0x24, 0x04,\n    0x24, 0x04,\n    0x28, 0x08,\n    0x34, 0x0b,\n    0x01, 0x80, 0x90,\n    0x81, 0x37, 0x09,\n    0x16, 0x0a,\n    0x08, 0x80, 0x98,\n    0x39, 0x03,\n    0x63, 0x08,\n    0x09, 0x30,\n    0x16, 0x05,\n    0x21, 0x03,\n    0x1b, 0x05,\n    0x01, 0x40,\n    0x38, 0x04,\n    0x4b, 0x05,\n    0x28, 0x04,\n    0x03, 0x04,\n    0x09, 0x08,\n    0x09, 0x07,\n    0x40, 0x20,\n    0x27, 0x04,\n    0x0c, 0x09,\n    0x36, 0x03,\n    0x3a, 0x05,\n    0x1a, 0x07,\n    0x04, 0x0c,\n    0x07, 0x50,\n    0x49, 0x37,\n    0x33, 0x0d,\n    0x33, 0x07,\n    0x06, 0x81, 0x60,\n    0x1f, 0x81, 0x81,\n    0x4e, 0x04,\n    0x1e, 0x0f,\n    0x43, 0x0e,\n    0x19, 0x07,\n    0x0a, 0x06,\n    0x44, 0x0c,\n    0x27, 0x09,\n    0x75, 0x0b,\n    0x3f, 0x41,\n    0x2a, 0x06,\n    0x3b, 0x05,\n    0x0a, 0x06,\n    0x51, 0x06,\n    0x01, 0x05,\n    0x10, 0x03,\n    0x05, 0x80, 0x8b,\n    0x5e, 0x22,\n    0x48, 0x08,\n    0x0a, 0x80, 0xa6,\n    0x5e, 0x22,\n    0x45, 0x0b,\n    0x0a, 0x06,\n    0x0d, 0x13,\n    0x38, 0x08,\n    0x0a, 0x36,\n    0x1a, 0x03,\n    0x0f, 0x04,\n    0x10, 0x81, 0x60,\n    0x53, 0x0c,\n    0x01, 0x81, 0xc0,\n    0x39, 0x81, 0x07,\n    0x46, 0x0a,\n    0x1d, 0x03,\n    0x47, 0x83, 0x49,\n    0x83, 0x9a, 0x66,\n    0x75, 0x0b,\n    0x80, 0xc4, 0x8a, 0xbc,\n    0x84, 0x2f, 0x8f, 0xd1,\n    0x82, 0x47, 0xa1, 0xb9,\n    0x82, 0x39, 0x07,\n    0x2a, 0x04,\n    0x02, 0x60,\n    0x26, 0x0a,\n    0x46, 0x0a,\n    0x28, 0x05,\n    0x13, 0x83, 0x70,\n    0x45, 0x0b,\n    0x2f, 0x10,\n    0x11, 0x40,\n    0x01, 0x1f,\n    0x97, 0xed, 0x13,\n    0x82, 0xf3, 0xa5, 0x0d,\n    0x02, 0x8b, 0xfe,\n    0x6b, 0x05,\n    0x0d, 0x03,\n    0x09, 0x07,\n    0x10, 0x93, 0x60,\n    0x80, 0xf6, 0x0a,\n    0x73, 0x08,\n    0x6e, 0x17,\n    0x46, 0x80, 0xba,\n    0x57, 0x09,\n    0x12, 0x80, 0x8e,\n    0x81, 0x47, 0x03,\n    0x85, 0x42, 0x0f,\n    0x15, 0x85, 0x50,\n    0x2b, 0x87, 0xd5,\n    0x80, 0xd7, 0x29,\n    0x4b, 0x05,\n    0x0a, 0x04,\n    0x02, 0x84, 0xa0,\n    0x3c, 0x06,\n    0x01, 0x04,\n    0x55, 0x05,\n    0x1b, 0x34,\n    0x02, 0x81, 0x0e,\n    0x2c, 0x04,\n    0x64, 0x0c,\n    0x56, 0x0a,\n    0x0d, 0x03,\n    0x5c, 0x04,\n    0x3d, 0x39,\n    0x1d, 0x0d,\n    0x2c, 0x04,\n    0x09, 0x07,\n    0x02, 0x80, 0xae,\n    0x83, 0xd3, 0x0d,\n    0x0d, 0x03,\n    0x07, 0x09,\n    0x74, 0x0c,\n    0x55, 0x2b,\n    0x0c, 0x04,\n    0x38, 0x08,\n    0x0a, 0x06,\n    0x28, 0x08,\n    0x1e, 0x62,\n    0x18, 0x08,\n    0x1c, 0x04,\n    0x0f, 0x21,\n    0x12, 0x2e,\n    0x01, 0x86, 0x3f,\n];\n","// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse fmt;\n\n/// An unbounded range. Use `..` (two dots) for its shorthand.\n///\n/// Its primary use case is slicing index. It cannot serve as an iterator\n/// because it doesn't have a starting point.\n///\n/// # Examples\n///\n/// The `..` syntax is a `RangeFull`:\n///\n/// ```\n/// assert_eq!((..), std::ops::RangeFull);\n/// ```\n///\n/// It does not have an `IntoIterator` implementation, so you can't use it in a\n/// `for` loop directly. This won't compile:\n///\n/// ```compile_fail,E0277\n/// for i in .. {\n///    // ...\n/// }\n/// ```\n///\n/// Used as a slicing index, `RangeFull` produces the full array as a slice.\n///\n/// ```\n/// let arr = [0, 1, 2, 3];\n/// assert_eq!(arr[ .. ], [0,1,2,3]);  // RangeFull\n/// assert_eq!(arr[ ..3], [0,1,2  ]);\n/// assert_eq!(arr[1.. ], [  1,2,3]);\n/// assert_eq!(arr[1..3], [  1,2  ]);\n/// ```\n#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RangeFull;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for RangeFull {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        write!(fmt, \"..\")\n    }\n}\n\n/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.\n/// Use `start..end` (two dots) for its shorthand.\n///\n/// See the [`contains`](#method.contains) method for its characterization.\n///\n/// # Examples\n///\n/// ```\n/// fn main() {\n///     assert_eq!((3..5), std::ops::Range{ start: 3, end: 5 });\n///     assert_eq!(3+4+5, (3..6).sum());\n///\n///     let arr = [0, 1, 2, 3];\n///     assert_eq!(arr[ .. ], [0,1,2,3]);\n///     assert_eq!(arr[ ..3], [0,1,2  ]);\n///     assert_eq!(arr[1.. ], [  1,2,3]);\n///     assert_eq!(arr[1..3], [  1,2  ]);  // Range\n/// }\n/// ```\n#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Range<Idx> {\n    /// The lower bound of the range (inclusive).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub start: Idx,\n    /// The upper bound of the range (exclusive).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub end: Idx,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n    }\n}\n\n#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\nimpl<Idx: PartialOrd<Idx>> Range<Idx> {\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(range_contains)]\n    /// fn main() {\n    ///     assert!( ! (3..5).contains(2));\n    ///     assert!(   (3..5).contains(3));\n    ///     assert!(   (3..5).contains(4));\n    ///     assert!( ! (3..5).contains(5));\n    ///\n    ///     assert!( ! (3..3).contains(3));\n    ///     assert!( ! (3..2).contains(3));\n    /// }\n    /// ```\n    pub fn contains(&self, item: Idx) -> bool {\n        (self.start <= item) && (item < self.end)\n    }\n}\n\n/// A range which is only bounded below: { x | start <= x }.\n/// Use `start..` for its shorthand.\n///\n/// See the [`contains`](#method.contains) method for its characterization.\n///\n/// Note: Currently, no overflow checking is done for the iterator\n/// implementation; if you use an integer range and the integer overflows, it\n/// might panic in debug mode or create an endless loop in release mode. This\n/// overflow behavior might change in the future.\n///\n/// # Examples\n///\n/// ```\n/// fn main() {\n///     assert_eq!((2..), std::ops::RangeFrom{ start: 2 });\n///     assert_eq!(2+3+4, (2..).take(3).sum());\n///\n///     let arr = [0, 1, 2, 3];\n///     assert_eq!(arr[ .. ], [0,1,2,3]);\n///     assert_eq!(arr[ ..3], [0,1,2  ]);\n///     assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n///     assert_eq!(arr[1..3], [  1,2  ]);\n/// }\n/// ```\n#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RangeFrom<Idx> {\n    /// The lower bound of the range (inclusive).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub start: Idx,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        write!(fmt, \"{:?}..\", self.start)\n    }\n}\n\n#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\nimpl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(range_contains)]\n    /// fn main() {\n    ///     assert!( ! (3..).contains(2));\n    ///     assert!(   (3..).contains(3));\n    ///     assert!(   (3..).contains(1_000_000_000));\n    /// }\n    /// ```\n    pub fn contains(&self, item: Idx) -> bool {\n        (self.start <= item)\n    }\n}\n\n/// A range which is only bounded above: { x | x < end }.\n/// Use `..end` (two dots) for its shorthand.\n///\n/// See the [`contains`](#method.contains) method for its characterization.\n///\n/// It cannot serve as an iterator because it doesn't have a starting point.\n///\n/// # Examples\n///\n/// The `..{integer}` syntax is a `RangeTo`:\n///\n/// ```\n/// assert_eq!((..5), std::ops::RangeTo{ end: 5 });\n/// ```\n///\n/// It does not have an `IntoIterator` implementation, so you can't use it in a\n/// `for` loop directly. This won't compile:\n///\n/// ```compile_fail,E0277\n/// for i in ..5 {\n///     // ...\n/// }\n/// ```\n///\n/// When used as a slicing index, `RangeTo` produces a slice of all array\n/// elements before the index indicated by `end`.\n///\n/// ```\n/// let arr = [0, 1, 2, 3];\n/// assert_eq!(arr[ .. ], [0,1,2,3]);\n/// assert_eq!(arr[ ..3], [0,1,2  ]);  // RangeTo\n/// assert_eq!(arr[1.. ], [  1,2,3]);\n/// assert_eq!(arr[1..3], [  1,2  ]);\n/// ```\n#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RangeTo<Idx> {\n    /// The upper bound of the range (exclusive).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub end: Idx,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        write!(fmt, \"..{:?}\", self.end)\n    }\n}\n\n#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\nimpl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(range_contains)]\n    /// fn main() {\n    ///     assert!(   (..5).contains(-1_000_000_000));\n    ///     assert!(   (..5).contains(4));\n    ///     assert!( ! (..5).contains(5));\n    /// }\n    /// ```\n    pub fn contains(&self, item: Idx) -> bool {\n        (item < self.end)\n    }\n}\n\n/// An inclusive range which is bounded at both ends: { x | start <= x <= end }.\n/// Use `start...end` (three dots) for its shorthand.\n///\n/// See the [`contains`](#method.contains) method for its characterization.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(inclusive_range,inclusive_range_syntax)]\n/// fn main() {\n///     assert_eq!((3...5), std::ops::RangeInclusive{ start: 3, end: 5 });\n///     assert_eq!(3+4+5, (3...5).sum());\n///\n///     let arr = [0, 1, 2, 3];\n///     assert_eq!(arr[ ...2], [0,1,2  ]);\n///     assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n/// }\n/// ```\n#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\npub struct RangeInclusive<Idx> {\n    /// The lower bound of the range (inclusive).\n    #[unstable(feature = \"inclusive_range\",\n               reason = \"recently added, follows RFC\",\n               issue = \"28237\")]\n    pub start: Idx,\n    /// The upper bound of the range (inclusive).\n    #[unstable(feature = \"inclusive_range\",\n               reason = \"recently added, follows RFC\",\n               issue = \"28237\")]\n    pub end: Idx,\n}\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        write!(fmt, \"{:?}...{:?}\", self.start, self.end)\n    }\n}\n\n#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\nimpl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(range_contains,inclusive_range_syntax)]\n    /// fn main() {\n    ///     assert!( ! (3...5).contains(2));\n    ///     assert!(   (3...5).contains(3));\n    ///     assert!(   (3...5).contains(4));\n    ///     assert!(   (3...5).contains(5));\n    ///     assert!( ! (3...5).contains(6));\n    ///\n    ///     assert!(   (3...3).contains(3));\n    ///     assert!( ! (3...2).contains(3));\n    /// }\n    /// ```\n    pub fn contains(&self, item: Idx) -> bool {\n        self.start <= item && item <= self.end\n    }\n}\n\n/// An inclusive range which is only bounded above: { x | x <= end }.\n/// Use `...end` (three dots) for its shorthand.\n///\n/// See the [`contains`](#method.contains) method for its characterization.\n///\n/// It cannot serve as an iterator because it doesn't have a starting point.\n///\n/// # Examples\n///\n/// The `...{integer}` syntax is a `RangeToInclusive`:\n///\n/// ```\n/// #![feature(inclusive_range,inclusive_range_syntax)]\n/// assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n/// ```\n///\n/// It does not have an `IntoIterator` implementation, so you can't use it in a\n/// `for` loop directly. This won't compile:\n///\n/// ```compile_fail,E0277\n/// #![feature(inclusive_range_syntax)]\n/// for i in ...5 {\n///     // ...\n/// }\n/// ```\n///\n/// When used as a slicing index, `RangeToInclusive` produces a slice of all\n/// array elements up to and including the index indicated by `end`.\n///\n/// ```\n/// #![feature(inclusive_range_syntax)]\n/// let arr = [0, 1, 2, 3];\n/// assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n/// assert_eq!(arr[1...2], [  1,2  ]);\n/// ```\n#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\npub struct RangeToInclusive<Idx> {\n    /// The upper bound of the range (inclusive)\n    #[unstable(feature = \"inclusive_range\",\n               reason = \"recently added, follows RFC\",\n               issue = \"28237\")]\n    pub end: Idx,\n}\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        write!(fmt, \"...{:?}\", self.end)\n    }\n}\n\n#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\nimpl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(range_contains,inclusive_range_syntax)]\n    /// fn main() {\n    ///     assert!(   (...5).contains(-1_000_000_000));\n    ///     assert!(   (...5).contains(5));\n    ///     assert!( ! (...5).contains(6));\n    /// }\n    /// ```\n    pub fn contains(&self, item: Idx) -> bool {\n        (item <= self.end)\n    }\n}\n\n// RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n// because underflow would be possible with (..0).into()\n"]}