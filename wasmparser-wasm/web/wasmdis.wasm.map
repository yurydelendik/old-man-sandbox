{"version":3,"sources":["rust-src://wasmdis0-cb7df6f5b7cc54c9b9c620d3cba78e78.rs","rust-src:///Users/yury/Work/rust/src/liballoc/raw_vec.rs","rust-src://<assert macros>","rust-src:///Users/yury/Work/rust/src/libcore/mem.rs","rust-src:///Users/yury/Work/rust/src/liballoc/heap.rs","rust-src://<panic macros>","rust-src:///Users/yury/Work/rust/src/liballoc/allocator.rs","rust-src:///Users/yury/Work/rust/src/libcore/num/mod.rs","rust-src:///Users/yury/Work/rust/src/libcore/cmp.rs","rust-src:///Users/yury/Work/rust/src/libcore/ptr.rs","rust-src:///Users/yury/Work/rust/src/libcore/option.rs","rust-src:///Users/yury/.cargo/git/checkouts/wasmtext-50af5d6b2afa704f/ab3fbe5/src/writer.rs","rust-src:///Users/yury/Work/rust/src/liballoc/vec.rs","rust-src:///Users/yury/Work/rust/src/libcore/slice/mod.rs","rust-src:///Users/yury/Work/rust/src/libcore/result.rs","rust-src:///Users/yury/.cargo/registry/src/github.com-1ecc6299db9ec823/wasmparser-0.14.1/src/parser.rs","rust-src:///Users/yury/Work/rust/src/liballoc/slice.rs","rust-src:///Users/yury/Work/rust/src/libcore/iter/range.rs","rust-src:///Users/yury/Work/rust/src/libcore/fmt/mod.rs","rust-src:///Users/yury/Work/rust/src/liballoc/string.rs","rust-src:///Users/yury/Work/rust/src/libcore/macros.rs","rust-src:///Users/yury/.cargo/registry/src/github.com-1ecc6299db9ec823/wasmparser-0.14.1/src/parser.rs","rust-src:///Users/yury/Work/rust/src/libstd/io/impls.rs","rust-src:///Users/yury/Work/rust/src/libcore/char.rs","rust-src:///Users/yury/Work/rust/src/libstd/io/mod.rs","rust-src:///Users/yury/Work/rust/src/libcore/lib.rs","rust-src:///Users/yury/Work/rust/src/libstd/panicking.rs","rust-src:///Users/yury/Work/rust/src/liballoc/boxed.rs","rust-src:///Users/yury/Work/rust/src/libcore/convert.rs","rust-src:///Users/yury/Work/rust/src/libstd/io/error.rs","rust-src:///Users/yury/Work/rust/src/libcore/any.rs","rust-src:///Users/yury/Work/old-man-sandbox/wasmparser-wasm/src/wasmdis.rs"],"names":[],"mappings":"wpDC+RA,yBA/DA,UC5NA,YDmTA,OE2oBA,wEC9zBA,uBH+KA,OApTA,OGoFA,YHsPA,OACA,UAEA,YI1UA,QD+FA,WH8LA,uBA/DA,UC5NA,YDmTA,OE2oBA,wECp0BA,mBA7BA,GAdA,eHsPA,OACA,UAEA,YI1UA,QD+FA,QH8LA,yBA/DA,UC5NA,YDmTA,OE2oBA,wEC9zBA,uBH+KA,OApTA,OGoFA,WHsPA,OACA,UAEA,YI1UA,QD+FA,WH8LA,yBA/DA,UC5NA,YDmTA,OE2oBA,wEC9zBA,uBH+KA,OApTA,OGoFA,YHsPA,OACA,UAEA,YI1UA,QD+FA,WHyZA,uBASA,eM8hCA,YL7hDA,sBALA,SDkhBA,OEibA,wEC9zBA,kCArIA,IAoFA,8CAGA,SKyjCA,MRrnBA,OACA,WAEA,YShPA,QL3SA,QD+FA,UO62BA,4CAEA,eAj9BA,idA0LA,cACA,wBADA,cACA,wBADA,cACA,2BADA,cACA,wBAu5BA,UCxIA,2BD8HA,eAFA,UA54BA,cACA,2BAkyBA,UAFA,oBAjyBA,cACA,2BCi9BA,YDl9BA,cACA,2BADA,cACA,wBADA,cACA,wBADA,cACA,wBAi0BA,oBADA,oBAj0BA,cACA,2BAi4BA,eAJA,UA93BA,cACA,2BA3LA,EAgpCA,eACA,UAIA,cA39BA,cACA,2BJ24CA,uBLjkDA,WDkMA,eGnHA,SAcA,GO6kCA,wCGUA,WHKA,UApgCA,cACA,2BADA,cACA,2BADA,cACA,wBADA,cACA,wBADA,cACA,2BADA,cACA,wBADA,cACA,wBADA,cACA,2BAEA,eAIA,iBAo/BA,kBGIA,WH5/BA,eAIA,iBA2+BA,kBGaA,WH5/BA,eAIA,mBAy/BA,iBACA,4BAjgCA,cACA,2BG8/BA,WH5/BA,eAIA,iBA65BA,kBG2FA,WH5/BA,eAIA,iBAjMA,EAykCA,iBACA,QCmlBA,OXt9CA,OUbA,cACA,2BG8/BA,WH5/BA,eAIA,iBAjMA,EA+9BA,iBACA,2BAtyBA,cACA,2BG8/BA,WH5/BA,eAIA,iBAmgCA,kBGXA,WH5/BA,eAIA,iBAqxBA,kBGmOA,WH5/BA,eAIA,iBAixBA,kBGuOA,WH5/BA,eAIA,iBAjMA,EAggCA,iBAtDA,2BAhxBA,cACA,2BG8/BA,WH5/BA,eAIA,iBAjMA,EA6jCA,iBACA,MC+lBA,OXt9CA,OUbA,cACA,2BG8/BA,WH5/BA,eAIA,mBA8/BA,iBACA,yBAtgCA,cACA,2BG8/BA,WH5/BA,eAIA,mBAg6BA,iBAGA,mBCyjBA,OXt9CA,OUbA,cACA,2BG8/BA,WH5/BA,eAIA,mBA28BA,iBACA,iBG4CA,WH5/BA,eAIA,iBAsgCA,kBGdA,WH5/BA,eAIA,iBAjMA,EA+iCA,iBC6FA,YGvkCA,UAmDA,eACA,SAJA,2DHq1BA,sBE+OA,WH5/BA,eAIA,iBAw+BA,kBGgBA,WH5/BA,eAIA,iBAi/BA,kBGOA,WH5/BA,eAIA,mBAq5BA,iBAEA,eACA,MCokBA,OXt9CA,OUbA,cACA,2BG8/BA,WAzrCA,KDwsBA,gBAxsBA,6BJgSA,OAhSA,IG4oCA,UDj9BA,wBAEA,kBAIA,iBA0gCA,iBACA,yBF9lBA,OGorDA,UAlyEA,MRwGA,SUilCA,OVjlCA,SOqFA,eAIA,mBAs9BA,iBAvpCA,EAypCA,mBAzpCA,gCA0LA,UACA,wBAEA,eAIA,iBA49BA,iBH/UA,cGiVA,yBA/pCA,EAiqCA,aAEA,mBAz+BA,cACA,2BG8/BA,4CH5/BA,eAIA,mBAw7BA,iBCsZA,mDGv5CA,qBACA,SAJA,4BArHA,EH6pDA,aGxiDA,OF0LA,wCA/SA,IF8nCA,qBA9nCA,MC4oCA,UDj9BA,wBAEA,eAIA,iBA+7BA,iBACA,SC4hBA,UXt9CA,OAvMA,IU0LA,UACA,wBAEA,eAIA,oBAg8BA,iBAjoCA,EViOA,QGzHA,MAxGA,IQ4oCA,UDj9BA,wBAEA,eAIA,iBAi8BA,iBACA,yBAnoCA,IA0LA,UACA,wBAEA,eAIA,iBAm8BA,iBHtTA,aG+SA,QE6BA,cFh+BA,cACA,2BG8/BA,WHtCA,WAt9BA,eAIA,sBAy4BA,iBA1kCA,EViOA,QGzHA,MOkFA,cACA,2BG8/BA,Obx9BA,SGzHA,SOqFA,eAIA,sBA63BA,iBA9jCA,EViOA,QGzHA,MOkFA,cACA,2BG8/BA,Obx9BA,SGzHA,SOqFA,eAIA,sBAm6BA,iBApmCA,EViOA,QGzHA,MQu6CA,sDGv5CA,qBACA,SAJA,mCArHA,EAqHA,UArHA,gCJ0LA,UACA,wBAEA,eAIA,iBAu6BA,iBACA,MCojBA,UXt9CA,OAvMA,IU0LA,UACA,wBAEA,eAIA,oBAw6BA,iBAzmCA,EViOA,QGzHA,MAxGA,IQ4oCA,UDj9BA,wBAEA,eAIA,iBAy6BA,iBACA,+BA3mCA,IA0LA,UACA,wBAEA,eAIA,iBA26BA,iBH9RA,cA90BA,uCG0LA,UACA,wBAEA,eAIA,iBA86BA,iBACA,+BAhnCA,IA0LA,UACA,wBAEA,eAIA,iBAg7BA,iBHnSA,cGppBA,cACA,2BG8/BA,Obx9BA,SGzHA,SOqFA,eAIA,sBAw5BA,iBAzlCA,EViOA,QGzHA,MOkFA,cACA,2BG8/BA,Obx9BA,SGzHA,SUilCA,sBH5/BA,eAIA,iBA2/BA,kBGHA,WH5/BA,eAIA,mBAgyBA,iBAEA,kBAn+BA,cA0LA,cACA,2BG8/BA,WH5/BA,eAIA,iBA0wBA,iBACA,oBA58BA,UAigCA,YAEA,kBAngCA,cAoiCA,eA12BA,cACA,2BG8/BA,UH5/BA,eAIA,mBA04BA,iBACA,+CANA,SCsEA,cDj9BA,2BG8/BA,UH5/BA,eAIA,mBA83BA,iBACA,+CAt4BA,cACA,2BG8/BA,UH5/BA,eAIA,iBAggCA,iBGRA,UH5/BA,eAIA,mBAy5BA,iBACA,4BG8FA,oBH//BA,cACA,2BAg2BA,eAj2BA,cACA,2BG8/BA,oBHtLA,UCzDA,0BACA,iBD9wBA,eAIA,iBAq+BA,iBGmBA,UH5/BA,eAIA,mBAu8BA,iBAxoCA,OPwGA,MAxGA,KAwGA,QUilCA,OAzrCA,OAyrCA,qBbx9BA,QGzHA,YUilCA,oCAzrCA,MVwGA,MAxGA,KAwGA,QOkFA,cACA,2BADA,cACA,2BADA,cACA,2BCgxBA,iBE8OA,OAzrCA,OAyrCA,Obx9BA,QGzHA,YUilCA,0CH5/BA,eAIA,mBAg4BA,iBACA,yBAx4BA,cACA,2BG8/BA,UH5/BA,eAIA,mBA80BA,iBAEA,eACA,MC2oBA,OXt9CA,OUbA,cACA,2BG8/BA,UH5/BA,eAIA,iBAjMA,EA4hCA,iBACA,QCgoBA,OXt9CA,OUbA,cACA,2BG8/BA,UH5/BA,eAIA,iBAjMA,EAqiCA,iBACA,MCunBA,OXt9CA,OUbA,cACA,2BG8/BA,UH5/BA,eAIA,mBAk7BA,iBACA,cP5gCA,MAxGA,KAwGA,QUilCA,kDAzrCA,MVwGA,MAxGA,KAwGA,QUilCA,UH5/BA,eAIA,iBA64BA,kBAp5BA,cACA,2BG8/BA,UH5/BA,eAIA,iBA+4BA,iBGyGA,UH5/BA,eAIA,mBAkzBA,iBACA,MCyqBA,OXt9CA,OUbA,cACA,2BG8/BA,UH5/BA,eAIA,mBAwyBA,iBACA,MCmrBA,OXt9CA,OUbA,cACA,2BG8/BA,UH5/BA,eAIA,mBA6yBA,iBACA,QC8qBA,OXt9CA,OUbA,cACA,2BG8/BA,UH5/BA,eAIA,mBAmyBA,iBACA,yBA3yBA,cACA,2BG8/BA,UH5/BA,eAIA,sBAi1BA,iBAlhCA,EViOA,QGzHA,MOkFA,cACA,2BG8/BA,Obx9BA,QGzHA,QOqFA,eAIA,sBA41BA,iBA7hCA,EViOA,QGzHA,MOkFA,cACA,2BG8/BA,Obx9BA,QGzHA,QOqFA,eAIA,sBAq2BA,iBAtiCA,EViOA,QGzHA,MOkFA,cACA,2BG8/BA,Obx9BA,QGzHA,QUilCA,UH5/BA,eAIA,iBAk4BA,iBGsHA,UH5/BA,eAIA,sBAmzBA,iBAp/BA,EViOA,QGzHA,MOkFA,cACA,2BG8/BA,Obx9BA,QGzHA,QOqFA,eAIA,sBAyyBA,iBA1+BA,EViOA,QGzHA,MOkFA,cACA,2BG8/BA,Obx9BA,QGzHA,QOqFA,eAIA,sBA8yBA,iBA/+BA,EViOA,QGzHA,MOkFA,cACA,2BG8/BA,Obx9BA,QGzHA,QOqFA,eAIA,mBAk1BA,iBACA,+CA11BA,cACA,2BG8/BA,UH5/BA,eAIA,mBA61BA,iBACA,+CAr2BA,cACA,2BG8/BA,UH5/BA,eAIA,mBAs2BA,iBACA,4BA92BA,cACA,2BG8/BA,wCF9OA,iBD9wBA,eAIA,iBAqyBA,iBGmNA,UH5/BA,eAIA,iBAozBA,iBGoMA,UH5/BA,eAIA,iBA0yBA,iBG8MA,UH5/BA,eAIA,iBA+yBA,kBAh/BA,IA0LA,cACA,2BAEA,eAIA,iBAuzBA,iBGiMA,oBH5/BA,eAIA,mBAo1BA,iBACA,+BA51BA,cACA,2BG8/BA,UH5/BA,eAIA,iBA+1BA,iBGyJA,UH5/BA,eAIA,iBAw2BA,iBGgJA,oBH5/BA,eAIA,iBAs1BA,iBGkKA,UHrOA,YAiQA,YDv6BA,QL3SA,QO4gDA,gDHnqCA,mBGomBA,aDsDA,eACA,aAvgCA,IA0LA,cACA,2BAEA,eAIA,iBAjMA,MAwgCA,iBACA,QCopBA,OXt9CA,OUbA,cACA,2BG8/BA,UH5/BA,eAIA,4BAw0BA,iBAzgCA,EViOA,QGzHA,MQu6CA,eG18CA,kBAmDA,SACA,aAJA,4EJs5BA,6BCiIA,cDj9BA,2BG8/BA,Obx9BA,QGzHA,QOqFA,eAIA,qBA20BA,iBA5gCA,EViOA,QGzHA,SHyHA,WGzHA,cUilCA,OAzrCA,EbiOA,QGzHA,SHyHA,WGzHA,cAxGA,IO0LA,cACA,2BAEA,eAIA,iBA22BA,iBG6IA,UFsVA,YXx0CA,UWwwBA,8FHnmBA,+IGomBA,aDkGA,MC2mBA,OXt9CA,OAvMA,IW4oCA,cDj9BA,2BAEA,eAIA,0BAi3BA,iBAljCA,EViOA,QGzHA,MOkFA,cACA,2BG8/BA,Obx9BA,QGzHA,QOqFA,eAIA,yBAk3BA,iBACA,yBA13BA,cACA,2BG8/BA,oBH5/BA,eAIA,iBAo3BA,iBGoIA,UL70BA,mBGomBA,cDuQA,QACA,mBAphCA,yHAIA,mBACA,sBAzMA,QAgNA,UAhNA,EA0MA,OATA,8BAUA,kBOkKA,sBPhKA,OOgKA,UPhKA,UOgKA,ePhKA,0CA7MA,UAuMA,YAvMA,KAkNA,OEqrBA,OJzRA,OEpbA,cACA,wBG8/BA,UH5/BA,eAIA,mBAkBA,kBAEA,UGo+BA,kBHn+BA,kBAEA,mBA9BA,cACA,2BAEA,eAIA,oBAjMA,UAyNA,iBACA,8BAhCA,KACA,mBA3LA,QGyrCA,oBH5/BA,eAIA,sBA0BA,iBACA,UG69BA,QH59BA,gBAmEA,eAEA,cC23CA,OXt9CA,OAvMA,IU0LA,cACA,wBAEA,eAIA,gBAjMA,EViOA,QGzHA,MO2LA,kBA5OA,uBC8QA,cMwCA,iBPrTA,OOqTA,SPrTA,UOqTA,8BPrTA,aV+IA,OWyQA,gBAyNA,eC+BA,gBFhpBA,+CAxDA,EViOA,QGzHA,MO/CA,mBAEA,2BACA,KCyQA,cMwCA,iBPhTA,OOgTA,SPhTA,UOgTA,8BPhTA,aV0IA,OWyQA,gBAyNA,eC+BA,gBF3oBA,+CVoKA,QGzHA,QQ6NA,cMwCA,iBP9SA,OO8SA,SP9SA,UO8SA,8BP9SA,aVwIA,OWyQA,gBAyNA,eC+BA,gBFzoBA,+CVkKA,QGzHA,MOvCA,mBAdA,uBCkRA,cMwCA,iBPzTA,OOyTA,SPzTA,UOyTA,8BPzTA,aVmJA,OWyQA,gBAyNA,eC+BA,gBFppBA,+CApDA,EViOA,QGzHA,MOnDA,mBAVA,2BACA,KCyRA,cMwCA,iBPhUA,OOgUA,SPhUA,UOgUA,8BPhUA,aV0JA,OWyQA,gBAyNA,eC+BA,gBF3pBA,+CVoLA,QGzHA,QQ6NA,cMwCA,iBP9TA,OO8TA,SP9TA,UO8TA,8BP9TA,aVwJA,OWyQA,gBAyNA,eC+BA,gBFzpBA,+CVkLA,QGzHA,MOvDA,mBA6LA,qBACA,UA/OA,oBC4oCA,UA5oCA,ID0LA,cACA,2BAEA,eAIA,8BAgDA,iBAjPA,sCA0LA,KACA,kBA3LA,GA6LA,eAIA,oBAkDA,iBC4xCA,OD3xCA,kCH0lBA,aGppBA,KACA,2BG8/BA,8BH5/BA,eAIA,oBAqDA,kBCs5BA,aA5oCA,ID0LA,cACA,2BAEA,eAIA,sBAwDA,iBAzPA,mCC4oCA,IA5oCA,WF8UA,KCnJA,kBA3LA,OA6LA,mBAIA,oBA0DA,iBCoxCA,ODnxCA,kCHklBA,aGppBA,KACA,2BG8/BA,wCH5/BA,eAIA,oBA6DA,kBAKA,UGs7BA,UFsVA,wBD9wCA,YS7OA,QTgPA,kBAEA,0BA5EA,cACA,wBAEA,eOgLA,iBP7IA,OO6IA,SP7IA,UO6IA,4BP7IA,iBAhOA,YAuQA,iBACA,OA9EA,KACA,wBG8/BA,UH5/BA,eAIA,0BAwEA,iBAzQA,OA0LA,KACA,wBG8/BA,UH5/BA,eOgLA,iBP7IA,OO6IA,SP7IA,UO6IA,4BP7IA,iBA0CA,kBAEA,UG66BA,QH56BA,cA1CA,EAEA,aArOA,yCA0LA,cACA,gBA3LA,QA0LA,cACA,gBA3LA,QA0LA,cACA,gBA3LA,QA0LA,cACA,gBA3LA,QA0LA,cACA,gBA3LA,QA6LA,eAIA,iBA2CA,EA/CA,eAIA,iBA2CA,EA/CA,eAIA,iBA2CA,EA/CA,eAIA,iBA2CA,EA/CA,eAIA,iBA2CA,EAFA,mBAqCA,uBACA,QAtFA,cACA,2BAsFA,cApFA,eAIA,4BAkFA,iBACA,+BA1FA,KACA,mBA3LA,QGyrCA,oBH5/BA,eAIA,kBAqFA,kBAnNA,uBCkQA,cMwCA,iBPzSA,OOySA,SPzSA,UOySA,8BPzSA,aVmIA,OWyQA,gBAyNA,eC+BA,gBFpoBA,+CApEA,EViOA,QGzHA,MOnCA,mBAEA,uBC8PA,cMwCA,iBPrSA,OOqSA,SPrSA,UOqSA,8BPrSA,aV+HA,OWyQA,gBAyNA,eC+BA,gBFhoBA,+CAxEA,EViOA,QGzHA,MO/BA,mBA4TA,svEAEA,gBAvYA,wYA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0aA,UAhPA,eACA,yBADA,eACA,gBA3LA,SA4bA,UAlQA,eACA,yBADA,eACA,yBADA,eACA,gBA3LA,SAmZA,OAzNA,eACA,4BADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,gBA3LA,SA0LA,eACA,4BADA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA8aA,UApPA,eACA,4BAyPA,UA1PA,eACA,yBAqQA,UAtQA,eACA,yBAyQA,UA1QA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,gBA3LA,SAsiBA,UA5WA,eACA,4BA+WA,UAhXA,eACA,4BADA,eACA,4BADA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBA8MA,OA/MA,eACA,4BAmNA,OApNA,eACA,4BADA,eACA,gBA3LA,SA0LA,eACA,4BAkOA,UAnOA,eACA,yBAsOA,UAvOA,eACA,yBADA,eACA,4BADA,eACA,gBA3LA,SAwbA,UA9PA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,yBADA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA0LA,eACA,gBA3LA,SA6LA,eAIA,iBAqMA,IAzMA,eAIA,iBAqMA,IAzMA,eAIA,sBA0OA,iBACA,QAtCA,IGmzBA,OH9wBA,IA9OA,eAIA,iBAqMA,IAzMA,eAIA,sBA4PA,iBACA,QAxDA,IGmzBA,OH5vBA,IAhQA,eAIA,sBAwSA,iBACA,wBApGA,IGmzBA,OHhtBA,IA5SA,eAIA,iBAqMA,IAzMA,eAIA,oBAjMA,EAoZA,iBCsjBA,8BE+OA,OHryBA,IAvNA,eAIA,sBAgRA,iBACA,wBA5EA,IGmzBA,OHxuBA,IApRA,eAIA,sBAgSA,iBACA,wBA5FA,IGmzBA,OHxtBA,IApSA,eAIA,sBAoSA,iBACA,wBAhGA,IGmzBA,OHptBA,IAxSA,eAIA,sBA4SA,iBACA,wBAxGA,IGmzBA,OH5sBA,IAhTA,eAIA,sBAgTA,iBACA,4BGusBA,WH5/BA,eAIA,sBAgVA,iBACA,4BGuqBA,WH5/BA,eAIA,sBAoVA,iBACA,4BGmqBA,WH5/BA,eAIA,sBAwVA,iBACA,4BG+pBA,WH5/BA,eAIA,sBA4VA,iBACA,4BG2pBA,WH5/BA,eAIA,qBAJA,eAIA,sBA8WA,iBArPA,mBCm2CA,OXt9CA,OUbA,eACA,mBA3LA,SGyrCA,WH5/BA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,sBAoPA,iBACA,QAhDA,IGmzBA,OHpwBA,IAxPA,eAIA,sBAwQA,iBACA,wBApEA,IGmzBA,OHhvBA,IA5QA,eAIA,sBAoRA,iBACA,wBAhFA,IGmzBA,OHpuBA,IAxRA,eAIA,sBAgUA,iBACA,4BGurBA,WH5/BA,eAIA,sBAoUA,iBACA,4BGmrBA,WH5/BA,eAIA,oBAjMA,EAuiBA,iBAviBA,OO6WA,iBP9DA,OO8DA,SP9DA,WO8DA,4BP9DA,aC82CA,OXt9CA,OUbA,eACA,mBA3LA,SGyrCA,WH5/BA,eAIA,oBAjMA,EA2iBA,iBA3iBA,OO6WA,iBPzDA,OOyDA,SPzDA,WOyDA,4BPzDA,aCy2CA,OXt9CA,OUbA,eACA,mBA3LA,SGyrCA,WH5/BA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,sBAkgBA,iBACA,4BGqfA,WH5/BA,eAIA,sBAsgBA,iBACA,4BGifA,WH5/BA,eAIA,sBAkhBA,iBACA,4BGqeA,WH5/BA,eAIA,sBA0hBA,iBACA,4BG6dA,WH5/BA,eAIA,sBAkiBA,iBACA,4BGqdA,WH5/BA,eAIA,sBA8iBA,iBACA,4BGycA,WH5/BA,eAIA,sBA0jBA,iBACA,4BG6bA,WH5/BA,eAIA,sBA8jBA,iBACA,4BGybA,WH5/BA,eAIA,sBAkkBA,iBACA,4BGqbA,WH5/BA,eAIA,sBAskBA,iBACA,4BGibA,WH5/BA,eAIA,sBAklBA,iBACA,4BGqaA,WH5/BA,eAIA,sBAslBA,iBACA,4BGiaA,WH5/BA,eAIA,sBAkmBA,iBACA,4BGqZA,WH5/BA,eAIA,sBA8mBA,iBACA,4BGyYA,WH5/BA,eAIA,sBAknBA,iBACA,4BGqYA,WH5/BA,eAIA,sBAsnBA,iBACA,4BGiYA,WH5/BA,eAIA,sBA0nBA,iBACA,4BG6XA,WH5/BA,eAIA,sBA8nBA,iBACA,4BGyXA,WH5/BA,eAIA,sBAspBA,iBACA,4BGiWA,WH5/BA,eAIA,sBA8pBA,iBACA,4BGyVA,WH5/BA,eAIA,sBAkqBA,iBACA,4BGqVA,WH5/BA,eAIA,sBAksBA,iBACA,4BGqTA,WH5/BA,eAIA,sBAssBA,iBACA,4BGiTA,WH5/BA,eAIA,sBA0sBA,iBACA,4BG6SA,WH5/BA,eAIA,sBAktBA,iBACA,4BGqSA,WH5/BA,eAIA,sBAstBA,iBACA,4BGiSA,WH5/BA,eAIA,sBA8tBA,iBACA,4BGyRA,WH5/BA,eAIA,sBAsuBA,iBACA,4BGiRA,WH5/BA,eAIA,sBAkvBA,iBACA,4BGqQA,WH5/BA,eAIA,sBAsvBA,iBACA,4BGiQA,WH5/BA,eAIA,sBA0vBA,iBACA,4BG6PA,WH5/BA,eAIA,sBA8OA,iBACA,SC6uCA,OXt9CA,OUbA,eACA,mBA3LA,SGyrCA,OH1wBA,IAlPA,eAIA,sBAgQA,iBACA,QA5DA,IGmzBA,OHxvBA,IApQA,eAIA,sBAoQA,iBACA,QAhEA,IGmzBA,OHpvBA,IAxQA,eAIA,sBA4RA,iBACA,wBAxFA,IGmzBA,OH5tBA,IAhSA,eAIA,sBAwUA,iBACA,4BG+qBA,WH5/BA,eAIA,qBAJA,eAIA,sBAkXA,iBApPA,mBC81CA,OXt9CA,OUbA,eACA,mBA3LA,SGyrCA,WH5/BA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,sBA8fA,iBACA,4BGyfA,WH5/BA,eAIA,sBA0gBA,iBACA,4BG6eA,WH5/BA,eAIA,sBA8gBA,iBACA,4BGyeA,WH5/BA,eAIA,sBAshBA,iBACA,4BGieA,WH5/BA,eAIA,sBA8hBA,iBACA,4BGydA,WH5/BA,eAIA,sBAsiBA,iBACA,4BGidA,WH5/BA,eAIA,sBA0iBA,iBACA,4BG6cA,WH5/BA,eAIA,sBAkjBA,iBACA,4BGqcA,WH5/BA,eAIA,sBAsjBA,iBACA,4BGicA,WH5/BA,eAIA,sBA0kBA,iBACA,4BG6aA,WH5/BA,eAIA,sBA8kBA,iBACA,4BGyaA,WH5/BA,eAIA,sBA0lBA,iBACA,4BG6ZA,WH5/BA,eAIA,sBA8lBA,iBACA,4BGyZA,WH5/BA,eAIA,sBAsmBA,iBACA,4BGiZA,WH5/BA,eAIA,sBA0mBA,iBACA,4BG6YA,WH5/BA,eAIA,sBAkoBA,iBACA,4BGqXA,WH5/BA,eAIA,sBAsoBA,iBACA,4BGiXA,WH5/BA,eAIA,sBA0oBA,iBACA,4BG6WA,WH5/BA,eAIA,sBA8oBA,iBACA,4BGyWA,WH5/BA,eAIA,sBAkpBA,iBACA,4BGqWA,WH5/BA,eAIA,sBA0pBA,iBACA,4BG6VA,WH5/BA,eAIA,sBAsqBA,iBACA,4BGiVA,WH5/BA,eAIA,sBA0qBA,iBACA,4BG6UA,WH5/BA,eAIA,sBA8qBA,iBACA,4BGyUA,WH5/BA,eAIA,sBAkrBA,iBACA,4BGqUA,WH5/BA,eAIA,sBAsrBA,iBACA,4BGiUA,WH5/BA,eAIA,sBA0rBA,iBACA,4BG6TA,WH5/BA,eAIA,sBA8rBA,iBACA,2BGyTA,UH5/BA,eAIA,sBA8sBA,iBACA,2BGySA,UH5/BA,eAIA,sBA0tBA,iBACA,2BG6RA,UH5/BA,eAIA,sBAkuBA,iBACA,2BGqRA,UH5/BA,eAIA,sBA0uBA,iBACA,2BG6QA,UH5/BA,eAIA,sBA8uBA,iBACA,2BGyQA,UH5/BA,eAIA,sBA8vBA,iBACA,2BGyPA,UH5/BA,eAIA,sBAkwBA,iBACA,2BGqPA,UH5/BA,eAIA,oBAjMA,EA0YA,iBCgkBA,6BE+OA,WH5/BA,eAIA,oBAjMA,EA+YA,iBC2jBA,6BE+OA,OH1yBA,IAlNA,eAIA,iBAqMA,IAzMA,eAIA,sBAyNA,iBCgmBA,gBAIA,YH9tBA,+FACA,yDG8tBA,oBFjrBA,mEC7IA,8CAuKA,iBCqzCA,QDn+CA,cACA,2BG8/BA,OH/xBA,IA7NA,eAIA,sBA6NA,iBACA,QAzBA,IGmzBA,OH3xBA,IAjOA,eAIA,sBAiOA,iBACA,QA7BA,IGmzBA,OHvxBA,IArOA,eAIA,sBAqOA,iBUhNA,UADA,UVoEA,sDUvDA,YACA,YP0iBA,+BF+XA,gBA5oCA,QEyrCA,OHnxBA,IAzOA,eAIA,iBAqMA,IAzMA,eAIA,sBAwPA,iBACA,QApDA,IGmzBA,OHhwBA,IA5PA,eAIA,sBA4QA,iBACA,wBAxEA,IGmzBA,OH5uBA,IAhRA,eAIA,sBAwRA,iBACA,wBApFA,IGmzBA,OHhuBA,IA5RA,eAIA,sBAoTA,iBACA,4BGmsBA,WH5/BA,eAIA,sBAwTA,iBACA,4BG+rBA,WH5/BA,eAIA,sBA4TA,iBACA,4BG2rBA,WH5/BA,eAIA,sBA4UA,iBACA,4BG2qBA,WH5/BA,eAIA,sBAgWA,iBACA,4BGupBA,WH5/BA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,qBAJA,eAIA,gBVgCA,SGzHA,SOqFA,eAIA,gBVgCA,SGzHA,SOqFA,eAIA,gBVgCA,SGzHA,SOqFA,eAIA,gBVgCA,SGzHA,SOqFA,eAIA,gBVgCA,SGzHA,SOyFA,0CAjMA,QA6LA,eAIA,mBAwKA,iBA/KA,cACA,2BCgxBA,sDD9wBA,eAIA,mBAyKA,iBA1WA,IA0LA,cACA,2BAEA,eAIA,oBA0KA,iBAjLA,cACA,mBA3LA,QGyrCA,OAzrCA,EbiOA,MGzHA,MAxGA,OAwGA,QAxGA,QO6LA,eAIA,gBAjMA,EViOA,MGzHA,MAxGA,MAwGA,KAxGA,IgBoBA,QN0vBA,oEA9wBA,muFbuMA,UWwwBA,kCHnmBA,qGGomBA,aD/jBA,QAjZA,OVuMA,UWwwBA,kCHnmBA,qGGomBA,aDpkBA,QA5YA,OVuMA,UWwwBA,kCHnmBA,qGGomBA,aD1jBA,QAtZA,8DA2LA,wBGklBA,OF+XA,SA5oCA,OD6LA,cA7LA,OAiMA,oBAyFA,iBA1RA,OA2RA,4BA3RA,OU+NA,UA/NA,OAkOA,UACA,YP0iBA,UA7wBA,OA8wBA,oEHjfA,OACA,GG25BA,OH/5BA,GA6qBA,aAv8BA,kEAkUA,mBACA,WACA,UApUA,IA0LA,cACA,2BAEA,eAIA,4BAqIA,iBACA,4BA7IA,KACA,mBA3LA,QGyrCA,oBH5/BA,eAIA,kBAwIA,gBAsCA,8BACA,gBCyqCA,eAzhDA,EDsXA,uBACA,YClDA,cMwCA,kBPjSA,OOiSA,SPjSA,UOiSA,6BPjSA,aV2HA,OWyQA,gBAyNA,eC+BA,gBF5nBA,yEA5EA,EViOA,QGzHA,MO8QA,OA1SA,sBFjBA,URsKA,cGzHA,MO+QA,6BAEA,OADA,cDtLA,UR7LA,qBALA,KEoFA,kCAcA,GAlGA,WO0LA,KACA,mBA3LA,QA6LA,eOgLA,kBP7IA,OO6IA,SP7IA,UO6IA,6BP7IA,iBAhOA,UA6LA,cOgLA,kBP7IA,OO6IA,SP7IA,UO6IA,6BP7IA,qCAhOA,QCyWA,qBAuGA,WAyNA,iBC+BA,kBG/hBA,OLwBA,0CAjMA,KPwGA,MO2RA,aCspCA,YPthDA,aMkSA,eAEA,MCs3CA,OXt9CA,OAvMA,IU0LA,cACA,wBAEA,eAIA,gBAjMA,EViOA,QGzHA,MOgMA,gBAEA,eACA,MCk3CA,OXt9CA,OAvMA,IU0LA,cACA,wBAEA,eAIA,gBAjMA,EViOA,QGzHA,MOoMA,kBA+BA,oCAjJA,cACA,wBAEA,eAIA,0BA4IA,iBA7UA,OA0LA,KACA,wBG8/BA,UH5/BA,eOgLA,iBP7IA,OO6IA,SP7IA,UO6IA,4BP7IA,iBA8GA,kBAEA,OAtJA,cACA,wBG8/BA,UH5/BA,eAIA,0BAiJA,iBACA,aAzJA,KACA,wBG8/BA,UH5/BA,eOgLA,iBP7IA,OO6IA,SP7IA,UO6IA,4BP7IA,iBAmHA,iBGs2BA,UHp2BA,QACA,kBA1PA,gBAMA,wBAKA,6CACA,UAKA,oCCwNA,gBDpNA,kBC01BA,OH/lBA,uBGomBA,aAh9BA,YDqHA,OAUA,OACA,UAMA,iBC0UA,WAyNA,oBC+BA,iCAxsBA,GFsHA,QAMA,8COiPA,OPjPA,UOiPA,QPjPA,UOiPA,QPjPA,WOiPA,qCPjPA,aV2EA,OWyQA,gBAyNA,oBC+BA,gBZveA,QGzHA,QOsCA,8CO+NA,OP/NA,UO+NA,QP/NA,UO+NA,QP/NA,WO+NA,qCP/NA,aVyDA,OWyQA,wBAyNA,eC+BA,gBZveA,QGzHA,QQwWA,WAyNA,oBC+BA,iCAxsBA,GDgdA,WAyNA,oBC+BA,iCAxsBA,GK6WA,kBPtOA,OOsOA,SPtOA,OOsOA,6BPtOA,cVgEA,OWyQA,wBAyNA,eC+BA,gBZveA,QGzHA,MOyCA,sDACA,eFvFA,ERsKA,QGzHA,cQwWA,WAyNA,eC+BA,gBShcA,iBAUA,YV8LA,WAyNA,eC+BA,gBS1bA,YJ3FA,eACA,OApLA,IKqeA,QACA,cAteA,EAweA,QAEA,cADA,wBAzeA,EA4eA,SAGA,cADA,iBADA,wBAKA,cAGA,cAFA,iBACA,sBXpCA,gBAyNA,eC+BA,mBKnhBA,kBAuBA,eAsBA,yEACA,oBN6OA,gBAyNA,eC+BA,gBWscA,OE7nBA,EtB7bA,SAcA,GuBgJA,cDuSA,mBFomBA,gBAoBA,wDACA,+EVr1BA,UckGA,mBChKA,yFL05BA,iBf9lCA,QewlCA,OfxlCA,KA3DA,WA2DA,0BA3DA,ELkQA,WA1JA,oBoB+iCA,WAMA,aK95BA,QpBpMA,QA3DA,WA2DA,0BA3DA,ELkQA,WA1JA,uBQq4CA,iBVx+CA,YDkMA,OAvMA,SGoFA,iCAcA,GAlGA,KSwsBA,UG/hBA,qBJs0CA,YP5+CA,WauNA,UACA,OAEA,gBACA,2DAIA,mEAHA,mBNiPA,mBAyNA,eC+BA,gBKjfA,KYpGA,iBT0zBA,kBANA,iBACA,YACA,eAOA,mBACA,cAoBA,EPoPA,gCOpPA,EAr8BA,IAu6BA,OACA,YACA,eAeA,8BAEA,WPuPA,cAjrCA,QOu6BA,OACA,YACA,eAeA,2BAEA,SAnBA,OACA,YACA,eAeA,4BAEA,SAnBA,OACA,YACA,eAiBA,mBAFA,aPyPA,0COnPA,sCAOA,EA7BA,4DPiRA,yBOpPA,EADA,oBAxSA,uBA2QA,eACA,YACA,eAz6BA,EAwoBA,mBAuBA,mBA/pBA,wEAqqBA,QAQA,EAlCA,aP8iBA,kCO5gBA,EANA,yCAMA,EATA,QASA,EAVA,QAUA,EAXA,QAWA,EAZA,QAYA,EAbA,QAaA,EAdA,OAcA,EA2PA,iBAlBA,EArSA,oBPwkBA,gCO3RA,EA95BA,QAw5BA,YACA,YACA,YACA,YAHA,eACA,UAIA,OADA,UACA,qCACA,EANA,YACA,YACA,YACA,mBA8NA,gBPwDA,o1BO1QA,YACA,aACA,eAmNA,oBA5nCA,yYA8nCA,UPmDA,wHOnDA,2DOxtBA,0EdmxBA,uFO/CA,UPuCA,OOvCA,WPuCA,cAQA,4BOzDA,UPiDA,+HOjDA,2DO1tBA,0EdmxBA,oDO9KA,UPsKA,OOtKA,WPsKA,cAQA,4BAzrCA,QOspCA,UP2BA,qBO3BA,WP2BA,cAQA,sCOpMA,mCAr/BA,MAsmBA,YAiUA,QACA,QACA,YA+EA,OADA,sBAEA,WAz/BA,WAsmBA,gBAtmBA,SA8pCA,UPmBA,qBOnBA,WPmBA,cAQA,sCOzBA,UPiBA,qBOjBA,WPiBA,cAQA,sCAzrCA,SOyqCA,UPQA,qBORA,WPQA,cAQA,sCO5VA,UPoVA,OOpVA,WP4VA,6BAzrCA,iBOmpCA,UP8BA,OO9BA,WP8BA,cAQA,4BAzrCA,SO0qCA,UPOA,qBOPA,WPOA,cAQA,sCOlDA,UP0CA,OO1CA,WP0CA,cAQA,4BAzrCA,2BOopCA,UP6BA,OO7BA,WP6BA,cAQA,4BOlCA,UP0BA,qBO1BA,WP0BA,cAQA,sCAzrCA,oDOwpCA,UPyBA,qBOzBA,WPyBA,cAQA,sCAzrCA,SO2pCA,UPsBA,qBOtBA,WPsBA,cAQA,sCAzrCA,6COkpCA,UP+BA,OO/BA,WP+BA,cAQA,4BOrDA,cP6CA,OO7CA,WP6CA,cAQA,4BO7BA,UPqBA,qBOrBA,WPqBA,cAQA,sCAzrCA,SOoqCA,UPaA,qBObA,WPaA,cAQA,sCAzrCA,sGOwqCA,UPSA,qBOTA,WPSA,cAQA,sCAzrCA,QO+pCA,UPkBA,qBOlBA,WPkBA,cAQA,sCAzrCA,+BOu6BA,OACA,aACA,eA5SA,qBAGA,aPyjBA,mCOxRA,UPgRA,kBOhRA,WPgRA,WAjrCA,oLO0pCA,UPuBA,qBOvBA,UPuBA,cAQA,sCO5BA,UPoBA,qBOpBA,UPoBA,cAQA,sCAzrCA,+DOu6BA,OACA,aACA,eADA,mBA4ZA,gBA7ZA,OACA,aACA,eADA,oBAx6BA,qKAgiCA,UPiJA,qBOjJA,WPiJA,WAQA,WAzrCA,gJOmoCA,UP8CA,OO9CA,UP8CA,cAQA,4BAzrCA,QOmqCA,UPcA,qBOdA,UPcA,cAQA,sCAzrCA,2GO+nCA,UPkDA,wHOlDA,0DOztBA,0EdmxBA,oDAzrCA,uDOkqCA,UPeA,qBOfA,UPeA,cAQA,sCOdA,UPMA,qBONA,UPMA,cAQA,sCAzrCA,+COqqCA,UPYA,qBOZA,UPYA,cAQA,sCAzrCA,wEOypCA,UPwBA,qBOxBA,UPwBA,cAQA,sCAzrCA,uBOu6BA,OACA,aACA,eA5SA,oBAGA,aPyjBA,mCAzrCA,gBOsqCA,UPWA,qBOXA,UPWA,cAQA,sCOxBA,UPgBA,qBOhBA,UPgBA,cAQA,sCAzrCA,eOipCA,UPgCA,OOhCA,UPgCA,cAQA,4BAzrCA,SOu6BA,QACA,aACA,eA8CA,kBACA,cAx9BA,QAuqCA,UPUA,qBOVA,UPUA,cAQA,sCAzrCA,OOqpCA,UP4BA,qBO5BA,UP4BA,cAQA,sCOzCA,UPiCA,OOjCA,UPiCA,cAQA,4BAzrCA,SOyzCA,0CAzzCA,OAu6BA,qBACA,aACA,eA5SA,oBAGA,aPyjBA,mCAzrCA,QOspCA,aAQA,aAEA,aASA,aPQA,UOnVA,SAGA,oBAj2BA,QA0qCA,aA1qCA,gBAupCA,aACA,aAGA,aA3pCA,SA4pCA,aAQA,aAIA,aATA,aA7PA,UP+QA,OO/QA,UP+QA,YAQA,4BO/BA,aAGA,aA7pCA,IPyrCA,QAzrCA,QAyrCA,SAzrCA,QOmqCA,aAnqCA,QAkqCA,aASA,aANA,aArqCA,QAypCA,aAaA,aALA,aAjqCA,QAuqCA,aAlBA,aArpCA,QPirCA,WAQA,kCAzrCA,WOugCA,qBAvgCA,oDAw8BA,kBAx8BA,Ib80BA,caxOA,YAiUA,OACA,QACA,aADA,Od40BA,Sc1yBA,YArGA,ObvBA,UA90BA,IMyrCA,KN3WA,Sa0HA,kBAx8BA,Eb80BA,caxOA,YAiUA,OACA,QACA,aADA,Od40BA,Sc1yBA,YRzDA,gBQkBA,iBAn6BA,IAg1CA,iBPvJA,uDOlRA,OACA,aACA,eAz6BA,IA+9BA,8BAEA,YAj+BA,gBAs2BA,WP2UA,eOxCA,aAlOA,OACA,aACA,eAz6BA,IA+9BA,2BAEA,UA1DA,OACA,aACA,eAz6BA,IA+9BA,4BAEA,UA1DA,QACA,aACA,eAwDA,oBAFA,cAvHA,WPiVA,OAzrCA,aDi5BA,SAEA,QC8RA,wDOjJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,WOzJA,cPiJA,qBOjJA,UPiJA,WAQA,WOzJA,UPiJA,qBOjJA,UPiJA,WAQA,UOzJA,cPiJA,qBOjJA,UPiJA,WAQA,UOzJA,UPiJA,qBOjJA,UPiJA,WAQA,UOzJA,UPiJA,qBOjJA,UPiJA,WAQA,UOzJA,UPiJA,qBOjJA,UPiJA,WAQA,UOzJA,cPiJA,qBOjJA,UPiJA,WAQA,UOzJA,UPiJA,qBOjJA,UPiJA,WAQA,UOzJA,cPiJA,qBOjJA,UPiJA,WAQA,UOzJA,UPiJA,qBOjJA,UPiJA,WAQA,UOzJA,UPiJA,qBOjJA,UPiJA,WAQA,UOzJA,cPiJA,qBOjJA,UPiJA,WAQA,UOzJA,UPiJA,qBOjJA,UPiJA,WAQA,UOzJA,cPiJA,qBOjJA,UPiJA,WAQA,UOzJA,UPiJA,qBOjJA,UPiJA,WAQA,UOzJA,UPiJA,qBOjJA,UPiJA,WAQA,UOzJA,UPiJA,qBOjJA,UPiJA,WAQA,UOzJA,UPiJA,qBOjJA,UPiJA,WAQA,UOtEA,uBAnnCA,SAiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UAzrCA,KOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,SOiiCA,OAGA,sBPqJA,UAzrCA,KOoiCA,sBPqJA,UARA,cAjrCA,mJAirCA,YAjrCA,YOw6BA,0IRtBA,SAEA,SQoBA,oCAsDA,WP2NA,2CAzrCA,UAyrCA,mCO1MA,mBA/+BA,OPyrCA,2DO9DA,0DAoMA,oBAlhBA,eAEA,MPkYA,kBOlYA,UPkYA,OAQA,2BOzYA,MPiYA,SOjYA,UPiYA,OAQA,2BO3YA,yBAIA,kBAuzCA,kQAtIA,eAn+DA,sDA2iEA,YA9cA,YP5aA,uCO4aA,UP5aA,0CJn2BA,aW0nDA,WAv1CA,0CPwkBA,mBJ32BA,UW81CA,sBAWA,YPtgBA,4BOsgBA,UPtgBA,UO+fA,QAuTA,YAmDA,8BApjBA,cPrTA,OOqTA,UPrTA,kBOwqBA,8CAz1DA,mBA01DA,YPzqBA,OOyqBA,UPzqBA,UAjrCA,OJ8UA,UWslDA,2BACA,aPpvBA,cO6tBA,sBA94DA,YA+4DA,YA8FA,YACA,YACA,YAEA,YADA,YAEA,YA+CA,YXntDA,UWslDA,2BPnvBA,WOovBA,eA4FA,wBAjgEA,OAgtDA,YP/hBA,iBO+hBA,UAhtDA,KPirCA,UO42BA,8BArcA,2BACA,UA8cA,YAzcA,WACA,8BA96BA,cPggBA,OOhgBA,6BPwgBA,eOs1BA,YAgBA,YAvcA,2BACA,UA6ZA,YAkDA,YX1tDA,UWmsDA,wBAEA,WADA,OAEA,YA5bA,2BACA,UA6bA,YXxsDA,UWslDA,2BPnvBA,WOovBA,eA+HA,YPn3BA,OOm3BA,UPn3BA,iBAjrCA,SO6qDA,oBACA,2BACA,cP9fA,kBOwxBA,2BACA,cAxjCA,ORDA,OAEA,eQAA,OAgkCA,mBACA,gIA7eA,WAMA,SP5TA,OO4TA,UP5TA,8BOibA,gJAh7BA,SAGA,uBP4fA,kBOm3BA,OACA,YPp3BA,aOugBA,gHAwPA,UADA,OAEA,4BA0DA,YA3DA,UADA,OAEA,8BADA,UADA,OAEA,8BAjTA,cP/cA,OO+cA,UAhoDA,KPyrCA,mBOy0BA,8BAxhBA,yBd4FA,cLjkDA,UALA,KEoFA,SAcA,GiB0zDA,YA55DA,KAu6BA,qBACA,eACA,eAtRA,sBA4nCA,gBP9lBA,sBO8lBA,UAEA,+HAuIA,YPvuBA,OOuuBA,UPvuBA,iBO5JA,YP4JA,OO5JA,UPoKA,wBOwhBA,+GACA,qBAjFA,UAGA,yBApoDA,EA8+CA,OA9+CA,QAo/CA,2HAoaA,OACA,YAz5DA,UAshCA,SAGA,mBAzhCA,KTyWA,yBAzWA,iDS6rBA,SPofA,OAjrCA,IO6rBA,UP4fA,8BO3fA,qBPmfA,cAQA,mBARA,OAjrCA,IPkiDA,YGtiCA,eWwMA,qBApsBA,sBX4fA,OIqrBA,cAQA,kCAzrCA,MOusBA,SAGA,4BA1sBA,OPirCA,4BAjrCA,SF08BA,UACA,4BH/lBA,sBGomBA,kBJlIA,WM2WA,qCAzrCA,EbiOA,QGzHA,SUilCA,cO4sBA,YAvCA,YP7qBA,OO6qBA,UP7qBA,iBOirBA,YPjrBA,OOirBA,UPjrBA,iBOysBA,YPzsBA,OOysBA,UPzsBA,iBOqrBA,YPrrBA,OOqrBA,UPrrBA,iBOyrBA,YPzrBA,OOyrBA,UPzrBA,iBO6rBA,YP7rBA,OO6rBA,UP7rBA,iBOitBA,YPjtBA,OOitBA,UPjtBA,oBOisBA,YPjsBA,OOisBA,UPjsBA,iBOqsBA,YPrsBA,OOqsBA,UPrsBA,iBO6sBA,YP7sBA,OO6sBA,UP7sBA,iBPqZA,cLjkDA,UALA,KEoFA,SAcA,GAlGA,QiBuqDA,4IAtjCA,kBAjnBA,UPyrCA,mBOniBA,aP2hBA,kBOgUA,yBAyWA,OACA,YAGA,OACA,YAGA,OACA,YAuBA,OACA,YArBA,OACA,YAGA,OACA,YAGA,OACA,YAmBA,wHAhBA,OACA,YAGA,OACA,YAOA,OACA,UA/3DA,4BTyWA,yBAzWA,2BSyoDA,SPxdA,OOwdA,UAzoDA,ST08BA,UACA,4BH/lBA,aGomBA,kBJlIA,YMmWA,OAjrCA,EbiOA,QGzHA,SAxGA,KUyrCA,eAzrCA,QO2oDA,0IA+XA,cAxnCA,URDA,OAEA,eQAA,UAo3BA,wIA6NA,YADA,YD/8DA,gBCm3DA,YDn3DA,QC04DA,YD14DA,QCo/DA,YDp/DA,QC6/DA,aD7/DA,QP83BA,SAEA,SHtmBA,QL3SA,QgBq6BA,YX1nBA,QL3SA,QQ+4BA,SAEA,SC6RA,yBAQA,SARA,wBO27BA,6GAGA,mBZpjEA,iBA3DA,oCRiOA,WGzHA,YHyHA,WGzHA,WK7CA,eA3DA,ORiOA,WGzHA,WK7CA,ERsKA,WGzHA,WK7CA,ERsKA,WGzHA,WK7CA,EA3DA,EGAA,aH2DA,oBA3DA,IRiOA,WGzHA,SK7CA,kBRsKA,WGzHA,WK7CA,UY65DA,+BAplCA,qBAoCA,eACA,aAtRA,8BAu2BA,IACA,WP1UA,cO0UA,UPlUA,2BOiyBA,2BA19DA,WA4/CA,UACA,UP5UA,0BO4UA,UA7/CA,aA8/CA,oBA9/CA,YAogDA,eApgDA,cPyrCA,yBOqVA,oHACA,6BA+cA,QACA,YAvjCA,iBA6gCA,qBXvmDA,UA9UA,IWo6DA,wBP3uBA,yBAzrCA,EOu7DA,OACA,2BAEA,OADA,aAz7DA,EAinBA,qCPwkBA,4BOvSA,URDA,OAEA,eQAA,OAgjCA,4HACA,QACA,YDj7DA,QP83BA,SAEA,gBQ+nBA,oCACA,QAnzBA,mBPgdA,kBOhdA,UPgdA,4BJn2BA,UWslDA,wBP3uBA,yBOvdA,cP+cA,OO/cA,UPudA,qBOuvBA,UADA,OAEA,4BACA,UAl7DA,EAmuBA,QAGA,6BpBzlBA,aW4NA,oCAzWA,+BS2uBA,oBA3uBA,OPirCA,OAjrCA,EF08BA,UACA,4BH/lBA,UGomBA,kBJlIA,YMmWA,qBbh9BA,UoB4gBA,UPocA,OAjrCA,EO6uBA,UP4cA,sBbx9BA,UAjOA,EoB8uBA,OAGA,yBpBpmBA,aW4NA,oCAzWA,6BSsvBA,2BAtvBA,OPirCA,SFvOA,OACA,8BH/lBA,UGomBA,mBJlIA,YMmWA,qBAjrCA,KVwGA,QHyHA,UAjOA,YoB0vBA,cACA,0BAHA,gBAGA,wBAHA,gFDpuBA,QnB6MA,SGzHA,SAxGA,KUirCA,4HAQA,2BO8VA,+UAEA,OADA,oBAEA,mBAEA,wCACA,QAxgBA,cP4JA,OO5JA,UPoKA,yBJ32BA,UWslDA,wBP3uBA,yBAzrCA,UOshCA,SAGA,mBAu5BA,UADA,OAEA,2BACA,UAj0CA,kBAjnBA,UPyrCA,2BOvSA,URDA,OAEA,eQAA,UAkIA,SP4JA,OAjrCA,MOqhCA,UPoKA,yBAzrCA,YOshCA,SAGA,mBAxaA,kBAjnBA,UPyrCA,2BOvSA,URDA,OAEA,eQAA,UA+oBA,SPjXA,kIOiXA,6DO5nCA,yEdmxBA,4CAzrCA,gBOqiDA,YAriDA,oBA+iDA,SP9XA,qIO8XA,0DOzoCA,yEdmxBA,4COmXA,SP3XA,kBO2XA,UP3XA,cOwXA,aPxXA,kBOwXA,WAziDA,iBAsiDA,SPrXA,OOqXA,UP7WA,wBAzrCA,OAirCA,cAjrCA,MOmjDA,+IAMA,OADA,sBDpiDA,QP83BA,SAEA,SAFA,SAEA,SQsqBA,iBAEA,yBACA,QAGA,YP/YA,iBO+YA,UPvYA,oBJ32BA,UWslDA,wBP3uBA,yBOuYA,+GAEA,OADA,sBA+WA,UADA,OAEA,2BACA,QA/WA,YD/iDA,eCijDA,0BACA,QAGA,aPxZA,mHOwZA,uDOnqCA,iEdmxBA,4CJ32BA,UWslDA,wBP3uBA,yBOgZA,4NAEA,OADA,sBAsWA,UADA,OAEA,4BACA,QAtWA,aDxjDA,eC0jDA,0BACA,QAGA,YPjaA,qIOiaA,0DO5qCA,yEdmxBA,4CJ32BA,UWslDA,wBP3uBA,yBOyZA,4CAEA,OADA,sBA6VA,UADA,OAEA,2BACA,QA7VA,aDjkDA,eCklDA,oCACA,QAllBA,cP4JA,OO5JA,UPoKA,yBJ32BA,UWslDA,wBP3uBA,yBAzrCA,UOshCA,SAGA,mBAu5BA,UADA,OAEA,2BACA,UAj0CA,kBAjnBA,UPyrCA,2BOvSA,URDA,OAEA,eQAA,UAwtBA,SP1bA,kIO0bA,6DOrsCA,yEdmxBA,4COmbA,SP3bA,OAjrCA,EO4mDA,UPnbA,0BOobA,yJAMA,OADA,sBD9lDA,QP83BA,SAEA,SQguBA,iBAEA,yBACA,QAGA,YPzcA,iBOycA,UPjcA,oBJ32BA,UWslDA,wBP3uBA,yBOicA,+GAEA,OADA,sBAqTA,UADA,OAEA,2BACA,QArTA,YDzmDA,aC2nDA,yBACA,QAGA,YPleA,iBOkeA,UP1dA,oBJ32BA,UWslDA,wBP3uBA,yBO2dA,UAKA,wHACA,6BAEA,OADA,sBAqRA,UADA,OAEA,2BACA,QArRA,YDzoDA,eCwqDA,0BACA,QAGA,aP/gBA,mHO+gBA,uDO1xCA,iEdmxBA,4CJ32BA,UWslDA,wBP3uBA,yBOugBA,4NAEA,OADA,sBA+OA,UADA,OAEA,4BACA,QA/OA,aD/qDA,aCirDA,yBACA,QAGA,YPxhBA,iBOwhBA,UPhhBA,oBJ32BA,UWslDA,wBP3uBA,yBOihBA,+GAEA,OADA,sBAqOA,UADA,OAEA,2BACA,QArOA,YDzrDA,eCitDA,gCXv5CA,UA9UA,UWsuDA,wBAtuDA,KAu6BA,aACA,eACA,eAtRA,sBAskCA,OAiBA,cPzjBA,0FOyjBA,uDOp0CA,iEdmxBA,4CAzrCA,EOo6DA,OP3uBA,yBOuvBA,UADA,UAEA,2BACA,UA5xCA,aAtpBA,OA+tDA,mBA/tDA,4BA4uDA,YA5uDA,OAivDA,SPhkBA,OOgkBA,UPxjBA,wBOqjBA,iBP7jBA,+BO6jBA,UPrjBA,2BOpKA,SP4JA,OO5JA,UPoKA,yBOyjBA,SACA,qCAnvDA,UAshCA,SAGA,mBd6iBA,cLjkDA,UALA,KEoFA,SAcA,GiB+gBA,kBAjnBA,UPyrCA,2BOvSA,URDA,OAEA,eJrSA,aA9mBA,YGyWA,gCAzWA,gCS2vDA,SP1kBA,OO0kBA,UACA,aP3kBA,uFO2kBA,OA5vDA,OA4vDA,qFAFA,4BA1vDA,ET08BA,UACA,sBAIA,oBHnmBA,0DGomBA,oBJlIA,YM2WA,iBbl/BA,OAvMA,OoB+vDA,cA/vDA,KAkwDA,iIACA,OAnwDA,GA4vDA,+DOt1CA,yEdmxBA,yCbl/BA,OAvMA,MQ2DA,cA3DA,IRiOA,WGzHA,SK7CA,kBRsKA,QGzHA,QgBpFA,QCo5BA,YX1nBA,QL3SA,QQ+4BA,SAEA,SCqSA,yBO2kBA,mBAqCA,iCACA,QA1yDA,KAu6BA,qBACA,eACA,eAtRA,sBAqoCA,OAsBA,cP7nBA,OO6nBA,UPrnBA,0BJ32BA,UA9UA,EWo6DA,wBP3uBA,yBOuvBA,UADA,OAEA,2BACA,UA5xCA,aAtpBA,OAmyDA,mBAYA,SP9nBA,OAjrCA,EO+yDA,UPtnBA,uBAzrCA,UOizDA,UAOA,SPvoBA,OAjrCA,EOwzDA,UP/nBA,uBOunBA,aAUA,+KAOA,OADA,sBD5yDA,QCo5BA,YPiRA,yBOyoBA,gBAEA,6BACA,QAGA,cPvpBA,OOupBA,UP/oBA,uBJ32BA,UWslDA,wBP3uBA,yBOipBA,gBPzpBA,iBOypBA,UPjpBA,oBOuvBA,UADA,OAEA,2BACA,UAtGA,qCAMA,+GAEA,OADA,oBAEA,YDj0DA,eCgyBA,mCAEA,OAtzBA,gCAqhCA,MP4JA,OO5JA,UPoKA,wBOhXA,iDACA,iDACA,iDAGA,iDAEA,iDAEA,iDAEA,sCAZA,iDAIA,iDACA,iDAEA,iDAEA,iDAj1BA,SAshCA,SAGA,mBAxaA,eAjnBA,UPyrCA,qCOvSA,gBRDA,OAEA,YJrSA,UA9mBA,YY2iBA,OA3iBA,aJ0NA,OIsVA,wCAhjBA,UJ0NA,OIsVA,qCAhjBA,IAwjBA,OAxjBA,MJ0NA,OImWA,2CA7jBA,IA2iBA,OA3iBA,MJ0NA,OIsVA,oCAhjBA,4BA6jBA,YRqVA,SAEA,SQjFA,gEAuBA,kBAqBA,eACA,SPiUA,OAjrCA,YOg3BA,UPiUA,aAQA,2BAzrCA,EOi3BA,OACA,4CdotBA,cLjkDA,UALA,SEoFA,SAcA,GAlGA,KQyWA,yBAzWA,iDSy3BA,SPwTA,OOxTA,UA4JA,SP4JA,OO5JA,UArhCA,YAshCA,SAraA,sBAjnBA,IAk5BA,ORDA,OAEA,YAn5BA,OJ8mBA,YG4VA,UACA,sBH/lBA,gCGomBA,oBJlIA,YMmWA,OAQA,wBbx9BA,UoB+pBA,4DPyTA,qBOhKA,mBAzhCA,UPyrCA,kCbx9BA,SGzHA,SiByxBA,YRiBA,SAEA,SHtmBA,QL3SA,egBswBA,gBACA,SPuaA,6HOvaA,0DOpWA,yEdmxBA,mDO9aA,SPsaA,OAjrCA,EO2wBA,UPsaA,aAQA,2BAzrCA,EO4wBA,OACA,4CAKA,cP+ZA,8FO/ZA,uDO5WA,8DdmxBA,mDOvaA,kFAGA,YAFA,OAEA,wBAFA,iGAIA,mBAxBA,eACA,MPibA,OAjrCA,IOgwBA,UPibA,UAQA,2BAzrCA,WOkwBA,UP+aA,OO/aA,UP+aA,UAQA,2BOnbA,mCACA,gBAvDA,YAuNA,eACA,YACA,eAtNA,kBAntBA,YAmtBA,OAWA,EP2dA,mCO3dA,EAVA,QAUA,EATA,QASA,EARA,QAQA,EANA,yCAMA,EA0MA,mBAlIA,gBAEA,SPyYA,gIOzYA,0DOlYA,yEdmxBA,sDAzrCA,WOu6BA,eACA,YACA,eA5SA,oBAGA,aPyjBA,qCOlZA,8BAiIA,YA7HA,mBAlBA,gBACA,SPuZA,OAjrCA,IO0xBA,UPuZA,aAQA,2BAzrCA,EO2xBA,OACA,4CAKA,cPgZA,8FOhZA,uDO3XA,iEdmxBA,mDOxZA,qFAEA,kJACA,iBAzwBA,0DAEA,OAFA,oBAGA,UAHA,0BA3BA,EA2BA,kHpBuDA,iBC7EA,OALA,SEoFA,iCAcA,GAlGA,KH+GA,0BI5GA,YJ6RA,uBA/DA,UC5NA,YDmTA,OE2oBA,wECp0BA,mBA7BA,GAdA,eHsPA,OACA,UAEA,YI1UA,QD+FA,QH8LA,yBA/DA,UC5NA,YDmTA,OE2oBA,wEC9zBA,uBH+KA,OApTA,OGoFA,WHsPA,OACA,UAEA,YI1UA,QD+FA,WH8LA,yBA/DA,UC5NA,YDmTA,OE2oBA,wEC9zBA,uBH+KA,OApTA,OGoFA,WHsPA,OACA,UAEA,YI1UA,QD+FA,WH8LA,yBA/DA,UC5NA,YDmTA,OE2oBA,wEC9zBA,uBH+KA,OApTA,OGoFA,WHsPA,OACA,UAEA,YI1UA,QD+FA,WH8LA,yBA/DA,UC5NA,YDmTA,OE2oBA,wEC9zBA,uBH+KA,OApTA,OGoFA,YHsPA,OACA,UAEA,YI1UA,QD+FA,WsB+aA,EtB7bA,SAcA,GuBgJA,cDuSA,iBItaA,ehB6zBA,8BACA,2BIpkBA,gBJokBA,OIpkBA,yCEtVA,gBFkgDA,sDAzhDA,256CAyhDA,kBA/zCA,WACA,OAEA,gBACA,2DAIA,oEAHA,iBI8CA,eJtDA,ONoiCA,6BXvvBA,oBM8hCA,YL7hDA,sBALA,KDkhBA,OEibA,wEC9zBA,kCQ6uDA,iBAl3DA,IRoFA,8CAGA,SKyjCA,MRrnBA,OACA,WW6IA,UC+BA,aDqjBA,YF/8BA,OL3SA,QD+FA,QoB2hCA,gBAoBA,wDACA,gFVr1BA,UckGA,oBChKA,yFL05BA,iBf9lCA,QewlCA,OfxlCA,KA3DA,WA2DA,0BA3DA,ELkQA,WA1JA,oBoB+iCA,WAMA,aK95BA,QpBpMA,QA3DA,WA2DA,0BA3DA,ELkQA,WA1JA,uB2B1FA,iB7BTA,OALA,SEoFA,iCAcA,GAlGA,K2BmBA,c1BhBA,U0BmBA,O3BkFA,W2B3EA,gBnBwSA,cD3JA,uJUwyCA,6GAl9CA,MUsCA,gBAGA,ejBouBA,WiBnuBA,WA1CA,EtB2DA,eA3DA,oCRiOA,YGzHA,SHyHA,YGzHA,eK7CA,UA3DA,ORiOA,YGzHA,eHyHA,YGzHA,WHyHA,YGzHA,WAxGA,EQwqDA,iBH7mDA,qBA3DA,IRiOA,WGzHA,SK7CA,kBRsKA,YGzHA,aAxGA,EQwqDA,gBXj+CA,UQ5IA,OA3DA,IRiOA,WGzHA,SAxGA,EHiOA,WGzHA,YK7CA,kBA3DA,ERiOA,WGzHA,YAxGA,EHiOA,WGzHA,YAxGA,EQwqDA,cH7mDA,mBA3DA,IA2DA,URsKA,WGzHA,MAxGA,EHiOA,WGzHA,YK7CA,cA3DA,ERiOA,YGzHA,a2BvDA,eAjDA,E9BiOA,QGzHA,S2BrDA,aAbA,+BbuUA,sBatUA,QbsUA,UatUA,YbsUA,iCatUA,ejBuuBA,0BLntBA,ERsKA,QGzHA,YkB+JA,SACA,iBAUA,UALA,SACA,YJ3FA,eACA,OApLA,IKqeA,QACA,cAteA,EAweA,QAEA,cADA,wBAzeA,EA4eA,SAGA,cADA,iBADA,wBAKA,cAGA,cAFA,iBACA,sBDvOA,eJxFA,kBAuBA,eAsBA,0EACA,kBI0CA,YEi4BA,OV9NA,+BACA,2BIpkBA,gBJokBA,OIpkBA,0CEtVA","sourcesContent":["// unknown wasmdis0-cb7df6f5b7cc54c9b9c620d3cba78e78.rs","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse core::cmp;\nuse core::mem;\nuse core::ops::Drop;\nuse core::ptr::{self, Unique};\nuse core::slice;\nuse heap::{Alloc, Layout, Heap};\nuse super::boxed::Box;\n\n/// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n/// a buffer of memory on the heap without having to worry about all the corner cases\n/// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n/// In particular:\n///\n/// * Produces Unique::empty() on zero-sized types\n/// * Produces Unique::empty() on zero-length allocations\n/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics)\n/// * Guards against 32-bit systems allocating more than isize::MAX bytes\n/// * Guards against overflowing your length\n/// * Aborts on OOM\n/// * Avoids freeing Unique::empty()\n/// * Contains a ptr::Unique and thus endows the user with all related benefits\n///\n/// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n/// free its memory, but it *won't* try to Drop its contents. It is up to the user of RawVec\n/// to handle the actual things *stored* inside of a RawVec.\n///\n/// Note that a RawVec always forces its capacity to be usize::MAX for zero-sized types.\n/// This enables you to use capacity growing logic catch the overflows in your length\n/// that might occur with zero-sized types.\n///\n/// However this means that you need to be careful when roundtripping this type\n/// with a `Box<[T]>`: `cap()` won't yield the len. However `with_capacity`,\n/// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n/// field. This allows zero-sized types to not be special-cased by consumers of\n/// this type.\n#[allow(missing_debug_implementations)]\npub struct RawVec<T, A: Alloc = Heap> {\n    ptr: Unique<T>,\n    cap: usize,\n    a: A,\n}\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    /// Like `new` but parameterized over the choice of allocator for\n    /// the returned RawVec.\n    pub fn new_in(a: A) -> Self {\n        // !0 is usize::MAX. This branch should be stripped at compile time.\n        let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n\n        // Unique::empty() doubles as \"unallocated\" and \"zero-sized allocation\"\n        RawVec {\n            ptr: Unique::empty(),\n            cap,\n            a,\n        }\n    }\n\n    /// Like `with_capacity` but parameterized over the choice of\n    /// allocator for the returned RawVec.\n    #[inline]\n    pub fn with_capacity_in(cap: usize, a: A) -> Self {\n        RawVec::allocate_in(cap, false, a)\n    }\n\n    /// Like `with_capacity_zeroed` but parameterized over the choice\n    /// of allocator for the returned RawVec.\n    #[inline]\n    pub fn with_capacity_zeroed_in(cap: usize, a: A) -> Self {\n        RawVec::allocate_in(cap, true, a)\n    }\n\n    fn allocate_in(cap: usize, zeroed: bool, mut a: A) -> Self {\n        unsafe {\n            let elem_size = mem::size_of::<T>();\n\n            let alloc_size = cap.checked_mul(elem_size).expect(\"capacity overflow\");\n            alloc_guard(alloc_size);\n\n            // handles ZSTs and `cap = 0` alike\n            let ptr = if alloc_size == 0 {\n                mem::align_of::<T>() as *mut u8\n            } else {\n                let align = mem::align_of::<T>();\n                let result = if zeroed {\n                    a.alloc_zeroed(Layout::from_size_align(alloc_size, align).unwrap())\n                } else {\n                    a.alloc(Layout::from_size_align(alloc_size, align).unwrap())\n                };\n                match result {\n                    Ok(ptr) => ptr,\n                    Err(err) => a.oom(err),\n                }\n            };\n\n            RawVec {\n                ptr: Unique::new_unchecked(ptr as *mut _),\n                cap,\n                a,\n            }\n        }\n    }\n}\n\nimpl<T> RawVec<T, Heap> {\n    /// Creates the biggest possible RawVec (on the system heap)\n    /// without allocating. If T has positive size, then this makes a\n    /// RawVec with capacity 0. If T has 0 size, then it makes a\n    /// RawVec with capacity `usize::MAX`. Useful for implementing\n    /// delayed allocation.\n    pub fn new() -> Self {\n        Self::new_in(Heap)\n    }\n\n    /// Creates a RawVec (on the system heap) with exactly the\n    /// capacity and alignment requirements for a `[T; cap]`. This is\n    /// equivalent to calling RawVec::new when `cap` is 0 or T is\n    /// zero-sized. Note that if `T` is zero-sized this means you will\n    /// *not* get a RawVec with the requested capacity!\n    ///\n    /// # Panics\n    ///\n    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM\n    #[inline]\n    pub fn with_capacity(cap: usize) -> Self {\n        RawVec::allocate_in(cap, false, Heap)\n    }\n\n    /// Like `with_capacity` but guarantees the buffer is zeroed.\n    #[inline]\n    pub fn with_capacity_zeroed(cap: usize) -> Self {\n        RawVec::allocate_in(cap, true, Heap)\n    }\n}\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    /// Reconstitutes a RawVec from a pointer, capacity, and allocator.\n    ///\n    /// # Undefined Behavior\n    ///\n    /// The ptr must be allocated (via the given allocator `a`), and with the given capacity. The\n    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n    /// If the ptr and capacity come from a RawVec created via `a`, then this is guaranteed.\n    pub unsafe fn from_raw_parts_in(ptr: *mut T, cap: usize, a: A) -> Self {\n        RawVec {\n            ptr: Unique::new_unchecked(ptr),\n            cap,\n            a,\n        }\n    }\n}\n\nimpl<T> RawVec<T, Heap> {\n    /// Reconstitutes a RawVec from a pointer, capacity.\n    ///\n    /// # Undefined Behavior\n    ///\n    /// The ptr must be allocated (on the system heap), and with the given capacity. The\n    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n    /// If the ptr and capacity come from a RawVec, then this is guaranteed.\n    pub unsafe fn from_raw_parts(ptr: *mut T, cap: usize) -> Self {\n        RawVec {\n            ptr: Unique::new_unchecked(ptr),\n            cap,\n            a: Heap,\n        }\n    }\n\n    /// Converts a `Box<[T]>` into a `RawVec<T>`.\n    pub fn from_box(mut slice: Box<[T]>) -> Self {\n        unsafe {\n            let result = RawVec::from_raw_parts(slice.as_mut_ptr(), slice.len());\n            mem::forget(slice);\n            result\n        }\n    }\n}\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    /// Gets a raw pointer to the start of the allocation. Note that this is\n    /// Unique::empty() if `cap = 0` or T is zero-sized. In the former case, you must\n    /// be careful.\n    pub fn ptr(&self) -> *mut T {\n        self.ptr.as_ptr()\n    }\n\n    /// Gets the capacity of the allocation.\n    ///\n    /// This will always be `usize::MAX` if `T` is zero-sized.\n    #[inline(always)]\n    pub fn cap(&self) -> usize {\n        if mem::size_of::<T>() == 0 {\n            !0\n        } else {\n            self.cap\n        }\n    }\n\n    /// Returns a shared reference to the allocator backing this RawVec.\n    pub fn alloc(&self) -> &A {\n        &self.a\n    }\n\n    /// Returns a mutable reference to the allocator backing this RawVec.\n    pub fn alloc_mut(&mut self) -> &mut A {\n        &mut self.a\n    }\n\n    fn current_layout(&self) -> Option<Layout> {\n        if self.cap == 0 {\n            None\n        } else {\n            // We have an allocated chunk of memory, so we can bypass runtime\n            // checks to get our current layout.\n            unsafe {\n                let align = mem::align_of::<T>();\n                let size = mem::size_of::<T>() * self.cap;\n                Some(Layout::from_size_align_unchecked(size, align))\n            }\n        }\n    }\n\n    /// Doubles the size of the type's backing allocation. This is common enough\n    /// to want to do that it's easiest to just have a dedicated method. Slightly\n    /// more efficient logic can be provided for this than the general case.\n    ///\n    /// This function is ideal for when pushing elements one-at-a-time because\n    /// you don't need to incur the costs of the more general computations\n    /// reserve needs to do to guard against overflow. You do however need to\n    /// manually check if your `len == cap`.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n    ///   all `usize::MAX` slots in your imaginary buffer.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(alloc)]\n    /// # extern crate alloc;\n    /// # use std::ptr;\n    /// # use alloc::raw_vec::RawVec;\n    /// struct MyVec<T> {\n    ///     buf: RawVec<T>,\n    ///     len: usize,\n    /// }\n    ///\n    /// impl<T> MyVec<T> {\n    ///     pub fn push(&mut self, elem: T) {\n    ///         if self.len == self.buf.cap() { self.buf.double(); }\n    ///         // double would have aborted or panicked if the len exceeded\n    ///         // `isize::MAX` so this is safe to do unchecked now.\n    ///         unsafe {\n    ///             ptr::write(self.buf.ptr().offset(self.len as isize), elem);\n    ///         }\n    ///         self.len += 1;\n    ///     }\n    /// }\n    /// # fn main() {\n    /// #   let mut vec = MyVec { buf: RawVec::new(), len: 0 };\n    /// #   vec.push(1);\n    /// # }\n    /// ```\n    #[inline(never)]\n    #[cold]\n    pub fn double(&mut self) {\n        unsafe {\n            let elem_size = mem::size_of::<T>();\n\n            // since we set the capacity to usize::MAX when elem_size is\n            // 0, getting to here necessarily means the RawVec is overfull.\n            assert!(elem_size != 0, \"capacity overflow\");\n\n            let (new_cap, uniq) = match self.current_layout() {\n                Some(cur) => {\n                    // Since we guarantee that we never allocate more than\n                    // isize::MAX bytes, `elem_size * self.cap <= isize::MAX` as\n                    // a precondition, so this can't overflow. Additionally the\n                    // alignment will never be too large as to \"not be\n                    // satisfiable\", so `Layout::from_size_align` will always\n                    // return `Some`.\n                    //\n                    // tl;dr; we bypass runtime checks due to dynamic assertions\n                    // in this module, allowing us to use\n                    // `from_size_align_unchecked`.\n                    let new_cap = 2 * self.cap;\n                    let new_size = new_cap * elem_size;\n                    let new_layout = Layout::from_size_align_unchecked(new_size, cur.align());\n                    alloc_guard(new_size);\n                    let ptr_res = self.a.realloc(self.ptr.as_ptr() as *mut u8,\n                                                 cur,\n                                                 new_layout);\n                    match ptr_res {\n                        Ok(ptr) => (new_cap, Unique::new_unchecked(ptr as *mut T)),\n                        Err(e) => self.a.oom(e),\n                    }\n                }\n                None => {\n                    // skip to 4 because tiny Vec's are dumb; but not if that\n                    // would cause overflow\n                    let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                    match self.a.alloc_array::<T>(new_cap) {\n                        Ok(ptr) => (new_cap, ptr.into()),\n                        Err(e) => self.a.oom(e),\n                    }\n                }\n            };\n            self.ptr = uniq;\n            self.cap = new_cap;\n        }\n    }\n\n    /// Attempts to double the size of the type's backing allocation in place. This is common\n    /// enough to want to do that it's easiest to just have a dedicated method. Slightly\n    /// more efficient logic can be provided for this than the general case.\n    ///\n    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n    ///   all `usize::MAX` slots in your imaginary buffer.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    #[inline(never)]\n    #[cold]\n    pub fn double_in_place(&mut self) -> bool {\n        unsafe {\n            let elem_size = mem::size_of::<T>();\n            let old_layout = match self.current_layout() {\n                Some(layout) => layout,\n                None => return false, // nothing to double\n            };\n\n            // since we set the capacity to usize::MAX when elem_size is\n            // 0, getting to here necessarily means the RawVec is overfull.\n            assert!(elem_size != 0, \"capacity overflow\");\n\n            // Since we guarantee that we never allocate more than isize::MAX\n            // bytes, `elem_size * self.cap <= isize::MAX` as a precondition, so\n            // this can't overflow.\n            //\n            // Similarly like with `double` above we can go straight to\n            // `Layout::from_size_align_unchecked` as we know this won't\n            // overflow and the alignment is sufficiently small.\n            let new_cap = 2 * self.cap;\n            let new_size = new_cap * elem_size;\n            alloc_guard(new_size);\n            let ptr = self.ptr() as *mut _;\n            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n            match self.a.grow_in_place(ptr, old_layout, new_layout) {\n                Ok(_) => {\n                    // We can't directly divide `size`.\n                    self.cap = new_cap;\n                    true\n                }\n                Err(_) => {\n                    false\n                }\n            }\n        }\n    }\n\n    /// Ensures that the buffer contains at least enough space to hold\n    /// `used_cap + needed_extra_cap` elements. If it doesn't already,\n    /// will reallocate the minimum possible amount of memory necessary.\n    /// Generally this will be exactly the amount of memory necessary,\n    /// but in principle the allocator is free to give back more than\n    /// we asked for.\n    ///\n    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n    /// the requested space. This is not really unsafe, but the unsafe\n    /// code *you* write that relies on the behavior of this function may break.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM\n    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n        unsafe {\n            // NOTE: we don't early branch on ZSTs here because we want this\n            // to actually catch \"asking for more than usize::MAX\" in that case.\n            // If we make it past the first branch then we are guaranteed to\n            // panic.\n\n            // Don't actually need any more capacity.\n            // Wrapping in case they gave a bad `used_cap`.\n            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n                return;\n            }\n\n            // Nothing we can really do about these checks :(\n            let new_cap = used_cap.checked_add(needed_extra_cap).expect(\"capacity overflow\");\n            let new_layout = match Layout::array::<T>(new_cap) {\n                Some(layout) => layout,\n                None => panic!(\"capacity overflow\"),\n            };\n            alloc_guard(new_layout.size());\n            let res = match self.current_layout() {\n                Some(layout) => {\n                    let old_ptr = self.ptr.as_ptr() as *mut u8;\n                    self.a.realloc(old_ptr, layout, new_layout)\n                }\n                None => self.a.alloc(new_layout),\n            };\n            let uniq = match res {\n                Ok(ptr) => Unique::new_unchecked(ptr as *mut T),\n                Err(e) => self.a.oom(e),\n            };\n            self.ptr = uniq;\n            self.cap = new_cap;\n        }\n    }\n\n    /// Calculates the buffer's new size given that it'll hold `used_cap +\n    /// needed_extra_cap` elements. This logic is used in amortized reserve methods.\n    /// Returns `(new_capacity, new_alloc_size)`.\n    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize) -> usize {\n        // Nothing we can really do about these checks :(\n        let required_cap = used_cap.checked_add(needed_extra_cap)\n            .expect(\"capacity overflow\");\n        // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n        let double_cap = self.cap * 2;\n        // `double_cap` guarantees exponential growth.\n        cmp::max(double_cap, required_cap)\n    }\n\n    /// Ensures that the buffer contains at least enough space to hold\n    /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n    /// enough capacity, will reallocate enough space plus comfortable slack\n    /// space to get amortized `O(1)` behavior. Will limit this behavior\n    /// if it would needlessly cause itself to panic.\n    ///\n    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n    /// the requested space. This is not really unsafe, but the unsafe\n    /// code *you* write that relies on the behavior of this function may break.\n    ///\n    /// This is ideal for implementing a bulk-push operation like `extend`.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(alloc)]\n    /// # extern crate alloc;\n    /// # use std::ptr;\n    /// # use alloc::raw_vec::RawVec;\n    /// struct MyVec<T> {\n    ///     buf: RawVec<T>,\n    ///     len: usize,\n    /// }\n    ///\n    /// impl<T: Clone> MyVec<T> {\n    ///     pub fn push_all(&mut self, elems: &[T]) {\n    ///         self.buf.reserve(self.len, elems.len());\n    ///         // reserve would have aborted or panicked if the len exceeded\n    ///         // `isize::MAX` so this is safe to do unchecked now.\n    ///         for x in elems {\n    ///             unsafe {\n    ///                 ptr::write(self.buf.ptr().offset(self.len as isize), x.clone());\n    ///             }\n    ///             self.len += 1;\n    ///         }\n    ///     }\n    /// }\n    /// # fn main() {\n    /// #   let mut vector = MyVec { buf: RawVec::new(), len: 0 };\n    /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n    /// # }\n    /// ```\n    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n        unsafe {\n            // NOTE: we don't early branch on ZSTs here because we want this\n            // to actually catch \"asking for more than usize::MAX\" in that case.\n            // If we make it past the first branch then we are guaranteed to\n            // panic.\n\n            // Don't actually need any more capacity.\n            // Wrapping in case they give a bad `used_cap`\n            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n                return;\n            }\n\n            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap);\n\n            let new_layout = match Layout::array::<T>(new_cap) {\n                Some(layout) => layout,\n                None => panic!(\"capacity overflow\"),\n            };\n            // FIXME: may crash and burn on over-reserve\n            alloc_guard(new_layout.size());\n            let res = match self.current_layout() {\n                Some(layout) => {\n                    let old_ptr = self.ptr.as_ptr() as *mut u8;\n                    self.a.realloc(old_ptr, layout, new_layout)\n                }\n                None => self.a.alloc(new_layout),\n            };\n            let uniq = match res {\n                Ok(ptr) => Unique::new_unchecked(ptr as *mut T),\n                Err(e) => self.a.oom(e),\n            };\n            self.ptr = uniq;\n            self.cap = new_cap;\n        }\n    }\n\n    /// Attempts to ensure that the buffer contains at least enough space to hold\n    /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n    /// enough capacity, will reallocate in place enough space plus comfortable slack\n    /// space to get amortized `O(1)` behavior. Will limit this behaviour\n    /// if it would needlessly cause itself to panic.\n    ///\n    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n    /// the requested space. This is not really unsafe, but the unsafe\n    /// code *you* write that relies on the behavior of this function may break.\n    ///\n    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    pub fn reserve_in_place(&mut self, used_cap: usize, needed_extra_cap: usize) -> bool {\n        unsafe {\n            // NOTE: we don't early branch on ZSTs here because we want this\n            // to actually catch \"asking for more than usize::MAX\" in that case.\n            // If we make it past the first branch then we are guaranteed to\n            // panic.\n\n            // Don't actually need any more capacity. If the current `cap` is 0, we can't\n            // reallocate in place.\n            // Wrapping in case they give a bad `used_cap`\n            let old_layout = match self.current_layout() {\n                Some(layout) => layout,\n                None => return false,\n            };\n            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n                return false;\n            }\n\n            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap);\n\n            // Here, `cap < used_cap + needed_extra_cap <= new_cap`\n            // (regardless of whether `self.cap - used_cap` wrapped).\n            // Therefore we can safely call grow_in_place.\n\n            let ptr = self.ptr() as *mut _;\n            let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n            // FIXME: may crash and burn on over-reserve\n            alloc_guard(new_layout.size());\n            match self.a.grow_in_place(ptr, old_layout, new_layout) {\n                Ok(_) => {\n                    self.cap = new_cap;\n                    true\n                }\n                Err(_) => {\n                    false\n                }\n            }\n        }\n    }\n\n    /// Shrinks the allocation down to the specified amount. If the given amount\n    /// is 0, actually completely deallocates.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the given amount is *larger* than the current capacity.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM.\n    pub fn shrink_to_fit(&mut self, amount: usize) {\n        let elem_size = mem::size_of::<T>();\n\n        // Set the `cap` because they might be about to promote to a `Box<[T]>`\n        if elem_size == 0 {\n            self.cap = amount;\n            return;\n        }\n\n        // This check is my waterloo; it's the only thing Vec wouldn't have to do.\n        assert!(self.cap >= amount, \"Tried to shrink to a larger capacity\");\n\n        if amount == 0 {\n            // We want to create a new zero-length vector within the\n            // same allocator.  We use ptr::write to avoid an\n            // erroneous attempt to drop the contents, and we use\n            // ptr::read to sidestep condition against destructuring\n            // types that implement Drop.\n\n            unsafe {\n                let a = ptr::read(&self.a as *const A);\n                self.dealloc_buffer();\n                ptr::write(self, RawVec::new_in(a));\n            }\n        } else if self.cap != amount {\n            unsafe {\n                // We know here that our `amount` is greater than zero. This\n                // implies, via the assert above, that capacity is also greater\n                // than zero, which means that we've got a current layout that\n                // \"fits\"\n                //\n                // We also know that `self.cap` is greater than `amount`, and\n                // consequently we don't need runtime checks for creating either\n                // layout\n                let old_size = elem_size * self.cap;\n                let new_size = elem_size * amount;\n                let align = mem::align_of::<T>();\n                let old_layout = Layout::from_size_align_unchecked(old_size, align);\n                let new_layout = Layout::from_size_align_unchecked(new_size, align);\n                match self.a.realloc(self.ptr.as_ptr() as *mut u8,\n                                     old_layout,\n                                     new_layout) {\n                    Ok(p) => self.ptr = Unique::new_unchecked(p as *mut T),\n                    Err(err) => self.a.oom(err),\n                }\n            }\n            self.cap = amount;\n        }\n    }\n}\n\nimpl<T> RawVec<T, Heap> {\n    /// Converts the entire buffer into `Box<[T]>`.\n    ///\n    /// While it is not *strictly* Undefined Behavior to call\n    /// this procedure while some of the RawVec is uninitialized,\n    /// it certainly makes it trivial to trigger it.\n    ///\n    /// Note that this will correctly reconstitute any `cap` changes\n    /// that may have been performed. (see description of type for details)\n    pub unsafe fn into_box(self) -> Box<[T]> {\n        // NOTE: not calling `cap()` here, actually using the real `cap` field!\n        let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);\n        let output: Box<[T]> = Box::from_raw(slice);\n        mem::forget(self);\n        output\n    }\n}\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n    pub unsafe fn dealloc_buffer(&mut self) {\n        let elem_size = mem::size_of::<T>();\n        if elem_size != 0 {\n            if let Some(layout) = self.current_layout() {\n                let ptr = self.ptr() as *mut u8;\n                self.a.dealloc(ptr, layout);\n            }\n        }\n    }\n}\n\nunsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n    fn drop(&mut self) {\n        unsafe { self.dealloc_buffer(); }\n    }\n}\n\n\n\n// We need to guarantee the following:\n// * We don't ever allocate `> isize::MAX` byte-size objects\n// * We don't overflow `usize::MAX` and actually allocate too little\n//\n// On 64-bit we just need to check for overflow since trying to allocate\n// `> isize::MAX` bytes will surely fail. On 32-bit and 16-bit we need to add\n// an extra guard for this in case we're running on a platform which can use\n// all 4GB in user-space. e.g. PAE or x32\n\n#[inline]\nfn alloc_guard(alloc_size: usize) {\n    if mem::size_of::<usize>() < 8 {\n        assert!(alloc_size <= ::core::isize::MAX as usize,\n                \"capacity overflow\");\n    }\n}\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn allocator_param() {\n        use allocator::{Alloc, AllocErr};\n\n        // Writing a test of integration between third-party\n        // allocators and RawVec is a little tricky because the RawVec\n        // API does not expose fallible allocation methods, so we\n        // cannot check what happens when allocator is exhausted\n        // (beyond detecting a panic).\n        //\n        // Instead, this just checks that the RawVec methods do at\n        // least go through the Allocator API when it reserves\n        // storage.\n\n        // A dumb allocator that consumes a fixed amount of fuel\n        // before allocation attempts start failing.\n        struct BoundedAlloc { fuel: usize }\n        unsafe impl Alloc for BoundedAlloc {\n            unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n                let size = layout.size();\n                if size > self.fuel {\n                    return Err(AllocErr::Unsupported { details: \"fuel exhausted\" });\n                }\n                match Heap.alloc(layout) {\n                    ok @ Ok(_) => { self.fuel -= size; ok }\n                    err @ Err(_) => err,\n                }\n            }\n            unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n                Heap.dealloc(ptr, layout)\n            }\n        }\n\n        let a = BoundedAlloc { fuel: 500 };\n        let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n        assert_eq!(v.a.fuel, 450);\n        v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n        assert_eq!(v.a.fuel, 250);\n    }\n\n    #[test]\n    fn reserve_does_not_overallocate() {\n        {\n            let mut v: RawVec<u32> = RawVec::new();\n            // First `reserve` allocates like `reserve_exact`\n            v.reserve(0, 9);\n            assert_eq!(9, v.cap());\n        }\n\n        {\n            let mut v: RawVec<u32> = RawVec::new();\n            v.reserve(0, 7);\n            assert_eq!(7, v.cap());\n            // 97 if more than double of 7, so `reserve` should work\n            // like `reserve_exact`.\n            v.reserve(7, 90);\n            assert_eq!(97, v.cap());\n        }\n\n        {\n            let mut v: RawVec<u32> = RawVec::new();\n            v.reserve(0, 12);\n            assert_eq!(12, v.cap());\n            v.reserve(12, 3);\n            // 3 is less than half of 12, so `reserve` must grow\n            // exponentially. At the time of writing this test grow\n            // factor is 2, so new capacity is 24, however, grow factor\n            // of 1.5 is OK too. Hence `>= 18` in assert.\n            assert!(v.cap() >= 12 + 12 / 2);\n        }\n    }\n\n\n}\n","// unknown <assert macros>","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Basic functions for dealing with memory.\n//!\n//! This module contains functions for querying the size and alignment of\n//! types, initializing and manipulating memory.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse clone;\nuse cmp;\nuse fmt;\nuse hash;\nuse intrinsics;\nuse marker::{Copy, PhantomData, Sized};\nuse ptr;\nuse ops::{Deref, DerefMut};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use intrinsics::transmute;\n\n/// Leaks a value: takes ownership and \"forgets\" about the value **without running\n/// its destructor**.\n///\n/// Any resources the value manages, such as heap memory or a file handle, will linger\n/// forever in an unreachable state.\n///\n/// If you want to dispose of a value properly, running its destructor, see\n/// [`mem::drop`][drop].\n///\n/// # Safety\n///\n/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n/// do not include a guarantee that destructors will always run. For example,\n/// a program can create a reference cycle using [`Rc`][rc], or call\n/// [`process::exit`][exit] to exit without running destructors. Thus, allowing\n/// `mem::forget` from safe code does not fundamentally change Rust's safety\n/// guarantees.\n///\n/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n/// so `forget` is only recommended for specialized use cases like those shown below.\n///\n/// Because forgetting a value is allowed, any `unsafe` code you write must\n/// allow for this possibility. You cannot return a value and expect that the\n/// caller will necessarily run the value's destructor.\n///\n/// [rc]: ../../std/rc/struct.Rc.html\n/// [exit]: ../../std/process/fn.exit.html\n///\n/// # Examples\n///\n/// Leak some heap memory by never deallocating it:\n///\n/// ```\n/// use std::mem;\n///\n/// let heap_memory = Box::new(3);\n/// mem::forget(heap_memory);\n/// ```\n///\n/// Leak an I/O object, never closing the file:\n///\n/// ```no_run\n/// use std::mem;\n/// use std::fs::File;\n///\n/// let file = File::open(\"foo.txt\").unwrap();\n/// mem::forget(file);\n/// ```\n///\n/// The practical use cases for `forget` are rather specialized and mainly come\n/// up in unsafe or FFI code.\n///\n/// ## Use case 1\n///\n/// You have created an uninitialized value using [`mem::uninitialized`][uninit].\n/// You must either initialize or `forget` it on every computation path before\n/// Rust drops it automatically, like at the end of a scope or after a panic.\n/// Running the destructor on an uninitialized value would be [undefined behavior][ub].\n///\n/// ```\n/// use std::mem;\n/// use std::ptr;\n///\n/// # let some_condition = false;\n/// unsafe {\n///     let mut uninit_vec: Vec<u32> = mem::uninitialized();\n///\n///     if some_condition {\n///         // Initialize the variable.\n///         ptr::write(&mut uninit_vec, Vec::new());\n///     } else {\n///         // Forget the uninitialized value so its destructor doesn't run.\n///         mem::forget(uninit_vec);\n///     }\n/// }\n/// ```\n///\n/// ## Use case 2\n///\n/// You have duplicated the bytes making up a value, without doing a proper\n/// [`Clone`][clone]. You need the value's destructor to run only once,\n/// because a double `free` is undefined behavior.\n///\n/// An example is a possible implementation of [`mem::swap`][swap]:\n///\n/// ```\n/// use std::mem;\n/// use std::ptr;\n///\n/// # #[allow(dead_code)]\n/// fn swap<T>(x: &mut T, y: &mut T) {\n///     unsafe {\n///         // Give ourselves some scratch space to work with\n///         let mut t: T = mem::uninitialized();\n///\n///         // Perform the swap, `&mut` pointers never alias\n///         ptr::copy_nonoverlapping(&*x, &mut t, 1);\n///         ptr::copy_nonoverlapping(&*y, x, 1);\n///         ptr::copy_nonoverlapping(&t, y, 1);\n///\n///         // y and t now point to the same thing, but we need to completely\n///         // forget `t` because we do not want to run the destructor for `T`\n///         // on its value, which is still owned somewhere outside this function.\n///         mem::forget(t);\n///     }\n/// }\n/// ```\n///\n/// ## Use case 3\n///\n/// You are transferring ownership across a [FFI] boundary to code written in\n/// another language. You need to `forget` the value on the Rust side because Rust\n/// code is no longer responsible for it.\n///\n/// ```no_run\n/// use std::mem;\n///\n/// extern \"C\" {\n///     fn my_c_function(x: *const u32);\n/// }\n///\n/// let x: Box<u32> = Box::new(3);\n///\n/// // Transfer ownership into C code.\n/// unsafe {\n///     my_c_function(&*x);\n/// }\n/// mem::forget(x);\n/// ```\n///\n/// In this case, C code must call back into Rust to free the object. Calling C's `free`\n/// function on a [`Box`][box] is *not* safe! Also, `Box` provides an [`into_raw`][into_raw]\n/// method which is the preferred way to do this in practice.\n///\n/// [drop]: fn.drop.html\n/// [uninit]: fn.uninitialized.html\n/// [clone]: ../clone/trait.Clone.html\n/// [swap]: fn.swap.html\n/// [FFI]: ../../book/first-edition/ffi.html\n/// [box]: ../../std/boxed/struct.Box.html\n/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n/// [ub]: ../../reference/behavior-considered-undefined.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn forget<T>(t: T) {\n    ManuallyDrop::new(t);\n}\n\n/// Returns the size of a type in bytes.\n///\n/// More specifically, this is the offset in bytes between successive elements\n/// in an array with that item type including alignment padding. Thus, for any\n/// type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n///\n/// In general, the size of a type is not stable across compilations, but\n/// specific types such as primitives are.\n///\n/// The following table gives the size for primitives.\n///\n/// Type | size_of::\\<Type>()\n/// ---- | ---------------\n/// () | 0\n/// u8 | 1\n/// u16 | 2\n/// u32 | 4\n/// u64 | 8\n/// i8 | 1\n/// i16 | 2\n/// i32 | 4\n/// i64 | 8\n/// f32 | 4\n/// f64 | 8\n/// char | 4\n///\n/// Furthermore, `usize` and `isize` have the same size.\n///\n/// The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have\n/// the same size. If `T` is Sized, all of those types have the same size as `usize`.\n///\n/// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n/// have the same size. Likewise for `*const T` and `*mut T`.\n///\n/// # Size of `#[repr(C)]` items\n///\n/// The `C` representation for items has a defined layout. With this layout,\n/// the size of items is also stable as long as all fields have a stable size.\n///\n/// ## Size of Structs\n///\n/// For `structs`, the size is determined by the following algorithm.\n///\n/// For each field in the struct ordered by declaration order:\n///\n/// 1. Add the size of the field.\n/// 2. Round up the current size to the nearest multiple of the next field's [alignment].\n///\n/// Finally, round the size of the struct to the nearest multiple of its [alignment].\n///\n/// Unlike `C`, zero sized structs are not rounded up to one byte in size.\n///\n/// ## Size of Enums\n///\n/// Enums that carry no data other than the descriminant have the same size as C enums\n/// on the platform they are compiled for.\n///\n/// ## Size of Unions\n///\n/// The size of a union is the size of its largest field.\n///\n/// Unlike `C`, zero sized unions are not rounded up to one byte in size.\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// // Some primitives\n/// assert_eq!(4, mem::size_of::<i32>());\n/// assert_eq!(8, mem::size_of::<f64>());\n/// assert_eq!(0, mem::size_of::<()>());\n///\n/// // Some arrays\n/// assert_eq!(8, mem::size_of::<[i32; 2]>());\n/// assert_eq!(12, mem::size_of::<[i32; 3]>());\n/// assert_eq!(0, mem::size_of::<[i32; 0]>());\n///\n///\n/// // Pointer size equality\n/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\n/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\n/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n/// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n/// ```\n///\n/// Using `#[repr(C)]`.\n///\n/// ```\n/// use std::mem;\n///\n/// #[repr(C)]\n/// struct FieldStruct {\n///     first: u8,\n///     second: u16,\n///     third: u8\n/// }\n///\n/// // The size of the first field is 1, so add 1 to the size. Size is 1.\n/// // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n/// // The size of the second field is 2, so add 2 to the size. Size is 4.\n/// // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n/// // The size of the third field is 1, so add 1 to the size. Size is 5.\n/// // Finally, the alignment of the struct is 2, so add 1 to the size for padding. Size is 6.\n/// assert_eq!(6, mem::size_of::<FieldStruct>());\n///\n/// #[repr(C)]\n/// struct TupleStruct(u8, u16, u8);\n///\n/// // Tuple structs follow the same rules.\n/// assert_eq!(6, mem::size_of::<TupleStruct>());\n///\n/// // Note that reordering the fields can lower the size. We can remove both padding bytes\n/// // by putting `third` before `second`.\n/// #[repr(C)]\n/// struct FieldStructOptimized {\n///     first: u8,\n///     third: u8,\n///     second: u16\n/// }\n///\n/// assert_eq!(4, mem::size_of::<FieldStructOptimized>());\n///\n/// // Union size is the size of the largest field.\n/// #[repr(C)]\n/// union ExampleUnion {\n///     smaller: u8,\n///     larger: u16\n/// }\n///\n/// assert_eq!(2, mem::size_of::<ExampleUnion>());\n/// ```\n///\n/// [alignment]: ./fn.align_of.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const fn size_of<T>() -> usize {\n    unsafe { intrinsics::size_of::<T>() }\n}\n\n/// Returns the size of the pointed-to value in bytes.\n///\n/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n/// statically known size, e.g. a slice [`[T]`][slice] or a [trait object],\n/// then `size_of_val` can be used to get the dynamically-known size.\n///\n/// [slice]: ../../std/primitive.slice.html\n/// [trait object]: ../../book/first-edition/trait-objects.html\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::size_of_val(&5i32));\n///\n/// let x: [u8; 13] = [0; 13];\n/// let y: &[u8] = &x;\n/// assert_eq!(13, mem::size_of_val(y));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n    unsafe { intrinsics::size_of_val(val) }\n}\n\n/// Returns the [ABI]-required minimum alignment of a type.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// # #![allow(deprecated)]\n/// use std::mem;\n///\n/// assert_eq!(4, mem::min_align_of::<i32>());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\npub fn min_align_of<T>() -> usize {\n    unsafe { intrinsics::min_align_of::<T>() }\n}\n\n/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// # #![allow(deprecated)]\n/// use std::mem;\n///\n/// assert_eq!(4, mem::min_align_of_val(&5i32));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\npub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n    unsafe { intrinsics::min_align_of_val(val) }\n}\n\n/// Returns the [ABI]-required minimum alignment of a type.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::align_of::<i32>());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const fn align_of<T>() -> usize {\n    unsafe { intrinsics::min_align_of::<T>() }\n}\n\n/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::align_of_val(&5i32));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n    unsafe { intrinsics::min_align_of_val(val) }\n}\n\n/// Returns whether dropping values of type `T` matters.\n///\n/// This is purely an optimization hint, and may be implemented conservatively:\n/// it may return `true` for types that don't actually need to be dropped.\n/// As such always returning `true` would be a valid implementation of\n/// this function. However if this function actually returns `false`, then you\n/// can be certain dropping `T` has no side effect.\n///\n/// Low level implementations of things like collections, which need to manually\n/// drop their data, should use this function to avoid unnecessarily\n/// trying to drop all their contents when they are destroyed. This might not\n/// make a difference in release builds (where a loop that has no side-effects\n/// is easily detected and eliminated), but is often a big win for debug builds.\n///\n/// Note that `ptr::drop_in_place` already performs this check, so if your workload\n/// can be reduced to some small number of drop_in_place calls, using this is\n/// unnecessary. In particular note that you can drop_in_place a slice, and that\n/// will do a single needs_drop check for all the values.\n///\n/// Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n/// needs_drop explicitly. Types like HashMap, on the other hand, have to drop\n/// values one at a time and should use this API.\n///\n///\n/// # Examples\n///\n/// Here's an example of how a collection might make use of needs_drop:\n///\n/// ```\n/// use std::{mem, ptr};\n///\n/// pub struct MyCollection<T> {\n/// #   data: [T; 1],\n///     /* ... */\n/// }\n/// # impl<T> MyCollection<T> {\n/// #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n/// #   fn free_buffer(&mut self) {}\n/// # }\n///\n/// impl<T> Drop for MyCollection<T> {\n///     fn drop(&mut self) {\n///         unsafe {\n///             // drop the data\n///             if mem::needs_drop::<T>() {\n///                 for x in self.iter_mut() {\n///                     ptr::drop_in_place(x);\n///                 }\n///             }\n///             self.free_buffer();\n///         }\n///     }\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"needs_drop\", since = \"1.21.0\")]\npub fn needs_drop<T>() -> bool {\n    unsafe { intrinsics::needs_drop::<T>() }\n}\n\n/// Creates a value whose bytes are all zero.\n///\n/// This has the same effect as allocating space with\n/// [`mem::uninitialized`][uninit] and then zeroing it out. It is useful for\n/// [FFI] sometimes, but should generally be avoided.\n///\n/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n/// some type `T`. If `T` has a destructor and the value is destroyed (due to\n/// a panic or the end of a scope) before being initialized, then the destructor\n/// will run on zeroed data, likely leading to [undefined behavior][ub].\n///\n/// See also the documentation for [`mem::uninitialized`][uninit], which has\n/// many of the same caveats.\n///\n/// [uninit]: fn.uninitialized.html\n/// [FFI]: ../../book/first-edition/ffi.html\n/// [ub]: ../../reference/behavior-considered-undefined.html\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// let x: i32 = unsafe { mem::zeroed() };\n/// assert_eq!(0, x);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn zeroed<T>() -> T {\n    intrinsics::init()\n}\n\n/// Bypasses Rust's normal memory-initialization checks by pretending to\n/// produce a value of type `T`, while doing nothing at all.\n///\n/// **This is incredibly dangerous and should not be done lightly. Deeply\n/// consider initializing your memory with a default value instead.**\n///\n/// This is useful for [FFI] functions and initializing arrays sometimes,\n/// but should generally be avoided.\n///\n/// [FFI]: ../../book/first-edition/ffi.html\n///\n/// # Undefined behavior\n///\n/// It is [undefined behavior][ub] to read uninitialized memory, even just an\n/// uninitialized boolean. For instance, if you branch on the value of such\n/// a boolean, your program may take one, both, or neither of the branches.\n///\n/// Writing to the uninitialized value is similarly dangerous. Rust believes the\n/// value is initialized, and will therefore try to [`Drop`] the uninitialized\n/// value and its fields if you try to overwrite it in a normal manner. The only way\n/// to safely initialize an uninitialized value is with [`ptr::write`][write],\n/// [`ptr::copy`][copy], or [`ptr::copy_nonoverlapping`][copy_no].\n///\n/// If the value does implement [`Drop`], it must be initialized before\n/// it goes out of scope (and therefore would be dropped). Note that this\n/// includes a `panic` occurring and unwinding the stack suddenly.\n///\n/// # Examples\n///\n/// Here's how to safely initialize an array of [`Vec`]s.\n///\n/// ```\n/// use std::mem;\n/// use std::ptr;\n///\n/// // Only declare the array. This safely leaves it\n/// // uninitialized in a way that Rust will track for us.\n/// // However we can't initialize it element-by-element\n/// // safely, and we can't use the `[value; 1000]`\n/// // constructor because it only works with `Copy` data.\n/// let mut data: [Vec<u32>; 1000];\n///\n/// unsafe {\n///     // So we need to do this to initialize it.\n///     data = mem::uninitialized();\n///\n///     // DANGER ZONE: if anything panics or otherwise\n///     // incorrectly reads the array here, we will have\n///     // Undefined Behavior.\n///\n///     // It's ok to mutably iterate the data, since this\n///     // doesn't involve reading it at all.\n///     // (ptr and len are statically known for arrays)\n///     for elem in &mut data[..] {\n///         // *elem = Vec::new() would try to drop the\n///         // uninitialized memory at `elem` -- bad!\n///         //\n///         // Vec::new doesn't allocate or do really\n///         // anything. It's only safe to call here\n///         // because we know it won't panic.\n///         ptr::write(elem, Vec::new());\n///     }\n///\n///     // SAFE ZONE: everything is initialized.\n/// }\n///\n/// println!(\"{:?}\", &data[0]);\n/// ```\n///\n/// This example emphasizes exactly how delicate and dangerous using `mem::uninitialized`\n/// can be. Note that the [`vec!`] macro *does* let you initialize every element with a\n/// value that is only [`Clone`], so the following is semantically equivalent and\n/// vastly less dangerous, as long as you can live with an extra heap\n/// allocation:\n///\n/// ```\n/// let data: Vec<Vec<u32>> = vec![Vec::new(); 1000];\n/// println!(\"{:?}\", &data[0]);\n/// ```\n///\n/// [`Vec`]: ../../std/vec/struct.Vec.html\n/// [`vec!`]: ../../std/macro.vec.html\n/// [`Clone`]: ../../std/clone/trait.Clone.html\n/// [ub]: ../../reference/behavior-considered-undefined.html\n/// [write]: ../ptr/fn.write.html\n/// [copy]: ../intrinsics/fn.copy.html\n/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n/// [`Drop`]: ../ops/trait.Drop.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn uninitialized<T>() -> T {\n    intrinsics::uninit()\n}\n\n/// Swaps the values at two mutable locations, without deinitializing either one.\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// let mut x = 5;\n/// let mut y = 42;\n///\n/// mem::swap(&mut x, &mut y);\n///\n/// assert_eq!(42, x);\n/// assert_eq!(5, y);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn swap<T>(x: &mut T, y: &mut T) {\n    unsafe {\n        ptr::swap_nonoverlapping(x, y, 1);\n    }\n}\n\n/// Replaces the value at a mutable location with a new one, returning the old value, without\n/// deinitializing either one.\n///\n/// # Examples\n///\n/// A simple example:\n///\n/// ```\n/// use std::mem;\n///\n/// let mut v: Vec<i32> = vec![1, 2];\n///\n/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n/// assert_eq!(2, old_v.len());\n/// assert_eq!(3, v.len());\n/// ```\n///\n/// `replace` allows consumption of a struct field by replacing it with another value.\n/// Without `replace` you can run into issues like these:\n///\n/// ```compile_fail,E0507\n/// struct Buffer<T> { buf: Vec<T> }\n///\n/// impl<T> Buffer<T> {\n///     fn get_and_reset(&mut self) -> Vec<T> {\n///         // error: cannot move out of dereference of `&mut`-pointer\n///         let buf = self.buf;\n///         self.buf = Vec::new();\n///         buf\n///     }\n/// }\n/// ```\n///\n/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n/// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n/// `self`, allowing it to be returned:\n///\n/// ```\n/// # #![allow(dead_code)]\n/// use std::mem;\n///\n/// # struct Buffer<T> { buf: Vec<T> }\n/// impl<T> Buffer<T> {\n///     fn get_and_reset(&mut self) -> Vec<T> {\n///         mem::replace(&mut self.buf, Vec::new())\n///     }\n/// }\n/// ```\n///\n/// [`Clone`]: ../../std/clone/trait.Clone.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn replace<T>(dest: &mut T, mut src: T) -> T {\n    swap(dest, &mut src);\n    src\n}\n\n/// Disposes of a value.\n///\n/// While this does call the argument's implementation of [`Drop`][drop],\n/// it will not release any borrows, as borrows are based on lexical scope.\n///\n/// This effectively does nothing for\n/// [types which implement `Copy`](../../book/first-edition/ownership.html#copy-types),\n/// e.g. integers. Such values are copied and _then_ moved into the function,\n/// so the value persists after this function call.\n///\n/// This function is not magic; it is literally defined as\n///\n/// ```\n/// pub fn drop<T>(_x: T) { }\n/// ```\n///\n/// Because `_x` is moved into the function, it is automatically dropped before\n/// the function returns.\n///\n/// [drop]: ../ops/trait.Drop.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let v = vec![1, 2, 3];\n///\n/// drop(v); // explicitly drop the vector\n/// ```\n///\n/// Borrows are based on lexical scope, so this produces an error:\n///\n/// ```compile_fail,E0502\n/// let mut v = vec![1, 2, 3];\n/// let x = &v[0];\n///\n/// drop(x); // explicitly drop the reference, but the borrow still exists\n///\n/// v.push(4); // error: cannot borrow `v` as mutable because it is also\n///            // borrowed as immutable\n/// ```\n///\n/// An inner scope is needed to fix this:\n///\n/// ```\n/// let mut v = vec![1, 2, 3];\n///\n/// {\n///     let x = &v[0];\n///\n///     drop(x); // this is now redundant, as `x` is going out of scope anyway\n/// }\n///\n/// v.push(4); // no problems\n/// ```\n///\n/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n/// release a [`RefCell`] borrow:\n///\n/// ```\n/// use std::cell::RefCell;\n///\n/// let x = RefCell::new(1);\n///\n/// let mut mutable_borrow = x.borrow_mut();\n/// *mutable_borrow = 1;\n///\n/// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n///\n/// let borrow = x.borrow();\n/// println!(\"{}\", *borrow);\n/// ```\n///\n/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n///\n/// ```\n/// #[derive(Copy, Clone)]\n/// struct Foo(u8);\n///\n/// let x = 1;\n/// let y = Foo(2);\n/// drop(x); // a copy of `x` is moved and dropped\n/// drop(y); // a copy of `y` is moved and dropped\n///\n/// println!(\"x: {}, y: {}\", x, y.0); // still available\n/// ```\n///\n/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n/// [`Copy`]: ../../std/marker/trait.Copy.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn drop<T>(_x: T) { }\n\n/// Interprets `src` as having type `&U`, and then reads `src` without moving\n/// the contained value.\n///\n/// This function will unsafely assume the pointer `src` is valid for\n/// [`size_of::<U>`][size_of] bytes by transmuting `&T` to `&U` and then reading\n/// the `&U`. It will also unsafely create a copy of the contained value instead of\n/// moving out of `src`.\n///\n/// It is not a compile-time error if `T` and `U` have different sizes, but it\n/// is highly encouraged to only invoke this function where `T` and `U` have the\n/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n/// `T`.\n///\n/// [ub]: ../../reference/behavior-considered-undefined.html\n/// [size_of]: fn.size_of.html\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// #[repr(packed)]\n/// struct Foo {\n///     bar: u8,\n/// }\n///\n/// let foo_slice = [10u8];\n///\n/// unsafe {\n///     // Copy the data from 'foo_slice' and treat it as a 'Foo'\n///     let mut foo_struct: Foo = mem::transmute_copy(&foo_slice);\n///     assert_eq!(foo_struct.bar, 10);\n///\n///     // Modify the copied data\n///     foo_struct.bar = 20;\n///     assert_eq!(foo_struct.bar, 20);\n/// }\n///\n/// // The contents of 'foo_slice' should not have changed\n/// assert_eq!(foo_slice, [10]);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n    ptr::read(src as *const T as *const U)\n}\n\n/// Opaque type representing the discriminant of an enum.\n///\n/// See the `discriminant` function in this module for more information.\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\npub struct Discriminant<T>(u64, PhantomData<fn() -> T>);\n\n// N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\nimpl<T> Copy for Discriminant<T> {}\n\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\nimpl<T> clone::Clone for Discriminant<T> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\nimpl<T> cmp::PartialEq for Discriminant<T> {\n    fn eq(&self, rhs: &Self) -> bool {\n        self.0 == rhs.0\n    }\n}\n\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\nimpl<T> cmp::Eq for Discriminant<T> {}\n\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\nimpl<T> hash::Hash for Discriminant<T> {\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        self.0.hash(state);\n    }\n}\n\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\nimpl<T> fmt::Debug for Discriminant<T> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_tuple(\"Discriminant\")\n           .field(&self.0)\n           .finish()\n    }\n}\n\n/// Returns a value uniquely identifying the enum variant in `v`.\n///\n/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n/// return value is unspecified.\n///\n/// # Stability\n///\n/// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n/// of some variant will not change between compilations with the same compiler.\n///\n/// # Examples\n///\n/// This can be used to compare enums that carry data, while disregarding\n/// the actual data:\n///\n/// ```\n/// use std::mem;\n///\n/// enum Foo { A(&'static str), B(i32), C(i32) }\n///\n/// assert!(mem::discriminant(&Foo::A(\"bar\")) == mem::discriminant(&Foo::A(\"baz\")));\n/// assert!(mem::discriminant(&Foo::B(1))     == mem::discriminant(&Foo::B(2)));\n/// assert!(mem::discriminant(&Foo::B(3))     != mem::discriminant(&Foo::C(3)));\n/// ```\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\npub fn discriminant<T>(v: &T) -> Discriminant<T> {\n    unsafe {\n        Discriminant(intrinsics::discriminant_value(v), PhantomData)\n    }\n}\n\n\n/// A wrapper to inhibit compiler from automatically calling `T`’s destructor.\n///\n/// This wrapper is 0-cost.\n///\n/// # Examples\n///\n/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n/// the type:\n///\n/// ```rust\n/// use std::mem::ManuallyDrop;\n/// struct Peach;\n/// struct Banana;\n/// struct Melon;\n/// struct FruitBox {\n///     // Immediately clear there’s something non-trivial going on with these fields.\n///     peach: ManuallyDrop<Peach>,\n///     melon: Melon, // Field that’s independent of the other two.\n///     banana: ManuallyDrop<Banana>,\n/// }\n///\n/// impl Drop for FruitBox {\n///     fn drop(&mut self) {\n///         unsafe {\n///             // Explicit ordering in which field destructors are run specified in the intuitive\n///             // location – the destructor of the structure containing the fields.\n///             // Moreover, one can now reorder fields within the struct however much they want.\n///             ManuallyDrop::drop(&mut self.peach);\n///             ManuallyDrop::drop(&mut self.banana);\n///         }\n///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n///     }\n/// }\n/// ```\n#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n#[allow(unions_with_drop_fields)]\n#[derive(Copy)]\npub union ManuallyDrop<T>{ value: T }\n\nimpl<T> ManuallyDrop<T> {\n    /// Wrap a value to be manually dropped.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::mem::ManuallyDrop;\n    /// ManuallyDrop::new(Box::new(()));\n    /// ```\n    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n    #[inline]\n    pub fn new(value: T) -> ManuallyDrop<T> {\n        ManuallyDrop { value: value }\n    }\n\n    /// Extract the value from the ManuallyDrop container.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::mem::ManuallyDrop;\n    /// let x = ManuallyDrop::new(Box::new(()));\n    /// let _: Box<()> = ManuallyDrop::into_inner(x);\n    /// ```\n    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n    #[inline]\n    pub fn into_inner(slot: ManuallyDrop<T>) -> T {\n        unsafe {\n            slot.value\n        }\n    }\n\n    /// Manually drops the contained value.\n    ///\n    /// # Safety\n    ///\n    /// This function runs the destructor of the contained value and thus the wrapped value\n    /// now represents uninitialized data. It is up to the user of this method to ensure the\n    /// uninitialized data is not actually used.\n    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n    #[inline]\n    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n        ptr::drop_in_place(&mut slot.value)\n    }\n}\n\n#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\nimpl<T> Deref for ManuallyDrop<T> {\n    type Target = T;\n    #[inline]\n    fn deref(&self) -> &Self::Target {\n        unsafe {\n            &self.value\n        }\n    }\n}\n\n#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\nimpl<T> DerefMut for ManuallyDrop<T> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        unsafe {\n            &mut self.value\n        }\n    }\n}\n\n#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\nimpl<T: ::fmt::Debug> ::fmt::Debug for ManuallyDrop<T> {\n    fn fmt(&self, fmt: &mut ::fmt::Formatter) -> ::fmt::Result {\n        unsafe {\n            fmt.debug_tuple(\"ManuallyDrop\").field(&self.value).finish()\n        }\n    }\n}\n\n#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\nimpl<T: Clone> Clone for ManuallyDrop<T> {\n    fn clone(&self) -> Self {\n        ManuallyDrop::new(self.deref().clone())\n    }\n\n    fn clone_from(&mut self, source: &Self) {\n        self.deref_mut().clone_from(source);\n    }\n}\n\n#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\nimpl<T: Default> Default for ManuallyDrop<T> {\n    fn default() -> Self {\n        ManuallyDrop::new(Default::default())\n    }\n}\n\n#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\nimpl<T: PartialEq> PartialEq for ManuallyDrop<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.deref().eq(other)\n    }\n\n    fn ne(&self, other: &Self) -> bool {\n        self.deref().ne(other)\n    }\n}\n\n#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\nimpl<T: Eq> Eq for ManuallyDrop<T> {}\n\n#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\nimpl<T: PartialOrd> PartialOrd for ManuallyDrop<T> {\n    fn partial_cmp(&self, other: &Self) -> Option<::cmp::Ordering> {\n        self.deref().partial_cmp(other)\n    }\n\n    fn lt(&self, other: &Self) -> bool {\n        self.deref().lt(other)\n    }\n\n    fn le(&self, other: &Self) -> bool {\n        self.deref().le(other)\n    }\n\n    fn gt(&self, other: &Self) -> bool {\n        self.deref().gt(other)\n    }\n\n    fn ge(&self, other: &Self) -> bool {\n        self.deref().ge(other)\n    }\n}\n\n#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\nimpl<T: Ord> Ord for ManuallyDrop<T> {\n    fn cmp(&self, other: &Self) -> ::cmp::Ordering {\n        self.deref().cmp(other)\n    }\n}\n\n#[stable(feature = \"manually_drop_impls\", since = \"1.22.0\")]\nimpl<T: ::hash::Hash> ::hash::Hash for ManuallyDrop<T> {\n    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n        self.deref().hash(state);\n    }\n}\n\n/// Tells LLVM that this point in the code is not reachable, enabling further\n/// optimizations.\n///\n/// NB: This is very different from the `unreachable!()` macro: Unlike the\n/// macro, which panics when it is executed, it is *undefined behavior* to\n/// reach code marked with this function.\n#[inline]\n#[unstable(feature = \"unreachable\", issue = \"43751\")]\npub unsafe fn unreachable() -> ! {\n    intrinsics::unreachable()\n}\n","// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![unstable(feature = \"allocator_api\",\n            reason = \"the precise API and guarantees it provides may be tweaked \\\n                      slightly, especially to possibly take into account the \\\n                      types being stored to make room for a future \\\n                      tracing garbage collector\",\n            issue = \"32838\")]\n\nuse core::intrinsics::{min_align_of_val, size_of_val};\nuse core::mem::{self, ManuallyDrop};\nuse core::usize;\n\npub use allocator::*;\n#[doc(hidden)]\npub mod __core {\n    pub use core::*;\n}\n\nextern \"Rust\" {\n    #[allocator]\n    #[rustc_allocator_nounwind]\n    fn __rust_alloc(size: usize, align: usize, err: *mut u8) -> *mut u8;\n    #[cold]\n    #[rustc_allocator_nounwind]\n    fn __rust_oom(err: *const u8) -> !;\n    #[rustc_allocator_nounwind]\n    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n    #[rustc_allocator_nounwind]\n    fn __rust_usable_size(layout: *const u8,\n                          min: *mut usize,\n                          max: *mut usize);\n    #[rustc_allocator_nounwind]\n    fn __rust_realloc(ptr: *mut u8,\n                      old_size: usize,\n                      old_align: usize,\n                      new_size: usize,\n                      new_align: usize,\n                      err: *mut u8) -> *mut u8;\n    #[rustc_allocator_nounwind]\n    fn __rust_alloc_zeroed(size: usize, align: usize, err: *mut u8) -> *mut u8;\n    #[rustc_allocator_nounwind]\n    fn __rust_alloc_excess(size: usize,\n                           align: usize,\n                           excess: *mut usize,\n                           err: *mut u8) -> *mut u8;\n    #[rustc_allocator_nounwind]\n    fn __rust_realloc_excess(ptr: *mut u8,\n                             old_size: usize,\n                             old_align: usize,\n                             new_size: usize,\n                             new_align: usize,\n                             excess: *mut usize,\n                             err: *mut u8) -> *mut u8;\n    #[rustc_allocator_nounwind]\n    fn __rust_grow_in_place(ptr: *mut u8,\n                            old_size: usize,\n                            old_align: usize,\n                            new_size: usize,\n                            new_align: usize) -> u8;\n    #[rustc_allocator_nounwind]\n    fn __rust_shrink_in_place(ptr: *mut u8,\n                              old_size: usize,\n                              old_align: usize,\n                              new_size: usize,\n                              new_align: usize) -> u8;\n}\n\n#[derive(Copy, Clone, Default, Debug)]\npub struct Heap;\n\nunsafe impl Alloc for Heap {\n    #[inline]\n    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n        let ptr = __rust_alloc(layout.size(),\n                               layout.align(),\n                               &mut *err as *mut AllocErr as *mut u8);\n        if ptr.is_null() {\n            Err(ManuallyDrop::into_inner(err))\n        } else {\n            Ok(ptr)\n        }\n    }\n\n    #[inline]\n    #[cold]\n    fn oom(&mut self, err: AllocErr) -> ! {\n        unsafe {\n            __rust_oom(&err as *const AllocErr as *const u8)\n        }\n    }\n\n    #[inline]\n    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n        __rust_dealloc(ptr, layout.size(), layout.align())\n    }\n\n    #[inline]\n    fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n        let mut min = 0;\n        let mut max = 0;\n        unsafe {\n            __rust_usable_size(layout as *const Layout as *const u8,\n                               &mut min,\n                               &mut max);\n        }\n        (min, max)\n    }\n\n    #[inline]\n    unsafe fn realloc(&mut self,\n                      ptr: *mut u8,\n                      layout: Layout,\n                      new_layout: Layout)\n                      -> Result<*mut u8, AllocErr>\n    {\n        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n        let ptr = __rust_realloc(ptr,\n                                 layout.size(),\n                                 layout.align(),\n                                 new_layout.size(),\n                                 new_layout.align(),\n                                 &mut *err as *mut AllocErr as *mut u8);\n        if ptr.is_null() {\n            Err(ManuallyDrop::into_inner(err))\n        } else {\n            mem::forget(err);\n            Ok(ptr)\n        }\n    }\n\n    #[inline]\n    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n        let ptr = __rust_alloc_zeroed(layout.size(),\n                                      layout.align(),\n                                      &mut *err as *mut AllocErr as *mut u8);\n        if ptr.is_null() {\n            Err(ManuallyDrop::into_inner(err))\n        } else {\n            Ok(ptr)\n        }\n    }\n\n    #[inline]\n    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n        let mut size = 0;\n        let ptr = __rust_alloc_excess(layout.size(),\n                                      layout.align(),\n                                      &mut size,\n                                      &mut *err as *mut AllocErr as *mut u8);\n        if ptr.is_null() {\n            Err(ManuallyDrop::into_inner(err))\n        } else {\n            Ok(Excess(ptr, size))\n        }\n    }\n\n    #[inline]\n    unsafe fn realloc_excess(&mut self,\n                             ptr: *mut u8,\n                             layout: Layout,\n                             new_layout: Layout) -> Result<Excess, AllocErr> {\n        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n        let mut size = 0;\n        let ptr = __rust_realloc_excess(ptr,\n                                        layout.size(),\n                                        layout.align(),\n                                        new_layout.size(),\n                                        new_layout.align(),\n                                        &mut size,\n                                        &mut *err as *mut AllocErr as *mut u8);\n        if ptr.is_null() {\n            Err(ManuallyDrop::into_inner(err))\n        } else {\n            Ok(Excess(ptr, size))\n        }\n    }\n\n    #[inline]\n    unsafe fn grow_in_place(&mut self,\n                            ptr: *mut u8,\n                            layout: Layout,\n                            new_layout: Layout)\n                            -> Result<(), CannotReallocInPlace>\n    {\n        debug_assert!(new_layout.size() >= layout.size());\n        debug_assert!(new_layout.align() == layout.align());\n        let ret = __rust_grow_in_place(ptr,\n                                       layout.size(),\n                                       layout.align(),\n                                       new_layout.size(),\n                                       new_layout.align());\n        if ret != 0 {\n            Ok(())\n        } else {\n            Err(CannotReallocInPlace)\n        }\n    }\n\n    #[inline]\n    unsafe fn shrink_in_place(&mut self,\n                              ptr: *mut u8,\n                              layout: Layout,\n                              new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n        debug_assert!(new_layout.size() <= layout.size());\n        debug_assert!(new_layout.align() == layout.align());\n        let ret = __rust_shrink_in_place(ptr,\n                                         layout.size(),\n                                         layout.align(),\n                                         new_layout.size(),\n                                         new_layout.align());\n        if ret != 0 {\n            Ok(())\n        } else {\n            Err(CannotReallocInPlace)\n        }\n    }\n}\n\n/// An arbitrary non-null address to represent zero-size allocations.\n///\n/// This preserves the non-null invariant for types like `Box<T>`. The address\n/// may overlap with non-zero-size memory allocations.\n#[rustc_deprecated(since = \"1.19\", reason = \"Use Unique/NonNull::empty() instead\")]\n#[unstable(feature = \"heap_api\", issue = \"27700\")]\npub const EMPTY: *mut () = 1 as *mut ();\n\n/// The allocator for unique pointers.\n// This function must not unwind. If it does, MIR trans will fail.\n#[cfg(not(test))]\n#[lang = \"exchange_malloc\"]\n#[inline]\nunsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n    if size == 0 {\n        align as *mut u8\n    } else {\n        let layout = Layout::from_size_align_unchecked(size, align);\n        Heap.alloc(layout).unwrap_or_else(|err| {\n            Heap.oom(err)\n        })\n    }\n}\n\n#[cfg_attr(not(test), lang = \"box_free\")]\n#[inline]\npub(crate) unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n    let size = size_of_val(&*ptr);\n    let align = min_align_of_val(&*ptr);\n    // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n    if size != 0 {\n        let layout = Layout::from_size_align_unchecked(size, align);\n        Heap.dealloc(ptr as *mut u8, layout);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate test;\n    use self::test::Bencher;\n    use boxed::Box;\n    use heap::{Heap, Alloc, Layout};\n\n    #[test]\n    fn allocate_zeroed() {\n        unsafe {\n            let layout = Layout::from_size_align(1024, 1).unwrap();\n            let ptr = Heap.alloc_zeroed(layout.clone())\n                .unwrap_or_else(|e| Heap.oom(e));\n\n            let end = ptr.offset(layout.size() as isize);\n            let mut i = ptr;\n            while i < end {\n                assert_eq!(*i, 0);\n                i = i.offset(1);\n            }\n            Heap.dealloc(ptr, layout);\n        }\n    }\n\n    #[bench]\n    fn alloc_owned_small(b: &mut Bencher) {\n        b.iter(|| {\n            let _: Box<_> = box 10;\n        })\n    }\n}\n","// unknown <panic macros>","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n#![unstable(feature = \"allocator_api\",\n            reason = \"the precise API and guarantees it provides may be tweaked \\\n                      slightly, especially to possibly take into account the \\\n                      types being stored to make room for a future \\\n                      tracing garbage collector\",\n            issue = \"32838\")]\n\nuse core::cmp;\nuse core::fmt;\nuse core::mem;\nuse core::usize;\nuse core::ptr::{self, NonNull};\n\n/// Represents the combination of a starting address and\n/// a total capacity of the returned block.\n#[derive(Debug)]\npub struct Excess(pub *mut u8, pub usize);\n\nfn size_align<T>() -> (usize, usize) {\n    (mem::size_of::<T>(), mem::align_of::<T>())\n}\n\n/// Layout of a block of memory.\n///\n/// An instance of `Layout` describes a particular layout of memory.\n/// You build a `Layout` up as an input to give to an allocator.\n///\n/// All layouts have an associated non-negative size and a\n/// power-of-two alignment.\n///\n/// (Note however that layouts are *not* required to have positive\n/// size, even though many allocators require that all memory\n/// requests have positive size. A caller to the `Alloc::alloc`\n/// method must either ensure that conditions like this are met, or\n/// use specific allocators with looser requirements.)\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Layout {\n    // size of the requested block of memory, measured in bytes.\n    size: usize,\n\n    // alignment of the requested block of memory, measured in bytes.\n    // we ensure that this is always a power-of-two, because API's\n    // like `posix_memalign` require it and it is a reasonable\n    // constraint to impose on Layout constructors.\n    //\n    // (However, we do not analogously require `align >= sizeof(void*)`,\n    //  even though that is *also* a requirement of `posix_memalign`.)\n    align: usize,\n}\n\n\n// FIXME: audit default implementations for overflow errors,\n// (potentially switching to overflowing_add and\n//  overflowing_mul as necessary).\n\nimpl Layout {\n    /// Constructs a `Layout` from a given `size` and `align`,\n    /// or returns `None` if any of the following conditions\n    /// are not met:\n    ///\n    /// * `align` must be a power of two,\n    ///\n    /// * `align` must not exceed 2<sup>31</sup> (i.e. `1 << 31`),\n    ///\n    /// * `size`, when rounded up to the nearest multiple of `align`,\n    ///    must not overflow (i.e. the rounded value must be less than\n    ///    `usize::MAX`).\n    #[inline]\n    pub fn from_size_align(size: usize, align: usize) -> Option<Layout> {\n        if !align.is_power_of_two() {\n            return None;\n        }\n\n        if align > (1 << 31) {\n            return None;\n        }\n\n        // (power-of-two implies align != 0.)\n\n        // Rounded up size is:\n        //   size_rounded_up = (size + align - 1) & !(align - 1);\n        //\n        // We know from above that align != 0. If adding (align - 1)\n        // does not overflow, then rounding up will be fine.\n        //\n        // Conversely, &-masking with !(align - 1) will subtract off\n        // only low-order-bits. Thus if overflow occurs with the sum,\n        // the &-mask cannot subtract enough to undo that overflow.\n        //\n        // Above implies that checking for summation overflow is both\n        // necessary and sufficient.\n        if size > usize::MAX - (align - 1) {\n            return None;\n        }\n\n        unsafe {\n            Some(Layout::from_size_align_unchecked(size, align))\n        }\n    }\n\n    /// Creates a layout, bypassing all checks.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe as it does not verify that `align` is\n    /// a power-of-two that is also less than or equal to 2<sup>31</sup>, nor\n    /// that `size` aligned to `align` fits within the address space\n    /// (i.e. the `Layout::from_size_align` preconditions).\n    #[inline]\n    pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Layout {\n        Layout { size: size, align: align }\n    }\n\n    /// The minimum size in bytes for a memory block of this layout.\n    #[inline]\n    pub fn size(&self) -> usize { self.size }\n\n    /// The minimum byte alignment for a memory block of this layout.\n    #[inline]\n    pub fn align(&self) -> usize { self.align }\n\n    /// Constructs a `Layout` suitable for holding a value of type `T`.\n    pub fn new<T>() -> Self {\n        let (size, align) = size_align::<T>();\n        Layout::from_size_align(size, align).unwrap()\n    }\n\n    /// Produces layout describing a record that could be used to\n    /// allocate backing structure for `T` (which could be a trait\n    /// or other unsized type like a slice).\n    pub fn for_value<T: ?Sized>(t: &T) -> Self {\n        let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n        Layout::from_size_align(size, align).unwrap()\n    }\n\n    /// Creates a layout describing the record that can hold a value\n    /// of the same layout as `self`, but that also is aligned to\n    /// alignment `align` (measured in bytes).\n    ///\n    /// If `self` already meets the prescribed alignment, then returns\n    /// `self`.\n    ///\n    /// Note that this method does not add any padding to the overall\n    /// size, regardless of whether the returned layout has a different\n    /// alignment. In other words, if `K` has size 16, `K.align_to(32)`\n    /// will *still* have size 16.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the combination of `self.size` and the given `align`\n    /// violates the conditions listed in `from_size_align`.\n    #[inline]\n    pub fn align_to(&self, align: usize) -> Self {\n        Layout::from_size_align(self.size, cmp::max(self.align, align)).unwrap()\n    }\n\n    /// Returns the amount of padding we must insert after `self`\n    /// to ensure that the following address will satisfy `align`\n    /// (measured in bytes).\n    ///\n    /// E.g. if `self.size` is 9, then `self.padding_needed_for(4)`\n    /// returns 3, because that is the minimum number of bytes of\n    /// padding required to get a 4-aligned address (assuming that the\n    /// corresponding memory block starts at a 4-aligned address).\n    ///\n    /// The return value of this function has no meaning if `align` is\n    /// not a power-of-two.\n    ///\n    /// Note that the utility of the returned value requires `align`\n    /// to be less than or equal to the alignment of the starting\n    /// address for the whole allocated block of memory. One way to\n    /// satisfy this constraint is to ensure `align <= self.align`.\n    #[inline]\n    pub fn padding_needed_for(&self, align: usize) -> usize {\n        let len = self.size();\n\n        // Rounded up value is:\n        //   len_rounded_up = (len + align - 1) & !(align - 1);\n        // and then we return the padding difference: `len_rounded_up - len`.\n        //\n        // We use modular arithmetic throughout:\n        //\n        // 1. align is guaranteed to be > 0, so align - 1 is always\n        //    valid.\n        //\n        // 2. `len + align - 1` can overflow by at most `align - 1`,\n        //    so the &-mask wth `!(align - 1)` will ensure that in the\n        //    case of overflow, `len_rounded_up` will itself be 0.\n        //    Thus the returned padding, when added to `len`, yields 0,\n        //    which trivially satisfies the alignment `align`.\n        //\n        // (Of course, attempts to allocate blocks of memory whose\n        // size and padding overflow in the above manner should cause\n        // the allocator to yield an error anyway.)\n\n        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);\n        return len_rounded_up.wrapping_sub(len);\n    }\n\n    /// Creates a layout describing the record for `n` instances of\n    /// `self`, with a suitable amount of padding between each to\n    /// ensure that each instance is given its requested size and\n    /// alignment. On success, returns `(k, offs)` where `k` is the\n    /// layout of the array and `offs` is the distance between the start\n    /// of each element in the array.\n    ///\n    /// On arithmetic overflow, returns `None`.\n    #[inline]\n    pub fn repeat(&self, n: usize) -> Option<(Self, usize)> {\n        let padded_size = self.size.checked_add(self.padding_needed_for(self.align))?;\n        let alloc_size = padded_size.checked_mul(n)?;\n\n        // We can assume that `self.align` is a power-of-two that does\n        // not exceed 2<sup>31</sup>. Furthermore, `alloc_size` has already been\n        // rounded up to a multiple of `self.align`; therefore, the\n        // call to `Layout::from_size_align` below should never panic.\n        Some((Layout::from_size_align(alloc_size, self.align).unwrap(), padded_size))\n    }\n\n    /// Creates a layout describing the record for `self` followed by\n    /// `next`, including any necessary padding to ensure that `next`\n    /// will be properly aligned. Note that the result layout will\n    /// satisfy the alignment properties of both `self` and `next`.\n    ///\n    /// Returns `Some((k, offset))`, where `k` is layout of the concatenated\n    /// record and `offset` is the relative location, in bytes, of the\n    /// start of the `next` embedded within the concatenated record\n    /// (assuming that the record itself starts at offset 0).\n    ///\n    /// On arithmetic overflow, returns `None`.\n    pub fn extend(&self, next: Self) -> Option<(Self, usize)> {\n        let new_align = cmp::max(self.align, next.align);\n        let realigned = Layout::from_size_align(self.size, new_align)?;\n\n        let pad = realigned.padding_needed_for(next.align);\n\n        let offset = self.size.checked_add(pad)?;\n        let new_size = offset.checked_add(next.size)?;\n\n        let layout = Layout::from_size_align(new_size, new_align)?;\n        Some((layout, offset))\n    }\n\n    /// Creates a layout describing the record for `n` instances of\n    /// `self`, with no padding between each instance.\n    ///\n    /// Note that, unlike `repeat`, `repeat_packed` does not guarantee\n    /// that the repeated instances of `self` will be properly\n    /// aligned, even if a given instance of `self` is properly\n    /// aligned. In other words, if the layout returned by\n    /// `repeat_packed` is used to allocate an array, it is not\n    /// guaranteed that all elements in the array will be properly\n    /// aligned.\n    ///\n    /// On arithmetic overflow, returns `None`.\n    pub fn repeat_packed(&self, n: usize) -> Option<Self> {\n        let size = self.size().checked_mul(n)?;\n        Layout::from_size_align(size, self.align)\n    }\n\n    /// Creates a layout describing the record for `self` followed by\n    /// `next` with no additional padding between the two. Since no\n    /// padding is inserted, the alignment of `next` is irrelevant,\n    /// and is not incorporated *at all* into the resulting layout.\n    ///\n    /// Returns `(k, offset)`, where `k` is layout of the concatenated\n    /// record and `offset` is the relative location, in bytes, of the\n    /// start of the `next` embedded within the concatenated record\n    /// (assuming that the record itself starts at offset 0).\n    ///\n    /// (The `offset` is always the same as `self.size()`; we use this\n    ///  signature out of convenience in matching the signature of\n    ///  `extend`.)\n    ///\n    /// On arithmetic overflow, returns `None`.\n    pub fn extend_packed(&self, next: Self) -> Option<(Self, usize)> {\n        let new_size = self.size().checked_add(next.size())?;\n        let layout = Layout::from_size_align(new_size, self.align)?;\n        Some((layout, self.size()))\n    }\n\n    /// Creates a layout describing the record for a `[T; n]`.\n    ///\n    /// On arithmetic overflow, returns `None`.\n    pub fn array<T>(n: usize) -> Option<Self> {\n        Layout::new::<T>()\n            .repeat(n)\n            .map(|(k, offs)| {\n                debug_assert!(offs == mem::size_of::<T>());\n                k\n            })\n    }\n}\n\n/// The `AllocErr` error specifies whether an allocation failure is\n/// specifically due to resource exhaustion or if it is due to\n/// something wrong when combining the given input arguments with this\n/// allocator.\n#[derive(Clone, PartialEq, Eq, Debug)]\npub enum AllocErr {\n    /// Error due to hitting some resource limit or otherwise running\n    /// out of memory. This condition strongly implies that *some*\n    /// series of deallocations would allow a subsequent reissuing of\n    /// the original allocation request to succeed.\n    Exhausted { request: Layout },\n\n    /// Error due to allocator being fundamentally incapable of\n    /// satisfying the original request. This condition implies that\n    /// such an allocation request will never succeed on the given\n    /// allocator, regardless of environment, memory pressure, or\n    /// other contextual conditions.\n    ///\n    /// For example, an allocator that does not support requests for\n    /// large memory blocks might return this error variant.\n    Unsupported { details: &'static str },\n}\n\nimpl AllocErr {\n    #[inline]\n    pub fn invalid_input(details: &'static str) -> Self {\n        AllocErr::Unsupported { details: details }\n    }\n    #[inline]\n    pub fn is_memory_exhausted(&self) -> bool {\n        if let AllocErr::Exhausted { .. } = *self { true } else { false }\n    }\n    #[inline]\n    pub fn is_request_unsupported(&self) -> bool {\n        if let AllocErr::Unsupported { .. } = *self { true } else { false }\n    }\n    #[inline]\n    pub fn description(&self) -> &str {\n        match *self {\n            AllocErr::Exhausted { .. } => \"allocator memory exhausted\",\n            AllocErr::Unsupported { .. } => \"unsupported allocator request\",\n        }\n    }\n}\n\n// (we need this for downstream impl of trait Error)\nimpl fmt::Display for AllocErr {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.description())\n    }\n}\n\n/// The `CannotReallocInPlace` error is used when `grow_in_place` or\n/// `shrink_in_place` were unable to reuse the given memory block for\n/// a requested layout.\n#[derive(Clone, PartialEq, Eq, Debug)]\npub struct CannotReallocInPlace;\n\nimpl CannotReallocInPlace {\n    pub fn description(&self) -> &str {\n        \"cannot reallocate allocator's memory in place\"\n    }\n}\n\n// (we need this for downstream impl of trait Error)\nimpl fmt::Display for CannotReallocInPlace {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.description())\n    }\n}\n\n/// An implementation of `Alloc` can allocate, reallocate, and\n/// deallocate arbitrary blocks of data described via `Layout`.\n///\n/// Some of the methods require that a memory block be *currently\n/// allocated* via an allocator. This means that:\n///\n/// * the starting address for that memory block was previously\n///   returned by a previous call to an allocation method (`alloc`,\n///   `alloc_zeroed`, `alloc_excess`, `alloc_one`, `alloc_array`) or\n///   reallocation method (`realloc`, `realloc_excess`, or\n///   `realloc_array`), and\n///\n/// * the memory block has not been subsequently deallocated, where\n///   blocks are deallocated either by being passed to a deallocation\n///   method (`dealloc`, `dealloc_one`, `dealloc_array`) or by being\n///   passed to a reallocation method (see above) that returns `Ok`.\n///\n/// A note regarding zero-sized types and zero-sized layouts: many\n/// methods in the `Alloc` trait state that allocation requests\n/// must be non-zero size, or else undefined behavior can result.\n///\n/// * However, some higher-level allocation methods (`alloc_one`,\n///   `alloc_array`) are well-defined on zero-sized types and can\n///   optionally support them: it is left up to the implementor\n///   whether to return `Err`, or to return `Ok` with some pointer.\n///\n/// * If an `Alloc` implementation chooses to return `Ok` in this\n///   case (i.e. the pointer denotes a zero-sized inaccessible block)\n///   then that returned pointer must be considered \"currently\n///   allocated\". On such an allocator, *all* methods that take\n///   currently-allocated pointers as inputs must accept these\n///   zero-sized pointers, *without* causing undefined behavior.\n///\n/// * In other words, if a zero-sized pointer can flow out of an\n///   allocator, then that allocator must likewise accept that pointer\n///   flowing back into its deallocation and reallocation methods.\n///\n/// Some of the methods require that a layout *fit* a memory block.\n/// What it means for a layout to \"fit\" a memory block means (or\n/// equivalently, for a memory block to \"fit\" a layout) is that the\n/// following two conditions must hold:\n///\n/// 1. The block's starting address must be aligned to `layout.align()`.\n///\n/// 2. The block's size must fall in the range `[use_min, use_max]`, where:\n///\n///    * `use_min` is `self.usable_size(layout).0`, and\n///\n///    * `use_max` is the capacity that was (or would have been)\n///      returned when (if) the block was allocated via a call to\n///      `alloc_excess` or `realloc_excess`.\n///\n/// Note that:\n///\n///  * the size of the layout most recently used to allocate the block\n///    is guaranteed to be in the range `[use_min, use_max]`, and\n///\n///  * a lower-bound on `use_max` can be safely approximated by a call to\n///    `usable_size`.\n///\n///  * if a layout `k` fits a memory block (denoted by `ptr`)\n///    currently allocated via an allocator `a`, then it is legal to\n///    use that layout to deallocate it, i.e. `a.dealloc(ptr, k);`.\n///\n/// # Unsafety\n///\n/// The `Alloc` trait is an `unsafe` trait for a number of reasons, and\n/// implementors must ensure that they adhere to these contracts:\n///\n/// * Pointers returned from allocation functions must point to valid memory and\n///   retain their validity until at least the instance of `Alloc` is dropped\n///   itself.\n///\n/// * It's undefined behavior if global allocators unwind.  This restriction may\n///   be lifted in the future, but currently a panic from any of these\n///   functions may lead to memory unsafety. Note that as of the time of this\n///   writing allocators *not* intending to be global allocators can still panic\n///   in their implementation without violating memory safety.\n///\n/// * `Layout` queries and calculations in general must be correct. Callers of\n///   this trait are allowed to rely on the contracts defined on each method,\n///   and implementors must ensure such contracts remain true.\n///\n/// Note that this list may get tweaked over time as clarifications are made in\n/// the future. Additionally global allocators may gain unique requirements for\n/// how to safely implement one in the future as well.\npub unsafe trait Alloc {\n\n    // (Note: existing allocators have unspecified but well-defined\n    // behavior in response to a zero size allocation request ;\n    // e.g. in C, `malloc` of 0 will either return a null pointer or a\n    // unique pointer, but will not have arbitrary undefined\n    // behavior. Rust should consider revising the alloc::heap crate\n    // to reflect this reality.)\n\n    /// Returns a pointer meeting the size and alignment guarantees of\n    /// `layout`.\n    ///\n    /// If this method returns an `Ok(addr)`, then the `addr` returned\n    /// will be non-null address pointing to a block of storage\n    /// suitable for holding an instance of `layout`.\n    ///\n    /// The returned block of storage may or may not have its contents\n    /// initialized. (Extension subtraits might restrict this\n    /// behavior, e.g. to ensure initialization to particular sets of\n    /// bit patterns.)\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure that `layout` has non-zero size.\n    ///\n    /// (Extension subtraits might provide more specific bounds on\n    /// behavior, e.g. guarantee a sentinel address or a null pointer\n    /// in response to a zero-size allocation request.)\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `layout` does not meet allocator's size or alignment\n    /// constraints.\n    ///\n    /// Implementations are encouraged to return `Err` on memory\n    /// exhaustion rather than panicking or aborting, but this is not\n    /// a strict requirement. (Specifically: it is *legal* to\n    /// implement this trait atop an underlying native allocation\n    /// library that aborts on memory exhaustion.)\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// allocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr>;\n\n    /// Deallocate the memory referenced by `ptr`.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure all of the following:\n    ///\n    /// * `ptr` must denote a block of memory currently allocated via\n    ///   this allocator,\n    ///\n    /// * `layout` must *fit* that block of memory,\n    ///\n    /// * In addition to fitting the block of memory `layout`, the\n    ///   alignment of the `layout` must match the alignment used\n    ///   to allocate that block of memory.\n    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout);\n\n    /// Allocator-specific method for signaling an out-of-memory\n    /// condition.\n    ///\n    /// `oom` aborts the thread or process, optionally performing\n    /// cleanup or logging diagnostic information before panicking or\n    /// aborting.\n    ///\n    /// `oom` is meant to be used by clients unable to cope with an\n    /// unsatisfied allocation request (signaled by an error such as\n    /// `AllocErr::Exhausted`), and wish to abandon computation rather\n    /// than attempt to recover locally. Such clients should pass the\n    /// signaling error value back into `oom`, where the allocator\n    /// may incorporate that error value into its diagnostic report\n    /// before aborting.\n    ///\n    /// Implementations of the `oom` method are discouraged from\n    /// infinitely regressing in nested calls to `oom`. In\n    /// practice this means implementors should eschew allocating,\n    /// especially from `self` (directly or indirectly).\n    ///\n    /// Implementations of the allocation and reallocation methods\n    /// (e.g. `alloc`, `alloc_one`, `realloc`) are discouraged from\n    /// panicking (or aborting) in the event of memory exhaustion;\n    /// instead they should return an appropriate error from the\n    /// invoked method, and let the client decide whether to invoke\n    /// this `oom` method in response.\n    fn oom(&mut self, _: AllocErr) -> ! {\n        unsafe { ::core::intrinsics::abort() }\n    }\n\n    // == ALLOCATOR-SPECIFIC QUANTITIES AND LIMITS ==\n    // usable_size\n\n    /// Returns bounds on the guaranteed usable size of a successful\n    /// allocation created with the specified `layout`.\n    ///\n    /// In particular, if one has a memory block allocated via a given\n    /// allocator `a` and layout `k` where `a.usable_size(k)` returns\n    /// `(l, u)`, then one can pass that block to `a.dealloc()` with a\n    /// layout in the size range [l, u].\n    ///\n    /// (All implementors of `usable_size` must ensure that\n    /// `l <= k.size() <= u`)\n    ///\n    /// Both the lower- and upper-bounds (`l` and `u` respectively)\n    /// are provided, because an allocator based on size classes could\n    /// misbehave if one attempts to deallocate a block without\n    /// providing a correct value for its size (i.e., one within the\n    /// range `[l, u]`).\n    ///\n    /// Clients who wish to make use of excess capacity are encouraged\n    /// to use the `alloc_excess` and `realloc_excess` instead, as\n    /// this method is constrained to report conservative values that\n    /// serve as valid bounds for *all possible* allocation method\n    /// calls.\n    ///\n    /// However, for clients that do not wish to track the capacity\n    /// returned by `alloc_excess` locally, this method is likely to\n    /// produce useful results.\n    #[inline]\n    fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n        (layout.size(), layout.size())\n    }\n\n    // == METHODS FOR MEMORY REUSE ==\n    // realloc. alloc_excess, realloc_excess\n\n    /// Returns a pointer suitable for holding data described by\n    /// `new_layout`, meeting its size and alignment guarantees. To\n    /// accomplish this, this may extend or shrink the allocation\n    /// referenced by `ptr` to fit `new_layout`.\n    ///\n    /// If this returns `Ok`, then ownership of the memory block\n    /// referenced by `ptr` has been transferred to this\n    /// allocator. The memory may or may not have been freed, and\n    /// should be considered unusable (unless of course it was\n    /// transferred back to the caller again via the return value of\n    /// this method).\n    ///\n    /// If this method returns `Err`, then ownership of the memory\n    /// block has not been transferred to this allocator, and the\n    /// contents of the memory block are unaltered.\n    ///\n    /// For best results, `new_layout` should not impose a different\n    /// alignment constraint than `layout`. (In other words,\n    /// `new_layout.align()` should equal `layout.align()`.) However,\n    /// behavior is well-defined (though underspecified) when this\n    /// constraint is violated; further discussion below.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure all of the following:\n    ///\n    /// * `ptr` must be currently allocated via this allocator,\n    ///\n    /// * `layout` must *fit* the `ptr` (see above). (The `new_layout`\n    ///   argument need not fit it.)\n    ///\n    /// * `new_layout` must have size greater than zero.\n    ///\n    /// * the alignment of `new_layout` is non-zero.\n    ///\n    /// (Extension subtraits might provide more specific bounds on\n    /// behavior, e.g. guarantee a sentinel address or a null pointer\n    /// in response to a zero-size allocation request.)\n    ///\n    /// # Errors\n    ///\n    /// Returns `Err` only if `new_layout` does not match the\n    /// alignment of `layout`, or does not meet the allocator's size\n    /// and alignment constraints of the allocator, or if reallocation\n    /// otherwise fails.\n    ///\n    /// (Note the previous sentence did not say \"if and only if\" -- in\n    /// particular, an implementation of this method *can* return `Ok`\n    /// if `new_layout.align() != old_layout.align()`; or it can\n    /// return `Err` in that scenario, depending on whether this\n    /// allocator can dynamically adjust the alignment constraint for\n    /// the block.)\n    ///\n    /// Implementations are encouraged to return `Err` on memory\n    /// exhaustion rather than panicking or aborting, but this is not\n    /// a strict requirement. (Specifically: it is *legal* to\n    /// implement this trait atop an underlying native allocation\n    /// library that aborts on memory exhaustion.)\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// reallocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    unsafe fn realloc(&mut self,\n                      ptr: *mut u8,\n                      layout: Layout,\n                      new_layout: Layout) -> Result<*mut u8, AllocErr> {\n        let new_size = new_layout.size();\n        let old_size = layout.size();\n        let aligns_match = layout.align == new_layout.align;\n\n        if new_size >= old_size && aligns_match {\n            if let Ok(()) = self.grow_in_place(ptr, layout.clone(), new_layout.clone()) {\n                return Ok(ptr);\n            }\n        } else if new_size < old_size && aligns_match {\n            if let Ok(()) = self.shrink_in_place(ptr, layout.clone(), new_layout.clone()) {\n                return Ok(ptr);\n            }\n        }\n\n        // otherwise, fall back on alloc + copy + dealloc.\n        let result = self.alloc(new_layout);\n        if let Ok(new_ptr) = result {\n            ptr::copy_nonoverlapping(ptr as *const u8, new_ptr, cmp::min(old_size, new_size));\n            self.dealloc(ptr, layout);\n        }\n        result\n    }\n\n    /// Behaves like `alloc`, but also ensures that the contents\n    /// are set to zero before being returned.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe for the same reasons that `alloc` is.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `layout` does not meet allocator's size or alignment\n    /// constraints, just as in `alloc`.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// allocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n        let size = layout.size();\n        let p = self.alloc(layout);\n        if let Ok(p) = p {\n            ptr::write_bytes(p, 0, size);\n        }\n        p\n    }\n\n    /// Behaves like `alloc`, but also returns the whole size of\n    /// the returned block. For some `layout` inputs, like arrays, this\n    /// may include extra storage usable for additional data.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe for the same reasons that `alloc` is.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `layout` does not meet allocator's size or alignment\n    /// constraints, just as in `alloc`.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// allocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n        let usable_size = self.usable_size(&layout);\n        self.alloc(layout).map(|p| Excess(p, usable_size.1))\n    }\n\n    /// Behaves like `realloc`, but also returns the whole size of\n    /// the returned block. For some `layout` inputs, like arrays, this\n    /// may include extra storage usable for additional data.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe for the same reasons that `realloc` is.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `layout` does not meet allocator's size or alignment\n    /// constraints, just as in `realloc`.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// reallocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    unsafe fn realloc_excess(&mut self,\n                             ptr: *mut u8,\n                             layout: Layout,\n                             new_layout: Layout) -> Result<Excess, AllocErr> {\n        let usable_size = self.usable_size(&new_layout);\n        self.realloc(ptr, layout, new_layout)\n            .map(|p| Excess(p, usable_size.1))\n    }\n\n    /// Attempts to extend the allocation referenced by `ptr` to fit `new_layout`.\n    ///\n    /// If this returns `Ok`, then the allocator has asserted that the\n    /// memory block referenced by `ptr` now fits `new_layout`, and thus can\n    /// be used to carry data of that layout. (The allocator is allowed to\n    /// expend effort to accomplish this, such as extending the memory block to\n    /// include successor blocks, or virtual memory tricks.)\n    ///\n    /// Regardless of what this method returns, ownership of the\n    /// memory block referenced by `ptr` has not been transferred, and\n    /// the contents of the memory block are unaltered.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure all of the following:\n    ///\n    /// * `ptr` must be currently allocated via this allocator,\n    ///\n    /// * `layout` must *fit* the `ptr` (see above); note the\n    ///   `new_layout` argument need not fit it,\n    ///\n    /// * `new_layout.size()` must not be less than `layout.size()`,\n    ///\n    /// * `new_layout.align()` must equal `layout.align()`.\n    ///\n    /// # Errors\n    ///\n    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n    /// unable to assert that the memory block referenced by `ptr`\n    /// could fit `layout`.\n    ///\n    /// Note that one cannot pass `CannotReallocInPlace` to the `oom`\n    /// method; clients are expected either to be able to recover from\n    /// `grow_in_place` failures without aborting, or to fall back on\n    /// another reallocation method before resorting to an abort.\n    unsafe fn grow_in_place(&mut self,\n                            ptr: *mut u8,\n                            layout: Layout,\n                            new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n        let _ = ptr; // this default implementation doesn't care about the actual address.\n        debug_assert!(new_layout.size >= layout.size);\n        debug_assert!(new_layout.align == layout.align);\n        let (_l, u) = self.usable_size(&layout);\n        // _l <= layout.size()                       [guaranteed by usable_size()]\n        //       layout.size() <= new_layout.size()  [required by this method]\n        if new_layout.size <= u {\n            return Ok(());\n        } else {\n            return Err(CannotReallocInPlace);\n        }\n    }\n\n    /// Attempts to shrink the allocation referenced by `ptr` to fit `new_layout`.\n    ///\n    /// If this returns `Ok`, then the allocator has asserted that the\n    /// memory block referenced by `ptr` now fits `new_layout`, and\n    /// thus can only be used to carry data of that smaller\n    /// layout. (The allocator is allowed to take advantage of this,\n    /// carving off portions of the block for reuse elsewhere.) The\n    /// truncated contents of the block within the smaller layout are\n    /// unaltered, and ownership of block has not been transferred.\n    ///\n    /// If this returns `Err`, then the memory block is considered to\n    /// still represent the original (larger) `layout`. None of the\n    /// block has been carved off for reuse elsewhere, ownership of\n    /// the memory block has not been transferred, and the contents of\n    /// the memory block are unaltered.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure all of the following:\n    ///\n    /// * `ptr` must be currently allocated via this allocator,\n    ///\n    /// * `layout` must *fit* the `ptr` (see above); note the\n    ///   `new_layout` argument need not fit it,\n    ///\n    /// * `new_layout.size()` must not be greater than `layout.size()`\n    ///   (and must be greater than zero),\n    ///\n    /// * `new_layout.align()` must equal `layout.align()`.\n    ///\n    /// # Errors\n    ///\n    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n    /// unable to assert that the memory block referenced by `ptr`\n    /// could fit `layout`.\n    ///\n    /// Note that one cannot pass `CannotReallocInPlace` to the `oom`\n    /// method; clients are expected either to be able to recover from\n    /// `shrink_in_place` failures without aborting, or to fall back\n    /// on another reallocation method before resorting to an abort.\n    unsafe fn shrink_in_place(&mut self,\n                              ptr: *mut u8,\n                              layout: Layout,\n                              new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n        let _ = ptr; // this default implementation doesn't care about the actual address.\n        debug_assert!(new_layout.size <= layout.size);\n        debug_assert!(new_layout.align == layout.align);\n        let (l, _u) = self.usable_size(&layout);\n        //                      layout.size() <= _u  [guaranteed by usable_size()]\n        // new_layout.size() <= layout.size()        [required by this method]\n        if l <= new_layout.size {\n            return Ok(());\n        } else {\n            return Err(CannotReallocInPlace);\n        }\n    }\n\n\n    // == COMMON USAGE PATTERNS ==\n    // alloc_one, dealloc_one, alloc_array, realloc_array. dealloc_array\n\n    /// Allocates a block suitable for holding an instance of `T`.\n    ///\n    /// Captures a common usage pattern for allocators.\n    ///\n    /// The returned block is suitable for passing to the\n    /// `alloc`/`realloc` methods of this allocator.\n    ///\n    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n    /// must be considered \"currently allocated\" and must be\n    /// acceptable input to methods such as `realloc` or `dealloc`,\n    /// *even if* `T` is a zero-sized type. In other words, if your\n    /// `Alloc` implementation overrides this method in a manner\n    /// that can return a zero-sized `ptr`, then all reallocation and\n    /// deallocation methods need to be similarly overridden to accept\n    /// such values as input.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `T` does not meet allocator's size or alignment constraints.\n    ///\n    /// For zero-sized `T`, may return either of `Ok` or `Err`, but\n    /// will *not* yield undefined behavior.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// allocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    fn alloc_one<T>(&mut self) -> Result<NonNull<T>, AllocErr>\n        where Self: Sized\n    {\n        let k = Layout::new::<T>();\n        if k.size() > 0 {\n            unsafe { self.alloc(k).map(|p| NonNull::new_unchecked(p as *mut T)) }\n        } else {\n            Err(AllocErr::invalid_input(\"zero-sized type invalid for alloc_one\"))\n        }\n    }\n\n    /// Deallocates a block suitable for holding an instance of `T`.\n    ///\n    /// The given block must have been produced by this allocator,\n    /// and must be suitable for storing a `T` (in terms of alignment\n    /// as well as minimum and maximum size); otherwise yields\n    /// undefined behavior.\n    ///\n    /// Captures a common usage pattern for allocators.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure both:\n    ///\n    /// * `ptr` must denote a block of memory currently allocated via this allocator\n    ///\n    /// * the layout of `T` must *fit* that block of memory.\n    unsafe fn dealloc_one<T>(&mut self, ptr: NonNull<T>)\n        where Self: Sized\n    {\n        let raw_ptr = ptr.as_ptr() as *mut u8;\n        let k = Layout::new::<T>();\n        if k.size() > 0 {\n            self.dealloc(raw_ptr, k);\n        }\n    }\n\n    /// Allocates a block suitable for holding `n` instances of `T`.\n    ///\n    /// Captures a common usage pattern for allocators.\n    ///\n    /// The returned block is suitable for passing to the\n    /// `alloc`/`realloc` methods of this allocator.\n    ///\n    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n    /// must be considered \"currently allocated\" and must be\n    /// acceptable input to methods such as `realloc` or `dealloc`,\n    /// *even if* `T` is a zero-sized type. In other words, if your\n    /// `Alloc` implementation overrides this method in a manner\n    /// that can return a zero-sized `ptr`, then all reallocation and\n    /// deallocation methods need to be similarly overridden to accept\n    /// such values as input.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `[T; n]` does not meet allocator's size or alignment\n    /// constraints.\n    ///\n    /// For zero-sized `T` or `n == 0`, may return either of `Ok` or\n    /// `Err`, but will *not* yield undefined behavior.\n    ///\n    /// Always returns `Err` on arithmetic overflow.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// allocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    fn alloc_array<T>(&mut self, n: usize) -> Result<NonNull<T>, AllocErr>\n        where Self: Sized\n    {\n        match Layout::array::<T>(n) {\n            Some(ref layout) if layout.size() > 0 => {\n                unsafe {\n                    self.alloc(layout.clone())\n                        .map(|p| {\n                            NonNull::new_unchecked(p as *mut T)\n                        })\n                }\n            }\n            _ => Err(AllocErr::invalid_input(\"invalid layout for alloc_array\")),\n        }\n    }\n\n    /// Reallocates a block previously suitable for holding `n_old`\n    /// instances of `T`, returning a block suitable for holding\n    /// `n_new` instances of `T`.\n    ///\n    /// Captures a common usage pattern for allocators.\n    ///\n    /// The returned block is suitable for passing to the\n    /// `alloc`/`realloc` methods of this allocator.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure all of the following:\n    ///\n    /// * `ptr` must be currently allocated via this allocator,\n    ///\n    /// * the layout of `[T; n_old]` must *fit* that block of memory.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either memory is exhausted or\n    /// `[T; n_new]` does not meet allocator's size or alignment\n    /// constraints.\n    ///\n    /// For zero-sized `T` or `n_new == 0`, may return either of `Ok` or\n    /// `Err`, but will *not* yield undefined behavior.\n    ///\n    /// Always returns `Err` on arithmetic overflow.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// reallocation error are encouraged to call the allocator's `oom`\n    /// method, rather than directly invoking `panic!` or similar.\n    unsafe fn realloc_array<T>(&mut self,\n                               ptr: NonNull<T>,\n                               n_old: usize,\n                               n_new: usize) -> Result<NonNull<T>, AllocErr>\n        where Self: Sized\n    {\n        match (Layout::array::<T>(n_old), Layout::array::<T>(n_new), ptr.as_ptr()) {\n            (Some(ref k_old), Some(ref k_new), ptr) if k_old.size() > 0 && k_new.size() > 0 => {\n                self.realloc(ptr as *mut u8, k_old.clone(), k_new.clone())\n                    .map(|p| NonNull::new_unchecked(p as *mut T))\n            }\n            _ => {\n                Err(AllocErr::invalid_input(\"invalid layout for realloc_array\"))\n            }\n        }\n    }\n\n    /// Deallocates a block suitable for holding `n` instances of `T`.\n    ///\n    /// Captures a common usage pattern for allocators.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure both:\n    ///\n    /// * `ptr` must denote a block of memory currently allocated via this allocator\n    ///\n    /// * the layout of `[T; n]` must *fit* that block of memory.\n    ///\n    /// # Errors\n    ///\n    /// Returning `Err` indicates that either `[T; n]` or the given\n    /// memory block does not meet allocator's size or alignment\n    /// constraints.\n    ///\n    /// Always returns `Err` on arithmetic overflow.\n    unsafe fn dealloc_array<T>(&mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>\n        where Self: Sized\n    {\n        let raw_ptr = ptr.as_ptr() as *mut u8;\n        match Layout::array::<T>(n) {\n            Some(ref k) if k.size() > 0 => {\n                Ok(self.dealloc(raw_ptr, k.clone()))\n            }\n            _ => {\n                Err(AllocErr::invalid_input(\"invalid layout for dealloc_array\"))\n            }\n        }\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Numeric traits and functions for the built-in numeric types.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse convert::{Infallible, TryFrom};\nuse fmt;\nuse intrinsics;\nuse ops;\nuse str::FromStr;\n\n/// Provides intentionally-wrapped arithmetic on `T`.\n///\n/// Operations like `+` on `u32` values is intended to never overflow,\n/// and in some debug configurations overflow is detected and results\n/// in a panic. While most arithmetic falls into this category, some\n/// code explicitly expects and relies upon modular arithmetic (e.g.,\n/// hashing).\n///\n/// Wrapping arithmetic can be achieved either through methods like\n/// `wrapping_add`, or through the `Wrapping<T>` type, which says that\n/// all standard arithmetic operations on the underlying value are\n/// intended to have wrapping semantics.\n///\n/// # Examples\n///\n/// ```\n/// use std::num::Wrapping;\n///\n/// let zero = Wrapping(0u32);\n/// let one = Wrapping(1u32);\n///\n/// assert_eq!(std::u32::MAX, (zero - one).0);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\npub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n                       pub T);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_display\", since = \"1.10.0\")]\nimpl<T: fmt::Display> fmt::Display for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::Binary> fmt::Binary for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::Octal> fmt::Octal for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::LowerHex> fmt::LowerHex for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::UpperHex> fmt::UpperHex for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\nmod wrapping;\n\n// All these modules are technically private and only exposed for coretests:\npub mod flt2dec;\npub mod dec2flt;\npub mod bignum;\npub mod diy_float;\n\n// `Int` + `SignedInt` implemented for signed integers\nmacro_rules! int_impl {\n    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr) => {\n        /// Returns the smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(i8::min_value(), -128);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub const fn min_value() -> Self {\n            !0 ^ ((!0 as $UnsignedT) >> 1) as Self\n        }\n\n        /// Returns the largest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(i8::max_value(), 127);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub const fn max_value() -> Self {\n            !Self::min_value()\n        }\n\n        /// Converts a string slice in a given base to an integer.\n        ///\n        /// The string is expected to be an optional `+` or `-` sign\n        /// followed by digits.\n        /// Leading and trailing whitespace represent an error.\n        /// Digits are a subset of these characters, depending on `radix`:\n        ///\n        /// * `0-9`\n        /// * `a-z`\n        /// * `A-Z`\n        ///\n        /// # Panics\n        ///\n        /// This function panics if `radix` is not in the range from 2 to 36.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(i32::from_str_radix(\"A\", 16), Ok(10));\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n            from_str_radix(src, radix)\n        }\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = -0b1000_0000i8;\n        ///\n        /// assert_eq!(n.count_ones(), 1);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = -0b1000_0000i8;\n        ///\n        /// assert_eq!(n.count_zeros(), 7);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = -1i16;\n        ///\n        /// assert_eq!(n.leading_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn leading_zeros(self) -> u32 {\n            (self as $UnsignedT).leading_zeros()\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = -4i8;\n        ///\n        /// assert_eq!(n.trailing_zeros(), 2);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn trailing_zeros(self) -> u32 {\n            (self as $UnsignedT).trailing_zeros()\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as `<<`!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFi64;\n        /// let m = -0x76543210FEDCBA99i64;\n        ///\n        /// assert_eq!(n.rotate_left(32), m);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn rotate_left(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_left(n) as Self\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as `>>`!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFi64;\n        /// let m = -0xFEDCBA987654322i64;\n        ///\n        /// assert_eq!(n.rotate_right(4), m);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn rotate_right(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_right(n) as Self\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n: i16 = 0b0000000_01010101;\n        /// assert_eq!(n, 85);\n        ///\n        /// let m = n.swap_bytes();\n        ///\n        /// assert_eq!(m, 0b01010101_00000000);\n        /// assert_eq!(m, 21760);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn swap_bytes(self) -> Self {\n            (self as $UnsignedT).swap_bytes() as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFi64;\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(i64::from_be(n), n)\n        /// } else {\n        ///     assert_eq!(i64::from_be(n), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn from_be(x: Self) -> Self {\n            if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFi64;\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(i64::from_le(n), n)\n        /// } else {\n        ///     assert_eq!(i64::from_le(n), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn from_le(x: Self) -> Self {\n            if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFi64;\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn to_be(self) -> Self { // or not to be?\n            if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFi64;\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn to_le(self) -> Self {\n            if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(7i16.checked_add(32760), Some(32767));\n        /// assert_eq!(8i16.checked_add(32760), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_add(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_add(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n        /// assert_eq!((-128i8).checked_sub(1), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(6i8.checked_mul(21), Some(126));\n        /// assert_eq!(6i8.checked_mul(22), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!((-127i8).checked_div(-1), Some(127));\n        /// assert_eq!((-128i8).checked_div(-1), None);\n        /// assert_eq!((1i8).checked_div(0), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_div(self, rhs: Self) -> Option<Self> {\n            if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                None\n            } else {\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(5i32.checked_rem(2), Some(1));\n        /// assert_eq!(5i32.checked_rem(0), None);\n        /// assert_eq!(i32::MIN.checked_rem(-1), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                None\n            } else {\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` if `self ==\n        /// MIN`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(5i32.checked_neg(), Some(-5));\n        /// assert_eq!(i32::MIN.checked_neg(), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(0x10i32.checked_shl(4), Some(0x100));\n        /// assert_eq!(0x10i32.checked_shl(33), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(0x10i32.checked_shr(4), Some(0x1));\n        /// assert_eq!(0x10i32.checked_shr(33), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked absolute value. Computes `self.abs()`, returning `None` if\n        /// `self == MIN`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!((-5i32).checked_abs(), Some(5));\n        /// assert_eq!(i32::MIN.checked_abs(), None);\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[inline]\n        pub fn checked_abs(self) -> Option<Self> {\n            if self.is_negative() {\n                self.checked_neg()\n            } else {\n                Some(self)\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100i8.saturating_add(1), 101);\n        /// assert_eq!(100i8.saturating_add(127), 127);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn saturating_add(self, rhs: Self) -> Self {\n            match self.checked_add(rhs) {\n                Some(x) => x,\n                None if rhs >= 0 => Self::max_value(),\n                None => Self::min_value(),\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100i8.saturating_sub(127), -27);\n        /// assert_eq!((-100i8).saturating_sub(127), -128);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn saturating_sub(self, rhs: Self) -> Self {\n            match self.checked_sub(rhs) {\n                Some(x) => x,\n                None if rhs >= 0 => Self::min_value(),\n                None => Self::max_value(),\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(100i32.saturating_mul(127), 12700);\n        /// assert_eq!((1i32 << 23).saturating_mul(1 << 23), i32::MAX);\n        /// assert_eq!((-1i32 << 23).saturating_mul(1 << 23), i32::MIN);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn saturating_mul(self, rhs: Self) -> Self {\n            self.checked_mul(rhs).unwrap_or_else(|| {\n                if (self < 0 && rhs < 0) || (self > 0 && rhs > 0) {\n                    Self::max_value()\n                } else {\n                    Self::min_value()\n                }\n            })\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100i8.wrapping_add(27), 127);\n        /// assert_eq!(100i8.wrapping_add(127), -29);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn wrapping_add(self, rhs: Self) -> Self {\n            unsafe {\n                intrinsics::overflowing_add(self, rhs)\n            }\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(0i8.wrapping_sub(127), -127);\n        /// assert_eq!((-2i8).wrapping_sub(127), 127);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn wrapping_sub(self, rhs: Self) -> Self {\n            unsafe {\n                intrinsics::overflowing_sub(self, rhs)\n            }\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(10i8.wrapping_mul(12), 120);\n        /// assert_eq!(11i8.wrapping_mul(12), -124);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn wrapping_mul(self, rhs: Self) -> Self {\n            unsafe {\n                intrinsics::overflowing_mul(self, rhs)\n            }\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one\n        /// divides `MIN / -1` on a signed type (where `MIN` is the\n        /// negative minimal value for the type); this is equivalent\n        /// to `-MIN`, a positive value that is too large to represent\n        /// in the type. In such a case, this function returns `MIN`\n        /// itself.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.wrapping_div(10), 10);\n        /// assert_eq!((-128i8).wrapping_div(-1), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline]\n        pub fn wrapping_div(self, rhs: Self) -> Self {\n            self.overflowing_div(rhs).0\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Such wrap-around never actually occurs mathematically;\n        /// implementation artifacts make `x % y` invalid for `MIN /\n        /// -1` on a signed type (where `MIN` is the negative\n        /// minimal value). In such a case, this function returns `0`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100i8.wrapping_rem(10), 0);\n        /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline]\n        pub fn wrapping_rem(self, rhs: Self) -> Self {\n            self.overflowing_rem(rhs).0\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one\n        /// negates `MIN` on a signed type (where `MIN` is the\n        /// negative minimal value for the type); this is a positive\n        /// value that is too large to represent in the type. In such\n        /// a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100i8.wrapping_neg(), -100);\n        /// assert_eq!((-128i8).wrapping_neg(), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline]\n        pub fn wrapping_neg(self) -> Self {\n            self.overflowing_neg().0\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a `rotate_left` function, which may\n        /// be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!((-1i8).wrapping_shl(7), -128);\n        /// assert_eq!((-1i8).wrapping_shl(8), -1);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline]\n        pub fn wrapping_shl(self, rhs: u32) -> Self {\n            unsafe {\n                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a `rotate_right` function, which may\n        /// be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!((-128i8).wrapping_shr(7), -1);\n        /// assert_eq!((-128i8).wrapping_shr(8), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline]\n        pub fn wrapping_shr(self, rhs: u32) -> Self {\n            unsafe {\n                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n            }\n        }\n\n        /// Wrapping (modular) absolute value. Computes `self.abs()`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one takes\n        /// the absolute value of the negative minimal value for the type\n        /// this is a positive value that is too large to represent in the\n        /// type. In such a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100i8.wrapping_abs(), 100);\n        /// assert_eq!((-100i8).wrapping_abs(), 100);\n        /// assert_eq!((-128i8).wrapping_abs(), -128);\n        /// assert_eq!((-128i8).wrapping_abs() as u8, 128);\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[inline]\n        pub fn wrapping_abs(self) -> Self {\n            if self.is_negative() {\n                self.wrapping_neg()\n            } else {\n                self\n            }\n        }\n\n        /// Calculates `self` + `rhs`\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(5i32.overflowing_add(2), (7, false));\n        /// assert_eq!(i32::MAX.overflowing_add(1), (i32::MIN, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = unsafe {\n                intrinsics::add_with_overflow(self as $ActualT,\n                                              rhs as $ActualT)\n            };\n            (a as Self, b)\n        }\n\n        /// Calculates `self` - `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(5i32.overflowing_sub(2), (3, false));\n        /// assert_eq!(i32::MIN.overflowing_sub(1), (i32::MAX, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = unsafe {\n                intrinsics::sub_with_overflow(self as $ActualT,\n                                              rhs as $ActualT)\n            };\n            (a as Self, b)\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(5i32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = unsafe {\n                intrinsics::mul_with_overflow(self as $ActualT,\n                                              rhs as $ActualT)\n            };\n            (a as Self, b)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// occur then self is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(5i32.overflowing_div(2), (2, false));\n        /// assert_eq!(i32::MIN.overflowing_div(-1), (i32::MIN, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            if self == Self::min_value() && rhs == -1 {\n                (self, true)\n            } else {\n                (self / rhs, false)\n            }\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would occur then 0 is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(5i32.overflowing_rem(2), (1, false));\n        /// assert_eq!(i32::MIN.overflowing_rem(-1), (0, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            if self == Self::min_value() && rhs == -1 {\n                (0, true)\n            } else {\n                (self % rhs, false)\n            }\n        }\n\n        /// Negates self, overflowing if this is equal to the minimum value.\n        ///\n        /// Returns a tuple of the negated version of self along with a boolean\n        /// indicating whether an overflow happened. If `self` is the minimum\n        /// value (e.g. `i32::MIN` for values of type `i32`), then the minimum\n        /// value will be returned again and `true` will be returned for an\n        /// overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::i32;\n        ///\n        /// assert_eq!(2i32.overflowing_neg(), (-2, false));\n        /// assert_eq!(i32::MIN.overflowing_neg(), (i32::MIN, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_neg(self) -> (Self, bool) {\n            if self == Self::min_value() {\n                (Self::min_value(), true)\n            } else {\n                (-self, false)\n            }\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(0x10i32.overflowing_shl(4), (0x100, false));\n        /// assert_eq!(0x10i32.overflowing_shl(36), (0x100, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(0x10i32.overflowing_shr(4), (0x1, false));\n        /// assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// Returns a tuple of the absolute version of self along with a\n        /// boolean indicating whether an overflow happened. If self is the\n        /// minimum value (e.g. i32::MIN for values of type i32), then the\n        /// minimum value will be returned again and true will be returned for\n        /// an overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(10i8.overflowing_abs(), (10,false));\n        /// assert_eq!((-10i8).overflowing_abs(), (10,false));\n        /// assert_eq!((-128i8).overflowing_abs(), (-128,true));\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[inline]\n        pub fn overflowing_abs(self) -> (Self, bool) {\n            if self.is_negative() {\n                self.overflowing_neg()\n            } else {\n                (self, false)\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let x: i32 = 2; // or any other integer type\n        ///\n        /// assert_eq!(x.pow(4), 16);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub fn pow(self, mut exp: u32) -> Self {\n            let mut base = self;\n            let mut acc = 1;\n\n            while exp > 1 {\n                if (exp & 1) == 1 {\n                    acc = acc * base;\n                }\n                exp /= 2;\n                base = base * base;\n            }\n\n            // Deal with the final bit of the exponent separately, since\n            // squaring the base afterwards is not necessary and may cause a\n            // needless overflow.\n            if exp == 1 {\n                acc = acc * base;\n            }\n\n            acc\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// # Overflow behavior\n        ///\n        /// The absolute value of `i32::min_value()` cannot be represented as an\n        /// `i32`, and attempting to calculate it will cause an overflow. This\n        /// means that code in debug mode will trigger a panic on this case and\n        /// optimized code will return `i32::min_value()` without a panic.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(10i8.abs(), 10);\n        /// assert_eq!((-10i8).abs(), 10);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub fn abs(self) -> Self {\n            if self.is_negative() {\n                // Note that the #[inline] above means that the overflow\n                // semantics of this negation depend on the crate we're being\n                // inlined into.\n                -self\n            } else {\n                self\n            }\n        }\n\n        /// Returns a number representing sign of `self`.\n        ///\n        /// - `0` if the number is zero\n        /// - `1` if the number is positive\n        /// - `-1` if the number is negative\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(10i8.signum(), 1);\n        /// assert_eq!(0i8.signum(), 0);\n        /// assert_eq!((-10i8).signum(), -1);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn signum(self) -> Self {\n            match self {\n                n if n > 0 =>  1,\n                0          =>  0,\n                _          => -1,\n            }\n        }\n\n        /// Returns `true` if `self` is positive and `false` if the number\n        /// is zero or negative.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert!(10i8.is_positive());\n        /// assert!(!(-10i8).is_positive());\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn is_positive(self) -> bool { self > 0 }\n\n        /// Returns `true` if `self` is negative and `false` if the number\n        /// is zero or positive.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert!((-10i8).is_negative());\n        /// assert!(!10i8.is_negative());\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn is_negative(self) -> bool { self < 0 }\n    }\n}\n\n#[lang = \"i8\"]\nimpl i8 {\n    int_impl! { i8, i8, u8, 8 }\n}\n\n#[lang = \"i16\"]\nimpl i16 {\n    int_impl! { i16, i16, u16, 16 }\n}\n\n#[lang = \"i32\"]\nimpl i32 {\n    int_impl! { i32, i32, u32, 32 }\n}\n\n#[lang = \"i64\"]\nimpl i64 {\n    int_impl! { i64, i64, u64, 64 }\n}\n\n#[lang = \"i128\"]\nimpl i128 {\n    int_impl! { i128, i128, u128, 128 }\n}\n\n#[cfg(target_pointer_width = \"16\")]\n#[lang = \"isize\"]\nimpl isize {\n    int_impl! { isize, i16, u16, 16 }\n}\n\n#[cfg(target_pointer_width = \"32\")]\n#[lang = \"isize\"]\nimpl isize {\n    int_impl! { isize, i32, u32, 32 }\n}\n\n#[cfg(target_pointer_width = \"64\")]\n#[lang = \"isize\"]\nimpl isize {\n    int_impl! { isize, i64, u64, 64 }\n}\n\n// `Int` + `UnsignedInt` implemented for unsigned integers\nmacro_rules! uint_impl {\n    ($SelfT:ty, $ActualT:ty, $BITS:expr) => {\n        /// Returns the smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(u8::min_value(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub const fn min_value() -> Self { 0 }\n\n        /// Returns the largest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(u8::max_value(), 255);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub const fn max_value() -> Self { !0 }\n\n        /// Converts a string slice in a given base to an integer.\n        ///\n        /// The string is expected to be an optional `+` sign\n        /// followed by digits.\n        /// Leading and trailing whitespace represent an error.\n        /// Digits are a subset of these characters, depending on `radix`:\n        ///\n        /// * `0-9`\n        /// * `a-z`\n        /// * `A-Z`\n        ///\n        /// # Panics\n        ///\n        /// This function panics if `radix` is not in the range from 2 to 36.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(u32::from_str_radix(\"A\", 16), Ok(10));\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n            from_str_radix(src, radix)\n        }\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0b01001100u8;\n        ///\n        /// assert_eq!(n.count_ones(), 3);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn count_ones(self) -> u32 {\n            unsafe { intrinsics::ctpop(self as $ActualT) as u32 }\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0b01001100u8;\n        ///\n        /// assert_eq!(n.count_zeros(), 5);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0b0101000u16;\n        ///\n        /// assert_eq!(n.leading_zeros(), 10);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn leading_zeros(self) -> u32 {\n            unsafe { intrinsics::ctlz(self as $ActualT) as u32 }\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0b0101000u16;\n        ///\n        /// assert_eq!(n.trailing_zeros(), 3);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn trailing_zeros(self) -> u32 {\n            // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n            // emits two conditional moves on x86_64. By promoting the value to\n            // u16 and setting bit 8, we get better code without any conditional\n            // operations.\n            // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n            // pending, remove this workaround once LLVM generates better code\n            // for cttz8.\n            unsafe {\n                if $BITS == 8 {\n                    intrinsics::cttz(self as u16 | 0x100) as u32\n                } else {\n                    intrinsics::cttz(self) as u32\n                }\n            }\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as `<<`!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        /// let m = 0x3456789ABCDEF012u64;\n        ///\n        /// assert_eq!(n.rotate_left(12), m);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn rotate_left(self, n: u32) -> Self {\n            // Protect against undefined behaviour for over-long bit shifts\n            let n = n % $BITS;\n            (self << n) | (self >> (($BITS - n) % $BITS))\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as `>>`!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        /// let m = 0xDEF0123456789ABCu64;\n        ///\n        /// assert_eq!(n.rotate_right(12), m);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn rotate_right(self, n: u32) -> Self {\n            // Protect against undefined behaviour for over-long bit shifts\n            let n = n % $BITS;\n            (self >> n) | (self << (($BITS - n) % $BITS))\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n: u16 = 0b0000000_01010101;\n        /// assert_eq!(n, 85);\n        ///\n        /// let m = n.swap_bytes();\n        ///\n        /// assert_eq!(m, 0b01010101_00000000);\n        /// assert_eq!(m, 21760);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn swap_bytes(self) -> Self {\n            unsafe { intrinsics::bswap(self as $ActualT) as Self }\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(u64::from_be(n), n)\n        /// } else {\n        ///     assert_eq!(u64::from_be(n), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn from_be(x: Self) -> Self {\n            if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(u64::from_le(n), n)\n        /// } else {\n        ///     assert_eq!(u64::from_le(n), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn from_le(x: Self) -> Self {\n            if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn to_be(self) -> Self { // or not to be?\n            if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// let n = 0x0123456789ABCDEFu64;\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn to_le(self) -> Self {\n            if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(5u16.checked_add(65530), Some(65535));\n        /// assert_eq!(6u16.checked_add(65530), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_add(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_add(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(1u8.checked_sub(1), Some(0));\n        /// assert_eq!(0u8.checked_sub(1), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(5u8.checked_mul(51), Some(255));\n        /// assert_eq!(5u8.checked_mul(52), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(128u8.checked_div(2), Some(64));\n        /// assert_eq!(1u8.checked_div(0), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn checked_div(self, rhs: Self) -> Option<Self> {\n            match rhs {\n                0 => None,\n                rhs => Some(unsafe { intrinsics::unchecked_div(self, rhs) }),\n            }\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(5u32.checked_rem(2), Some(1));\n        /// assert_eq!(5u32.checked_rem(0), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if rhs == 0 {\n                None\n            } else {\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(0u32.checked_neg(), Some(0));\n        /// assert_eq!(1u32.checked_neg(), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(0x10u32.checked_shl(4), Some(0x100));\n        /// assert_eq!(0x10u32.checked_shl(33), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(0x10u32.checked_shr(4), Some(0x1));\n        /// assert_eq!(0x10u32.checked_shr(33), None);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b {None} else {Some(a)}\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.saturating_add(1), 101);\n        /// assert_eq!(200u8.saturating_add(127), 255);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn saturating_add(self, rhs: Self) -> Self {\n            match self.checked_add(rhs) {\n                Some(x) => x,\n                None => Self::max_value(),\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.saturating_sub(27), 73);\n        /// assert_eq!(13u8.saturating_sub(127), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn saturating_sub(self, rhs: Self) -> Self {\n            match self.checked_sub(rhs) {\n                Some(x) => x,\n                None => Self::min_value(),\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// use std::u32;\n        ///\n        /// assert_eq!(100u32.saturating_mul(127), 12700);\n        /// assert_eq!((1u32 << 23).saturating_mul(1 << 23), u32::MAX);\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[inline]\n        pub fn saturating_mul(self, rhs: Self) -> Self {\n            self.checked_mul(rhs).unwrap_or(Self::max_value())\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(200u8.wrapping_add(55), 255);\n        /// assert_eq!(200u8.wrapping_add(155), 99);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn wrapping_add(self, rhs: Self) -> Self {\n            unsafe {\n                intrinsics::overflowing_add(self, rhs)\n            }\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.wrapping_sub(100), 0);\n        /// assert_eq!(100u8.wrapping_sub(155), 201);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn wrapping_sub(self, rhs: Self) -> Self {\n            unsafe {\n                intrinsics::overflowing_sub(self, rhs)\n            }\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn wrapping_mul(self, rhs: Self) -> Self {\n            unsafe {\n                intrinsics::overflowing_mul(self, rhs)\n            }\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        /// Wrapped division on unsigned types is just normal division.\n        /// There's no way wrapping could ever happen.\n        /// This function exists, so that all operations\n        /// are accounted for in the wrapping operations.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.wrapping_div(10), 10);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline]\n        pub fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        /// Wrapped remainder calculation on unsigned types is\n        /// just the regular remainder calculation.\n        /// There's no way wrapping could ever happen.\n        /// This function exists, so that all operations\n        /// are accounted for in the wrapping operations.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.wrapping_rem(10), 0);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline]\n        pub fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(100u8.wrapping_neg(), 156);\n        /// assert_eq!(0u8.wrapping_neg(), 0);\n        /// assert_eq!(180u8.wrapping_neg(), 76);\n        /// assert_eq!(180u8.wrapping_neg(), (127 + 1) - (180u8 - (127 + 1)));\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline]\n        pub fn wrapping_neg(self) -> Self {\n            self.overflowing_neg().0\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a `rotate_left` function, which may\n        /// be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(1u8.wrapping_shl(7), 128);\n        /// assert_eq!(1u8.wrapping_shl(8), 1);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline]\n        pub fn wrapping_shl(self, rhs: u32) -> Self {\n            unsafe {\n                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a `rotate_right` function, which may\n        /// be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(128u8.wrapping_shr(7), 1);\n        /// assert_eq!(128u8.wrapping_shr(8), 128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[inline]\n        pub fn wrapping_shr(self, rhs: u32) -> Self {\n            unsafe {\n                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n            }\n        }\n\n        /// Calculates `self` + `rhs`\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::u32;\n        ///\n        /// assert_eq!(5u32.overflowing_add(2), (7, false));\n        /// assert_eq!(u32::MAX.overflowing_add(1), (0, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = unsafe {\n                intrinsics::add_with_overflow(self as $ActualT,\n                                              rhs as $ActualT)\n            };\n            (a as Self, b)\n        }\n\n        /// Calculates `self` - `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// use std::u32;\n        ///\n        /// assert_eq!(5u32.overflowing_sub(2), (3, false));\n        /// assert_eq!(0u32.overflowing_sub(1), (u32::MAX, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = unsafe {\n                intrinsics::sub_with_overflow(self as $ActualT,\n                                              rhs as $ActualT)\n            };\n            (a as Self, b)\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = unsafe {\n                intrinsics::mul_with_overflow(self as $ActualT,\n                                              rhs as $ActualT)\n            };\n            (a as Self, b)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_div(2), (2, false));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_rem(2), (1, false));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(0u32.overflowing_neg(), (0, false));\n        /// assert_eq!(2u32.overflowing_neg(), (-2i32 as u32, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(0x10u32.overflowing_shl(4), (0x100, false));\n        /// assert_eq!(0x10u32.overflowing_shl(36), (0x100, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        /// assert_eq!(0x10u32.overflowing_shr(4), (0x1, false));\n        /// assert_eq!(0x10u32.overflowing_shr(36), (0x1, true));\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(2u32.pow(4), 16);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub fn pow(self, mut exp: u32) -> Self {\n            let mut base = self;\n            let mut acc = 1;\n\n            while exp > 1 {\n                if (exp & 1) == 1 {\n                    acc = acc * base;\n                }\n                exp /= 2;\n                base = base * base;\n            }\n\n            // Deal with the final bit of the exponent separately, since\n            // squaring the base afterwards is not necessary and may cause a\n            // needless overflow.\n            if exp == 1 {\n                acc = acc * base;\n            }\n\n            acc\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert!(16u8.is_power_of_two());\n        /// assert!(!10u8.is_power_of_two());\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn is_power_of_two(self) -> bool {\n            (self.wrapping_sub(1)) & self == 0 && !(self == 0)\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            // Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let p = self - 1;\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::max_value() >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e. `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and return value is wrapped to 0 in\n        /// release mode (the only situation in which method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(2u8.next_power_of_two(), 2);\n        /// assert_eq!(3u8.next_power_of_two(), 4);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline]\n        pub fn next_power_of_two(self) -> Self {\n            // Call the trait to get overflow checks\n            ops::Add::add(self.one_less_than_next_power_of_two(), 1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// assert_eq!(2u8.checked_next_power_of_two(), Some(2));\n        /// assert_eq!(3u8.checked_next_power_of_two(), Some(4));\n        /// assert_eq!(200u8.checked_next_power_of_two(), None);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n    }\n}\n\n#[lang = \"u8\"]\nimpl u8 {\n    uint_impl! { u8, u8, 8 }\n\n\n    /// Checks if the value is within the ASCII range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let ascii = 97u8;\n    /// let non_ascii = 150u8;\n    ///\n    /// assert!(ascii.is_ascii());\n    /// assert!(!non_ascii.is_ascii());\n    /// ```\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn is_ascii(&self) -> bool {\n        *self & 128 == 0\n    }\n\n    /// Makes a copy of the value in its ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let lowercase_a = 97u8;\n    ///\n    /// assert_eq!(65, lowercase_a.to_ascii_uppercase());\n    /// ```\n    ///\n    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_uppercase(&self) -> u8 {\n        ASCII_UPPERCASE_MAP[*self as usize]\n    }\n\n    /// Makes a copy of the value in its ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 65u8;\n    ///\n    /// assert_eq!(97, uppercase_a.to_ascii_lowercase());\n    /// ```\n    ///\n    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_lowercase(&self) -> u8 {\n        ASCII_LOWERCASE_MAP[*self as usize]\n    }\n\n    /// Checks that two values are an ASCII case-insensitive match.\n    ///\n    /// This is equivalent to `to_ascii_lowercase(a) == to_ascii_lowercase(b)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let lowercase_a = 97u8;\n    /// let uppercase_a = 65u8;\n    ///\n    /// assert!(lowercase_a.eq_ignore_ascii_case(&uppercase_a));\n    /// ```\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn eq_ignore_ascii_case(&self, other: &u8) -> bool {\n        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n    }\n\n    /// Converts this value to its ASCII upper case equivalent in-place.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new uppercased value without modifying the existing one, use\n    /// [`to_ascii_uppercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut byte = b'a';\n    ///\n    /// byte.make_ascii_uppercase();\n    ///\n    /// assert_eq!(b'A', byte);\n    /// ```\n    ///\n    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n        *self = self.to_ascii_uppercase();\n    }\n\n    /// Converts this value to its ASCII lower case equivalent in-place.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new lowercased value without modifying the existing one, use\n    /// [`to_ascii_lowercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut byte = b'A';\n    ///\n    /// byte.make_ascii_lowercase();\n    ///\n    /// assert_eq!(b'a', byte);\n    /// ```\n    ///\n    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n        *self = self.to_ascii_lowercase();\n    }\n\n    /// Checks if the value is an ASCII alphabetic character:\n    ///\n    /// - U+0041 'A' ... U+005A 'Z', or\n    /// - U+0061 'a' ... U+007A 'z'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ascii_ctype)]\n    ///\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_alphabetic());\n    /// assert!(uppercase_g.is_ascii_alphabetic());\n    /// assert!(a.is_ascii_alphabetic());\n    /// assert!(g.is_ascii_alphabetic());\n    /// assert!(!zero.is_ascii_alphabetic());\n    /// assert!(!percent.is_ascii_alphabetic());\n    /// assert!(!space.is_ascii_alphabetic());\n    /// assert!(!lf.is_ascii_alphabetic());\n    /// assert!(!esc.is_ascii_alphabetic());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_alphabetic(&self) -> bool {\n        if *self >= 0x80 { return false; }\n        match ASCII_CHARACTER_CLASS[*self as usize] {\n            L | Lx | U | Ux => true,\n            _ => false\n        }\n    }\n\n    /// Checks if the value is an ASCII uppercase character:\n    /// U+0041 'A' ... U+005A 'Z'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ascii_ctype)]\n    ///\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_uppercase());\n    /// assert!(uppercase_g.is_ascii_uppercase());\n    /// assert!(!a.is_ascii_uppercase());\n    /// assert!(!g.is_ascii_uppercase());\n    /// assert!(!zero.is_ascii_uppercase());\n    /// assert!(!percent.is_ascii_uppercase());\n    /// assert!(!space.is_ascii_uppercase());\n    /// assert!(!lf.is_ascii_uppercase());\n    /// assert!(!esc.is_ascii_uppercase());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_uppercase(&self) -> bool {\n        if *self >= 0x80 { return false }\n        match ASCII_CHARACTER_CLASS[*self as usize] {\n            U | Ux => true,\n            _ => false\n        }\n    }\n\n    /// Checks if the value is an ASCII lowercase character:\n    /// U+0061 'a' ... U+007A 'z'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ascii_ctype)]\n    ///\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_lowercase());\n    /// assert!(!uppercase_g.is_ascii_lowercase());\n    /// assert!(a.is_ascii_lowercase());\n    /// assert!(g.is_ascii_lowercase());\n    /// assert!(!zero.is_ascii_lowercase());\n    /// assert!(!percent.is_ascii_lowercase());\n    /// assert!(!space.is_ascii_lowercase());\n    /// assert!(!lf.is_ascii_lowercase());\n    /// assert!(!esc.is_ascii_lowercase());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_lowercase(&self) -> bool {\n        if *self >= 0x80 { return false }\n        match ASCII_CHARACTER_CLASS[*self as usize] {\n            L | Lx => true,\n            _ => false\n        }\n    }\n\n    /// Checks if the value is an ASCII alphanumeric character:\n    ///\n    /// - U+0041 'A' ... U+005A 'Z', or\n    /// - U+0061 'a' ... U+007A 'z', or\n    /// - U+0030 '0' ... U+0039 '9'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ascii_ctype)]\n    ///\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_alphanumeric());\n    /// assert!(uppercase_g.is_ascii_alphanumeric());\n    /// assert!(a.is_ascii_alphanumeric());\n    /// assert!(g.is_ascii_alphanumeric());\n    /// assert!(zero.is_ascii_alphanumeric());\n    /// assert!(!percent.is_ascii_alphanumeric());\n    /// assert!(!space.is_ascii_alphanumeric());\n    /// assert!(!lf.is_ascii_alphanumeric());\n    /// assert!(!esc.is_ascii_alphanumeric());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_alphanumeric(&self) -> bool {\n        if *self >= 0x80 { return false }\n        match ASCII_CHARACTER_CLASS[*self as usize] {\n            D | L | Lx | U | Ux => true,\n            _ => false\n        }\n    }\n\n    /// Checks if the value is an ASCII decimal digit:\n    /// U+0030 '0' ... U+0039 '9'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ascii_ctype)]\n    ///\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_digit());\n    /// assert!(!uppercase_g.is_ascii_digit());\n    /// assert!(!a.is_ascii_digit());\n    /// assert!(!g.is_ascii_digit());\n    /// assert!(zero.is_ascii_digit());\n    /// assert!(!percent.is_ascii_digit());\n    /// assert!(!space.is_ascii_digit());\n    /// assert!(!lf.is_ascii_digit());\n    /// assert!(!esc.is_ascii_digit());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_digit(&self) -> bool {\n        if *self >= 0x80 { return false }\n        match ASCII_CHARACTER_CLASS[*self as usize] {\n            D => true,\n            _ => false\n        }\n    }\n\n    /// Checks if the value is an ASCII hexadecimal digit:\n    ///\n    /// - U+0030 '0' ... U+0039 '9', or\n    /// - U+0041 'A' ... U+0046 'F', or\n    /// - U+0061 'a' ... U+0066 'f'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ascii_ctype)]\n    ///\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_hexdigit());\n    /// assert!(!uppercase_g.is_ascii_hexdigit());\n    /// assert!(a.is_ascii_hexdigit());\n    /// assert!(!g.is_ascii_hexdigit());\n    /// assert!(zero.is_ascii_hexdigit());\n    /// assert!(!percent.is_ascii_hexdigit());\n    /// assert!(!space.is_ascii_hexdigit());\n    /// assert!(!lf.is_ascii_hexdigit());\n    /// assert!(!esc.is_ascii_hexdigit());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_hexdigit(&self) -> bool {\n        if *self >= 0x80 { return false }\n        match ASCII_CHARACTER_CLASS[*self as usize] {\n            D | Lx | Ux => true,\n            _ => false\n        }\n    }\n\n    /// Checks if the value is an ASCII punctuation character:\n    ///\n    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n    /// - U+005B ... U+0060 ``[ \\ ] ^ _ ` ``, or\n    /// - U+007B ... U+007E `{ | } ~`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ascii_ctype)]\n    ///\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_punctuation());\n    /// assert!(!uppercase_g.is_ascii_punctuation());\n    /// assert!(!a.is_ascii_punctuation());\n    /// assert!(!g.is_ascii_punctuation());\n    /// assert!(!zero.is_ascii_punctuation());\n    /// assert!(percent.is_ascii_punctuation());\n    /// assert!(!space.is_ascii_punctuation());\n    /// assert!(!lf.is_ascii_punctuation());\n    /// assert!(!esc.is_ascii_punctuation());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_punctuation(&self) -> bool {\n        if *self >= 0x80 { return false }\n        match ASCII_CHARACTER_CLASS[*self as usize] {\n            P => true,\n            _ => false\n        }\n    }\n\n    /// Checks if the value is an ASCII graphic character:\n    /// U+0021 '@' ... U+007E '~'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ascii_ctype)]\n    ///\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_graphic());\n    /// assert!(uppercase_g.is_ascii_graphic());\n    /// assert!(a.is_ascii_graphic());\n    /// assert!(g.is_ascii_graphic());\n    /// assert!(zero.is_ascii_graphic());\n    /// assert!(percent.is_ascii_graphic());\n    /// assert!(!space.is_ascii_graphic());\n    /// assert!(!lf.is_ascii_graphic());\n    /// assert!(!esc.is_ascii_graphic());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_graphic(&self) -> bool {\n        if *self >= 0x80 { return false; }\n        match ASCII_CHARACTER_CLASS[*self as usize] {\n            Ux | U | Lx | L | D | P => true,\n            _ => false\n        }\n    }\n\n    /// Checks if the value is an ASCII whitespace character:\n    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n    ///\n    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n    /// whitespace][infra-aw]. There are several other definitions in\n    /// wide use. For instance, [the POSIX locale][pct] includes\n    /// U+000B VERTICAL TAB as well as all the above characters,\n    /// but—from the very same specification—[the default rule for\n    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n    ///\n    /// If you are writing a program that will process an existing\n    /// file format, check what that format's definition of whitespace is\n    /// before using this function.\n    ///\n    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ascii_ctype)]\n    ///\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_whitespace());\n    /// assert!(!uppercase_g.is_ascii_whitespace());\n    /// assert!(!a.is_ascii_whitespace());\n    /// assert!(!g.is_ascii_whitespace());\n    /// assert!(!zero.is_ascii_whitespace());\n    /// assert!(!percent.is_ascii_whitespace());\n    /// assert!(space.is_ascii_whitespace());\n    /// assert!(lf.is_ascii_whitespace());\n    /// assert!(!esc.is_ascii_whitespace());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_whitespace(&self) -> bool {\n        if *self >= 0x80 { return false; }\n        match ASCII_CHARACTER_CLASS[*self as usize] {\n            Cw | W => true,\n            _ => false\n        }\n    }\n\n    /// Checks if the value is an ASCII control character:\n    /// U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n    /// Note that most ASCII whitespace characters are control\n    /// characters, but SPACE is not.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ascii_ctype)]\n    ///\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_control());\n    /// assert!(!uppercase_g.is_ascii_control());\n    /// assert!(!a.is_ascii_control());\n    /// assert!(!g.is_ascii_control());\n    /// assert!(!zero.is_ascii_control());\n    /// assert!(!percent.is_ascii_control());\n    /// assert!(!space.is_ascii_control());\n    /// assert!(lf.is_ascii_control());\n    /// assert!(esc.is_ascii_control());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_control(&self) -> bool {\n        if *self >= 0x80 { return false; }\n        match ASCII_CHARACTER_CLASS[*self as usize] {\n            C | Cw => true,\n            _ => false\n        }\n    }\n}\n\n#[lang = \"u16\"]\nimpl u16 {\n    uint_impl! { u16, u16, 16 }\n}\n\n#[lang = \"u32\"]\nimpl u32 {\n    uint_impl! { u32, u32, 32 }\n}\n\n#[lang = \"u64\"]\nimpl u64 {\n    uint_impl! { u64, u64, 64 }\n}\n\n#[lang = \"u128\"]\nimpl u128 {\n    uint_impl! { u128, u128, 128 }\n}\n\n#[cfg(target_pointer_width = \"16\")]\n#[lang = \"usize\"]\nimpl usize {\n    uint_impl! { usize, u16, 16 }\n}\n#[cfg(target_pointer_width = \"32\")]\n#[lang = \"usize\"]\nimpl usize {\n    uint_impl! { usize, u32, 32 }\n}\n\n#[cfg(target_pointer_width = \"64\")]\n#[lang = \"usize\"]\nimpl usize {\n    uint_impl! { usize, u64, 64 }\n}\n\n/// A classification of floating point numbers.\n///\n/// This `enum` is used as the return type for [`f32::classify`] and [`f64::classify`]. See\n/// their documentation for more.\n///\n/// [`f32::classify`]: ../../std/primitive.f32.html#method.classify\n/// [`f64::classify`]: ../../std/primitive.f64.html#method.classify\n///\n/// # Examples\n///\n/// ```\n/// use std::num::FpCategory;\n/// use std::f32;\n///\n/// let num = 12.4_f32;\n/// let inf = f32::INFINITY;\n/// let zero = 0f32;\n/// let sub: f32 = 1.1754942e-38;\n/// let nan = f32::NAN;\n///\n/// assert_eq!(num.classify(), FpCategory::Normal);\n/// assert_eq!(inf.classify(), FpCategory::Infinite);\n/// assert_eq!(zero.classify(), FpCategory::Zero);\n/// assert_eq!(nan.classify(), FpCategory::Nan);\n/// assert_eq!(sub.classify(), FpCategory::Subnormal);\n/// ```\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum FpCategory {\n    /// \"Not a Number\", often obtained by dividing by zero.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Nan,\n\n    /// Positive or negative infinity.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Infinite,\n\n    /// Positive or negative zero.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Zero,\n\n    /// De-normalized floating point representation (less precise than `Normal`).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Subnormal,\n\n    /// A regular floating point number.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Normal,\n}\n\n/// A built-in floating point number.\n#[doc(hidden)]\n#[unstable(feature = \"core_float\",\n           reason = \"stable interface is via `impl f{32,64}` in later crates\",\n           issue = \"32110\")]\npub trait Float: Sized {\n    /// Type used by `to_bits` and `from_bits`.\n    #[stable(feature = \"core_float_bits\", since = \"1.24.0\")]\n    type Bits;\n\n    /// Returns `true` if this value is NaN and false otherwise.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_nan(self) -> bool;\n    /// Returns `true` if this value is positive infinity or negative infinity and\n    /// false otherwise.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_infinite(self) -> bool;\n    /// Returns `true` if this number is neither infinite nor NaN.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_finite(self) -> bool;\n    /// Returns `true` if this number is neither zero, infinite, denormal, or NaN.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_normal(self) -> bool;\n    /// Returns the category that this number falls into.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn classify(self) -> FpCategory;\n\n    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n    /// number is `Float::nan()`.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn abs(self) -> Self;\n    /// Returns a number that represents the sign of `self`.\n    ///\n    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n    /// - `Float::nan()` if the number is `Float::nan()`\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn signum(self) -> Self;\n\n    /// Returns `true` if `self` is positive, including `+0.0` and\n    /// `Float::infinity()`.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_sign_positive(self) -> bool;\n    /// Returns `true` if `self` is negative, including `-0.0` and\n    /// `Float::neg_infinity()`.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_sign_negative(self) -> bool;\n\n    /// Take the reciprocal (inverse) of a number, `1/x`.\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn recip(self) -> Self;\n\n    /// Raise a number to an integer power.\n    ///\n    /// Using this function is generally faster than using `powf`\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn powi(self, n: i32) -> Self;\n\n    /// Convert radians to degrees.\n    #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n    fn to_degrees(self) -> Self;\n    /// Convert degrees to radians.\n    #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n    fn to_radians(self) -> Self;\n\n    /// Returns the maximum of the two numbers.\n    #[stable(feature = \"core_float_min_max\", since=\"1.20.0\")]\n    fn max(self, other: Self) -> Self;\n    /// Returns the minimum of the two numbers.\n    #[stable(feature = \"core_float_min_max\", since=\"1.20.0\")]\n    fn min(self, other: Self) -> Self;\n\n    /// Raw transmutation to integer.\n    #[stable(feature = \"core_float_bits\", since=\"1.24.0\")]\n    fn to_bits(self) -> Self::Bits;\n    /// Raw transmutation from integer.\n    #[stable(feature = \"core_float_bits\", since=\"1.24.0\")]\n    fn from_bits(v: Self::Bits) -> Self;\n}\n\nmacro_rules! from_str_radix_int_impl {\n    ($($t:ty)*) => {$(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl FromStr for $t {\n            type Err = ParseIntError;\n            fn from_str(src: &str) -> Result<Self, ParseIntError> {\n                from_str_radix(src, 10)\n            }\n        }\n    )*}\n}\nfrom_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n\n/// The error type returned when a checked integral type conversion fails.\n#[unstable(feature = \"try_from\", issue = \"33417\")]\n#[derive(Debug, Copy, Clone)]\npub struct TryFromIntError(());\n\nimpl TryFromIntError {\n    #[unstable(feature = \"int_error_internals\",\n               reason = \"available through Error trait and this method should \\\n                         not be exposed publicly\",\n               issue = \"0\")]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n        \"out of range integral type conversion attempted\"\n    }\n}\n\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl fmt::Display for TryFromIntError {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        self.__description().fmt(fmt)\n    }\n}\n\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl From<Infallible> for TryFromIntError {\n    fn from(infallible: Infallible) -> TryFromIntError {\n        match infallible {\n        }\n    }\n}\n\n// no possible bounds violation\nmacro_rules! try_from_unbounded {\n    ($source:ty, $($target:ty),*) => {$(\n        #[unstable(feature = \"try_from\", issue = \"33417\")]\n        impl TryFrom<$source> for $target {\n            type Error = Infallible;\n\n            #[inline]\n            fn try_from(value: $source) -> Result<Self, Self::Error> {\n                Ok(value as $target)\n            }\n        }\n    )*}\n}\n\n// only negative bounds\nmacro_rules! try_from_lower_bounded {\n    ($source:ty, $($target:ty),*) => {$(\n        #[unstable(feature = \"try_from\", issue = \"33417\")]\n        impl TryFrom<$source> for $target {\n            type Error = TryFromIntError;\n\n            #[inline]\n            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n                if u >= 0 {\n                    Ok(u as $target)\n                } else {\n                    Err(TryFromIntError(()))\n                }\n            }\n        }\n    )*}\n}\n\n// unsigned to signed (only positive bound)\nmacro_rules! try_from_upper_bounded {\n    ($source:ty, $($target:ty),*) => {$(\n        #[unstable(feature = \"try_from\", issue = \"33417\")]\n        impl TryFrom<$source> for $target {\n            type Error = TryFromIntError;\n\n            #[inline]\n            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n                if u > (<$target>::max_value() as $source) {\n                    Err(TryFromIntError(()))\n                } else {\n                    Ok(u as $target)\n                }\n            }\n        }\n    )*}\n}\n\n// all other cases\nmacro_rules! try_from_both_bounded {\n    ($source:ty, $($target:ty),*) => {$(\n        #[unstable(feature = \"try_from\", issue = \"33417\")]\n        impl TryFrom<$source> for $target {\n            type Error = TryFromIntError;\n\n            #[inline]\n            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n                let min = <$target>::min_value() as $source;\n                let max = <$target>::max_value() as $source;\n                if u < min || u > max {\n                    Err(TryFromIntError(()))\n                } else {\n                    Ok(u as $target)\n                }\n            }\n        }\n    )*}\n}\n\nmacro_rules! rev {\n    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n        $mac!($target, $source);\n    )*}\n}\n\n/// intra-sign conversions\ntry_from_upper_bounded!(u16, u8);\ntry_from_upper_bounded!(u32, u16, u8);\ntry_from_upper_bounded!(u64, u32, u16, u8);\ntry_from_upper_bounded!(u128, u64, u32, u16, u8);\n\ntry_from_both_bounded!(i16, i8);\ntry_from_both_bounded!(i32, i16, i8);\ntry_from_both_bounded!(i64, i32, i16, i8);\ntry_from_both_bounded!(i128, i64, i32, i16, i8);\n\n// unsigned-to-signed\ntry_from_upper_bounded!(u8, i8);\ntry_from_upper_bounded!(u16, i8, i16);\ntry_from_upper_bounded!(u32, i8, i16, i32);\ntry_from_upper_bounded!(u64, i8, i16, i32, i64);\ntry_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n\n// signed-to-unsigned\ntry_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\ntry_from_lower_bounded!(i16, u16, u32, u64, u128);\ntry_from_lower_bounded!(i32, u32, u64, u128);\ntry_from_lower_bounded!(i64, u64, u128);\ntry_from_lower_bounded!(i128, u128);\ntry_from_both_bounded!(i16, u8);\ntry_from_both_bounded!(i32, u16, u8);\ntry_from_both_bounded!(i64, u32, u16, u8);\ntry_from_both_bounded!(i128, u64, u32, u16, u8);\n\n// usize/isize\ntry_from_upper_bounded!(usize, isize);\ntry_from_lower_bounded!(isize, usize);\n\n#[cfg(target_pointer_width = \"16\")]\nmod ptr_try_from_impls {\n    use super::TryFromIntError;\n    use convert::{Infallible, TryFrom};\n\n    try_from_upper_bounded!(usize, u8);\n    try_from_unbounded!(usize, u16, u32, u64, u128);\n    try_from_upper_bounded!(usize, i8, i16);\n    try_from_unbounded!(usize, i32, i64, i128);\n\n    try_from_both_bounded!(isize, u8);\n    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n    try_from_both_bounded!(isize, i8);\n    try_from_unbounded!(isize, i16, i32, i64, i128);\n\n    rev!(try_from_unbounded, usize, u16);\n    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n    rev!(try_from_lower_bounded, usize, i8, i16);\n    rev!(try_from_both_bounded, usize, i32, i64, i128);\n\n    rev!(try_from_unbounded, isize, u8);\n    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n    rev!(try_from_unbounded, isize, i16);\n    rev!(try_from_both_bounded, isize, i32, i64, i128);\n}\n\n#[cfg(target_pointer_width = \"32\")]\nmod ptr_try_from_impls {\n    use super::TryFromIntError;\n    use convert::{Infallible, TryFrom};\n\n    try_from_upper_bounded!(usize, u8, u16);\n    try_from_unbounded!(usize, u32, u64, u128);\n    try_from_upper_bounded!(usize, i8, i16, i32);\n    try_from_unbounded!(usize, i64, i128);\n\n    try_from_both_bounded!(isize, u8, u16);\n    try_from_lower_bounded!(isize, u32, u64, u128);\n    try_from_both_bounded!(isize, i8, i16);\n    try_from_unbounded!(isize, i32, i64, i128);\n\n    rev!(try_from_unbounded, usize, u16, u32);\n    rev!(try_from_upper_bounded, usize, u64, u128);\n    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n    rev!(try_from_both_bounded, usize, i64, i128);\n\n    rev!(try_from_unbounded, isize, u8, u16);\n    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n    rev!(try_from_unbounded, isize, i16, i32);\n    rev!(try_from_both_bounded, isize, i64, i128);\n}\n\n#[cfg(target_pointer_width = \"64\")]\nmod ptr_try_from_impls {\n    use super::TryFromIntError;\n    use convert::{Infallible, TryFrom};\n\n    try_from_upper_bounded!(usize, u8, u16, u32);\n    try_from_unbounded!(usize, u64, u128);\n    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n    try_from_unbounded!(usize, i128);\n\n    try_from_both_bounded!(isize, u8, u16, u32);\n    try_from_lower_bounded!(isize, u64, u128);\n    try_from_both_bounded!(isize, i8, i16, i32);\n    try_from_unbounded!(isize, i64, i128);\n\n    rev!(try_from_unbounded, usize, u16, u32, u64);\n    rev!(try_from_upper_bounded, usize, u128);\n    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n    rev!(try_from_both_bounded, usize, i128);\n\n    rev!(try_from_unbounded, isize, u8, u16, u32);\n    rev!(try_from_upper_bounded, isize, u64, u128);\n    rev!(try_from_unbounded, isize, i16, i32, i64);\n    rev!(try_from_both_bounded, isize, i128);\n}\n\n#[doc(hidden)]\ntrait FromStrRadixHelper: PartialOrd + Copy {\n    fn min_value() -> Self;\n    fn max_value() -> Self;\n    fn from_u32(u: u32) -> Self;\n    fn checked_mul(&self, other: u32) -> Option<Self>;\n    fn checked_sub(&self, other: u32) -> Option<Self>;\n    fn checked_add(&self, other: u32) -> Option<Self>;\n}\n\nmacro_rules! doit {\n    ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n        #[inline]\n        fn min_value() -> Self { Self::min_value() }\n        #[inline]\n        fn max_value() -> Self { Self::max_value() }\n        #[inline]\n        fn from_u32(u: u32) -> Self { u as Self }\n        #[inline]\n        fn checked_mul(&self, other: u32) -> Option<Self> {\n            Self::checked_mul(*self, other as Self)\n        }\n        #[inline]\n        fn checked_sub(&self, other: u32) -> Option<Self> {\n            Self::checked_sub(*self, other as Self)\n        }\n        #[inline]\n        fn checked_add(&self, other: u32) -> Option<Self> {\n            Self::checked_add(*self, other as Self)\n        }\n    })*)\n}\ndoit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n\nfn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {\n    use self::IntErrorKind::*;\n    use self::ParseIntError as PIE;\n\n    assert!(radix >= 2 && radix <= 36,\n           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n           radix);\n\n    if src.is_empty() {\n        return Err(PIE { kind: Empty });\n    }\n\n    let is_signed_ty = T::from_u32(0) > T::min_value();\n\n    // all valid digits are ascii, so we will just iterate over the utf8 bytes\n    // and cast them to chars. .to_digit() will safely return None for anything\n    // other than a valid ascii digit for the given radix, including the first-byte\n    // of multi-byte sequences\n    let src = src.as_bytes();\n\n    let (is_positive, digits) = match src[0] {\n        b'+' => (true, &src[1..]),\n        b'-' if is_signed_ty => (false, &src[1..]),\n        _ => (true, src),\n    };\n\n    if digits.is_empty() {\n        return Err(PIE { kind: Empty });\n    }\n\n    let mut result = T::from_u32(0);\n    if is_positive {\n        // The number is positive\n        for &c in digits {\n            let x = match (c as char).to_digit(radix) {\n                Some(x) => x,\n                None => return Err(PIE { kind: InvalidDigit }),\n            };\n            result = match result.checked_mul(radix) {\n                Some(result) => result,\n                None => return Err(PIE { kind: Overflow }),\n            };\n            result = match result.checked_add(x) {\n                Some(result) => result,\n                None => return Err(PIE { kind: Overflow }),\n            };\n        }\n    } else {\n        // The number is negative\n        for &c in digits {\n            let x = match (c as char).to_digit(radix) {\n                Some(x) => x,\n                None => return Err(PIE { kind: InvalidDigit }),\n            };\n            result = match result.checked_mul(radix) {\n                Some(result) => result,\n                None => return Err(PIE { kind: Underflow }),\n            };\n            result = match result.checked_sub(x) {\n                Some(result) => result,\n                None => return Err(PIE { kind: Underflow }),\n            };\n        }\n    }\n    Ok(result)\n}\n\n/// An error which can be returned when parsing an integer.\n///\n/// This error is used as the error type for the `from_str_radix()` functions\n/// on the primitive integer types, such as [`i8::from_str_radix`].\n///\n/// [`i8::from_str_radix`]: ../../std/primitive.i8.html#method.from_str_radix\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ParseIntError {\n    kind: IntErrorKind,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nenum IntErrorKind {\n    Empty,\n    InvalidDigit,\n    Overflow,\n    Underflow,\n}\n\nimpl ParseIntError {\n    #[unstable(feature = \"int_error_internals\",\n               reason = \"available through Error trait and this method should \\\n                         not be exposed publicly\",\n               issue = \"0\")]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n        match self.kind {\n            IntErrorKind::Empty => \"cannot parse integer from empty string\",\n            IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n            IntErrorKind::Overflow => \"number too large to fit in target type\",\n            IntErrorKind::Underflow => \"number too small to fit in target type\",\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for ParseIntError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.__description().fmt(f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use num::dec2flt::ParseFloatError;\n\n// Conversion traits for primitive integer and float types\n// Conversions T -> T are covered by a blanket impl and therefore excluded\n// Some conversions from and to usize/isize are not implemented due to portability concerns\nmacro_rules! impl_from {\n    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n        #[$attr]\n        impl From<$Small> for $Large {\n            #[inline]\n            fn from(small: $Small) -> $Large {\n                small as $Large\n            }\n        }\n    }\n}\n\n// Unsigned -> Unsigned\nimpl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u32, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { u64, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n\n// Signed -> Signed\nimpl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i8, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i16, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i32, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { i64, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n\n// Unsigned -> Signed\nimpl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u32, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\nimpl_from! { u64, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n\n// Note: integers can only be represented with full precision in a float if\n// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n// Lossy float conversions are not implemented at this time.\n\n// Signed -> Float\nimpl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n\n// Unsigned -> Float\nimpl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n\n// Float -> Float\nimpl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n\nstatic ASCII_LOWERCASE_MAP: [u8; 256] = [\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n    b'@',\n\n          b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n    b'x', b'y', b'z',\n\n                      b'[', b'\\\\', b']', b'^', b'_',\n    b'`', b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n    b'x', b'y', b'z', b'{', b'|', b'}', b'~', 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n];\n\nstatic ASCII_UPPERCASE_MAP: [u8; 256] = [\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n    b'@', b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n    b'X', b'Y', b'Z', b'[', b'\\\\', b']', b'^', b'_',\n    b'`',\n\n          b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n    b'X', b'Y', b'Z',\n\n                      b'{', b'|', b'}', b'~', 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n];\n\nenum AsciiCharacterClass {\n    C,  // control\n    Cw, // control whitespace\n    W,  // whitespace\n    D,  // digit\n    L,  // lowercase\n    Lx, // lowercase hex digit\n    U,  // uppercase\n    Ux, // uppercase hex digit\n    P,  // punctuation\n}\nuse self::AsciiCharacterClass::*;\n\nstatic ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 128] = [\n//  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n    C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_\n    C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, // 1_\n    W, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, // 2_\n    D, D, D, D, D, D, D, D, D, D, P, P, P, P, P, P, // 3_\n    P, Ux,Ux,Ux,Ux,Ux,Ux,U, U, U, U, U, U, U, U, U, // 4_\n    U, U, U, U, U, U, U, U, U, U, U, P, P, P, P, P, // 5_\n    P, Lx,Lx,Lx,Lx,Lx,Lx,L, L, L, L, L, L, L, L, L, // 6_\n    L, L, L, L, L, L, L, L, L, L, L, P, P, P, P, C, // 7_\n];\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Functionality for ordering and comparison.\n//!\n//! This module defines both [`PartialOrd`] and [`PartialEq`] traits which are used\n//! by the compiler to implement comparison operators. Rust programs may\n//! implement [`PartialOrd`] to overload the `<`, `<=`, `>`, and `>=` operators,\n//! and may implement [`PartialEq`] to overload the `==` and `!=` operators.\n//!\n//! [`PartialOrd`]: trait.PartialOrd.html\n//! [`PartialEq`]: trait.PartialEq.html\n//!\n//! # Examples\n//!\n//! ```\n//! let x: u32 = 0;\n//! let y: u32 = 1;\n//!\n//! // these two lines are equivalent\n//! assert_eq!(x < y, true);\n//! assert_eq!(x.lt(&y), true);\n//!\n//! // these two lines are also equivalent\n//! assert_eq!(x == y, false);\n//! assert_eq!(x.eq(&y), false);\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse self::Ordering::*;\n\n/// Trait for equality comparisons which are [partial equivalence\n/// relations](http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n///\n/// This trait allows for partial equality, for types that do not have a full\n/// equivalence relation.  For example, in floating point numbers `NaN != NaN`,\n/// so floating point types implement `PartialEq` but not `Eq`.\n///\n/// Formally, the equality must be (for all `a`, `b` and `c`):\n///\n/// - symmetric: `a == b` implies `b == a`; and\n/// - transitive: `a == b` and `b == c` implies `a == c`.\n///\n/// Note that these requirements mean that the trait itself must be implemented\n/// symmetrically and transitively: if `T: PartialEq<U>` and `U: PartialEq<V>`\n/// then `U: PartialEq<T>` and `T: PartialEq<V>`.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d on structs, two\n/// instances are equal if all fields are equal, and not equal if any fields\n/// are not equal. When `derive`d on enums, each variant is equal to itself\n/// and not equal to the other variants.\n///\n/// ## How can I implement `PartialEq`?\n///\n/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n/// in terms of it by default. Any manual implementation of `ne` *must* respect\n/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n/// only if `a != b`.\n///\n/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with\n/// each other. It's easy to accidentally make them disagree by deriving some\n/// of the traits and manually implementing others.\n///\n/// An example implementation for a domain in which two books are considered\n/// the same book if their ISBN matches, even if the formats differ:\n///\n/// ```\n/// enum BookFormat { Paperback, Hardback, Ebook }\n/// struct Book {\n///     isbn: i32,\n///     format: BookFormat,\n/// }\n///\n/// impl PartialEq for Book {\n///     fn eq(&self, other: &Book) -> bool {\n///         self.isbn == other.isbn\n///     }\n/// }\n///\n/// let b1 = Book { isbn: 3, format: BookFormat::Paperback };\n/// let b2 = Book { isbn: 3, format: BookFormat::Ebook };\n/// let b3 = Book { isbn: 10, format: BookFormat::Paperback };\n///\n/// assert!(b1 == b2);\n/// assert!(b1 != b3);\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// let x: u32 = 0;\n/// let y: u32 = 1;\n///\n/// assert_eq!(x == y, false);\n/// assert_eq!(x.eq(&y), false);\n/// ```\n#[lang = \"eq\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"can't compare `{Self}` with `{Rhs}`\"]\npub trait PartialEq<Rhs: ?Sized = Self> {\n    /// This method tests for `self` and `other` values to be equal, and is used\n    /// by `==`.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn eq(&self, other: &Rhs) -> bool;\n\n    /// This method tests for `!=`.\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }\n}\n\n/// Trait for equality comparisons which are [equivalence relations](\n/// https://en.wikipedia.org/wiki/Equivalence_relation).\n///\n/// This means, that in addition to `a == b` and `a != b` being strict inverses, the equality must\n/// be (for all `a`, `b` and `c`):\n///\n/// - reflexive: `a == a`;\n/// - symmetric: `a == b` implies `b == a`; and\n/// - transitive: `a == b` and `b == c` implies `a == c`.\n///\n/// This property cannot be checked by the compiler, and therefore `Eq` implies\n/// `PartialEq`, and has no extra methods.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d, because `Eq` has\n/// no extra methods, it is only informing the compiler that this is an\n/// equivalence relation rather than a partial equivalence relation. Note that\n/// the `derive` strategy requires all fields are `Eq`, which isn't\n/// always desired.\n///\n/// ## How can I implement `Eq`?\n///\n/// If you cannot use the `derive` strategy, specify that your type implements\n/// `Eq`, which has no methods:\n///\n/// ```\n/// enum BookFormat { Paperback, Hardback, Ebook }\n/// struct Book {\n///     isbn: i32,\n///     format: BookFormat,\n/// }\n/// impl PartialEq for Book {\n///     fn eq(&self, other: &Book) -> bool {\n///         self.isbn == other.isbn\n///     }\n/// }\n/// impl Eq for Book {}\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Eq: PartialEq<Self> {\n    // this method is used solely by #[deriving] to assert\n    // that every component of a type implements #[deriving]\n    // itself, the current deriving infrastructure means doing this\n    // assertion without using a method on this trait is nearly\n    // impossible.\n    //\n    // This should never be implemented by hand.\n    #[doc(hidden)]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn assert_receiver_is_total_eq(&self) {}\n}\n\n// FIXME: this struct is used solely by #[derive] to\n// assert that every component of a type implements Eq.\n//\n// This struct should never appear in user code.\n#[doc(hidden)]\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"derive_eq\",\n           reason = \"deriving hack, should not be public\",\n           issue = \"0\")]\npub struct AssertParamIsEq<T: Eq + ?Sized> { _field: ::marker::PhantomData<T> }\n\n/// An `Ordering` is the result of a comparison between two values.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// let result = 1.cmp(&2);\n/// assert_eq!(Ordering::Less, result);\n///\n/// let result = 1.cmp(&1);\n/// assert_eq!(Ordering::Equal, result);\n///\n/// let result = 2.cmp(&1);\n/// assert_eq!(Ordering::Greater, result);\n/// ```\n#[derive(Clone, Copy, PartialEq, Debug, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Ordering {\n    /// An ordering where a compared value is less [than another].\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Less = -1,\n    /// An ordering where a compared value is equal [to another].\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Equal = 0,\n    /// An ordering where a compared value is greater [than another].\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Greater = 1,\n}\n\nimpl Ordering {\n    /// Reverses the `Ordering`.\n    ///\n    /// * `Less` becomes `Greater`.\n    /// * `Greater` becomes `Less`.\n    /// * `Equal` becomes `Equal`.\n    ///\n    /// # Examples\n    ///\n    /// Basic behavior:\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(Ordering::Less.reverse(), Ordering::Greater);\n    /// assert_eq!(Ordering::Equal.reverse(), Ordering::Equal);\n    /// assert_eq!(Ordering::Greater.reverse(), Ordering::Less);\n    /// ```\n    ///\n    /// This method can be used to reverse a comparison:\n    ///\n    /// ```\n    /// let mut data: &mut [_] = &mut [2, 10, 5, 8];\n    ///\n    /// // sort the array from largest to smallest.\n    /// data.sort_by(|a, b| a.cmp(b).reverse());\n    ///\n    /// let b: &mut [_] = &mut [10, 8, 5, 2];\n    /// assert!(data == b);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reverse(self) -> Ordering {\n        match self {\n            Less => Greater,\n            Equal => Equal,\n            Greater => Less,\n        }\n    }\n\n    /// Chains two orderings.\n    ///\n    /// Returns `self` when it's not `Equal`. Otherwise returns `other`.\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// let result = Ordering::Equal.then(Ordering::Less);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then(Ordering::Equal);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then(Ordering::Greater);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Equal.then(Ordering::Equal);\n    /// assert_eq!(result, Ordering::Equal);\n    ///\n    /// let x: (i64, i64, i64) = (1, 2, 7);\n    /// let y: (i64, i64, i64) = (1, 5, 3);\n    /// let result = x.0.cmp(&y.0).then(x.1.cmp(&y.1)).then(x.2.cmp(&y.2));\n    ///\n    /// assert_eq!(result, Ordering::Less);\n    /// ```\n    #[inline]\n    #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n    pub fn then(self, other: Ordering) -> Ordering {\n        match self {\n            Equal => other,\n            _ => self,\n        }\n    }\n\n    /// Chains the ordering with the given function.\n    ///\n    /// Returns `self` when it's not `Equal`. Otherwise calls `f` and returns\n    /// the result.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// let result = Ordering::Equal.then_with(|| Ordering::Less);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then_with(|| Ordering::Equal);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then_with(|| Ordering::Greater);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Equal.then_with(|| Ordering::Equal);\n    /// assert_eq!(result, Ordering::Equal);\n    ///\n    /// let x: (i64, i64, i64) = (1, 2, 7);\n    /// let y: (i64, i64, i64)  = (1, 5, 3);\n    /// let result = x.0.cmp(&y.0).then_with(|| x.1.cmp(&y.1)).then_with(|| x.2.cmp(&y.2));\n    ///\n    /// assert_eq!(result, Ordering::Less);\n    /// ```\n    #[inline]\n    #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n    pub fn then_with<F: FnOnce() -> Ordering>(self, f: F) -> Ordering {\n        match self {\n            Equal => f(),\n            _ => self,\n        }\n    }\n}\n\n/// A helper struct for reverse ordering.\n///\n/// This struct is a helper to be used with functions like `Vec::sort_by_key` and\n/// can be used to reverse order a part of a key.\n///\n/// Example usage:\n///\n/// ```\n/// use std::cmp::Reverse;\n///\n/// let mut v = vec![1, 2, 3, 4, 5, 6];\n/// v.sort_by_key(|&num| (num > 3, Reverse(num)));\n/// assert_eq!(v, vec![3, 2, 1, 6, 5, 4]);\n/// ```\n#[derive(PartialEq, Eq, Debug)]\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\npub struct Reverse<T>(#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")] pub T);\n\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool { other.0 < self.0 }\n    #[inline]\n    fn le(&self, other: &Self) -> bool { other.0 <= self.0 }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool { other.0 >= self.0 }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool { other.0 > self.0 }\n}\n\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n/// Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).\n///\n/// An order is a total order if it is (for all `a`, `b` and `c`):\n///\n/// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and\n/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n/// lexicographic ordering based on the top-to-bottom declaration order of the struct's members.\n/// When `derive`d on enums, variants are ordered by their top-to-bottom declaration order.\n///\n/// ## How can I implement `Ord`?\n///\n/// `Ord` requires that the type also be `PartialOrd` and `Eq` (which requires `PartialEq`).\n///\n/// Then you must define an implementation for `cmp()`. You may find it useful to use\n/// `cmp()` on your type's fields.\n///\n/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n/// easy to accidentally make them disagree by deriving some of the traits and manually\n/// implementing others.\n///\n/// Here's an example where you want to sort people by height only, disregarding `id`\n/// and `name`:\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// #[derive(Eq)]\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     height: u32,\n/// }\n///\n/// impl Ord for Person {\n///     fn cmp(&self, other: &Person) -> Ordering {\n///         self.height.cmp(&other.height)\n///     }\n/// }\n///\n/// impl PartialOrd for Person {\n///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n///         Some(self.cmp(other))\n///     }\n/// }\n///\n/// impl PartialEq for Person {\n///     fn eq(&self, other: &Person) -> bool {\n///         self.height == other.height\n///     }\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Ord: Eq + PartialOrd<Self> {\n    /// This method returns an `Ordering` between `self` and `other`.\n    ///\n    /// By convention, `self.cmp(&other)` returns the ordering matching the expression\n    /// `self <operator> other` if true.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(5.cmp(&10), Ordering::Less);\n    /// assert_eq!(10.cmp(&5), Ordering::Greater);\n    /// assert_eq!(5.cmp(&5), Ordering::Equal);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn cmp(&self, other: &Self) -> Ordering;\n\n    /// Compares and returns the maximum of two values.\n    ///\n    /// Returns the second argument if the comparison determines them to be equal.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(2, 1.max(2));\n    /// assert_eq!(2, 2.max(2));\n    /// ```\n    #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n    fn max(self, other: Self) -> Self\n    where Self: Sized {\n        if other >= self { other } else { self }\n    }\n\n    /// Compares and returns the minimum of two values.\n    ///\n    /// Returns the first argument if the comparison determines them to be equal.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(1, 1.min(2));\n    /// assert_eq!(2, 2.min(2));\n    /// ```\n    #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n    fn min(self, other: Self) -> Self\n    where Self: Sized {\n        if self <= other { self } else { other }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for Ordering {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for Ordering {\n    #[inline]\n    fn cmp(&self, other: &Ordering) -> Ordering {\n        (*self as i32).cmp(&(*other as i32))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for Ordering {\n    #[inline]\n    fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n        (*self as i32).partial_cmp(&(*other as i32))\n    }\n}\n\n/// Trait for values that can be compared for a sort-order.\n///\n/// The comparison must satisfy, for all `a`, `b` and `c`:\n///\n/// - antisymmetry: if `a < b` then `!(a > b)`, as well as `a > b` implying `!(a < b)`; and\n/// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n///\n/// Note that these requirements mean that the trait itself must be implemented symmetrically and\n/// transitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n/// PartialOrd<V>`.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n/// lexicographic ordering based on the top-to-bottom declaration order of the struct's members.\n/// When `derive`d on enums, variants are ordered by their top-to-bottom declaration order.\n///\n/// ## How can I implement `PartialOrd`?\n///\n/// `PartialOrd` only requires implementation of the `partial_cmp` method, with the others\n/// generated from default implementations.\n///\n/// However it remains possible to implement the others separately for types which do not have a\n/// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n/// false` (cf. IEEE 754-2008 section 5.11).\n///\n/// `PartialOrd` requires your type to be `PartialEq`.\n///\n/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n/// easy to accidentally make them disagree by deriving some of the traits and manually\n/// implementing others.\n///\n/// If your type is `Ord`, you can implement `partial_cmp()` by using `cmp()`:\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// #[derive(Eq)]\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     height: u32,\n/// }\n///\n/// impl PartialOrd for Person {\n///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n///         Some(self.cmp(other))\n///     }\n/// }\n///\n/// impl Ord for Person {\n///     fn cmp(&self, other: &Person) -> Ordering {\n///         self.height.cmp(&other.height)\n///     }\n/// }\n///\n/// impl PartialEq for Person {\n///     fn eq(&self, other: &Person) -> bool {\n///         self.height == other.height\n///     }\n/// }\n/// ```\n///\n/// You may also find it useful to use `partial_cmp()` on your type's fields. Here\n/// is an example of `Person` types who have a floating-point `height` field that\n/// is the only field to be used for sorting:\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     height: f64,\n/// }\n///\n/// impl PartialOrd for Person {\n///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n///         self.height.partial_cmp(&other.height)\n///     }\n/// }\n///\n/// impl PartialEq for Person {\n///     fn eq(&self, other: &Person) -> bool {\n///         self.height == other.height\n///     }\n/// }\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// let x : u32 = 0;\n/// let y : u32 = 1;\n///\n/// assert_eq!(x < y, true);\n/// assert_eq!(x.lt(&y), true);\n/// ```\n#[lang = \"ord\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"can't compare `{Self}` with `{Rhs}`\"]\npub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n    /// This method returns an ordering between `self` and `other` values if one exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// let result = 1.0.partial_cmp(&2.0);\n    /// assert_eq!(result, Some(Ordering::Less));\n    ///\n    /// let result = 1.0.partial_cmp(&1.0);\n    /// assert_eq!(result, Some(Ordering::Equal));\n    ///\n    /// let result = 2.0.partial_cmp(&1.0);\n    /// assert_eq!(result, Some(Ordering::Greater));\n    /// ```\n    ///\n    /// When comparison is impossible:\n    ///\n    /// ```\n    /// let result = std::f64::NAN.partial_cmp(&1.0);\n    /// assert_eq!(result, None);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n\n    /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 1.0 < 2.0;\n    /// assert_eq!(result, true);\n    ///\n    /// let result = 2.0 < 1.0;\n    /// assert_eq!(result, false);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn lt(&self, other: &Rhs) -> bool {\n        match self.partial_cmp(other) {\n            Some(Less) => true,\n            _ => false,\n        }\n    }\n\n    /// This method tests less than or equal to (for `self` and `other`) and is used by the `<=`\n    /// operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 1.0 <= 2.0;\n    /// assert_eq!(result, true);\n    ///\n    /// let result = 2.0 <= 2.0;\n    /// assert_eq!(result, true);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn le(&self, other: &Rhs) -> bool {\n        match self.partial_cmp(other) {\n            Some(Less) | Some(Equal) => true,\n            _ => false,\n        }\n    }\n\n    /// This method tests greater than (for `self` and `other`) and is used by the `>` operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 1.0 > 2.0;\n    /// assert_eq!(result, false);\n    ///\n    /// let result = 2.0 > 2.0;\n    /// assert_eq!(result, false);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn gt(&self, other: &Rhs) -> bool {\n        match self.partial_cmp(other) {\n            Some(Greater) => true,\n            _ => false,\n        }\n    }\n\n    /// This method tests greater than or equal to (for `self` and `other`) and is used by the `>=`\n    /// operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 2.0 >= 1.0;\n    /// assert_eq!(result, true);\n    ///\n    /// let result = 2.0 >= 2.0;\n    /// assert_eq!(result, true);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn ge(&self, other: &Rhs) -> bool {\n        match self.partial_cmp(other) {\n            Some(Greater) | Some(Equal) => true,\n            _ => false,\n        }\n    }\n}\n\n/// Compares and returns the minimum of two values.\n///\n/// Returns the first argument if the comparison determines them to be equal.\n///\n/// Internally uses an alias to `Ord::min`.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp;\n///\n/// assert_eq!(1, cmp::min(1, 2));\n/// assert_eq!(2, cmp::min(2, 2));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn min<T: Ord>(v1: T, v2: T) -> T {\n    v1.min(v2)\n}\n\n/// Compares and returns the maximum of two values.\n///\n/// Returns the second argument if the comparison determines them to be equal.\n///\n/// Internally uses an alias to `Ord::max`.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp;\n///\n/// assert_eq!(2, cmp::max(1, 2));\n/// assert_eq!(2, cmp::max(2, 2));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn max<T: Ord>(v1: T, v2: T) -> T {\n    v1.max(v2)\n}\n\n// Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types\nmod impls {\n    use cmp::Ordering::{self, Less, Greater, Equal};\n\n    macro_rules! partial_eq_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialEq for $t {\n                #[inline]\n                fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n                #[inline]\n                fn ne(&self, other: &$t) -> bool { (*self) != (*other) }\n            }\n        )*)\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialEq for () {\n        #[inline]\n        fn eq(&self, _other: &()) -> bool { true }\n        #[inline]\n        fn ne(&self, _other: &()) -> bool { false }\n    }\n\n    partial_eq_impl! {\n        bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64\n    }\n\n    macro_rules! eq_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Eq for $t {}\n        )*)\n    }\n\n    eq_impl! { () bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n    macro_rules! partial_ord_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialOrd for $t {\n                #[inline]\n                fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n                    match (self <= other, self >= other) {\n                        (false, false) => None,\n                        (false, true) => Some(Greater),\n                        (true, false) => Some(Less),\n                        (true, true) => Some(Equal),\n                    }\n                }\n                #[inline]\n                fn lt(&self, other: &$t) -> bool { (*self) < (*other) }\n                #[inline]\n                fn le(&self, other: &$t) -> bool { (*self) <= (*other) }\n                #[inline]\n                fn ge(&self, other: &$t) -> bool { (*self) >= (*other) }\n                #[inline]\n                fn gt(&self, other: &$t) -> bool { (*self) > (*other) }\n            }\n        )*)\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialOrd for () {\n        #[inline]\n        fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n            Some(Equal)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialOrd for bool {\n        #[inline]\n        fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n            (*self as u8).partial_cmp(&(*other as u8))\n        }\n    }\n\n    partial_ord_impl! { f32 f64 }\n\n    macro_rules! ord_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialOrd for $t {\n                #[inline]\n                fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n                    Some(self.cmp(other))\n                }\n                #[inline]\n                fn lt(&self, other: &$t) -> bool { (*self) < (*other) }\n                #[inline]\n                fn le(&self, other: &$t) -> bool { (*self) <= (*other) }\n                #[inline]\n                fn ge(&self, other: &$t) -> bool { (*self) >= (*other) }\n                #[inline]\n                fn gt(&self, other: &$t) -> bool { (*self) > (*other) }\n            }\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Ord for $t {\n                #[inline]\n                fn cmp(&self, other: &$t) -> Ordering {\n                    if *self == *other { Equal }\n                    else if *self < *other { Less }\n                    else { Greater }\n                }\n            }\n        )*)\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Ord for () {\n        #[inline]\n        fn cmp(&self, _other: &()) -> Ordering { Equal }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Ord for bool {\n        #[inline]\n        fn cmp(&self, other: &bool) -> Ordering {\n            (*self as u8).cmp(&(*other as u8))\n        }\n    }\n\n    ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl PartialEq for ! {\n        fn eq(&self, _: &!) -> bool {\n            *self\n        }\n    }\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl Eq for ! {}\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl PartialOrd for ! {\n        fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n            *self\n        }\n    }\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl Ord for ! {\n        fn cmp(&self, _: &!) -> Ordering {\n            *self\n        }\n    }\n\n    // & pointers\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n        #[inline]\n        fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n        #[inline]\n        fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n        #[inline]\n        fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n            PartialOrd::partial_cmp(*self, *other)\n        }\n        #[inline]\n        fn lt(&self, other: & &'b B) -> bool { PartialOrd::lt(*self, *other) }\n        #[inline]\n        fn le(&self, other: & &'b B) -> bool { PartialOrd::le(*self, *other) }\n        #[inline]\n        fn ge(&self, other: & &'b B) -> bool { PartialOrd::ge(*self, *other) }\n        #[inline]\n        fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, A: ?Sized> Ord for &'a A where A: Ord {\n        #[inline]\n        fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, A: ?Sized> Eq for &'a A where A: Eq {}\n\n    // &mut pointers\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n        #[inline]\n        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n        #[inline]\n        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n        #[inline]\n        fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n            PartialOrd::partial_cmp(*self, *other)\n        }\n        #[inline]\n        fn lt(&self, other: &&'b mut B) -> bool { PartialOrd::lt(*self, *other) }\n        #[inline]\n        fn le(&self, other: &&'b mut B) -> bool { PartialOrd::le(*self, *other) }\n        #[inline]\n        fn ge(&self, other: &&'b mut B) -> bool { PartialOrd::ge(*self, *other) }\n        #[inline]\n        fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, A: ?Sized> Ord for &'a mut A where A: Ord {\n        #[inline]\n        fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, A: ?Sized> Eq for &'a mut A where A: Eq {}\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n        #[inline]\n        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n        #[inline]\n        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n        #[inline]\n        fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }\n        #[inline]\n        fn ne(&self, other: &&'b B) -> bool { PartialEq::ne(*self, *other) }\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n// FIXME: talk about offset, copy_memory, copy_nonoverlapping_memory\n\n//! Raw, unsafe pointers, `*const T`, and `*mut T`.\n//!\n//! *[See also the pointer primitive types](../../std/primitive.pointer.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse convert::From;\nuse intrinsics;\nuse ops::CoerceUnsized;\nuse fmt;\nuse hash;\nuse marker::{PhantomData, Unsize};\nuse mem;\nuse nonzero::NonZero;\n\nuse cmp::Ordering::{self, Less, Equal, Greater};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use intrinsics::copy_nonoverlapping;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use intrinsics::copy;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use intrinsics::write_bytes;\n\n/// Executes the destructor (if any) of the pointed-to value.\n///\n/// This has two use cases:\n///\n/// * It is *required* to use `drop_in_place` to drop unsized types like\n///   trait objects, because they can't be read out onto the stack and\n///   dropped normally.\n///\n/// * It is friendlier to the optimizer to do this over `ptr::read` when\n///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n///   as the compiler doesn't need to prove that it's sound to elide the\n///   copy.\n///\n/// # Safety\n///\n/// This has all the same safety problems as `ptr::read` with respect to\n/// invalid pointers, types, and double drops.\n#[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n#[lang = \"drop_in_place\"]\n#[allow(unconditional_recursion)]\npub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n    // Code here does not matter - this is replaced by the\n    // real drop glue by the compiler.\n    drop_in_place(to_drop);\n}\n\n/// Creates a null raw pointer.\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let p: *const i32 = ptr::null();\n/// assert!(p.is_null());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const fn null<T>() -> *const T { 0 as *const T }\n\n/// Creates a null mutable raw pointer.\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let p: *mut i32 = ptr::null_mut();\n/// assert!(p.is_null());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n\n/// Swaps the values at two mutable locations of the same type, without\n/// deinitializing either.\n///\n/// The values pointed at by `x` and `y` may overlap, unlike `mem::swap` which\n/// is otherwise equivalent. If the values do overlap, then the overlapping\n/// region of memory from `x` will be used. This is demonstrated in the\n/// examples section below.\n///\n/// # Safety\n///\n/// This function copies the memory through the raw pointers passed to it\n/// as arguments.\n///\n/// Ensure that these pointers are valid before calling `swap`.\n///\n/// # Examples\n///\n/// Swapping two non-overlapping regions:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut array = [0, 1, 2, 3];\n///\n/// let x = array[0..].as_mut_ptr() as *mut [u32; 2];\n/// let y = array[2..].as_mut_ptr() as *mut [u32; 2];\n///\n/// unsafe {\n///     ptr::swap(x, y);\n///     assert_eq!([2, 3, 0, 1], array);\n/// }\n/// ```\n///\n/// Swapping two overlapping regions:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut array = [0, 1, 2, 3];\n///\n/// let x = array[0..].as_mut_ptr() as *mut [u32; 3];\n/// let y = array[1..].as_mut_ptr() as *mut [u32; 3];\n///\n/// unsafe {\n///     ptr::swap(x, y);\n///     assert_eq!([1, 0, 1, 2], array);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n    // Give ourselves some scratch space to work with\n    let mut tmp: T = mem::uninitialized();\n\n    // Perform the swap\n    copy_nonoverlapping(x, &mut tmp, 1);\n    copy(y, x, 1); // `x` and `y` may overlap\n    copy_nonoverlapping(&tmp, y, 1);\n\n    // y and t now point to the same thing, but we need to completely forget `tmp`\n    // because it's no longer relevant.\n    mem::forget(tmp);\n}\n\n/// Swaps a sequence of values at two mutable locations of the same type.\n///\n/// # Safety\n///\n/// The two arguments must each point to the beginning of `count` locations\n/// of valid memory, and the two memory ranges must not overlap.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// #![feature(swap_nonoverlapping)]\n///\n/// use std::ptr;\n///\n/// let mut x = [1, 2, 3, 4];\n/// let mut y = [7, 8, 9];\n///\n/// unsafe {\n///     ptr::swap_nonoverlapping(x.as_mut_ptr(), y.as_mut_ptr(), 2);\n/// }\n///\n/// assert_eq!(x, [7, 8, 3, 4]);\n/// assert_eq!(y, [1, 2, 9]);\n/// ```\n#[inline]\n#[unstable(feature = \"swap_nonoverlapping\", issue = \"42818\")]\npub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n    let x = x as *mut u8;\n    let y = y as *mut u8;\n    let len = mem::size_of::<T>() * count;\n    swap_nonoverlapping_bytes(x, y, len)\n}\n\n#[inline]\nunsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n    // The approach here is to utilize simd to swap x & y efficiently. Testing reveals\n    // that swapping either 32 bytes or 64 bytes at a time is most efficient for intel\n    // Haswell E processors. LLVM is more able to optimize if we give a struct a\n    // #[repr(simd)], even if we don't actually use this struct directly.\n    //\n    // FIXME repr(simd) broken on emscripten and redox\n    // It's also broken on big-endian powerpc64 and s390x.  #42778\n    #[cfg_attr(not(any(target_os = \"emscripten\", target_os = \"redox\",\n                       target_endian = \"big\")),\n               repr(simd))]\n    struct Block(u64, u64, u64, u64);\n    struct UnalignedBlock(u64, u64, u64, u64);\n\n    let block_size = mem::size_of::<Block>();\n\n    // Loop through x & y, copying them `Block` at a time\n    // The optimizer should unroll the loop fully for most types\n    // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively\n    let mut i = 0;\n    while i + block_size <= len {\n        // Create some uninitialized memory as scratch space\n        // Declaring `t` here avoids aligning the stack when this loop is unused\n        let mut t: Block = mem::uninitialized();\n        let t = &mut t as *mut _ as *mut u8;\n        let x = x.offset(i as isize);\n        let y = y.offset(i as isize);\n\n        // Swap a block of bytes of x & y, using t as a temporary buffer\n        // This should be optimized into efficient SIMD operations where available\n        copy_nonoverlapping(x, t, block_size);\n        copy_nonoverlapping(y, x, block_size);\n        copy_nonoverlapping(t, y, block_size);\n        i += block_size;\n    }\n\n    if i < len {\n        // Swap any remaining bytes\n        let mut t: UnalignedBlock = mem::uninitialized();\n        let rem = len - i;\n\n        let t = &mut t as *mut _ as *mut u8;\n        let x = x.offset(i as isize);\n        let y = y.offset(i as isize);\n\n        copy_nonoverlapping(x, t, rem);\n        copy_nonoverlapping(y, x, rem);\n        copy_nonoverlapping(t, y, rem);\n    }\n}\n\n/// Replaces the value at `dest` with `src`, returning the old\n/// value, without dropping either.\n///\n/// # Safety\n///\n/// This is only unsafe because it accepts a raw pointer.\n/// Otherwise, this operation is identical to `mem::replace`.\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n    mem::swap(&mut *dest, &mut src); // cannot overlap\n    src\n}\n\n/// Reads the value from `src` without moving it. This leaves the\n/// memory in `src` unchanged.\n///\n/// # Safety\n///\n/// Beyond accepting a raw pointer, this is unsafe because it semantically\n/// moves the value out of `src` without preventing further usage of `src`.\n/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n/// `src` is not used before the data is overwritten again (e.g. with `write`,\n/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n/// because it will attempt to drop the value previously at `*src`.\n///\n/// The pointer must be aligned; use `read_unaligned` if that is not the case.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let x = 12;\n/// let y = &x as *const i32;\n///\n/// unsafe {\n///     assert_eq!(std::ptr::read(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn read<T>(src: *const T) -> T {\n    let mut tmp: T = mem::uninitialized();\n    copy_nonoverlapping(src, &mut tmp, 1);\n    tmp\n}\n\n/// Reads the value from `src` without moving it. This leaves the\n/// memory in `src` unchanged.\n///\n/// Unlike `read`, the pointer may be unaligned.\n///\n/// # Safety\n///\n/// Beyond accepting a raw pointer, this is unsafe because it semantically\n/// moves the value out of `src` without preventing further usage of `src`.\n/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n/// `src` is not used before the data is overwritten again (e.g. with `write`,\n/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n/// because it will attempt to drop the value previously at `*src`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let x = 12;\n/// let y = &x as *const i32;\n///\n/// unsafe {\n///     assert_eq!(std::ptr::read_unaligned(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\npub unsafe fn read_unaligned<T>(src: *const T) -> T {\n    let mut tmp: T = mem::uninitialized();\n    copy_nonoverlapping(src as *const u8,\n                        &mut tmp as *mut T as *mut u8,\n                        mem::size_of::<T>());\n    tmp\n}\n\n/// Overwrites a memory location with the given value without reading or\n/// dropping the old value.\n///\n/// # Safety\n///\n/// This operation is marked unsafe because it accepts a raw pointer.\n///\n/// It does not drop the contents of `dst`. This is safe, but it could leak\n/// allocations or resources, so care must be taken not to overwrite an object\n/// that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// This is appropriate for initializing uninitialized memory, or overwriting\n/// memory that has previously been `read` from.\n///\n/// The pointer must be aligned; use `write_unaligned` if that is not the case.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let mut x = 0;\n/// let y = &mut x as *mut i32;\n/// let z = 12;\n///\n/// unsafe {\n///     std::ptr::write(y, z);\n///     assert_eq!(std::ptr::read(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn write<T>(dst: *mut T, src: T) {\n    intrinsics::move_val_init(&mut *dst, src)\n}\n\n/// Overwrites a memory location with the given value without reading or\n/// dropping the old value.\n///\n/// Unlike `write`, the pointer may be unaligned.\n///\n/// # Safety\n///\n/// This operation is marked unsafe because it accepts a raw pointer.\n///\n/// It does not drop the contents of `dst`. This is safe, but it could leak\n/// allocations or resources, so care must be taken not to overwrite an object\n/// that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// This is appropriate for initializing uninitialized memory, or overwriting\n/// memory that has previously been `read` from.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let mut x = 0;\n/// let y = &mut x as *mut i32;\n/// let z = 12;\n///\n/// unsafe {\n///     std::ptr::write_unaligned(y, z);\n///     assert_eq!(std::ptr::read_unaligned(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\npub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n    copy_nonoverlapping(&src as *const T as *const u8,\n                        dst as *mut u8,\n                        mem::size_of::<T>());\n    mem::forget(src);\n}\n\n/// Performs a volatile read of the value from `src` without moving it. This\n/// leaves the memory in `src` unchanged.\n///\n/// Volatile operations are intended to act on I/O memory, and are guaranteed\n/// to not be elided or reordered by the compiler across other volatile\n/// operations.\n///\n/// # Notes\n///\n/// Rust does not currently have a rigorously and formally defined memory model,\n/// so the precise semantics of what \"volatile\" means here is subject to change\n/// over time. That being said, the semantics will almost always end up pretty\n/// similar to [C11's definition of volatile][c11].\n///\n/// The compiler shouldn't change the relative order or number of volatile\n/// memory operations. However, volatile memory operations on zero-sized types\n/// (e.g. if a zero-sized type is passed to `read_volatile`) are no-ops\n/// and may be ignored.\n///\n/// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n///\n/// # Safety\n///\n/// Beyond accepting a raw pointer, this is unsafe because it semantically\n/// moves the value out of `src` without preventing further usage of `src`.\n/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n/// `src` is not used before the data is overwritten again (e.g. with `write`,\n/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n/// because it will attempt to drop the value previously at `*src`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let x = 12;\n/// let y = &x as *const i32;\n///\n/// unsafe {\n///     assert_eq!(std::ptr::read_volatile(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"volatile\", since = \"1.9.0\")]\npub unsafe fn read_volatile<T>(src: *const T) -> T {\n    intrinsics::volatile_load(src)\n}\n\n/// Performs a volatile write of a memory location with the given value without\n/// reading or dropping the old value.\n///\n/// Volatile operations are intended to act on I/O memory, and are guaranteed\n/// to not be elided or reordered by the compiler across other volatile\n/// operations.\n///\n/// # Notes\n///\n/// Rust does not currently have a rigorously and formally defined memory model,\n/// so the precise semantics of what \"volatile\" means here is subject to change\n/// over time. That being said, the semantics will almost always end up pretty\n/// similar to [C11's definition of volatile][c11].\n///\n/// The compiler shouldn't change the relative order or number of volatile\n/// memory operations. However, volatile memory operations on zero-sized types\n/// (e.g. if a zero-sized type is passed to `write_volatile`) are no-ops\n/// and may be ignored.\n///\n/// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n///\n/// # Safety\n///\n/// This operation is marked unsafe because it accepts a raw pointer.\n///\n/// It does not drop the contents of `dst`. This is safe, but it could leak\n/// allocations or resources, so care must be taken not to overwrite an object\n/// that should be dropped.\n///\n/// This is appropriate for initializing uninitialized memory, or overwriting\n/// memory that has previously been `read` from.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let mut x = 0;\n/// let y = &mut x as *mut i32;\n/// let z = 12;\n///\n/// unsafe {\n///     std::ptr::write_volatile(y, z);\n///     assert_eq!(std::ptr::read_volatile(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"volatile\", since = \"1.9.0\")]\npub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n    intrinsics::volatile_store(dst, src);\n}\n\n#[lang = \"const_ptr\"]\nimpl<T: ?Sized> *const T {\n    /// Returns `true` if the pointer is null.\n    ///\n    /// Note that unsized types have many possible null pointers, as only the\n    /// raw data pointer is considered, not their length, vtable, etc.\n    /// Therefore, two pointers that are null may still not compare equal to\n    /// each other.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s: &str = \"Follow the rabbit\";\n    /// let ptr: *const u8 = s.as_ptr();\n    /// assert!(!ptr.is_null());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_null(self) -> bool {\n        // Compare via a cast to a thin pointer, so fat pointers are only\n        // considering their \"data\" part for null-ness.\n        (self as *const u8) == null()\n    }\n\n    /// Returns `None` if the pointer is null, or else returns a reference to\n    /// the value wrapped in `Some`.\n    ///\n    /// # Safety\n    ///\n    /// While this method and its mutable counterpart are useful for\n    /// null-safety, it is important to note that this is still an unsafe\n    /// operation because the returned value could be pointing to invalid\n    /// memory.\n    ///\n    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n    /// not necessarily reflect the actual lifetime of the data.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let ptr: *const u8 = &10u8 as *const u8;\n    ///\n    /// unsafe {\n    ///     if let Some(val_back) = ptr.as_ref() {\n    ///         println!(\"We got back the value: {}!\", val_back);\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n    #[inline]\n    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n        if self.is_null() {\n            None\n        } else {\n            Some(&*self)\n        }\n    }\n\n    /// Calculates the offset from a pointer.\n    ///\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and resulting pointer must be either in bounds or one\n    ///   byte past the end of an allocated object.\n    ///\n    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n    ///\n    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n    ///   space. That is, the infinite-precision sum, **in bytes** must fit in a usize.\n    ///\n    /// The compiler and standard library generally tries to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `vec.as_ptr().offset(vec.len() as isize)` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using `wrapping_offset` instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s: &str = \"123\";\n    /// let ptr: *const u8 = s.as_ptr();\n    ///\n    /// unsafe {\n    ///     println!(\"{}\", *ptr.offset(1) as char);\n    ///     println!(\"{}\", *ptr.offset(2) as char);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn offset(self, count: isize) -> *const T where T: Sized {\n        intrinsics::offset(self, count)\n    }\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    ///\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// Always use `.offset(count)` instead when possible, because `offset`\n    /// allows the compiler to optimize better.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // Iterate using a raw pointer in increments of two elements\n    /// let data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *const u8 = data.as_ptr();\n    /// let step = 2;\n    /// let end_rounded_up = ptr.wrapping_offset(6);\n    ///\n    /// // This loop prints \"1, 3, 5, \"\n    /// while ptr != end_rounded_up {\n    ///     unsafe {\n    ///         print!(\"{}, \", *ptr);\n    ///     }\n    ///     ptr = ptr.wrapping_offset(step);\n    /// }\n    /// ```\n    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n    #[inline]\n    pub fn wrapping_offset(self, count: isize) -> *const T where T: Sized {\n        unsafe {\n            intrinsics::arith_offset(self, count)\n        }\n    }\n\n    /// Calculates the distance between two pointers. The returned value is in\n    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n    ///\n    /// If the address different between the two pointers ia not a multiple of\n    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n    /// zero.\n    ///\n    /// This function returns `None` if `T` is a zero-sized typed.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(offset_to)]\n    ///\n    /// fn main() {\n    ///     let a = [0; 5];\n    ///     let ptr1: *const i32 = &a[1];\n    ///     let ptr2: *const i32 = &a[3];\n    ///     assert_eq!(ptr1.offset_to(ptr2), Some(2));\n    ///     assert_eq!(ptr2.offset_to(ptr1), Some(-2));\n    ///     assert_eq!(unsafe { ptr1.offset(2) }, ptr2);\n    ///     assert_eq!(unsafe { ptr2.offset(-2) }, ptr1);\n    /// }\n    /// ```\n    #[unstable(feature = \"offset_to\", issue = \"41079\")]\n    #[inline]\n    pub fn offset_to(self, other: *const T) -> Option<isize> where T: Sized {\n        let size = mem::size_of::<T>();\n        if size == 0 {\n            None\n        } else {\n            let diff = (other as isize).wrapping_sub(self as isize);\n            Some(diff / size as isize)\n        }\n    }\n\n    /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n    ///\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and resulting pointer must be either in bounds or one\n    ///   byte past the end of an allocated object.\n    ///\n    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n    ///\n    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n    ///   space. That is, the infinite-precision sum must fit in a `usize`.\n    ///\n    /// The compiler and standard library generally tries to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `vec.as_ptr().add(vec.len())` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using `wrapping_offset` instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let s: &str = \"123\";\n    /// let ptr: *const u8 = s.as_ptr();\n    ///\n    /// unsafe {\n    ///     println!(\"{}\", *ptr.add(1) as char);\n    ///     println!(\"{}\", *ptr.add(2) as char);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn add(self, count: usize) -> Self\n        where T: Sized,\n    {\n        self.offset(count as isize)\n    }\n\n    /// Calculates the offset from a pointer (convenience for\n    /// `.offset((count as isize).wrapping_neg())`).\n    ///\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and resulting pointer must be either in bounds or one\n    ///   byte past the end of an allocated object.\n    ///\n    /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n    ///\n    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n    ///   space. That is, the infinite-precision sum must fit in a usize.\n    ///\n    /// The compiler and standard library generally tries to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `vec.as_ptr().add(vec.len()).sub(vec.len())` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using `wrapping_offset` instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let s: &str = \"123\";\n    ///\n    /// unsafe {\n    ///     let end: *const u8 = s.as_ptr().add(3);\n    ///     println!(\"{}\", *end.sub(1) as char);\n    ///     println!(\"{}\", *end.sub(2) as char);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn sub(self, count: usize) -> Self\n        where T: Sized,\n    {\n        self.offset((count as isize).wrapping_neg())\n    }\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    /// (convenience for `.wrapping_offset(count as isize)`)\n    ///\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// Always use `.add(count)` instead when possible, because `add`\n    /// allows the compiler to optimize better.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// // Iterate using a raw pointer in increments of two elements\n    /// let data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *const u8 = data.as_ptr();\n    /// let step = 2;\n    /// let end_rounded_up = ptr.wrapping_add(6);\n    ///\n    /// // This loop prints \"1, 3, 5, \"\n    /// while ptr != end_rounded_up {\n    ///     unsafe {\n    ///         print!(\"{}, \", *ptr);\n    ///     }\n    ///     ptr = ptr.wrapping_add(step);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub fn wrapping_add(self, count: usize) -> Self\n        where T: Sized,\n    {\n        self.wrapping_offset(count as isize)\n    }\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    /// (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)\n    ///\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// Always use `.sub(count)` instead when possible, because `sub`\n    /// allows the compiler to optimize better.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// // Iterate using a raw pointer in increments of two elements (backwards)\n    /// let data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *const u8 = data.as_ptr();\n    /// let start_rounded_down = ptr.wrapping_sub(2);\n    /// ptr = ptr.wrapping_add(4);\n    /// let step = 2;\n    /// // This loop prints \"5, 3, 1, \"\n    /// while ptr != start_rounded_down {\n    ///     unsafe {\n    ///         print!(\"{}, \", *ptr);\n    ///     }\n    ///     ptr = ptr.wrapping_sub(step);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub fn wrapping_sub(self, count: usize) -> Self\n        where T: Sized,\n    {\n        self.wrapping_offset((count as isize).wrapping_neg())\n    }\n\n    /// Reads the value from `self` without moving it. This leaves the\n    /// memory in `self` unchanged.\n    ///\n    /// # Safety\n    ///\n    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n    /// moves the value out of `self` without preventing further usage of `self`.\n    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n    /// because it will attempt to drop the value previously at `*self`.\n    ///\n    /// The pointer must be aligned; use `read_unaligned` if that is not the case.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let x = 12;\n    /// let y = &x as *const i32;\n    ///\n    /// unsafe {\n    ///     assert_eq!(y.read(), 12);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn read(self) -> T\n        where T: Sized,\n    {\n        read(self)\n    }\n\n    /// Performs a volatile read of the value from `self` without moving it. This\n    /// leaves the memory in `self` unchanged.\n    ///\n    /// Volatile operations are intended to act on I/O memory, and are guaranteed\n    /// to not be elided or reordered by the compiler across other volatile\n    /// operations.\n    ///\n    /// # Notes\n    ///\n    /// Rust does not currently have a rigorously and formally defined memory model,\n    /// so the precise semantics of what \"volatile\" means here is subject to change\n    /// over time. That being said, the semantics will almost always end up pretty\n    /// similar to [C11's definition of volatile][c11].\n    ///\n    /// The compiler shouldn't change the relative order or number of volatile\n    /// memory operations. However, volatile memory operations on zero-sized types\n    /// (e.g. if a zero-sized type is passed to `read_volatile`) are no-ops\n    /// and may be ignored.\n    ///\n    /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n    ///\n    /// # Safety\n    ///\n    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n    /// moves the value out of `self` without preventing further usage of `self`.\n    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n    /// because it will attempt to drop the value previously at `*self`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let x = 12;\n    /// let y = &x as *const i32;\n    ///\n    /// unsafe {\n    ///     assert_eq!(y.read_volatile(), 12);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn read_volatile(self) -> T\n        where T: Sized,\n    {\n        read_volatile(self)\n    }\n\n    /// Reads the value from `self` without moving it. This leaves the\n    /// memory in `self` unchanged.\n    ///\n    /// Unlike `read`, the pointer may be unaligned.\n    ///\n    /// # Safety\n    ///\n    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n    /// moves the value out of `self` without preventing further usage of `self`.\n    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n    /// because it will attempt to drop the value previously at `*self`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let x = 12;\n    /// let y = &x as *const i32;\n    ///\n    /// unsafe {\n    ///     assert_eq!(y.read_unaligned(), 12);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn read_unaligned(self) -> T\n        where T: Sized,\n    {\n        read_unaligned(self)\n    }\n\n    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n    /// and destination may overlap.\n    ///\n    /// NOTE: this has the *same* argument order as `ptr::copy`.\n    ///\n    /// This is semantically equivalent to C's `memmove`.\n    ///\n    /// # Safety\n    ///\n    /// Care must be taken with the ownership of `self` and `dest`.\n    /// This method semantically moves the values of `self` into `dest`.\n    /// However it does not drop the contents of `self`, or prevent the contents\n    /// of `dest` from being dropped or used.\n    ///\n    /// # Examples\n    ///\n    /// Efficiently create a Rust vector from an unsafe buffer:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// # #[allow(dead_code)]\n    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n    ///     let mut dst = Vec::with_capacity(elts);\n    ///     dst.set_len(elts);\n    ///     ptr.copy_to(dst.as_mut_ptr(), elts);\n    ///     dst\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n        where T: Sized,\n    {\n        copy(self, dest, count)\n    }\n\n    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n    /// and destination may *not* overlap.\n    ///\n    /// NOTE: this has the *same* argument order as `ptr::copy_nonoverlapping`.\n    ///\n    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n    ///\n    /// # Safety\n    ///\n    /// Beyond requiring that the program must be allowed to access both regions\n    /// of memory, it is Undefined Behavior for source and destination to\n    /// overlap. Care must also be taken with the ownership of `self` and\n    /// `self`. This method semantically moves the values of `self` into `dest`.\n    /// However it does not drop the contents of `dest`, or prevent the contents\n    /// of `self` from being dropped or used.\n    ///\n    /// # Examples\n    ///\n    /// Efficiently create a Rust vector from an unsafe buffer:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// # #[allow(dead_code)]\n    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n    ///     let mut dst = Vec::with_capacity(elts);\n    ///     dst.set_len(elts);\n    ///     ptr.copy_to_nonoverlapping(dst.as_mut_ptr(), elts);\n    ///     dst\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n        where T: Sized,\n    {\n        copy_nonoverlapping(self, dest, count)\n    }\n\n    /// Computes the byte offset that needs to be applied in order to\n    /// make the pointer aligned to `align`.\n    /// If it is not possible to align the pointer, the implementation returns\n    /// `usize::max_value()`.\n    ///\n    /// There are no guarantees whatsover that offsetting the pointer will not\n    /// overflow or go beyond the allocation that the pointer points into.\n    /// It is up to the caller to ensure that the returned offset is correct\n    /// in all terms other than alignment.\n    ///\n    /// # Examples\n    ///\n    /// Accessing adjacent `u8` as `u16`\n    ///\n    /// ```\n    /// # #![feature(align_offset)]\n    /// # fn foo(n: usize) {\n    /// # use std::mem::align_of;\n    /// # unsafe {\n    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n    /// let ptr = &x[n] as *const u8;\n    /// let offset = ptr.align_offset(align_of::<u16>());\n    /// if offset < x.len() - n - 1 {\n    ///     let u16_ptr = ptr.offset(offset as isize) as *const u16;\n    ///     assert_ne!(*u16_ptr, 500);\n    /// } else {\n    ///     // while the pointer can be aligned via `offset`, it would point\n    ///     // outside the allocation\n    /// }\n    /// # } }\n    /// ```\n    #[unstable(feature = \"align_offset\", issue = \"44488\")]\n    pub fn align_offset(self, align: usize) -> usize {\n        unsafe {\n            intrinsics::align_offset(self as *const _, align)\n        }\n    }\n}\n\n#[lang = \"mut_ptr\"]\nimpl<T: ?Sized> *mut T {\n    /// Returns `true` if the pointer is null.\n    ///\n    /// Note that unsized types have many possible null pointers, as only the\n    /// raw data pointer is considered, not their length, vtable, etc.\n    /// Therefore, two pointers that are null may still not compare equal to\n    /// each other.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = [1, 2, 3];\n    /// let ptr: *mut u32 = s.as_mut_ptr();\n    /// assert!(!ptr.is_null());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_null(self) -> bool {\n        // Compare via a cast to a thin pointer, so fat pointers are only\n        // considering their \"data\" part for null-ness.\n        (self as *mut u8) == null_mut()\n    }\n\n    /// Returns `None` if the pointer is null, or else returns a reference to\n    /// the value wrapped in `Some`.\n    ///\n    /// # Safety\n    ///\n    /// While this method and its mutable counterpart are useful for\n    /// null-safety, it is important to note that this is still an unsafe\n    /// operation because the returned value could be pointing to invalid\n    /// memory.\n    ///\n    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n    /// not necessarily reflect the actual lifetime of the data.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let ptr: *mut u8 = &mut 10u8 as *mut u8;\n    ///\n    /// unsafe {\n    ///     if let Some(val_back) = ptr.as_ref() {\n    ///         println!(\"We got back the value: {}!\", val_back);\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n    #[inline]\n    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n        if self.is_null() {\n            None\n        } else {\n            Some(&*self)\n        }\n    }\n\n    /// Calculates the offset from a pointer.\n    ///\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and resulting pointer must be either in bounds or one\n    ///   byte past the end of an allocated object.\n    ///\n    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n    ///\n    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n    ///   space. That is, the infinite-precision sum, **in bytes** must fit in a usize.\n    ///\n    /// The compiler and standard library generally tries to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `vec.as_ptr().offset(vec.len() as isize)` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using `wrapping_offset` instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = [1, 2, 3];\n    /// let ptr: *mut u32 = s.as_mut_ptr();\n    ///\n    /// unsafe {\n    ///     println!(\"{}\", *ptr.offset(1));\n    ///     println!(\"{}\", *ptr.offset(2));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn offset(self, count: isize) -> *mut T where T: Sized {\n        intrinsics::offset(self, count) as *mut T\n    }\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// Always use `.offset(count)` instead when possible, because `offset`\n    /// allows the compiler to optimize better.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // Iterate using a raw pointer in increments of two elements\n    /// let mut data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *mut u8 = data.as_mut_ptr();\n    /// let step = 2;\n    /// let end_rounded_up = ptr.wrapping_offset(6);\n    ///\n    /// while ptr != end_rounded_up {\n    ///     unsafe {\n    ///         *ptr = 0;\n    ///     }\n    ///     ptr = ptr.wrapping_offset(step);\n    /// }\n    /// assert_eq!(&data, &[0, 2, 0, 4, 0]);\n    /// ```\n    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n    #[inline]\n    pub fn wrapping_offset(self, count: isize) -> *mut T where T: Sized {\n        unsafe {\n            intrinsics::arith_offset(self, count) as *mut T\n        }\n    }\n\n    /// Returns `None` if the pointer is null, or else returns a mutable\n    /// reference to the value wrapped in `Some`.\n    ///\n    /// # Safety\n    ///\n    /// As with `as_ref`, this is unsafe because it cannot verify the validity\n    /// of the returned pointer, nor can it ensure that the lifetime `'a`\n    /// returned is indeed a valid lifetime for the contained data.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = [1, 2, 3];\n    /// let ptr: *mut u32 = s.as_mut_ptr();\n    /// let first_value = unsafe { ptr.as_mut().unwrap() };\n    /// *first_value = 4;\n    /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n    /// ```\n    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n    #[inline]\n    pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n        if self.is_null() {\n            None\n        } else {\n            Some(&mut *self)\n        }\n    }\n\n    /// Calculates the distance between two pointers. The returned value is in\n    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n    ///\n    /// If the address different between the two pointers ia not a multiple of\n    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n    /// zero.\n    ///\n    /// This function returns `None` if `T` is a zero-sized typed.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(offset_to)]\n    ///\n    /// fn main() {\n    ///     let mut a = [0; 5];\n    ///     let ptr1: *mut i32 = &mut a[1];\n    ///     let ptr2: *mut i32 = &mut a[3];\n    ///     assert_eq!(ptr1.offset_to(ptr2), Some(2));\n    ///     assert_eq!(ptr2.offset_to(ptr1), Some(-2));\n    ///     assert_eq!(unsafe { ptr1.offset(2) }, ptr2);\n    ///     assert_eq!(unsafe { ptr2.offset(-2) }, ptr1);\n    /// }\n    /// ```\n    #[unstable(feature = \"offset_to\", issue = \"41079\")]\n    #[inline]\n    pub fn offset_to(self, other: *const T) -> Option<isize> where T: Sized {\n        let size = mem::size_of::<T>();\n        if size == 0 {\n            None\n        } else {\n            let diff = (other as isize).wrapping_sub(self as isize);\n            Some(diff / size as isize)\n        }\n    }\n\n    /// Computes the byte offset that needs to be applied in order to\n    /// make the pointer aligned to `align`.\n    /// If it is not possible to align the pointer, the implementation returns\n    /// `usize::max_value()`.\n    ///\n    /// There are no guarantees whatsover that offsetting the pointer will not\n    /// overflow or go beyond the allocation that the pointer points into.\n    /// It is up to the caller to ensure that the returned offset is correct\n    /// in all terms other than alignment.\n    ///\n    /// # Examples\n    ///\n    /// Accessing adjacent `u8` as `u16`\n    ///\n    /// ```\n    /// # #![feature(align_offset)]\n    /// # fn foo(n: usize) {\n    /// # use std::mem::align_of;\n    /// # unsafe {\n    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n    /// let ptr = &x[n] as *const u8;\n    /// let offset = ptr.align_offset(align_of::<u16>());\n    /// if offset < x.len() - n - 1 {\n    ///     let u16_ptr = ptr.offset(offset as isize) as *const u16;\n    ///     assert_ne!(*u16_ptr, 500);\n    /// } else {\n    ///     // while the pointer can be aligned via `offset`, it would point\n    ///     // outside the allocation\n    /// }\n    /// # } }\n    /// ```\n    #[unstable(feature = \"align_offset\", issue = \"44488\")]\n    pub fn align_offset(self, align: usize) -> usize {\n        unsafe {\n            intrinsics::align_offset(self as *const _, align)\n        }\n    }\n\n    /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n    ///\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and resulting pointer must be either in bounds or one\n    ///   byte past the end of an allocated object.\n    ///\n    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n    ///\n    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n    ///   space. That is, the infinite-precision sum must fit in a `usize`.\n    ///\n    /// The compiler and standard library generally tries to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `vec.as_ptr().add(vec.len())` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using `wrapping_offset` instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let s: &str = \"123\";\n    /// let ptr: *const u8 = s.as_ptr();\n    ///\n    /// unsafe {\n    ///     println!(\"{}\", *ptr.add(1) as char);\n    ///     println!(\"{}\", *ptr.add(2) as char);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn add(self, count: usize) -> Self\n        where T: Sized,\n    {\n        self.offset(count as isize)\n    }\n\n    /// Calculates the offset from a pointer (convenience for\n    /// `.offset((count as isize).wrapping_neg())`).\n    ///\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and resulting pointer must be either in bounds or one\n    ///   byte past the end of an allocated object.\n    ///\n    /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n    ///\n    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n    ///   space. That is, the infinite-precision sum must fit in a usize.\n    ///\n    /// The compiler and standard library generally tries to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `vec.as_ptr().add(vec.len()).sub(vec.len())` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using `wrapping_offset` instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let s: &str = \"123\";\n    ///\n    /// unsafe {\n    ///     let end: *const u8 = s.as_ptr().add(3);\n    ///     println!(\"{}\", *end.sub(1) as char);\n    ///     println!(\"{}\", *end.sub(2) as char);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn sub(self, count: usize) -> Self\n        where T: Sized,\n    {\n        self.offset((count as isize).wrapping_neg())\n    }\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    /// (convenience for `.wrapping_offset(count as isize)`)\n    ///\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// Always use `.add(count)` instead when possible, because `add`\n    /// allows the compiler to optimize better.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// // Iterate using a raw pointer in increments of two elements\n    /// let data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *const u8 = data.as_ptr();\n    /// let step = 2;\n    /// let end_rounded_up = ptr.wrapping_add(6);\n    ///\n    /// // This loop prints \"1, 3, 5, \"\n    /// while ptr != end_rounded_up {\n    ///     unsafe {\n    ///         print!(\"{}, \", *ptr);\n    ///     }\n    ///     ptr = ptr.wrapping_add(step);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub fn wrapping_add(self, count: usize) -> Self\n        where T: Sized,\n    {\n        self.wrapping_offset(count as isize)\n    }\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    /// (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)\n    ///\n    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// Always use `.sub(count)` instead when possible, because `sub`\n    /// allows the compiler to optimize better.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// // Iterate using a raw pointer in increments of two elements (backwards)\n    /// let data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *const u8 = data.as_ptr();\n    /// let start_rounded_down = ptr.wrapping_sub(2);\n    /// ptr = ptr.wrapping_add(4);\n    /// let step = 2;\n    /// // This loop prints \"5, 3, 1, \"\n    /// while ptr != start_rounded_down {\n    ///     unsafe {\n    ///         print!(\"{}, \", *ptr);\n    ///     }\n    ///     ptr = ptr.wrapping_sub(step);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub fn wrapping_sub(self, count: usize) -> Self\n        where T: Sized,\n    {\n        self.wrapping_offset((count as isize).wrapping_neg())\n    }\n\n    /// Reads the value from `self` without moving it. This leaves the\n    /// memory in `self` unchanged.\n    ///\n    /// # Safety\n    ///\n    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n    /// moves the value out of `self` without preventing further usage of `self`.\n    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n    /// because it will attempt to drop the value previously at `*self`.\n    ///\n    /// The pointer must be aligned; use `read_unaligned` if that is not the case.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let x = 12;\n    /// let y = &x as *const i32;\n    ///\n    /// unsafe {\n    ///     assert_eq!(y.read(), 12);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn read(self) -> T\n        where T: Sized,\n    {\n        read(self)\n    }\n\n    /// Performs a volatile read of the value from `self` without moving it. This\n    /// leaves the memory in `self` unchanged.\n    ///\n    /// Volatile operations are intended to act on I/O memory, and are guaranteed\n    /// to not be elided or reordered by the compiler across other volatile\n    /// operations.\n    ///\n    /// # Notes\n    ///\n    /// Rust does not currently have a rigorously and formally defined memory model,\n    /// so the precise semantics of what \"volatile\" means here is subject to change\n    /// over time. That being said, the semantics will almost always end up pretty\n    /// similar to [C11's definition of volatile][c11].\n    ///\n    /// The compiler shouldn't change the relative order or number of volatile\n    /// memory operations. However, volatile memory operations on zero-sized types\n    /// (e.g. if a zero-sized type is passed to `read_volatile`) are no-ops\n    /// and may be ignored.\n    ///\n    /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n    ///\n    /// # Safety\n    ///\n    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n    /// moves the value out of `self` without preventing further usage of `self`.\n    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n    /// `src` is not used before the data is overwritten again (e.g. with `write`,\n    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n    /// because it will attempt to drop the value previously at `*self`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let x = 12;\n    /// let y = &x as *const i32;\n    ///\n    /// unsafe {\n    ///     assert_eq!(y.read_volatile(), 12);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn read_volatile(self) -> T\n        where T: Sized,\n    {\n        read_volatile(self)\n    }\n\n    /// Reads the value from `self` without moving it. This leaves the\n    /// memory in `self` unchanged.\n    ///\n    /// Unlike `read`, the pointer may be unaligned.\n    ///\n    /// # Safety\n    ///\n    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n    /// moves the value out of `self` without preventing further usage of `self`.\n    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n    /// because it will attempt to drop the value previously at `*self`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let x = 12;\n    /// let y = &x as *const i32;\n    ///\n    /// unsafe {\n    ///     assert_eq!(y.read_unaligned(), 12);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn read_unaligned(self) -> T\n        where T: Sized,\n    {\n        read_unaligned(self)\n    }\n\n    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n    /// and destination may overlap.\n    ///\n    /// NOTE: this has the *same* argument order as `ptr::copy`.\n    ///\n    /// This is semantically equivalent to C's `memmove`.\n    ///\n    /// # Safety\n    ///\n    /// Care must be taken with the ownership of `self` and `dest`.\n    /// This method semantically moves the values of `self` into `dest`.\n    /// However it does not drop the contents of `self`, or prevent the contents\n    /// of `dest` from being dropped or used.\n    ///\n    /// # Examples\n    ///\n    /// Efficiently create a Rust vector from an unsafe buffer:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// # #[allow(dead_code)]\n    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n    ///     let mut dst = Vec::with_capacity(elts);\n    ///     dst.set_len(elts);\n    ///     ptr.copy_to(dst.as_mut_ptr(), elts);\n    ///     dst\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n        where T: Sized,\n    {\n        copy(self, dest, count)\n    }\n\n    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n    /// and destination may *not* overlap.\n    ///\n    /// NOTE: this has the *same* argument order as `ptr::copy_nonoverlapping`.\n    ///\n    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n    ///\n    /// # Safety\n    ///\n    /// Beyond requiring that the program must be allowed to access both regions\n    /// of memory, it is Undefined Behavior for source and destination to\n    /// overlap. Care must also be taken with the ownership of `self` and\n    /// `self`. This method semantically moves the values of `self` into `dest`.\n    /// However it does not drop the contents of `dest`, or prevent the contents\n    /// of `self` from being dropped or used.\n    ///\n    /// # Examples\n    ///\n    /// Efficiently create a Rust vector from an unsafe buffer:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// # #[allow(dead_code)]\n    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n    ///     let mut dst = Vec::with_capacity(elts);\n    ///     dst.set_len(elts);\n    ///     ptr.copy_to_nonoverlapping(dst.as_mut_ptr(), elts);\n    ///     dst\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n        where T: Sized,\n    {\n        copy_nonoverlapping(self, dest, count)\n    }\n\n    /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n    /// and destination may overlap.\n    ///\n    /// NOTE: this has the *opposite* argument order of `ptr::copy`.\n    ///\n    /// This is semantically equivalent to C's `memmove`.\n    ///\n    /// # Safety\n    ///\n    /// Care must be taken with the ownership of `src` and `self`.\n    /// This method semantically moves the values of `src` into `self`.\n    /// However it does not drop the contents of `self`, or prevent the contents\n    /// of `src` from being dropped or used.\n    ///\n    /// # Examples\n    ///\n    /// Efficiently create a Rust vector from an unsafe buffer:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// # #[allow(dead_code)]\n    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n    ///     let mut dst: Vec<T> = Vec::with_capacity(elts);\n    ///     dst.set_len(elts);\n    ///     dst.as_mut_ptr().copy_from(ptr, elts);\n    ///     dst\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn copy_from(self, src: *const T, count: usize)\n        where T: Sized,\n    {\n        copy(src, self, count)\n    }\n\n    /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n    /// and destination may *not* overlap.\n    ///\n    /// NOTE: this has the *opposite* argument order of `ptr::copy_nonoverlapping`.\n    ///\n    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n    ///\n    /// # Safety\n    ///\n    /// Beyond requiring that the program must be allowed to access both regions\n    /// of memory, it is Undefined Behavior for source and destination to\n    /// overlap. Care must also be taken with the ownership of `src` and\n    /// `self`. This method semantically moves the values of `src` into `self`.\n    /// However it does not drop the contents of `self`, or prevent the contents\n    /// of `src` from being dropped or used.\n    ///\n    /// # Examples\n    ///\n    /// Efficiently create a Rust vector from an unsafe buffer:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// # #[allow(dead_code)]\n    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n    ///     let mut dst: Vec<T> = Vec::with_capacity(elts);\n    ///     dst.set_len(elts);\n    ///     dst.as_mut_ptr().copy_from_nonoverlapping(ptr, elts);\n    ///     dst\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)\n        where T: Sized,\n    {\n        copy_nonoverlapping(src, self, count)\n    }\n\n    /// Executes the destructor (if any) of the pointed-to value.\n    ///\n    /// This has two use cases:\n    ///\n    /// * It is *required* to use `drop_in_place` to drop unsized types like\n    ///   trait objects, because they can't be read out onto the stack and\n    ///   dropped normally.\n    ///\n    /// * It is friendlier to the optimizer to do this over `ptr::read` when\n    ///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n    ///   as the compiler doesn't need to prove that it's sound to elide the\n    ///   copy.\n    ///\n    /// # Safety\n    ///\n    /// This has all the same safety problems as `ptr::read` with respect to\n    /// invalid pointers, types, and double drops.\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn drop_in_place(self) {\n        drop_in_place(self)\n    }\n\n    /// Overwrites a memory location with the given value without reading or\n    /// dropping the old value.\n    ///\n    /// # Safety\n    ///\n    /// This operation is marked unsafe because it writes through a raw pointer.\n    ///\n    /// It does not drop the contents of `self`. This is safe, but it could leak\n    /// allocations or resources, so care must be taken not to overwrite an object\n    /// that should be dropped.\n    ///\n    /// Additionally, it does not drop `val`. Semantically, `val` is moved into the\n    /// location pointed to by `self`.\n    ///\n    /// This is appropriate for initializing uninitialized memory, or overwriting\n    /// memory that has previously been `read` from.\n    ///\n    /// The pointer must be aligned; use `write_unaligned` if that is not the case.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let mut x = 0;\n    /// let y = &mut x as *mut i32;\n    /// let z = 12;\n    ///\n    /// unsafe {\n    ///     y.write(z);\n    ///     assert_eq!(y.read(), 12);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn write(self, val: T)\n        where T: Sized,\n    {\n        write(self, val)\n    }\n\n    /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n    /// bytes of memory starting at `self` to `val`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let mut vec = vec![0; 4];\n    /// unsafe {\n    ///     let vec_ptr = vec.as_mut_ptr();\n    ///     vec_ptr.write_bytes(b'a', 2);\n    /// }\n    /// assert_eq!(vec, [b'a', b'a', 0, 0]);\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn write_bytes(self, val: u8, count: usize)\n        where T: Sized,\n    {\n        write_bytes(self, val, count)\n    }\n\n    /// Performs a volatile write of a memory location with the given value without\n    /// reading or dropping the old value.\n    ///\n    /// Volatile operations are intended to act on I/O memory, and are guaranteed\n    /// to not be elided or reordered by the compiler across other volatile\n    /// operations.\n    ///\n    /// # Notes\n    ///\n    /// Rust does not currently have a rigorously and formally defined memory model,\n    /// so the precise semantics of what \"volatile\" means here is subject to change\n    /// over time. That being said, the semantics will almost always end up pretty\n    /// similar to [C11's definition of volatile][c11].\n    ///\n    /// The compiler shouldn't change the relative order or number of volatile\n    /// memory operations. However, volatile memory operations on zero-sized types\n    /// (e.g. if a zero-sized type is passed to `write_volatile`) are no-ops\n    /// and may be ignored.\n    ///\n    /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n    ///\n    /// # Safety\n    ///\n    /// This operation is marked unsafe because it accepts a raw pointer.\n    ///\n    /// It does not drop the contents of `self`. This is safe, but it could leak\n    /// allocations or resources, so care must be taken not to overwrite an object\n    /// that should be dropped.\n    ///\n    /// This is appropriate for initializing uninitialized memory, or overwriting\n    /// memory that has previously been `read` from.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let mut x = 0;\n    /// let y = &mut x as *mut i32;\n    /// let z = 12;\n    ///\n    /// unsafe {\n    ///     y.write_volatile(z);\n    ///     assert_eq!(y.read_volatile(), 12);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn write_volatile(self, val: T)\n        where T: Sized,\n    {\n        write_volatile(self, val)\n    }\n\n    /// Overwrites a memory location with the given value without reading or\n    /// dropping the old value.\n    ///\n    /// Unlike `write`, the pointer may be unaligned.\n    ///\n    /// # Safety\n    ///\n    /// This operation is marked unsafe because it writes through a raw pointer.\n    ///\n    /// It does not drop the contents of `self`. This is safe, but it could leak\n    /// allocations or resources, so care must be taken not to overwrite an object\n    /// that should be dropped.\n    ///\n    /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n    /// location pointed to by `dst`.\n    ///\n    /// This is appropriate for initializing uninitialized memory, or overwriting\n    /// memory that has previously been `read` from.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(pointer_methods)]\n    ///\n    /// let mut x = 0;\n    /// let y = &mut x as *mut i32;\n    /// let z = 12;\n    ///\n    /// unsafe {\n    ///     y.write_unaligned(z);\n    ///     assert_eq!(y.read_unaligned(), 12);\n    /// }\n    /// ```\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn write_unaligned(self, val: T)\n        where T: Sized,\n    {\n        write_unaligned(self, val)\n    }\n\n    /// Replaces the value at `self` with `src`, returning the old\n    /// value, without dropping either.\n    ///\n    /// # Safety\n    ///\n    /// This is only unsafe because it accepts a raw pointer.\n    /// Otherwise, this operation is identical to `mem::replace`.\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn replace(self, src: T) -> T\n        where T: Sized,\n    {\n        replace(self, src)\n    }\n\n    /// Swaps the values at two mutable locations of the same type, without\n    /// deinitializing either. They may overlap, unlike `mem::swap` which is\n    /// otherwise equivalent.\n    ///\n    /// # Safety\n    ///\n    /// This function copies the memory through the raw pointers passed to it\n    /// as arguments.\n    ///\n    /// Ensure that these pointers are valid before calling `swap`.\n    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n    #[inline]\n    pub unsafe fn swap(self, with: *mut T)\n        where T: Sized,\n    {\n        swap(self, with)\n    }\n}\n\n// Equality for pointers\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> PartialEq for *const T {\n    #[inline]\n    fn eq(&self, other: &*const T) -> bool { *self == *other }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Eq for *const T {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> PartialEq for *mut T {\n    #[inline]\n    fn eq(&self, other: &*mut T) -> bool { *self == *other }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Eq for *mut T {}\n\n/// Compare raw pointers for equality.\n///\n/// This is the same as using the `==` operator, but less generic:\n/// the arguments have to be `*const T` raw pointers,\n/// not anything that implements `PartialEq`.\n///\n/// This can be used to compare `&T` references (which coerce to `*const T` implicitly)\n/// by their address rather than comparing the values they point to\n/// (which is what the `PartialEq for &T` implementation does).\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let five = 5;\n/// let other_five = 5;\n/// let five_ref = &five;\n/// let same_five_ref = &five;\n/// let other_five_ref = &other_five;\n///\n/// assert!(five_ref == same_five_ref);\n/// assert!(five_ref == other_five_ref);\n///\n/// assert!(ptr::eq(five_ref, same_five_ref));\n/// assert!(!ptr::eq(five_ref, other_five_ref));\n/// ```\n#[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n#[inline]\npub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n    a == b\n}\n\n// Impls for function pointers\nmacro_rules! fnptr_impls_safety_abi {\n    ($FnTy: ty, $($Arg: ident),*) => {\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> PartialEq for $FnTy {\n            #[inline]\n            fn eq(&self, other: &Self) -> bool {\n                *self as usize == *other as usize\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> Eq for $FnTy {}\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> PartialOrd for $FnTy {\n            #[inline]\n            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n                (*self as usize).partial_cmp(&(*other as usize))\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> Ord for $FnTy {\n            #[inline]\n            fn cmp(&self, other: &Self) -> Ordering {\n                (*self as usize).cmp(&(*other as usize))\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> hash::Hash for $FnTy {\n            fn hash<HH: hash::Hasher>(&self, state: &mut HH) {\n                state.write_usize(*self as usize)\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> fmt::Pointer for $FnTy {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                fmt::Pointer::fmt(&(*self as *const ()), f)\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> fmt::Debug for $FnTy {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                fmt::Pointer::fmt(&(*self as *const ()), f)\n            }\n        }\n    }\n}\n\nmacro_rules! fnptr_impls_args {\n    ($($Arg: ident),+) => {\n        fnptr_impls_safety_abi! { extern \"Rust\" fn($($Arg),*) -> Ret, $($Arg),* }\n        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),*) -> Ret, $($Arg),* }\n        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),* , ...) -> Ret, $($Arg),* }\n        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn($($Arg),*) -> Ret, $($Arg),* }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),*) -> Ret, $($Arg),* }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),* , ...) -> Ret, $($Arg),* }\n    };\n    () => {\n        // No variadic functions with 0 parameters\n        fnptr_impls_safety_abi! { extern \"Rust\" fn() -> Ret, }\n        fnptr_impls_safety_abi! { extern \"C\" fn() -> Ret, }\n        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn() -> Ret, }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn() -> Ret, }\n    };\n}\n\nfnptr_impls_args! { }\nfnptr_impls_args! { A }\nfnptr_impls_args! { A, B }\nfnptr_impls_args! { A, B, C }\nfnptr_impls_args! { A, B, C, D }\nfnptr_impls_args! { A, B, C, D, E }\nfnptr_impls_args! { A, B, C, D, E, F }\nfnptr_impls_args! { A, B, C, D, E, F, G }\nfnptr_impls_args! { A, B, C, D, E, F, G, H }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n\n// Comparison for pointers\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Ord for *const T {\n    #[inline]\n    fn cmp(&self, other: &*const T) -> Ordering {\n        if self < other {\n            Less\n        } else if self == other {\n            Equal\n        } else {\n            Greater\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> PartialOrd for *const T {\n    #[inline]\n    fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n\n    #[inline]\n    fn lt(&self, other: &*const T) -> bool { *self < *other }\n\n    #[inline]\n    fn le(&self, other: &*const T) -> bool { *self <= *other }\n\n    #[inline]\n    fn gt(&self, other: &*const T) -> bool { *self > *other }\n\n    #[inline]\n    fn ge(&self, other: &*const T) -> bool { *self >= *other }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Ord for *mut T {\n    #[inline]\n    fn cmp(&self, other: &*mut T) -> Ordering {\n        if self < other {\n            Less\n        } else if self == other {\n            Equal\n        } else {\n            Greater\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> PartialOrd for *mut T {\n    #[inline]\n    fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n\n    #[inline]\n    fn lt(&self, other: &*mut T) -> bool { *self < *other }\n\n    #[inline]\n    fn le(&self, other: &*mut T) -> bool { *self <= *other }\n\n    #[inline]\n    fn gt(&self, other: &*mut T) -> bool { *self > *other }\n\n    #[inline]\n    fn ge(&self, other: &*mut T) -> bool { *self >= *other }\n}\n\n/// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n/// of this wrapper owns the referent. Useful for building abstractions like\n/// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n///\n/// Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n/// It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n/// the kind of strong aliasing guarantees an instance of `T` can expect:\n/// the referent of the pointer should not be modified without a unique path to\n/// its owning Unique.\n///\n/// If you're uncertain of whether it's correct to use `Unique` for your purposes,\n/// consider using `NonNull`, which has weaker semantics.\n///\n/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n/// is never dereferenced. This is so that enums may use this forbidden value\n/// as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n/// However the pointer may still dangle if it isn't dereferenced.\n///\n/// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n/// for any type which upholds Unique's aliasing requirements.\n#[unstable(feature = \"ptr_internals\", issue = \"0\",\n           reason = \"use NonNull instead and consider PhantomData<T> \\\n                     (if you also use #[may_dangle]), Send, and/or Sync\")]\npub struct Unique<T: ?Sized> {\n    pointer: NonZero<*const T>,\n    // NOTE: this marker has no consequences for variance, but is necessary\n    // for dropck to understand that we logically own a `T`.\n    //\n    // For details, see:\n    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data\n    _marker: PhantomData<T>,\n}\n\n#[unstable(feature = \"ptr_internals\", issue = \"0\")]\nimpl<T: ?Sized> fmt::Debug for Unique<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Pointer::fmt(&self.as_ptr(), f)\n    }\n}\n\n/// `Unique` pointers are `Send` if `T` is `Send` because the data they\n/// reference is unaliased. Note that this aliasing invariant is\n/// unenforced by the type system; the abstraction using the\n/// `Unique` must enforce it.\n#[unstable(feature = \"ptr_internals\", issue = \"0\")]\nunsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n\n/// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n/// reference is unaliased. Note that this aliasing invariant is\n/// unenforced by the type system; the abstraction using the\n/// `Unique` must enforce it.\n#[unstable(feature = \"ptr_internals\", issue = \"0\")]\nunsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n\n#[unstable(feature = \"ptr_internals\", issue = \"0\")]\nimpl<T: Sized> Unique<T> {\n    /// Creates a new `Unique` that is dangling, but well-aligned.\n    ///\n    /// This is useful for initializing types which lazily allocate, like\n    /// `Vec::new` does.\n    // FIXME: rename to dangling() to match NonNull?\n    pub fn empty() -> Self {\n        unsafe {\n            let ptr = mem::align_of::<T>() as *mut T;\n            Unique::new_unchecked(ptr)\n        }\n    }\n}\n\n#[unstable(feature = \"ptr_internals\", issue = \"0\")]\nimpl<T: ?Sized> Unique<T> {\n    /// Creates a new `Unique`.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n        Unique { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n    }\n\n    /// Creates a new `Unique` if `ptr` is non-null.\n    pub fn new(ptr: *mut T) -> Option<Self> {\n        NonZero::new(ptr as *const T).map(|nz| Unique { pointer: nz, _marker: PhantomData })\n    }\n\n    /// Acquires the underlying `*mut` pointer.\n    pub fn as_ptr(self) -> *mut T {\n        self.pointer.get() as *mut T\n    }\n\n    /// Dereferences the content.\n    ///\n    /// The resulting lifetime is bound to self so this behaves \"as if\"\n    /// it were actually an instance of T that is getting borrowed. If a longer\n    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n    pub unsafe fn as_ref(&self) -> &T {\n        &*self.as_ptr()\n    }\n\n    /// Mutably dereferences the content.\n    ///\n    /// The resulting lifetime is bound to self so this behaves \"as if\"\n    /// it were actually an instance of T that is getting borrowed. If a longer\n    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n    pub unsafe fn as_mut(&mut self) -> &mut T {\n        &mut *self.as_ptr()\n    }\n}\n\n#[unstable(feature = \"ptr_internals\", issue = \"0\")]\nimpl<T: ?Sized> Clone for Unique<T> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\n#[unstable(feature = \"ptr_internals\", issue = \"0\")]\nimpl<T: ?Sized> Copy for Unique<T> { }\n\n#[unstable(feature = \"ptr_internals\", issue = \"0\")]\nimpl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n\n#[unstable(feature = \"ptr_internals\", issue = \"0\")]\nimpl<T: ?Sized> fmt::Pointer for Unique<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Pointer::fmt(&self.as_ptr(), f)\n    }\n}\n\n#[unstable(feature = \"ptr_internals\", issue = \"0\")]\nimpl<'a, T: ?Sized> From<&'a mut T> for Unique<T> {\n    fn from(reference: &'a mut T) -> Self {\n        Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n    }\n}\n\n#[unstable(feature = \"ptr_internals\", issue = \"0\")]\nimpl<'a, T: ?Sized> From<&'a T> for Unique<T> {\n    fn from(reference: &'a T) -> Self {\n        Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n    }\n}\n\n#[unstable(feature = \"ptr_internals\", issue = \"0\")]\nimpl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n    fn from(p: NonNull<T>) -> Self {\n        Unique { pointer: p.pointer, _marker: PhantomData }\n    }\n}\n\n/// Previous name of `NonNull`.\n#[rustc_deprecated(since = \"1.24\", reason = \"renamed to `NonNull`\")]\n#[unstable(feature = \"shared\", issue = \"27730\")]\npub type Shared<T> = NonNull<T>;\n\n/// `*mut T` but non-zero and covariant.\n///\n/// This is often the correct thing to use when building data structures using\n/// raw pointers, but is ultimately more dangerous to use because of its additional\n/// properties. If you're not sure if you should use `NonNull<T>`, just use `*mut T`!\n///\n/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n/// is never dereferenced. This is so that enums may use this forbidden value\n/// as a discriminant -- `Option<NonNull<T>>` has the same size as `NonNull<T>`.\n/// However the pointer may still dangle if it isn't dereferenced.\n///\n/// Unlike `*mut T`, `NonNull<T>` is covariant over `T`. If this is incorrect\n/// for your use case, you should include some PhantomData in your type to\n/// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n/// Usually this won't be necessary; covariance is correct for most safe abstractions,\n/// such as Box, Rc, Arc, Vec, and LinkedList. This is the case because they\n/// provide a public API that follows the normal shared XOR mutable rules of Rust.\n#[stable(feature = \"nonnull\", since = \"1.24.0\")]\npub struct NonNull<T: ?Sized> {\n    pointer: NonZero<*const T>,\n}\n\n#[stable(feature = \"nonnull\", since = \"1.24.0\")]\nimpl<T: ?Sized> fmt::Debug for NonNull<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Pointer::fmt(&self.as_ptr(), f)\n    }\n}\n\n/// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n// NB: This impl is unnecessary, but should provide better error messages.\n#[stable(feature = \"nonnull\", since = \"1.24.0\")]\nimpl<T: ?Sized> !Send for NonNull<T> { }\n\n/// `NonNull` pointers are not `Sync` because the data they reference may be aliased.\n// NB: This impl is unnecessary, but should provide better error messages.\n#[stable(feature = \"nonnull\", since = \"1.24.0\")]\nimpl<T: ?Sized> !Sync for NonNull<T> { }\n\nimpl<T: Sized> NonNull<T> {\n    /// Creates a new `NonNull` that is dangling, but well-aligned.\n    ///\n    /// This is useful for initializing types which lazily allocate, like\n    /// `Vec::new` does.\n    #[stable(feature = \"nonnull\", since = \"1.24.0\")]\n    pub fn dangling() -> Self {\n        unsafe {\n            let ptr = mem::align_of::<T>() as *mut T;\n            NonNull::new_unchecked(ptr)\n        }\n    }\n}\n\nimpl<T: ?Sized> NonNull<T> {\n    /// Creates a new `NonNull`.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    #[stable(feature = \"nonnull\", since = \"1.24.0\")]\n    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n        NonNull { pointer: NonZero::new_unchecked(ptr) }\n    }\n\n    /// Creates a new `NonNull` if `ptr` is non-null.\n    #[stable(feature = \"nonnull\", since = \"1.24.0\")]\n    pub fn new(ptr: *mut T) -> Option<Self> {\n        NonZero::new(ptr as *const T).map(|nz| NonNull { pointer: nz })\n    }\n\n    /// Acquires the underlying `*mut` pointer.\n    #[stable(feature = \"nonnull\", since = \"1.24.0\")]\n    pub fn as_ptr(self) -> *mut T {\n        self.pointer.get() as *mut T\n    }\n\n    /// Dereferences the content.\n    ///\n    /// The resulting lifetime is bound to self so this behaves \"as if\"\n    /// it were actually an instance of T that is getting borrowed. If a longer\n    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n    #[stable(feature = \"nonnull\", since = \"1.24.0\")]\n    pub unsafe fn as_ref(&self) -> &T {\n        &*self.as_ptr()\n    }\n\n    /// Mutably dereferences the content.\n    ///\n    /// The resulting lifetime is bound to self so this behaves \"as if\"\n    /// it were actually an instance of T that is getting borrowed. If a longer\n    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n    #[stable(feature = \"nonnull\", since = \"1.24.0\")]\n    pub unsafe fn as_mut(&mut self) -> &mut T {\n        &mut *self.as_ptr()\n    }\n}\n\n#[stable(feature = \"nonnull\", since = \"1.24.0\")]\nimpl<T: ?Sized> Clone for NonNull<T> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\n#[stable(feature = \"nonnull\", since = \"1.24.0\")]\nimpl<T: ?Sized> Copy for NonNull<T> { }\n\n#[stable(feature = \"nonnull\", since = \"1.24.0\")]\nimpl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n\n#[stable(feature = \"nonnull\", since = \"1.24.0\")]\nimpl<T: ?Sized> fmt::Pointer for NonNull<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Pointer::fmt(&self.as_ptr(), f)\n    }\n}\n\n#[stable(feature = \"nonnull\", since = \"1.24.0\")]\nimpl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n    fn from(unique: Unique<T>) -> Self {\n        NonNull { pointer: unique.pointer }\n    }\n}\n\n#[stable(feature = \"nonnull\", since = \"1.24.0\")]\nimpl<'a, T: ?Sized> From<&'a mut T> for NonNull<T> {\n    fn from(reference: &'a mut T) -> Self {\n        NonNull { pointer: NonZero::from(reference) }\n    }\n}\n\n#[stable(feature = \"nonnull\", since = \"1.24.0\")]\nimpl<'a, T: ?Sized> From<&'a T> for NonNull<T> {\n    fn from(reference: &'a T) -> Self {\n        NonNull { pointer: NonZero::from(reference) }\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Optional values.\n//!\n//! Type [`Option`] represents an optional value: every [`Option`]\n//! is either [`Some`] and contains a value, or [`None`], and\n//! does not. [`Option`] types are very common in Rust code, as\n//! they have a number of uses:\n//!\n//! * Initial values\n//! * Return values for functions that are not defined\n//!   over their entire input range (partial functions)\n//! * Return value for otherwise reporting simple errors, where `None` is\n//!   returned on error\n//! * Optional struct fields\n//! * Struct fields that can be loaned or \"taken\"\n//! * Optional function arguments\n//! * Nullable pointers\n//! * Swapping things out of difficult situations\n//!\n//! [`Option`]s are commonly paired with pattern matching to query the presence\n//! of a value and take action, always accounting for the [`None`] case.\n//!\n//! ```\n//! fn divide(numerator: f64, denominator: f64) -> Option<f64> {\n//!     if denominator == 0.0 {\n//!         None\n//!     } else {\n//!         Some(numerator / denominator)\n//!     }\n//! }\n//!\n//! // The return value of the function is an option\n//! let result = divide(2.0, 3.0);\n//!\n//! // Pattern match to retrieve the value\n//! match result {\n//!     // The division was valid\n//!     Some(x) => println!(\"Result: {}\", x),\n//!     // The division was invalid\n//!     None    => println!(\"Cannot divide by 0\"),\n//! }\n//! ```\n//!\n//\n// FIXME: Show how `Option` is used in practice, with lots of methods\n//\n//! # Options and pointers (\"nullable\" pointers)\n//!\n//! Rust's pointer types must always point to a valid location; there are\n//! no \"null\" pointers. Instead, Rust has *optional* pointers, like\n//! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n//!\n//! The following example uses [`Option`] to create an optional box of\n//! [`i32`]. Notice that in order to use the inner [`i32`] value first, the\n//! `check_optional` function needs to use pattern matching to\n//! determine whether the box has a value (i.e. it is [`Some(...)`][`Some`]) or\n//! not ([`None`]).\n//!\n//! ```\n//! let optional = None;\n//! check_optional(optional);\n//!\n//! let optional = Some(Box::new(9000));\n//! check_optional(optional);\n//!\n//! fn check_optional(optional: Option<Box<i32>>) {\n//!     match optional {\n//!         Some(ref p) => println!(\"has value {}\", p),\n//!         None => println!(\"has no value\"),\n//!     }\n//! }\n//! ```\n//!\n//! This usage of [`Option`] to create safe nullable pointers is so\n//! common that Rust does special optimizations to make the\n//! representation of [`Option`]`<`[`Box<T>`]`>` a single pointer. Optional pointers\n//! in Rust are stored as efficiently as any other pointer type.\n//!\n//! # Examples\n//!\n//! Basic pattern matching on [`Option`]:\n//!\n//! ```\n//! let msg = Some(\"howdy\");\n//!\n//! // Take a reference to the contained string\n//! if let Some(ref m) = msg {\n//!     println!(\"{}\", *m);\n//! }\n//!\n//! // Remove the contained string, destroying the Option\n//! let unwrapped_msg = msg.unwrap_or(\"default message\");\n//! ```\n//!\n//! Initialize a result to [`None`] before a loop:\n//!\n//! ```\n//! enum Kingdom { Plant(u32, &'static str), Animal(u32, &'static str) }\n//!\n//! // A list of data to search through.\n//! let all_the_big_things = [\n//!     Kingdom::Plant(250, \"redwood\"),\n//!     Kingdom::Plant(230, \"noble fir\"),\n//!     Kingdom::Plant(229, \"sugar pine\"),\n//!     Kingdom::Animal(25, \"blue whale\"),\n//!     Kingdom::Animal(19, \"fin whale\"),\n//!     Kingdom::Animal(15, \"north pacific right whale\"),\n//! ];\n//!\n//! // We're going to search for the name of the biggest animal,\n//! // but to start with we've just got `None`.\n//! let mut name_of_biggest_animal = None;\n//! let mut size_of_biggest_animal = 0;\n//! for big_thing in &all_the_big_things {\n//!     match *big_thing {\n//!         Kingdom::Animal(size, name) if size > size_of_biggest_animal => {\n//!             // Now we've found the name of some big animal\n//!             size_of_biggest_animal = size;\n//!             name_of_biggest_animal = Some(name);\n//!         }\n//!         Kingdom::Animal(..) | Kingdom::Plant(..) => ()\n//!     }\n//! }\n//!\n//! match name_of_biggest_animal {\n//!     Some(name) => println!(\"the biggest animal is {}\", name),\n//!     None => println!(\"there are no animals :(\"),\n//! }\n//! ```\n//!\n//! [`Option`]: enum.Option.html\n//! [`Some`]: enum.Option.html#variant.Some\n//! [`None`]: enum.Option.html#variant.None\n//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n//! [`i32`]: ../../std/primitive.i32.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse iter::{FromIterator, FusedIterator, TrustedLen};\nuse {mem, ops};\n\n// Note that this is not a lang item per se, but it has a hidden dependency on\n// `Iterator`, which is one. The compiler assumes that the `next` method of\n// `Iterator` is an enumeration with one type parameter and two variants,\n// which basically means it must be `Option`.\n\n/// The `Option` type. See [the module level documentation](index.html) for more.\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Option<T> {\n    /// No value\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    None,\n    /// Some value `T`\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Type implementation\n/////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Option<T> {\n    /////////////////////////////////////////////////////////////////////////\n    // Querying the contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns `true` if the option is a [`Some`] value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x: Option<u32> = Some(2);\n    /// assert_eq!(x.is_some(), true);\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.is_some(), false);\n    /// ```\n    ///\n    /// [`Some`]: #variant.Some\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_some(&self) -> bool {\n        match *self {\n            Some(_) => true,\n            None => false,\n        }\n    }\n\n    /// Returns `true` if the option is a [`None`] value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x: Option<u32> = Some(2);\n    /// assert_eq!(x.is_none(), false);\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.is_none(), true);\n    /// ```\n    ///\n    /// [`None`]: #variant.None\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_none(&self) -> bool {\n        !self.is_some()\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Adapter for working with references\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Converts from `Option<T>` to `Option<&T>`.\n    ///\n    /// # Examples\n    ///\n    /// Convert an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n    /// The [`map`] method takes the `self` argument by value, consuming the original,\n    /// so this technique uses `as_ref` to first take an `Option` to a reference\n    /// to the value inside the original.\n    ///\n    /// [`map`]: enum.Option.html#method.map\n    /// [`String`]: ../../std/string/struct.String.html\n    /// [`usize`]: ../../std/primitive.usize.html\n    ///\n    /// ```\n    /// let num_as_str: Option<String> = Some(\"10\".to_string());\n    /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n    /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n    /// let num_as_int: Option<usize> = num_as_str.as_ref().map(|n| n.len());\n    /// println!(\"still can print num_as_str: {:?}\", num_as_str);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_ref(&self) -> Option<&T> {\n        match *self {\n            Some(ref x) => Some(x),\n            None => None,\n        }\n    }\n\n    /// Converts from `Option<T>` to `Option<&mut T>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(2);\n    /// match x.as_mut() {\n    ///     Some(v) => *v = 42,\n    ///     None => {},\n    /// }\n    /// assert_eq!(x, Some(42));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_mut(&mut self) -> Option<&mut T> {\n        match *self {\n            Some(ref mut x) => Some(x),\n            None => None,\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Getting to contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Unwraps an option, yielding the content of a [`Some`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is a [`None`] with a custom panic message provided by\n    /// `msg`.\n    ///\n    /// [`Some`]: #variant.Some\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"value\");\n    /// assert_eq!(x.expect(\"the world is ending\"), \"value\");\n    /// ```\n    ///\n    /// ```{.should_panic}\n    /// let x: Option<&str> = None;\n    /// x.expect(\"the world is ending\"); // panics with `the world is ending`\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn expect(self, msg: &str) -> T {\n        match self {\n            Some(val) => val,\n            None => expect_failed(msg),\n        }\n    }\n\n    /// Moves the value `v` out of the `Option<T>` if it is [`Some(v)`].\n    ///\n    /// In general, because this function may panic, its use is discouraged.\n    /// Instead, prefer to use pattern matching and handle the [`None`]\n    /// case explicitly.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the self value equals [`None`].\n    ///\n    /// [`Some(v)`]: #variant.Some\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"air\");\n    /// assert_eq!(x.unwrap(), \"air\");\n    /// ```\n    ///\n    /// ```{.should_panic}\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.unwrap(), \"air\"); // fails\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap(self) -> T {\n        match self {\n            Some(val) => val,\n            None => panic!(\"called `Option::unwrap()` on a `None` value\"),\n        }\n    }\n\n    /// Returns the contained value or a default.\n    ///\n    /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n    /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n    /// which is lazily evaluated.\n    ///\n    /// [`unwrap_or_else`]: #method.unwrap_or_else\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n    /// assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or(self, def: T) -> T {\n        match self {\n            Some(x) => x,\n            None => def,\n        }\n    }\n\n    /// Returns the contained value or computes it from a closure.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let k = 10;\n    /// assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n    /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Transforming contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n    ///\n    /// # Examples\n    ///\n    /// Convert an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    /// [`usize`]: ../../std/primitive.usize.html\n    ///\n    /// ```\n    /// let maybe_some_string = Some(String::from(\"Hello, World!\"));\n    /// // `Option::map` takes self *by value*, consuming `maybe_some_string`\n    /// let maybe_some_len = maybe_some_string.map(|s| s.len());\n    ///\n    /// assert_eq!(maybe_some_len, Some(13));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }\n\n    /// Applies a function to the contained value (if any),\n    /// or returns the provided default (if not).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.map_or(42, |v| v.len()), 3);\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.map_or(42, |v| v.len()), 42);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {\n        match self {\n            Some(t) => f(t),\n            None => default,\n        }\n    }\n\n    /// Applies a function to the contained value (if any),\n    /// or computes a default (if not).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let k = 21;\n    ///\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3);\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U {\n        match self {\n            Some(t) => f(t),\n            None => default(),\n        }\n    }\n\n    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n    /// [`Ok(v)`] and [`None`] to [`Err(err)`].\n    ///\n    /// Arguments passed to `ok_or` are eagerly evaluated; if you are passing the\n    /// result of a function call, it is recommended to use [`ok_or_else`], which is\n    /// lazily evaluated.\n    ///\n    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`Err(err)`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`None`]: #variant.None\n    /// [`Some(v)`]: #variant.Some\n    /// [`ok_or_else`]: #method.ok_or_else\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.ok_or(0), Ok(\"foo\"));\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.ok_or(0), Err(0));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ok_or<E>(self, err: E) -> Result<T, E> {\n        match self {\n            Some(v) => Ok(v),\n            None => Err(err),\n        }\n    }\n\n    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n    /// [`Ok(v)`] and [`None`] to [`Err(err())`].\n    ///\n    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`Err(err())`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`None`]: #variant.None\n    /// [`Some(v)`]: #variant.Some\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.ok_or_else(|| 0), Ok(\"foo\"));\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.ok_or_else(|| 0), Err(0));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {\n        match self {\n            Some(v) => Ok(v),\n            None => Err(err()),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Iterator constructors\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns an iterator over the possibly contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(4);\n    /// assert_eq!(x.iter().next(), Some(&4));\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.iter().next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<T> {\n        Iter { inner: Item { opt: self.as_ref() } }\n    }\n\n    /// Returns a mutable iterator over the possibly contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(4);\n    /// match x.iter_mut().next() {\n    ///     Some(v) => *v = 42,\n    ///     None => {},\n    /// }\n    /// assert_eq!(x, Some(42));\n    ///\n    /// let mut x: Option<u32> = None;\n    /// assert_eq!(x.iter_mut().next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut { inner: Item { opt: self.as_mut() } }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Boolean operations on the values, eager and lazy\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns [`None`] if the option is [`None`], otherwise returns `optb`.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(2);\n    /// let y: Option<&str> = None;\n    /// assert_eq!(x.and(y), None);\n    ///\n    /// let x: Option<u32> = None;\n    /// let y = Some(\"foo\");\n    /// assert_eq!(x.and(y), None);\n    ///\n    /// let x = Some(2);\n    /// let y = Some(\"foo\");\n    /// assert_eq!(x.and(y), Some(\"foo\"));\n    ///\n    /// let x: Option<u32> = None;\n    /// let y: Option<&str> = None;\n    /// assert_eq!(x.and(y), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n        match self {\n            Some(_) => optb,\n            None => None,\n        }\n    }\n\n    /// Returns [`None`] if the option is [`None`], otherwise calls `f` with the\n    /// wrapped value and returns the result.\n    ///\n    /// Some languages call this operation flatmap.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// fn sq(x: u32) -> Option<u32> { Some(x * x) }\n    /// fn nope(_: u32) -> Option<u32> { None }\n    ///\n    /// assert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\n    /// assert_eq!(Some(2).and_then(sq).and_then(nope), None);\n    /// assert_eq!(Some(2).and_then(nope).and_then(sq), None);\n    /// assert_eq!(None.and_then(sq).and_then(sq), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n        match self {\n            Some(x) => f(x),\n            None => None,\n        }\n    }\n\n    /// Returns `None` if the option is `None`, otherwise calls `predicate`\n    /// with the wrapped value and returns:\n    ///\n    /// - `Some(t)` if `predicate` returns `true` (where `t` is the wrapped\n    ///   value), and\n    /// - `None` if `predicate` returns `false`.\n    ///\n    /// This function works similar to `Iterator::filter()`. You can imagine\n    /// the `Option<T>` being an iterator over one or zero elements. `filter()`\n    /// lets you decide which elements to keep.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// #![feature(option_filter)]\n    ///\n    /// fn is_even(n: &i32) -> bool {\n    ///     n % 2 == 0\n    /// }\n    ///\n    /// assert_eq!(None.filter(is_even), None);\n    /// assert_eq!(Some(3).filter(is_even), None);\n    /// assert_eq!(Some(4).filter(is_even), Some(4));\n    /// ```\n    #[inline]\n    #[unstable(feature = \"option_filter\", issue = \"45860\")]\n    pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {\n        if let Some(x) = self {\n            if predicate(&x) {\n                return Some(x)\n            }\n        }\n        None\n    }\n\n    /// Returns the option if it contains a value, otherwise returns `optb`.\n    ///\n    /// Arguments passed to `or` are eagerly evaluated; if you are passing the\n    /// result of a function call, it is recommended to use [`or_else`], which is\n    /// lazily evaluated.\n    ///\n    /// [`or_else`]: #method.or_else\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(2);\n    /// let y = None;\n    /// assert_eq!(x.or(y), Some(2));\n    ///\n    /// let x = None;\n    /// let y = Some(100);\n    /// assert_eq!(x.or(y), Some(100));\n    ///\n    /// let x = Some(2);\n    /// let y = Some(100);\n    /// assert_eq!(x.or(y), Some(2));\n    ///\n    /// let x: Option<u32> = None;\n    /// let y = None;\n    /// assert_eq!(x.or(y), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or(self, optb: Option<T>) -> Option<T> {\n        match self {\n            Some(_) => self,\n            None => optb,\n        }\n    }\n\n    /// Returns the option if it contains a value, otherwise calls `f` and\n    /// returns the result.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// fn nobody() -> Option<&'static str> { None }\n    /// fn vikings() -> Option<&'static str> { Some(\"vikings\") }\n    ///\n    /// assert_eq!(Some(\"barbarians\").or_else(vikings), Some(\"barbarians\"));\n    /// assert_eq!(None.or_else(vikings), Some(\"vikings\"));\n    /// assert_eq!(None.or_else(nobody), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n        match self {\n            Some(_) => self,\n            None => f(),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Entry-like operations to insert if None and return a reference\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Inserts `v` into the option if it is [`None`], then\n    /// returns a mutable reference to the contained value.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = None;\n    ///\n    /// {\n    ///     let y: &mut u32 = x.get_or_insert(5);\n    ///     assert_eq!(y, &5);\n    ///\n    ///     *y = 7;\n    /// }\n    ///\n    /// assert_eq!(x, Some(7));\n    /// ```\n    #[inline]\n    #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n    pub fn get_or_insert(&mut self, v: T) -> &mut T {\n        match *self {\n            None => *self = Some(v),\n            _ => (),\n        }\n\n        match *self {\n            Some(ref mut v) => v,\n            _ => unreachable!(),\n        }\n    }\n\n    /// Inserts a value computed from `f` into the option if it is [`None`], then\n    /// returns a mutable reference to the contained value.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = None;\n    ///\n    /// {\n    ///     let y: &mut u32 = x.get_or_insert_with(|| 5);\n    ///     assert_eq!(y, &5);\n    ///\n    ///     *y = 7;\n    /// }\n    ///\n    /// assert_eq!(x, Some(7));\n    /// ```\n    #[inline]\n    #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n    pub fn get_or_insert_with<F: FnOnce() -> T>(&mut self, f: F) -> &mut T {\n        match *self {\n            None => *self = Some(f()),\n            _ => (),\n        }\n\n        match *self {\n            Some(ref mut v) => v,\n            _ => unreachable!(),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Misc\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Takes the value out of the option, leaving a [`None`] in its place.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(2);\n    /// x.take();\n    /// assert_eq!(x, None);\n    ///\n    /// let mut x: Option<u32> = None;\n    /// x.take();\n    /// assert_eq!(x, None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn take(&mut self) -> Option<T> {\n        mem::replace(self, None)\n    }\n}\n\nimpl<'a, T: Clone> Option<&'a T> {\n    /// Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n    /// option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 12;\n    /// let opt_x = Some(&x);\n    /// assert_eq!(opt_x, Some(&12));\n    /// let cloned = opt_x.cloned();\n    /// assert_eq!(cloned, Some(12));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn cloned(self) -> Option<T> {\n        self.map(|t| t.clone())\n    }\n}\n\nimpl<'a, T: Clone> Option<&'a mut T> {\n    /// Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the\n    /// option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(option_ref_mut_cloned)]\n    /// let mut x = 12;\n    /// let opt_x = Some(&mut x);\n    /// assert_eq!(opt_x, Some(&mut 12));\n    /// let cloned = opt_x.cloned();\n    /// assert_eq!(cloned, Some(12));\n    /// ```\n    #[unstable(feature = \"option_ref_mut_cloned\", issue = \"43738\")]\n    pub fn cloned(self) -> Option<T> {\n        self.map(|t| t.clone())\n    }\n}\n\nimpl<T: Default> Option<T> {\n    /// Returns the contained value or a default\n    ///\n    /// Consumes the `self` argument then, if [`Some`], returns the contained\n    /// value, otherwise if [`None`], returns the [default value] for that\n    /// type.\n    ///\n    /// # Examples\n    ///\n    /// Convert a string to an integer, turning poorly-formed strings\n    /// into 0 (the default value for integers). [`parse`] converts\n    /// a string to any other type that implements [`FromStr`], returning\n    /// [`None`] on error.\n    ///\n    /// ```\n    /// let good_year_from_input = \"1909\";\n    /// let bad_year_from_input = \"190blarg\";\n    /// let good_year = good_year_from_input.parse().ok().unwrap_or_default();\n    /// let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n    ///\n    /// assert_eq!(1909, good_year);\n    /// assert_eq!(0, bad_year);\n    /// ```\n    ///\n    /// [`Some`]: #variant.Some\n    /// [`None`]: #variant.None\n    /// [default value]: ../default/trait.Default.html#tymethod.default\n    /// [`parse`]: ../../std/primitive.str.html#method.parse\n    /// [`FromStr`]: ../../std/str/trait.FromStr.html\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or_default(self) -> T {\n        match self {\n            Some(x) => x,\n            None => Default::default(),\n        }\n    }\n}\n\nimpl<T, E> Option<Result<T, E>> {\n    /// Transposes an `Option` of a `Result` into a `Result` of an `Option`.\n    ///\n    /// `None` will be mapped to `Ok(None)`.\n    /// `Some(Ok(_))` and `Some(Err(_))` will be mapped to `Ok(Some(_))` and `Err(_)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(transpose_result)]\n    ///\n    /// #[derive(Debug, Eq, PartialEq)]\n    /// struct SomeErr;\n    ///\n    /// let x: Result<Option<i32>, SomeErr> = Ok(Some(5));\n    /// let y: Option<Result<i32, SomeErr>> = Some(Ok(5));\n    /// assert_eq!(x, y.transpose());\n    /// ```\n    #[inline]\n    #[unstable(feature = \"transpose_result\", issue = \"47338\")]\n    pub fn transpose(self) -> Result<Option<T>, E> {\n        match self {\n            Some(Ok(x)) => Ok(Some(x)),\n            Some(Err(e)) => Err(e),\n            None => Ok(None),\n        }\n    }\n}\n\n// This is a separate function to reduce the code size of .expect() itself.\n#[inline(never)]\n#[cold]\nfn expect_failed(msg: &str) -> ! {\n    panic!(\"{}\", msg)\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Trait implementations\n/////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for Option<T> {\n    /// Returns [`None`].\n    ///\n    /// [`None`]: #variant.None\n    #[inline]\n    fn default() -> Option<T> { None }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> IntoIterator for Option<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Returns a consuming iterator over the possibly contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"string\");\n    /// let v: Vec<&str> = x.into_iter().collect();\n    /// assert_eq!(v, [\"string\"]);\n    ///\n    /// let x = None;\n    /// let v: Vec<&str> = x.into_iter().collect();\n    /// assert!(v.is_empty());\n    /// ```\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n        IntoIter { inner: Item { opt: self } }\n    }\n}\n\n#[stable(since = \"1.4.0\", feature = \"option_iter\")]\nimpl<'a, T> IntoIterator for &'a Option<T> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(since = \"1.4.0\", feature = \"option_iter\")]\nimpl<'a, T> IntoIterator for &'a mut Option<T> {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n        self.iter_mut()\n    }\n}\n\n#[stable(since = \"1.12.0\", feature = \"option_from\")]\nimpl<T> From<T> for Option<T> {\n    fn from(val: T) -> Option<T> {\n        Some(val)\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The Option Iterators\n/////////////////////////////////////////////////////////////////////////////\n\n#[derive(Clone, Debug)]\nstruct Item<A> {\n    opt: Option<A>\n}\n\nimpl<A> Iterator for Item<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        self.opt.take()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match self.opt {\n            Some(_) => (1, Some(1)),\n            None => (0, Some(0)),\n        }\n    }\n}\n\nimpl<A> DoubleEndedIterator for Item<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A> {\n        self.opt.take()\n    }\n}\n\nimpl<A> ExactSizeIterator for Item<A> {}\nimpl<A> FusedIterator for Item<A> {}\nunsafe impl<A> TrustedLen for Item<A> {}\n\n/// An iterator over a reference to the [`Some`] variant of an [`Option`].\n///\n/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n///\n/// This `struct` is created by the [`Option::iter`] function.\n///\n/// [`Option`]: enum.Option.html\n/// [`Some`]: enum.Option.html#variant.Some\n/// [`Option::iter`]: enum.Option.html#method.iter\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> Iterator for Iter<'a, A> {\n    type Item = &'a A;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a A> { self.inner.next() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, A> FusedIterator for Iter<'a, A> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, A> TrustedLen for Iter<'a, A> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> Clone for Iter<'a, A> {\n    fn clone(&self) -> Iter<'a, A> {\n        Iter { inner: self.inner.clone() }\n    }\n}\n\n/// An iterator over a mutable reference to the [`Some`] variant of an [`Option`].\n///\n/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n///\n/// This `struct` is created by the [`Option::iter_mut`] function.\n///\n/// [`Option`]: enum.Option.html\n/// [`Some`]: enum.Option.html#variant.Some\n/// [`Option::iter_mut`]: enum.Option.html#method.iter_mut\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> Iterator for IterMut<'a, A> {\n    type Item = &'a mut A;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, A> FusedIterator for IterMut<'a, A> {}\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n\n/// An iterator over the value in [`Some`] variant of an [`Option`].\n///\n/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n///\n/// This `struct` is created by the [`Option::into_iter`] function.\n///\n/// [`Option`]: enum.Option.html\n/// [`Some`]: enum.Option.html#variant.Some\n/// [`Option::into_iter`]: enum.Option.html#method.into_iter\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<A> { inner: Item<A> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> Iterator for IntoIter<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> { self.inner.next() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> DoubleEndedIterator for IntoIter<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> ExactSizeIterator for IntoIter<A> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<A> FusedIterator for IntoIter<A> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A> TrustedLen for IntoIter<A> {}\n\n/////////////////////////////////////////////////////////////////////////////\n// FromIterator\n/////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n    /// Takes each element in the [`Iterator`]: if it is [`None`], no further\n    /// elements are taken, and the [`None`] is returned. Should no [`None`] occur, a\n    /// container with the values of each `Option` is returned.\n    ///\n    /// Here is an example which increments every integer in a vector,\n    /// checking for overflow:\n    ///\n    /// ```\n    /// use std::u16;\n    ///\n    /// let v = vec![1, 2];\n    /// let res: Option<Vec<u16>> = v.iter().map(|&x: &u16|\n    ///     if x == u16::MAX { None }\n    ///     else { Some(x + 1) }\n    /// ).collect();\n    /// assert!(res == Some(vec![2, 3]));\n    /// ```\n    ///\n    /// [`Iterator`]: ../iter/trait.Iterator.html\n    /// [`None`]: enum.Option.html#variant.None\n    #[inline]\n    fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> {\n        // FIXME(#11084): This could be replaced with Iterator::scan when this\n        // performance bug is closed.\n\n        struct Adapter<Iter> {\n            iter: Iter,\n            found_none: bool,\n        }\n\n        impl<T, Iter: Iterator<Item=Option<T>>> Iterator for Adapter<Iter> {\n            type Item = T;\n\n            #[inline]\n            fn next(&mut self) -> Option<T> {\n                match self.iter.next() {\n                    Some(Some(value)) => Some(value),\n                    Some(None) => {\n                        self.found_none = true;\n                        None\n                    }\n                    None => None,\n                }\n            }\n        }\n\n        let mut adapter = Adapter { iter: iter.into_iter(), found_none: false };\n        let v: V = FromIterator::from_iter(adapter.by_ref());\n\n        if adapter.found_none {\n            None\n        } else {\n            Some(v)\n        }\n    }\n}\n\n/// The error type that results from applying the try operator (`?`) to a `None` value. If you wish\n/// to allow `x?` (where `x` is an `Option<T>`) to be converted into your error type, you can\n/// implement `impl From<NoneError>` for `YourErrorType`. In that case, `x?` within a function that\n/// returns `Result<_, YourErrorType>` will translate a `None` value into an `Err` result.\n#[unstable(feature = \"try_trait\", issue = \"42327\")]\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\npub struct NoneError;\n\n#[unstable(feature = \"try_trait\", issue = \"42327\")]\nimpl<T> ops::Try for Option<T> {\n    type Ok = T;\n    type Error = NoneError;\n\n    fn into_result(self) -> Result<T, NoneError> {\n        self.ok_or(NoneError)\n    }\n\n    fn from_ok(v: T) -> Self {\n        Some(v)\n    }\n\n    fn from_error(_: NoneError) -> Self {\n        None\n    }\n}\n","/* Copyright 2017 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nuse std::io::Write;\nuse std::io::Result;\n\nuse wasmparser::ParserState;\nuse wasmparser::ExternalKind;\nuse wasmparser::Type;\nuse wasmparser::FuncType;\nuse wasmparser::TableType;\nuse wasmparser::MemoryType;\nuse wasmparser::GlobalType;\nuse wasmparser::ImportSectionEntryType;\nuse wasmparser::ResizableLimits;\nuse wasmparser::Operator;\nuse wasmparser::BrTable;\nuse wasmparser::MemoryImmediate;\nuse wasmparser::Ieee32;\nuse wasmparser::Ieee64;\n\nmacro_rules! format_to_vec {\n    ($fmt:expr, $($arg:tt)+) => {{\n        let mut name = Vec::new();\n        let s = &format!($fmt, $($arg)+);\n        name.extend_from_slice(s.as_bytes());\n        name\n    }};\n}\n\nfn get_func_name(index: u32, is_import: bool, _is_ref: bool) -> Vec<u8> {\n    if is_import {\n        format_to_vec!(\"$import{}\", index)\n    } else {\n        format_to_vec!(\"$func{}\", index)\n    }\n}\n\nfn get_global_name(index: u32, _is_ref: bool) -> Vec<u8> {\n    format_to_vec!(\"$global{}\", index)\n}\n\nfn get_table_name(index: u32, _is_ref: bool) -> Vec<u8> {\n    format_to_vec!(\"$table{}\", index)\n}\n\nfn get_memory_name(index: u32, is_ref: bool) -> Vec<u8> {\n    if is_ref {\n        format_to_vec!(\"{}\", index)\n    } else {\n        format_to_vec!(\"(;{};)\", index)\n    }\n}\n\nfn get_type_name(index: u32, _is_ref: bool) -> Vec<u8> {\n    format_to_vec!(\"$type{}\", index)\n}\n\nfn get_var_name(_func_index: u32, index: u32, _is_ref: bool) -> Vec<u8> {\n    format_to_vec!(\"$var{}\", index)\n}\n\nfn get_label(index: u32) -> Option<Vec<u8>> {\n    Some(format_to_vec!(\"$label{}\", index))\n}\n\n// Original can be found at\n// https://github.com/stoklund/cretonne/blob/dc809628f4c/lib/cretonne/src/ir/immediates.rs#L299\n//\n// Format a floating point number in a way that is reasonably human-readable, and that can be\n// converted back to binary without any rounding issues. The hexadecimal formatting of normal and\n// subnormal numbers is compatible with C99 and the `printf \"%a\"` format specifier. The NaN and Inf\n// formats are not supported by C99.\n//\n// The encoding parameters are:\n//\n// w - exponent field width in bits\n// t - trailing significand field width in bits\n//\nfn format_float(bits: u64, w: u8, t: u8) -> Vec<u8> {\n    debug_assert!(w > 0 && w <= 16, \"Invalid exponent range\");\n    debug_assert!(1 + w + t <= 64, \"Too large IEEE format for u64\");\n    debug_assert!((t + w + 1).is_power_of_two(), \"Unexpected IEEE format size\");\n\n    let max_e_bits = (1u64 << w) - 1;\n    let t_bits = bits & ((1u64 << t) - 1); // Trailing significand.\n    let e_bits = (bits >> t) & max_e_bits; // Biased exponent.\n    let sign_bit = (bits >> (w + t)) & 1;\n\n    let bias: i32 = (1 << (w - 1)) - 1;\n    let e = e_bits as i32 - bias; // Unbiased exponent.\n    let emin = 1 - bias; // Minimum exponent.\n\n    // How many hexadecimal digits are needed for the trailing significand?\n    let digits = (t + 3) / 4;\n    // Trailing significand left-aligned in `digits` hexadecimal digits.\n    let left_t_bits = t_bits << (4 * digits - t);\n\n    let mut result = Vec::new();\n    // All formats share the leading sign.\n    if sign_bit != 0 {\n        result.push(b'-');\n    }\n\n    if e_bits == 0 {\n        if t_bits == 0 {\n            // Zero.\n            result.extend_from_slice(b\"0.0\");\n        } else {\n            // Subnormal.\n            result\n                .extend_from_slice(format!(\"0x0.{0:01$x}p{2}\", left_t_bits, digits as usize, emin)\n                                       .as_bytes());\n        }\n    } else if e_bits == max_e_bits {\n        if t_bits == 0 {\n            // Infinity.\n            result.extend_from_slice(b\"inf\");\n        } else {\n            // NaN.\n            let default_payload = 1 << (t - 1);\n            if t_bits != default_payload {\n                result.extend_from_slice(format!(\"nan:0x{:x}\", t_bits).as_bytes());\n            } else {\n                result.extend_from_slice(b\"nan\")\n            }\n        }\n    } else {\n        // Normal number.\n        result.extend_from_slice(format!(\"0x1.{0:01$x}p{2}\", left_t_bits, digits as usize, e)\n                                     .as_bytes());\n    }\n    result\n}\n\nstruct BackrefLabel {\n    use_label: bool,\n    label: Option<Vec<u8>>,\n    buffer: Vec<u8>,\n}\n\npub struct Writer<'a> {\n    writable: &'a mut Write,\n    types: Vec<FuncType>,\n    func_types: Vec<u32>,\n    func_index: usize,\n    import_count: usize,\n    global_count: usize,\n    table_count: usize,\n    memory_count: usize,\n    indent: u32,\n    label_index: usize,\n    backref_labels: Vec<BackrefLabel>,\n}\n\nimpl<'a> Writer<'a> {\n    pub fn new(writable: &mut Write) -> Writer {\n        Writer {\n            writable,\n            types: Vec::new(),\n            func_types: Vec::new(),\n            func_index: 0,\n            import_count: 0,\n            global_count: 0,\n            table_count: 0,\n            memory_count: 0,\n            indent: 0,\n            label_index: 0,\n            backref_labels: Vec::new(),\n        }\n    }\n\n    fn w(&mut self) -> &mut Write {\n        if !self.backref_labels.is_empty() {\n            return &mut self.backref_labels.last_mut().unwrap().buffer;\n        }\n        self.writable\n    }\n\n    fn write_bytes(&mut self, bytes: &[u8]) -> Result<()> {\n        self.w().write_all(bytes)\n    }\n\n    fn write_string_chunk(&mut self, bytes: &[u8]) -> Result<()> {\n        let mut i = 0;\n        let mut j = 0;\n        while i < bytes.len() {\n            let byte = bytes[i];\n            if byte < 0x20 || byte >= 0x7F || byte == b'\\\"' || byte == b'\\\\' {\n                if j < i {\n                    self.write_bytes(&bytes[j..i])?;\n                }\n                self.w().write_fmt(format_args!(\"\\\\{:02x}\", byte))?;\n                j = i + 1;\n            }\n            i += 1;\n        }\n        if j < bytes.len() {\n            self.write_bytes(&bytes[j..])?;\n        }\n        Ok(())\n    }\n\n    fn write_string(&mut self, bytes: &[u8]) -> Result<()> {\n        self.write_bytes(b\"\\\"\")?;\n        self.write_string_chunk(bytes)?;\n        self.write_bytes(b\"\\\"\")?;\n        Ok(())\n    }\n\n    fn write_u32(&mut self, num: u32) -> Result<()> {\n        self.w().write_fmt(format_args!(\"{}\", num))\n    }\n\n    fn write_type(&mut self, ty: Type) -> Result<()> {\n        match ty {\n            Type::I32 => self.write_bytes(b\"i32\"),\n            Type::I64 => self.write_bytes(b\"i64\"),\n            Type::F32 => self.write_bytes(b\"f32\"),\n            Type::F64 => self.write_bytes(b\"f64\"),\n            Type::AnyFunc => self.write_bytes(b\"anyfunc\"),\n            _ => panic!(\"Unexpected type\"),\n        }\n    }\n\n    fn write_func_type(&mut self, func_type: &FuncType) -> Result<()> {\n        if let Type::Func = func_type.form {\n            if func_type.params.len() > 0 {\n                self.write_bytes(b\" (param\")?;\n                for i in 0..func_type.params.len() {\n                    self.write_bytes(b\" \")?;\n                    self.write_type(func_type.params[i])?;\n                }\n                self.write_bytes(b\")\")?;\n            }\n            if func_type.returns.len() > 0 {\n                self.write_bytes(b\" (result\")?;\n                for i in 0..func_type.returns.len() {\n                    self.write_bytes(b\" \")?;\n                    self.write_type(func_type.returns[i])?;\n                }\n                self.write_bytes(b\")\")?;\n            }\n        } else {\n            panic!(\"NYI other function form\");\n        }\n        Ok(())\n    }\n\n    fn write_limits(&mut self, limits: &ResizableLimits) -> Result<()> {\n        self.write_u32(limits.initial)?;\n        if let Some(maximum) = limits.maximum {\n            self.write_bytes(b\" \")?;\n            self.write_u32(maximum)?;\n        }\n        Ok(())\n    }\n\n    fn write_global_type(&mut self, global_type: &GlobalType) -> Result<()> {\n        if !global_type.mutable {\n            return self.write_type(global_type.content_type);\n        }\n        self.write_bytes(b\"(mut \")?;\n        self.write_type(global_type.content_type)?;\n        self.write_bytes(b\")\")\n    }\n\n    fn write_br_table(&mut self, br_table: &BrTable) -> Result<()> {\n        for index in br_table {\n            self.write_bytes(b\" \")?;\n            self.use_label(index)?;\n        }\n        Ok(())\n    }\n\n    fn write_func_name_ref(&mut self, func_index: u32) -> Result<()> {\n        let is_import = (func_index as usize) < self.import_count;\n        self.write_bytes(&get_func_name(func_index, is_import, true))\n    }\n\n    fn write_local_name_ref(&mut self, local_index: u32) -> Result<()> {\n        let func_index = self.func_index as u32;\n        self.write_bytes(&get_var_name(func_index, local_index, true))\n    }\n\n    fn write_global_name_ref(&mut self, index: u32) -> Result<()> {\n        self.write_bytes(&get_global_name(index, true))\n    }\n\n    fn write_i32(&mut self, value: i32) -> Result<()> {\n        let s = format!(\"{}\", value);\n        self.write_bytes(s.as_bytes())\n    }\n\n    fn write_i64(&mut self, value: i64) -> Result<()> {\n        let s = format!(\"{}\", value);\n        self.write_bytes(s.as_bytes())\n    }\n\n    fn write_f32(&mut self, value: &Ieee32) -> Result<()> {\n        let bits = value.bits();\n        self.write_bytes(&format_float(bits as u64, 8, 23))\n    }\n\n    fn write_f64(&mut self, value: &Ieee64) -> Result<()> {\n        let bits = value.bits();\n        self.write_bytes(&format_float(bits, 11, 52))\n    }\n\n    fn write_block_type(&mut self, block_type: Type) -> Result<()> {\n        if let Type::EmptyBlockType = block_type {\n            return Ok(());\n        }\n        self.write_bytes(b\" (result \")?;\n        self.write_type(block_type)?;\n        self.write_bytes(b\")\")\n    }\n\n    fn write_memarg(&mut self, memarg: &MemoryImmediate, default_align_flags: u32) -> Result<()> {\n        if memarg.offset != 0 {\n            self.write_bytes(b\" offset=\")?;\n            self.write_u32(memarg.offset)?;\n        }\n        if memarg.flags != default_align_flags {\n            // hide default flags\n            self.write_bytes(b\" align=\")?;\n            self.write_u32(1 << memarg.flags)?;\n        }\n        Ok(())\n    }\n\n    fn start_label_block(&mut self) {\n        let buffer = Vec::new();\n        self.backref_labels\n            .push(BackrefLabel {\n                      use_label: false,\n                      label: None,\n                      buffer: buffer,\n                  });\n    }\n\n    fn end_label_block(&mut self) -> Result<()> {\n        let backref_label = self.backref_labels.pop().unwrap();\n        if backref_label.label.is_none() {\n            return self.write_bytes(&backref_label.buffer);\n        }\n        let label = backref_label.label.unwrap();\n        self.write_bytes(b\" \")?;\n        self.write_bytes(&label)?;\n        self.write_bytes(&backref_label.buffer)?;\n        self.write_bytes(b\" \")?;\n        self.write_bytes(&label)\n    }\n\n    fn use_label(&mut self, depth: u32) -> Result<()> {\n        if depth as usize >= self.backref_labels.len() {\n            return self.write_u32(depth);\n        }\n        let index = self.backref_labels.len() - 1 - (depth as usize);\n        {\n            let ref mut backref_label = self.backref_labels[index];\n            if !backref_label.use_label {\n                backref_label.label = get_label(self.label_index as u32);\n                self.label_index += 1;\n                backref_label.use_label = true;\n            }\n        }\n\n        if self.backref_labels[index].label.is_none() {\n            self.write_u32(depth)\n        } else {\n            let label = self.backref_labels[index].label.as_ref().unwrap().clone();\n            self.write_bytes(&label)\n        }\n    }\n\n    fn write_operator(&mut self, operator: &Operator) -> Result<()> {\n        match *operator {\n            Operator::Unreachable => self.write_bytes(b\"unreachable\"),\n            Operator::Nop => self.write_bytes(b\"nop\"),\n            Operator::Block { ty } => {\n                self.write_bytes(b\"block\")?;\n                self.start_label_block();\n                self.write_block_type(ty)\n            }\n            Operator::Loop { ty } => {\n                self.write_bytes(b\"loop\")?;\n                self.start_label_block();\n                self.write_block_type(ty)\n            }\n            Operator::If { ty } => {\n                self.write_bytes(b\"if\")?;\n                self.start_label_block();\n                self.write_block_type(ty)\n            }\n            Operator::Else => self.write_bytes(b\"else\"),\n            Operator::End => {\n                self.write_bytes(b\"end\")?;\n                self.end_label_block()\n            }\n            Operator::Br { relative_depth } => {\n                self.write_bytes(b\"br \")?;\n                self.use_label(relative_depth)\n            }\n            Operator::BrIf { relative_depth } => {\n                self.write_bytes(b\"br_if \")?;\n                self.use_label(relative_depth)\n            }\n            Operator::BrTable { ref table } => {\n                self.write_bytes(b\"br_table\")?;\n                self.write_br_table(table)\n            }\n            Operator::Return => self.write_bytes(b\"return\"),\n            Operator::Call { function_index } => {\n                self.write_bytes(b\"call \")?;\n                self.write_func_name_ref(function_index)\n            }\n            Operator::CallIndirect { index, .. } => {\n                self.write_bytes(b\"call_indirect \")?;\n                self.write_bytes(&get_type_name(index, true))\n            }\n            Operator::Drop => self.write_bytes(b\"drop\"),\n            Operator::Select => self.write_bytes(b\"select\"),\n            Operator::GetLocal { local_index } => {\n                self.write_bytes(b\"get_local \")?;\n                self.write_local_name_ref(local_index)\n            }\n            Operator::SetLocal { local_index } => {\n                self.write_bytes(b\"set_local \")?;\n                self.write_local_name_ref(local_index)\n            }\n            Operator::TeeLocal { local_index } => {\n                self.write_bytes(b\"tee_local \")?;\n                self.write_local_name_ref(local_index)\n            }\n            Operator::GetGlobal { global_index } => {\n                self.write_bytes(b\"get_global \")?;\n                self.write_global_name_ref(global_index)\n            }\n            Operator::SetGlobal { global_index } => {\n                self.write_bytes(b\"set_global \")?;\n                self.write_global_name_ref(global_index)\n            }\n            Operator::I32Load { ref memarg } => {\n                self.write_bytes(b\"i32.load\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64Load { ref memarg } => {\n                self.write_bytes(b\"i64.load\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::F32Load { ref memarg } => {\n                self.write_bytes(b\"f32.load\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::F64Load { ref memarg } => {\n                self.write_bytes(b\"f64.load\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::I32Load8S { ref memarg } => {\n                self.write_bytes(b\"i32.load8_s\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I32Load8U { ref memarg } => {\n                self.write_bytes(b\"i32.load8_u\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I32Load16S { ref memarg } => {\n                self.write_bytes(b\"i32.load16_s\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I32Load16U { ref memarg } => {\n                self.write_bytes(b\"i32.load16_u\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64Load8S { ref memarg } => {\n                self.write_bytes(b\"i64.load8_s\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I64Load8U { ref memarg } => {\n                self.write_bytes(b\"i64.load8_u\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I64Load16S { ref memarg } => {\n                self.write_bytes(b\"i64.load16_s\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64Load16U { ref memarg } => {\n                self.write_bytes(b\"i64.load16_u\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64Load32S { ref memarg } => {\n                self.write_bytes(b\"i64.load32_s\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64Load32U { ref memarg } => {\n                self.write_bytes(b\"i64.load32_u\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I32Store { ref memarg } => {\n                self.write_bytes(b\"i32.store\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64Store { ref memarg } => {\n                self.write_bytes(b\"i64.store\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::F32Store { ref memarg } => {\n                self.write_bytes(b\"f32.store\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::F64Store { ref memarg } => {\n                self.write_bytes(b\"f64.store\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::I32Store8 { ref memarg } => {\n                self.write_bytes(b\"i32.store8\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I32Store16 { ref memarg } => {\n                self.write_bytes(b\"i32.store16\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64Store8 { ref memarg } => {\n                self.write_bytes(b\"i64.store8\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I64Store16 { ref memarg } => {\n                self.write_bytes(b\"i64.store16\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64Store32 { ref memarg } => {\n                self.write_bytes(b\"i64.store32\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::CurrentMemory { .. } => self.write_bytes(b\"current_memory\"),\n            Operator::GrowMemory { .. } => self.write_bytes(b\"grow_memory\"),\n            Operator::I32Const { value } => {\n                self.write_bytes(b\"i32.const \")?;\n                self.write_i32(value)\n            }\n            Operator::I64Const { value } => {\n                self.write_bytes(b\"i64.const \")?;\n                self.write_i64(value)\n            }\n            Operator::F32Const { ref value } => {\n                self.write_bytes(b\"f32.const \")?;\n                self.write_f32(value)\n            }\n            Operator::F64Const { ref value } => {\n                self.write_bytes(b\"f64.const \")?;\n                self.write_f64(value)\n            }\n            Operator::I32Eqz => self.write_bytes(b\"i32.eqz\"),\n            Operator::I32Eq => self.write_bytes(b\"i32.eq\"),\n            Operator::I32Ne => self.write_bytes(b\"i32.ne\"),\n            Operator::I32LtS => self.write_bytes(b\"i32.lt_s\"),\n            Operator::I32LtU => self.write_bytes(b\"i32.lt_u\"),\n            Operator::I32GtS => self.write_bytes(b\"i32.gt_s\"),\n            Operator::I32GtU => self.write_bytes(b\"i32.gt_u\"),\n            Operator::I32LeS => self.write_bytes(b\"i32.le_s\"),\n            Operator::I32LeU => self.write_bytes(b\"i32.le_u\"),\n            Operator::I32GeS => self.write_bytes(b\"i32.ge_s\"),\n            Operator::I32GeU => self.write_bytes(b\"i32.ge_u\"),\n            Operator::I64Eqz => self.write_bytes(b\"i64.eqz\"),\n            Operator::I64Eq => self.write_bytes(b\"i64.eq\"),\n            Operator::I64Ne => self.write_bytes(b\"i64.ne\"),\n            Operator::I64LtS => self.write_bytes(b\"i64.lt_s\"),\n            Operator::I64LtU => self.write_bytes(b\"i64.lt_u\"),\n            Operator::I64GtS => self.write_bytes(b\"i64.gt_s\"),\n            Operator::I64GtU => self.write_bytes(b\"i64.gt_u\"),\n            Operator::I64LeS => self.write_bytes(b\"i64.le_s\"),\n            Operator::I64LeU => self.write_bytes(b\"i64.le_u\"),\n            Operator::I64GeS => self.write_bytes(b\"i64.ge_s\"),\n            Operator::I64GeU => self.write_bytes(b\"i64.ge_u\"),\n            Operator::F32Eq => self.write_bytes(b\"f32.eq\"),\n            Operator::F32Ne => self.write_bytes(b\"f32.ne\"),\n            Operator::F32Lt => self.write_bytes(b\"f32.lt\"),\n            Operator::F32Gt => self.write_bytes(b\"f32.gt\"),\n            Operator::F32Le => self.write_bytes(b\"f32.le\"),\n            Operator::F32Ge => self.write_bytes(b\"f32.ge\"),\n            Operator::F64Eq => self.write_bytes(b\"f64.eq\"),\n            Operator::F64Ne => self.write_bytes(b\"f64.ne\"),\n            Operator::F64Lt => self.write_bytes(b\"f64.lt\"),\n            Operator::F64Gt => self.write_bytes(b\"f64.gt\"),\n            Operator::F64Le => self.write_bytes(b\"f64.le\"),\n            Operator::F64Ge => self.write_bytes(b\"f64.ge\"),\n            Operator::I32Clz => self.write_bytes(b\"i32.clz\"),\n            Operator::I32Ctz => self.write_bytes(b\"i32.ctz\"),\n            Operator::I32Popcnt => self.write_bytes(b\"i32.popcnt\"),\n            Operator::I32Add => self.write_bytes(b\"i32.add\"),\n            Operator::I32Sub => self.write_bytes(b\"i32.sub\"),\n            Operator::I32Mul => self.write_bytes(b\"i32.mul\"),\n            Operator::I32DivS => self.write_bytes(b\"i32.div_s\"),\n            Operator::I32DivU => self.write_bytes(b\"i32.div_u\"),\n            Operator::I32RemS => self.write_bytes(b\"i32.rem_s\"),\n            Operator::I32RemU => self.write_bytes(b\"i32.rem_u\"),\n            Operator::I32And => self.write_bytes(b\"i32.and\"),\n            Operator::I32Or => self.write_bytes(b\"i32.or\"),\n            Operator::I32Xor => self.write_bytes(b\"i32.xor\"),\n            Operator::I32Shl => self.write_bytes(b\"i32.shl\"),\n            Operator::I32ShrS => self.write_bytes(b\"i32.shr_s\"),\n            Operator::I32ShrU => self.write_bytes(b\"i32.shr_u\"),\n            Operator::I32Rotl => self.write_bytes(b\"i32.rotl\"),\n            Operator::I32Rotr => self.write_bytes(b\"i32.rotr\"),\n            Operator::I64Clz => self.write_bytes(b\"i64.clz\"),\n            Operator::I64Ctz => self.write_bytes(b\"i64.ctz\"),\n            Operator::I64Popcnt => self.write_bytes(b\"i64.popcnt\"),\n            Operator::I64Add => self.write_bytes(b\"i64.add\"),\n            Operator::I64Sub => self.write_bytes(b\"i64.sub\"),\n            Operator::I64Mul => self.write_bytes(b\"i64.mul\"),\n            Operator::I64DivS => self.write_bytes(b\"i64.div_s\"),\n            Operator::I64DivU => self.write_bytes(b\"i64.div_u\"),\n            Operator::I64RemS => self.write_bytes(b\"i64.rem_s\"),\n            Operator::I64RemU => self.write_bytes(b\"i64.rem_u\"),\n            Operator::I64And => self.write_bytes(b\"i64.and\"),\n            Operator::I64Or => self.write_bytes(b\"i64.or\"),\n            Operator::I64Xor => self.write_bytes(b\"i64.xor\"),\n            Operator::I64Shl => self.write_bytes(b\"i64.shl\"),\n            Operator::I64ShrS => self.write_bytes(b\"i64.shr_s\"),\n            Operator::I64ShrU => self.write_bytes(b\"i64.shr_u\"),\n            Operator::I64Rotl => self.write_bytes(b\"i64.rotl\"),\n            Operator::I64Rotr => self.write_bytes(b\"i64.rotr\"),\n            Operator::F32Abs => self.write_bytes(b\"f32.abs\"),\n            Operator::F32Neg => self.write_bytes(b\"f32.neg\"),\n            Operator::F32Ceil => self.write_bytes(b\"f32.ceil\"),\n            Operator::F32Floor => self.write_bytes(b\"f32.floor\"),\n            Operator::F32Trunc => self.write_bytes(b\"f32.trunc\"),\n            Operator::F32Nearest => self.write_bytes(b\"f32.nearest\"),\n            Operator::F32Sqrt => self.write_bytes(b\"f32.sqrt\"),\n            Operator::F32Add => self.write_bytes(b\"f32.add\"),\n            Operator::F32Sub => self.write_bytes(b\"f32.sub\"),\n            Operator::F32Mul => self.write_bytes(b\"f32.mul\"),\n            Operator::F32Div => self.write_bytes(b\"f32.div\"),\n            Operator::F32Min => self.write_bytes(b\"f32.min\"),\n            Operator::F32Max => self.write_bytes(b\"f32.max\"),\n            Operator::F32Copysign => self.write_bytes(b\"f32.copysign\"),\n            Operator::F64Abs => self.write_bytes(b\"f64.abs\"),\n            Operator::F64Neg => self.write_bytes(b\"f64.neg\"),\n            Operator::F64Ceil => self.write_bytes(b\"f64.ceil\"),\n            Operator::F64Floor => self.write_bytes(b\"f64.floor\"),\n            Operator::F64Trunc => self.write_bytes(b\"f64.trunc\"),\n            Operator::F64Nearest => self.write_bytes(b\"f64.nearest\"),\n            Operator::F64Sqrt => self.write_bytes(b\"f64.sqrt\"),\n            Operator::F64Add => self.write_bytes(b\"f64.add\"),\n            Operator::F64Sub => self.write_bytes(b\"f64.sub\"),\n            Operator::F64Mul => self.write_bytes(b\"f64.mul\"),\n            Operator::F64Div => self.write_bytes(b\"f64.div\"),\n            Operator::F64Min => self.write_bytes(b\"f64.min\"),\n            Operator::F64Max => self.write_bytes(b\"f64.max\"),\n            Operator::F64Copysign => self.write_bytes(b\"f64.copysign\"),\n            Operator::I32WrapI64 => self.write_bytes(b\"i32.wrap/i64\"),\n            Operator::I32TruncSF32 => self.write_bytes(b\"i32.trunc_s/f32\"),\n            Operator::I32TruncUF32 => self.write_bytes(b\"i32.trunc_u/f32\"),\n            Operator::I32TruncSF64 => self.write_bytes(b\"i32.trunc_s/f64\"),\n            Operator::I32TruncUF64 => self.write_bytes(b\"i32.trunc_u/f64\"),\n            Operator::I64ExtendSI32 => self.write_bytes(b\"i64.extend_s/i32\"),\n            Operator::I64ExtendUI32 => self.write_bytes(b\"i64.extend_u/i32\"),\n            Operator::I64TruncSF32 => self.write_bytes(b\"i64.trunc_s/f32\"),\n            Operator::I64TruncUF32 => self.write_bytes(b\"i64.trunc_u/f32\"),\n            Operator::I64TruncSF64 => self.write_bytes(b\"i64.trunc_s/f64\"),\n            Operator::I64TruncUF64 => self.write_bytes(b\"i64.trunc_u/f64\"),\n            Operator::F32ConvertSI32 => self.write_bytes(b\"f32.convert_s/i32\"),\n            Operator::F32ConvertUI32 => self.write_bytes(b\"f32.convert_u/i32\"),\n            Operator::F32ConvertSI64 => self.write_bytes(b\"f32.convert_s/i64\"),\n            Operator::F32ConvertUI64 => self.write_bytes(b\"f32.convert_u/i64\"),\n            Operator::F32DemoteF64 => self.write_bytes(b\"f32.demote/f64\"),\n            Operator::F64ConvertSI32 => self.write_bytes(b\"f64.convert_s/i32\"),\n            Operator::F64ConvertUI32 => self.write_bytes(b\"f64.convert_u/i32\"),\n            Operator::F64ConvertSI64 => self.write_bytes(b\"f64.convert_s/i64\"),\n            Operator::F64ConvertUI64 => self.write_bytes(b\"f64.convert_u/i64\"),\n            Operator::F64PromoteF32 => self.write_bytes(b\"f64.promote/f32\"),\n            Operator::I32ReinterpretF32 => self.write_bytes(b\"i32.reinterpret/f32\"),\n            Operator::I64ReinterpretF64 => self.write_bytes(b\"i64.reinterpret/f64\"),\n            Operator::F32ReinterpretI32 => self.write_bytes(b\"f32.reinterpret/i32\"),\n            Operator::F64ReinterpretI64 => self.write_bytes(b\"f64.reinterpret/i64\"),\n            Operator::I32TruncSSatF32 => self.write_bytes(b\"i32.trunc_s:sat/f32\"),\n            Operator::I32TruncUSatF32 => self.write_bytes(b\"i32.trunc_u:sat/f32\"),\n            Operator::I32TruncSSatF64 => self.write_bytes(b\"i32.trunc_s:sat/f64\"),\n            Operator::I32TruncUSatF64 => self.write_bytes(b\"i32.trunc_u:sat/f64\"),\n            Operator::I64TruncSSatF32 => self.write_bytes(b\"i64.trunc_s:sat/f32\"),\n            Operator::I64TruncUSatF32 => self.write_bytes(b\"i64.trunc_u:sat/f32\"),\n            Operator::I64TruncSSatF64 => self.write_bytes(b\"i64.trunc_s:sat/f64\"),\n            Operator::I64TruncUSatF64 => self.write_bytes(b\"i64.trunc_u:sat/f64\"),\n            Operator::I32Extend8S => self.write_bytes(b\"i32.extend8_s\"),\n            Operator::I32Extend16S => self.write_bytes(b\"i32.extend16_s\"),\n            Operator::I64Extend8S => self.write_bytes(b\"i64.extend8_s\"),\n            Operator::I64Extend16S => self.write_bytes(b\"i64.extend16_s\"),\n            Operator::I64Extend32S => self.write_bytes(b\"i64.extend32_s\"),\n            Operator::Wake { ref memarg } => {\n                self.write_bytes(b\"atomic.wake\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I32Wait { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.wait\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64Wait { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.wait\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::I32AtomicLoad { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.load\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64AtomicLoad { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.load\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::I32AtomicLoad8U { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.load8_u\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I32AtomicLoad16U { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.load16_u\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicLoad8U { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.load8_u\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I64AtomicLoad16U { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.load16_u\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicLoad32U { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.load32_u\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I32AtomicStore { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.store\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64AtomicStore { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.store\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::I32AtomicStore8 { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.store8\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I32AtomicStore16 { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.store16\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicStore8 { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.store8\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I64AtomicStore16 { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.store16\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicStore32 { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.store32\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I32AtomicRmwAdd { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw.add\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64AtomicRmwAdd { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw.add\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::I32AtomicRmw8UAdd { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw8_u.add\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I32AtomicRmw16UAdd { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw16_u.add\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw8UAdd { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw8_u.add\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I64AtomicRmw16UAdd { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw16_u.add\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw32UAdd { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw32_u.add\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I32AtomicRmwSub { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw.sub\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64AtomicRmwSub { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw.sub\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::I32AtomicRmw8USub { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw8_u.sub\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I32AtomicRmw16USub { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw16_u.sub\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw8USub { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw8_u.sub\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I64AtomicRmw16USub { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw16_u.sub\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw32USub { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw32_u.sub\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I32AtomicRmwAnd { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw.and\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64AtomicRmwAnd { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw.and\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::I32AtomicRmw8UAnd { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw8_u.and\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I32AtomicRmw16UAnd { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw16_u.and\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw8UAnd { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw8_u.and\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I64AtomicRmw16UAnd { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw16_u.and\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw32UAnd { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw32_u.and\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I32AtomicRmwOr { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw.or\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64AtomicRmwOr { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw.or\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::I32AtomicRmw8UOr { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw8_u.or\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I32AtomicRmw16UOr { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw16_u.or\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw8UOr { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw8_u.or\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I64AtomicRmw16UOr { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw16_u.or\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw32UOr { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw32_u.or\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I32AtomicRmwXor { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw.xor\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64AtomicRmwXor { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw.xor\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::I32AtomicRmw8UXor { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw8_u.xor\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I32AtomicRmw16UXor { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw16_u.xor\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw8UXor { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw8_u.xor\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I64AtomicRmw16UXor { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw16_u.xor\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw32UXor { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw32_u.xor\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I32AtomicRmwXchg { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw.xchg\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64AtomicRmwXchg { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw.xchg\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::I32AtomicRmw8UXchg { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw8_u.xchg\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I32AtomicRmw16UXchg { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw16_u.xchg\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw8UXchg { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw8_u.xchg\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I64AtomicRmw16UXchg { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw16_u.xchg\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw32UXchg { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw32_u.xchg\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I32AtomicRmwCmpxchg { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw.cmpxchg\")?;\n                self.write_memarg(memarg, 2)\n            }\n            Operator::I64AtomicRmwCmpxchg { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw.cmpxchg\")?;\n                self.write_memarg(memarg, 3)\n            }\n            Operator::I32AtomicRmw8UCmpxchg { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw8_u.cmpxchg\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I32AtomicRmw16UCmpxchg { ref memarg } => {\n                self.write_bytes(b\"i32.atomic.rmw16_u.cmpxchg\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw8UCmpxchg { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw8_u.cmpxchg\")?;\n                self.write_memarg(memarg, 0)\n            }\n            Operator::I64AtomicRmw16UCmpxchg { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw16_u.cmpxchg\")?;\n                self.write_memarg(memarg, 1)\n            }\n            Operator::I64AtomicRmw32UCmpxchg { ref memarg } => {\n                self.write_bytes(b\"i64.atomic.rmw32_u.cmpxchg\")?;\n                self.write_memarg(memarg, 2)\n            }\n        }\n    }\n\n    fn write_import_source(&mut self, module: &[u8], field: &[u8]) -> Result<()> {\n        self.write_string(module)?;\n        self.write_bytes(b\" \")?;\n        self.write_string(field)\n    }\n\n    pub fn write(&mut self, state: &ParserState) -> Result<()> {\n        match *state {\n            ParserState::EndWasm => {\n                self.write_bytes(b\")\\n\")?;\n            }\n            ParserState::Error(_) => unreachable!(),\n            ParserState::BeginWasm { .. } => {\n                self.write_bytes(b\"(module\\n\")?;\n            }\n            ParserState::EndSection => {}\n            ParserState::BeginSection { .. } => {}\n            ParserState::ExportSectionEntry {\n                field,\n                ref kind,\n                index,\n            } => {\n                self.write_bytes(b\"  (export \")?;\n                self.write_string(field)?;\n                self.write_bytes(b\" \")?;\n                match *kind {\n                    ExternalKind::Function => {\n                        self.write_bytes(b\"(func \")?;\n                        self.write_func_name_ref(index)?;\n                        self.write_bytes(b\")\")?;\n                    }\n                    ExternalKind::Table => {\n                        self.write_bytes(b\"(table \")?;\n                        self.write_bytes(&get_table_name(index, true))?;\n                        self.write_bytes(b\")\")?;\n                    }\n                    ExternalKind::Memory => {\n                        self.write_bytes(b\"(memory \")?;\n                        self.write_bytes(&get_memory_name(index, true))?;\n                        self.write_bytes(b\")\")?;\n                    }\n                    ExternalKind::Global => {\n                        self.write_bytes(b\"(global \")?;\n                        self.write_bytes(&get_global_name(index, true))?;\n                        self.write_bytes(b\")\")?;\n                    }\n                }\n                self.write_bytes(b\")\\n\")?;\n            }\n            ParserState::ImportSectionEntry {\n                module,\n                field,\n                ref ty,\n                ..\n            } => {\n                self.write_bytes(b\"  (import \")?;\n                self.write_import_source(module, field)?;\n                match *ty {\n                    ImportSectionEntryType::Function(type_index) => {\n                        self.func_types.push(type_index);\n                        let index = self.func_index as u32;\n                        self.func_index += 1;\n                        self.import_count += 1;\n                        self.write_bytes(b\" (func \")?;\n                        self.write_bytes(&get_func_name(index, true, false))?;\n                        let ty = self.types[type_index as usize].clone();\n                        self.write_func_type(&ty)?;\n                        self.write_bytes(b\")\")?;\n                    }\n                    ImportSectionEntryType::Table(ref table_type) => {\n                        self.write_bytes(b\" (table \")?;\n                        let index = self.table_count as u32;\n                        self.table_count += 1;\n                        self.write_bytes(&get_table_name(index, false))?;\n                        self.write_bytes(b\" \")?;\n                        self.write_limits(&table_type.limits)?;\n                        self.write_bytes(b\" \")?;\n                        self.write_type(table_type.element_type)?;\n                        self.write_bytes(b\")\")?;\n                    }\n                    ImportSectionEntryType::Memory(ref memory_type) => {\n                        let index = self.memory_count as u32;\n                        self.memory_count += 1;\n                        self.write_bytes(b\" (memory \")?;\n                        self.write_bytes(&get_memory_name(index, false))?;\n                        self.write_bytes(b\" \")?;\n                        self.write_limits(&memory_type.limits)?;\n                        self.write_bytes(b\")\")?;\n                    }\n                    ImportSectionEntryType::Global(ref global_type) => {\n                        let index = self.global_count as u32;\n                        self.global_count += 1;\n                        self.write_bytes(b\" (global \")?;\n                        self.write_bytes(&get_global_name(index, false))?;\n                        self.write_bytes(b\" \")?;\n                        self.write_global_type(global_type)?;\n                        self.write_bytes(b\")\")?;\n                    }\n                }\n                self.write_bytes(b\")\\n\")?;\n            }\n            ParserState::TypeSectionEntry(ref ty) => {\n                self.write_bytes(b\"  (type \")?;\n                let index = self.types.len() as u32;\n                self.types.push(ty.clone());\n                self.write_bytes(&get_type_name(index, false))?;\n                self.write_bytes(b\" (func\")?;\n                self.write_func_type(ty)?;\n                self.write_bytes(b\"))\\n\")?;\n            }\n            ParserState::TableSectionEntry(TableType {\n                                               element_type,\n                                               ref limits,\n                                           }) => {\n                let index = self.table_count as u32;\n                self.table_count += 1;\n                self.write_bytes(b\"  (table \")?;\n                self.write_bytes(&get_table_name(index, false))?;\n                self.write_bytes(b\" \")?;\n                self.write_limits(limits)?;\n                self.write_bytes(b\" \")?;\n                self.write_type(element_type)?;\n                self.write_bytes(b\")\\n\")?;\n\n            }\n            ParserState::MemorySectionEntry(MemoryType { ref limits, shared }) => {\n                let index = self.memory_count as u32;\n                self.memory_count += 1;\n                self.write_bytes(b\"  (memory \")?;\n                self.write_bytes(&get_memory_name(index, false))?;\n                self.write_bytes(b\" \")?;\n                self.write_limits(limits)?;\n                if shared {\n                    self.write_bytes(b\" shared\")?;\n                }\n                self.write_bytes(b\")\\n\")?;\n            }\n            ParserState::FunctionSectionEntry(index) => {\n                self.func_types.push(index);\n            }\n            ParserState::BeginGlobalSectionEntry(ref global_type) => {\n                self.write_bytes(b\"  (global \")?;\n                let index = self.global_count as u32;\n                self.global_count += 1;\n                self.write_bytes(&get_global_name(index, false))?;\n                self.write_bytes(b\" \")?;\n                self.write_global_type(global_type)?;\n            }\n            ParserState::EndGlobalSectionEntry => {\n                self.write_bytes(b\")\\n\")?;\n            }\n            ParserState::BeginFunctionBody { .. } => {\n                self.write_bytes(b\"  (func \")?;\n                let is_import = self.func_index < self.import_count;\n                let index = self.func_index as u32;\n                self.write_bytes(&get_func_name(index, is_import, false))?;\n                let func_type_index = self.func_types[self.func_index] as usize;\n                let func_type: FuncType = self.types[func_type_index].clone();\n                for i in 0..func_type.params.len() {\n                    self.write_bytes(b\" (param \")?;\n                    self.write_bytes(&get_var_name(index, i as u32, false))?;\n                    self.write_bytes(b\" \")?;\n                    self.write_type(func_type.params[i])?;\n                    self.write_bytes(b\")\")?;\n                }\n                for i in 0..func_type.returns.len() {\n                    self.write_bytes(b\" (result \")?;\n                    self.write_type(func_type.returns[i])?;\n                    self.write_bytes(b\")\")?;\n                }\n                self.write_bytes(b\"\\n\")?;\n                self.indent = 0;\n                self.label_index = 0;\n            }\n            ParserState::FunctionBodyLocals { ref locals } => {\n                if locals.len() > 0 {\n                    self.write_bytes(b\"   \")?;\n                    let index = self.func_index as u32;\n                    let func_type_index = self.func_types[self.func_index] as usize;\n                    let func_type: FuncType = self.types[func_type_index].clone();\n                    let mut local_index = func_type.params.len();\n                    for &(j, ty) in locals {\n                        for _ in 0..j {\n                            self.write_bytes(b\" (local \")?;\n                            self.write_bytes(&get_var_name(index, local_index as u32, false))?;\n                            self.write_bytes(b\" \")?;\n                            self.write_type(ty)?;\n                            self.write_bytes(b\")\")?;\n                            local_index += 1;\n                        }\n                    }\n                    self.write_bytes(b\"\\n\")?;\n                }\n            }\n            ParserState::EndFunctionBody => {\n                self.write_bytes(b\"  )\\n\")?;\n                self.func_index += 1;\n            }\n            ParserState::CodeOperator(ref operator) => {\n                if let Operator::End = *operator {\n                    if self.indent == 0 {\n                        // Ignoring function's last end operator.\n                        return Ok(());\n                    }\n                    self.indent -= 1;\n                }\n                self.write_bytes(b\"    \")?;\n                let mut indent = self.indent;\n                if let Operator::Else = *operator {\n                    indent -= 1;\n                }\n                for _ in 0..indent {\n                    self.write_bytes(b\"  \")?;\n                }\n                self.write_operator(operator)?;\n                match *operator {\n                    Operator::Block { .. } |\n                    Operator::Loop { .. } |\n                    Operator::If { .. } => self.indent += 1,\n                    _ => {}\n                }\n                self.write_bytes(b\"\\n\")?;\n            }\n            ParserState::BeginDataSectionEntry(_) => {\n                self.write_bytes(b\"  (data\")?;\n            }\n            ParserState::BeginDataSectionEntryBody(_) => {\n                self.write_bytes(b\"\\n    \\\"\")?;\n            }\n            ParserState::DataSectionEntryBodyChunk(data) => {\n                self.write_string_chunk(data)?;\n            }\n            ParserState::EndDataSectionEntryBody => {\n                self.write_bytes(b\"\\\"\")?;\n            }\n            ParserState::EndDataSectionEntry => {\n                self.write_bytes(b\"\\n  )\\n\")?;\n            }\n            ParserState::BeginInitExpressionBody |\n            ParserState::EndInitExpressionBody => {}\n            ParserState::InitExpressionOperator(ref operator) => {\n                self.write_bytes(b\" (\")?;\n                self.write_operator(operator)?;\n                self.write_bytes(b\")\")?;\n            }\n            ParserState::StartSectionEntry(index) => {\n                self.write_bytes(b\"  (start \")?;\n                self.write_func_name_ref(index)?;\n                self.write_bytes(b\")\\n\")?;\n            }\n            ParserState::BeginElementSectionEntry(_) => {\n                self.write_bytes(b\"  (elem\")?;\n            }\n            ParserState::EndElementSectionEntry => {\n                self.write_bytes(b\")\\n\")?;\n            }\n            ParserState::ElementSectionEntryBody(ref elements) => {\n                for index in elements.clone() {\n                    self.write_bytes(b\" \")?;\n                    self.write_func_name_ref(index)?;\n                }\n            }\n            ParserState::NameSectionEntry(_) |\n            ParserState::RelocSectionHeader(_) |\n            ParserState::RelocSectionEntry(_) |\n            ParserState::SourceMappingURL(_) |\n            ParserState::SectionRawData(_) |\n            ParserState::LinkingSectionEntry(_) => {}\n            _ => unreachable!(),\n        }\n        Ok(())\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A contiguous growable array type with heap-allocated contents, written\n//! `Vec<T>`.\n//!\n//! Vectors have `O(1)` indexing, amortized `O(1)` push (to the end) and\n//! `O(1)` pop (from the end).\n//!\n//! # Examples\n//!\n//! You can explicitly create a [`Vec<T>`] with [`new`]:\n//!\n//! ```\n//! let v: Vec<i32> = Vec::new();\n//! ```\n//!\n//! ...or by using the [`vec!`] macro:\n//!\n//! ```\n//! let v: Vec<i32> = vec![];\n//!\n//! let v = vec![1, 2, 3, 4, 5];\n//!\n//! let v = vec![0; 10]; // ten zeroes\n//! ```\n//!\n//! You can [`push`] values onto the end of a vector (which will grow the vector\n//! as needed):\n//!\n//! ```\n//! let mut v = vec![1, 2];\n//!\n//! v.push(3);\n//! ```\n//!\n//! Popping values works in much the same way:\n//!\n//! ```\n//! let mut v = vec![1, 2];\n//!\n//! let two = v.pop();\n//! ```\n//!\n//! Vectors also support indexing (through the [`Index`] and [`IndexMut`] traits):\n//!\n//! ```\n//! let mut v = vec![1, 2, 3];\n//! let three = v[2];\n//! v[1] = v[1] + 5;\n//! ```\n//!\n//! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n//! [`new`]: ../../std/vec/struct.Vec.html#method.new\n//! [`push`]: ../../std/vec/struct.Vec.html#method.push\n//! [`Index`]: ../../std/ops/trait.Index.html\n//! [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n//! [`vec!`]: ../../std/macro.vec.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::cmp::Ordering;\nuse core::fmt;\nuse core::hash::{self, Hash};\nuse core::intrinsics::{arith_offset, assume};\nuse core::iter::{FromIterator, FusedIterator, TrustedLen};\nuse core::marker::PhantomData;\nuse core::mem;\n#[cfg(not(test))]\nuse core::num::Float;\nuse core::ops::{InPlace, Index, IndexMut, Place, Placer};\nuse core::ops;\nuse core::ptr;\nuse core::ptr::NonNull;\nuse core::slice;\n\nuse borrow::ToOwned;\nuse borrow::Cow;\nuse boxed::Box;\nuse raw_vec::RawVec;\nuse super::range::RangeArgument;\nuse Bound::{Excluded, Included, Unbounded};\n\n/// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n///\n/// # Examples\n///\n/// ```\n/// let mut vec = Vec::new();\n/// vec.push(1);\n/// vec.push(2);\n///\n/// assert_eq!(vec.len(), 2);\n/// assert_eq!(vec[0], 1);\n///\n/// assert_eq!(vec.pop(), Some(2));\n/// assert_eq!(vec.len(), 1);\n///\n/// vec[0] = 7;\n/// assert_eq!(vec[0], 7);\n///\n/// vec.extend([1, 2, 3].iter().cloned());\n///\n/// for x in &vec {\n///     println!(\"{}\", x);\n/// }\n/// assert_eq!(vec, [7, 1, 2, 3]);\n/// ```\n///\n/// The [`vec!`] macro is provided to make initialization more convenient:\n///\n/// ```\n/// let mut vec = vec![1, 2, 3];\n/// vec.push(4);\n/// assert_eq!(vec, [1, 2, 3, 4]);\n/// ```\n///\n/// It can also initialize each element of a `Vec<T>` with a given value:\n///\n/// ```\n/// let vec = vec![0; 5];\n/// assert_eq!(vec, [0, 0, 0, 0, 0]);\n/// ```\n///\n/// Use a `Vec<T>` as an efficient stack:\n///\n/// ```\n/// let mut stack = Vec::new();\n///\n/// stack.push(1);\n/// stack.push(2);\n/// stack.push(3);\n///\n/// while let Some(top) = stack.pop() {\n///     // Prints 3, 2, 1\n///     println!(\"{}\", top);\n/// }\n/// ```\n///\n/// # Indexing\n///\n/// The `Vec` type allows to access values by index, because it implements the\n/// [`Index`] trait. An example will be more explicit:\n///\n/// ```\n/// let v = vec![0, 2, 4, 6];\n/// println!(\"{}\", v[1]); // it will display '2'\n/// ```\n///\n/// However be careful: if you try to access an index which isn't in the `Vec`,\n/// your software will panic! You cannot do this:\n///\n/// ```should_panic\n/// let v = vec![0, 2, 4, 6];\n/// println!(\"{}\", v[6]); // it will panic!\n/// ```\n///\n/// In conclusion: always check if the index you want to get really exists\n/// before doing it.\n///\n/// # Slicing\n///\n/// A `Vec` can be mutable. Slices, on the other hand, are read-only objects.\n/// To get a slice, use `&`. Example:\n///\n/// ```\n/// fn read_slice(slice: &[usize]) {\n///     // ...\n/// }\n///\n/// let v = vec![0, 1];\n/// read_slice(&v);\n///\n/// // ... and that's all!\n/// // you can also do it like this:\n/// let x : &[usize] = &v;\n/// ```\n///\n/// In Rust, it's more common to pass slices as arguments rather than vectors\n/// when you just want to provide a read access. The same goes for [`String`] and\n/// [`&str`].\n///\n/// # Capacity and reallocation\n///\n/// The capacity of a vector is the amount of space allocated for any future\n/// elements that will be added onto the vector. This is not to be confused with\n/// the *length* of a vector, which specifies the number of actual elements\n/// within the vector. If a vector's length exceeds its capacity, its capacity\n/// will automatically be increased, but its elements will have to be\n/// reallocated.\n///\n/// For example, a vector with capacity 10 and length 0 would be an empty vector\n/// with space for 10 more elements. Pushing 10 or fewer elements onto the\n/// vector will not change its capacity or cause reallocation to occur. However,\n/// if the vector's length is increased to 11, it will have to reallocate, which\n/// can be slow. For this reason, it is recommended to use [`Vec::with_capacity`]\n/// whenever possible to specify how big the vector is expected to get.\n///\n/// # Guarantees\n///\n/// Due to its incredibly fundamental nature, `Vec` makes a lot of guarantees\n/// about its design. This ensures that it's as low-overhead as possible in\n/// the general case, and can be correctly manipulated in primitive ways\n/// by unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\n/// If additional type parameters are added (e.g. to support custom allocators),\n/// overriding their defaults may change the behavior.\n///\n/// Most fundamentally, `Vec` is and always will be a (pointer, capacity, length)\n/// triplet. No more, no less. The order of these fields is completely\n/// unspecified, and you should use the appropriate methods to modify these.\n/// The pointer will never be null, so this type is null-pointer-optimized.\n///\n/// However, the pointer may not actually point to allocated memory. In particular,\n/// if you construct a `Vec` with capacity 0 via [`Vec::new`], [`vec![]`][`vec!`],\n/// [`Vec::with_capacity(0)`][`Vec::with_capacity`], or by calling [`shrink_to_fit`]\n/// on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\n/// types inside a `Vec`, it will not allocate space for them. *Note that in this case\n/// the `Vec` may not report a [`capacity`] of 0*. `Vec` will allocate if and only\n/// if [`mem::size_of::<T>`]`() * capacity() > 0`. In general, `Vec`'s allocation\n/// details are very subtle &mdash; if you intend to allocate memory using a `Vec`\n/// and use it for something else (either to pass to unsafe code, or to build your\n/// own memory-backed collection), be sure to deallocate this memory by using\n/// `from_raw_parts` to recover the `Vec` and then dropping it.\n///\n/// If a `Vec` *has* allocated memory, then the memory it points to is on the heap\n/// (as defined by the allocator Rust is configured to use by default), and its\n/// pointer points to [`len`] initialized elements in order (what you would see\n/// if you coerced it to a slice), followed by [`capacity`]` - `[`len`]\n/// logically uninitialized elements.\n///\n/// `Vec` will never perform a \"small optimization\" where elements are actually\n/// stored on the stack for two reasons:\n///\n/// * It would make it more difficult for unsafe code to correctly manipulate\n///   a `Vec`. The contents of a `Vec` wouldn't have a stable address if it were\n///   only moved, and it would be more difficult to determine if a `Vec` had\n///   actually allocated memory.\n///\n/// * It would penalize the general case, incurring an additional branch\n///   on every access.\n///\n/// `Vec` will never automatically shrink itself, even if completely empty. This\n/// ensures no unnecessary allocations or deallocations occur. Emptying a `Vec`\n/// and then filling it back up to the same [`len`] should incur no calls to\n/// the allocator. If you wish to free up unused memory, use\n/// [`shrink_to_fit`][`shrink_to_fit`].\n///\n/// [`push`] and [`insert`] will never (re)allocate if the reported capacity is\n/// sufficient. [`push`] and [`insert`] *will* (re)allocate if\n/// [`len`]` == `[`capacity`]. That is, the reported capacity is completely\n/// accurate, and can be relied on. It can even be used to manually free the memory\n/// allocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\n/// when not necessary.\n///\n/// `Vec` does not guarantee any particular growth strategy when reallocating\n/// when full, nor when [`reserve`] is called. The current strategy is basic\n/// and it may prove desirable to use a non-constant growth factor. Whatever\n/// strategy is used will of course guarantee `O(1)` amortized [`push`].\n///\n/// `vec![x; n]`, `vec![a, b, c, d]`, and\n/// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`\n/// with exactly the requested capacity. If [`len`]` == `[`capacity`],\n/// (as is the case for the [`vec!`] macro), then a `Vec<T>` can be converted to\n/// and from a [`Box<[T]>`][owned slice] without reallocating or moving the elements.\n///\n/// `Vec` will not specifically overwrite any data that is removed from it,\n/// but also won't specifically preserve it. Its uninitialized memory is\n/// scratch space that it may use however it wants. It will generally just do\n/// whatever is most efficient or otherwise easy to implement. Do not rely on\n/// removed data to be erased for security purposes. Even if you drop a `Vec`, its\n/// buffer may simply be reused by another `Vec`. Even if you zero a `Vec`'s memory\n/// first, that may not actually happen because the optimizer does not consider\n/// this a side-effect that must be preserved. There is one case which we will\n/// not break, however: using `unsafe` code to write to the excess capacity,\n/// and then increasing the length to match, is always valid.\n///\n/// `Vec` does not currently guarantee the order in which elements are dropped\n/// (the order has changed in the past, and may change again).\n///\n/// [`vec!`]: ../../std/macro.vec.html\n/// [`Index`]: ../../std/ops/trait.Index.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [`&str`]: ../../std/primitive.str.html\n/// [`Vec::with_capacity`]: ../../std/vec/struct.Vec.html#method.with_capacity\n/// [`Vec::new`]: ../../std/vec/struct.Vec.html#method.new\n/// [`shrink_to_fit`]: ../../std/vec/struct.Vec.html#method.shrink_to_fit\n/// [`capacity`]: ../../std/vec/struct.Vec.html#method.capacity\n/// [`mem::size_of::<T>`]: ../../std/mem/fn.size_of.html\n/// [`len`]: ../../std/vec/struct.Vec.html#method.len\n/// [`push`]: ../../std/vec/struct.Vec.html#method.push\n/// [`insert`]: ../../std/vec/struct.Vec.html#method.insert\n/// [`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n/// [owned slice]: ../../std/boxed/struct.Box.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Vec<T> {\n    buf: RawVec<T>,\n    len: usize,\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Inherent methods\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Vec<T> {\n    /// Constructs a new, empty `Vec<T>`.\n    ///\n    /// The vector will not allocate until elements are pushed onto it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![allow(unused_mut)]\n    /// let mut vec: Vec<i32> = Vec::new();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> Vec<T> {\n        Vec {\n            buf: RawVec::new(),\n            len: 0,\n        }\n    }\n\n    /// Constructs a new, empty `Vec<T>` with the specified capacity.\n    ///\n    /// The vector will be able to hold exactly `capacity` elements without\n    /// reallocating. If `capacity` is 0, the vector will not allocate.\n    ///\n    /// It is important to note that this function does not specify the *length*\n    /// of the returned vector, but only the *capacity*. For an explanation of\n    /// the difference between length and capacity, see *[Capacity and reallocation]*.\n    ///\n    /// [Capacity and reallocation]: #capacity-and-reallocation\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    ///\n    /// // The vector contains no items, even though it has capacity for more\n    /// assert_eq!(vec.len(), 0);\n    ///\n    /// // These are all done without reallocating...\n    /// for i in 0..10 {\n    ///     vec.push(i);\n    /// }\n    ///\n    /// // ...but this may make the vector reallocate\n    /// vec.push(11);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> Vec<T> {\n        Vec {\n            buf: RawVec::with_capacity(capacity),\n            len: 0,\n        }\n    }\n\n    /// Creates a `Vec<T>` directly from the raw components of another vector.\n    ///\n    /// # Safety\n    ///\n    /// This is highly unsafe, due to the number of invariants that aren't\n    /// checked:\n    ///\n    /// * `ptr` needs to have been previously allocated via [`String`]/`Vec<T>`\n    ///   (at least, it's highly likely to be incorrect if it wasn't).\n    /// * `ptr`'s `T` needs to have the same size and alignment as it was allocated with.\n    /// * `length` needs to be less than or equal to `capacity`.\n    /// * `capacity` needs to be the capacity that the pointer was allocated with.\n    ///\n    /// Violating these may cause problems like corrupting the allocator's\n    /// internal data structures. For example it is **not** safe\n    /// to build a `Vec<u8>` from a pointer to a C `char` array and a `size_t`.\n    ///\n    /// The ownership of `ptr` is effectively transferred to the\n    /// `Vec<T>` which may then deallocate, reallocate or change the\n    /// contents of memory pointed to by the pointer at will. Ensure\n    /// that nothing else uses the pointer after calling this\n    /// function.\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ptr;\n    /// use std::mem;\n    ///\n    /// fn main() {\n    ///     let mut v = vec![1, 2, 3];\n    ///\n    ///     // Pull out the various important pieces of information about `v`\n    ///     let p = v.as_mut_ptr();\n    ///     let len = v.len();\n    ///     let cap = v.capacity();\n    ///\n    ///     unsafe {\n    ///         // Cast `v` into the void: no destructor run, so we are in\n    ///         // complete control of the allocation to which `p` points.\n    ///         mem::forget(v);\n    ///\n    ///         // Overwrite memory with 4, 5, 6\n    ///         for i in 0..len as isize {\n    ///             ptr::write(p.offset(i), 4 + i);\n    ///         }\n    ///\n    ///         // Put everything back together into a Vec\n    ///         let rebuilt = Vec::from_raw_parts(p, len, cap);\n    ///         assert_eq!(rebuilt, [4, 5, 6]);\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -> Vec<T> {\n        Vec {\n            buf: RawVec::from_raw_parts(ptr, capacity),\n            len: length,\n        }\n    }\n\n    /// Returns the number of elements the vector can hold without\n    /// reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let vec: Vec<i32> = Vec::with_capacity(10);\n    /// assert_eq!(vec.capacity(), 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n        self.buf.cap()\n    }\n\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the given `Vec<T>`. The collection may reserve more space to avoid\n    /// frequent reallocations. After calling `reserve`, capacity will be\n    /// greater than or equal to `self.len() + additional`. Does nothing if\n    /// capacity is already sufficient.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.reserve(10);\n    /// assert!(vec.capacity() >= 11);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n        self.buf.reserve(self.len, additional);\n    }\n\n    /// Reserves the minimum capacity for exactly `additional` more elements to\n    /// be inserted in the given `Vec<T>`. After calling `reserve_exact`,\n    /// capacity will be greater than or equal to `self.len() + additional`.\n    /// Does nothing if the capacity is already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it\n    /// requests. Therefore capacity can not be relied upon to be precisely\n    /// minimal. Prefer `reserve` if future insertions are expected.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.reserve_exact(10);\n    /// assert!(vec.capacity() >= 11);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.buf.reserve_exact(self.len, additional);\n    }\n\n    /// Shrinks the capacity of the vector as much as possible.\n    ///\n    /// It will drop down as close as possible to the length but the allocator\n    /// may still inform the vector that there is space for a few more elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    /// vec.extend([1, 2, 3].iter().cloned());\n    /// assert_eq!(vec.capacity(), 10);\n    /// vec.shrink_to_fit();\n    /// assert!(vec.capacity() >= 3);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n        self.buf.shrink_to_fit(self.len);\n    }\n\n    /// Converts the vector into [`Box<[T]>`][owned slice].\n    ///\n    /// Note that this will drop any excess capacity.\n    ///\n    /// [owned slice]: ../../std/boxed/struct.Box.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = vec![1, 2, 3];\n    ///\n    /// let slice = v.into_boxed_slice();\n    /// ```\n    ///\n    /// Any excess capacity is removed:\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    /// vec.extend([1, 2, 3].iter().cloned());\n    ///\n    /// assert_eq!(vec.capacity(), 10);\n    /// let slice = vec.into_boxed_slice();\n    /// assert_eq!(slice.into_vec().capacity(), 3);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_boxed_slice(mut self) -> Box<[T]> {\n        unsafe {\n            self.shrink_to_fit();\n            let buf = ptr::read(&self.buf);\n            mem::forget(self);\n            buf.into_box()\n        }\n    }\n\n    /// Shortens the vector, keeping the first `len` elements and dropping\n    /// the rest.\n    ///\n    /// If `len` is greater than the vector's current length, this has no\n    /// effect.\n    ///\n    /// The [`drain`] method can emulate `truncate`, but causes the excess\n    /// elements to be returned instead of dropped.\n    ///\n    /// Note that this method has no effect on the allocated capacity\n    /// of the vector.\n    ///\n    /// # Examples\n    ///\n    /// Truncating a five element vector to two elements:\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3, 4, 5];\n    /// vec.truncate(2);\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    ///\n    /// No truncation occurs when `len` is greater than the vector's current\n    /// length:\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.truncate(8);\n    /// assert_eq!(vec, [1, 2, 3]);\n    /// ```\n    ///\n    /// Truncating when `len == 0` is equivalent to calling the [`clear`]\n    /// method.\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.truncate(0);\n    /// assert_eq!(vec, []);\n    /// ```\n    ///\n    /// [`clear`]: #method.clear\n    /// [`drain`]: #method.drain\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn truncate(&mut self, len: usize) {\n        unsafe {\n            // drop any extra elements\n            while len < self.len {\n                // decrement len before the drop_in_place(), so a panic on Drop\n                // doesn't re-drop the just-failed value.\n                self.len -= 1;\n                let len = self.len;\n                ptr::drop_in_place(self.get_unchecked_mut(len));\n            }\n        }\n    }\n\n    /// Extracts a slice containing the entire vector.\n    ///\n    /// Equivalent to `&s[..]`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Write};\n    /// let buffer = vec![1, 2, 3, 5, 8];\n    /// io::sink().write(buffer.as_slice()).unwrap();\n    /// ```\n    #[inline]\n    #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n    pub fn as_slice(&self) -> &[T] {\n        self\n    }\n\n    /// Extracts a mutable slice of the entire vector.\n    ///\n    /// Equivalent to `&mut s[..]`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Read};\n    /// let mut buffer = vec![0; 3];\n    /// io::repeat(0b101).read_exact(buffer.as_mut_slice()).unwrap();\n    /// ```\n    #[inline]\n    #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n        self\n    }\n\n    /// Sets the length of a vector.\n    ///\n    /// This will explicitly set the size of the vector, without actually\n    /// modifying its buffers, so it is up to the caller to ensure that the\n    /// vector is actually the specified size.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ptr;\n    ///\n    /// let mut vec = vec!['r', 'u', 's', 't'];\n    ///\n    /// unsafe {\n    ///     ptr::drop_in_place(&mut vec[3]);\n    ///     vec.set_len(3);\n    /// }\n    /// assert_eq!(vec, ['r', 'u', 's']);\n    /// ```\n    ///\n    /// In this example, there is a memory leak since the memory locations\n    /// owned by the inner vectors were not freed prior to the `set_len` call:\n    ///\n    /// ```\n    /// let mut vec = vec![vec![1, 0, 0],\n    ///                    vec![0, 1, 0],\n    ///                    vec![0, 0, 1]];\n    /// unsafe {\n    ///     vec.set_len(0);\n    /// }\n    /// ```\n    ///\n    /// In this example, the vector gets expanded from zero to four items\n    /// without any memory allocations occurring, resulting in vector\n    /// values of unallocated memory:\n    ///\n    /// ```\n    /// let mut vec: Vec<char> = Vec::new();\n    ///\n    /// unsafe {\n    ///     vec.set_len(4);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn set_len(&mut self, len: usize) {\n        self.len = len;\n    }\n\n    /// Removes an element from the vector and returns it.\n    ///\n    /// The removed element is replaced by the last element of the vector.\n    ///\n    /// This does not preserve ordering, but is O(1).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index` is out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n    ///\n    /// assert_eq!(v.swap_remove(1), \"bar\");\n    /// assert_eq!(v, [\"foo\", \"qux\", \"baz\"]);\n    ///\n    /// assert_eq!(v.swap_remove(0), \"foo\");\n    /// assert_eq!(v, [\"baz\", \"qux\"]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn swap_remove(&mut self, index: usize) -> T {\n        let length = self.len();\n        self.swap(index, length - 1);\n        self.pop().unwrap()\n    }\n\n    /// Inserts an element at position `index` within the vector, shifting all\n    /// elements after it to the right.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.insert(1, 4);\n    /// assert_eq!(vec, [1, 4, 2, 3]);\n    /// vec.insert(4, 5);\n    /// assert_eq!(vec, [1, 4, 2, 3, 5]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, index: usize, element: T) {\n        let len = self.len();\n        assert!(index <= len);\n\n        // space for the new element\n        if len == self.buf.cap() {\n            self.buf.double();\n        }\n\n        unsafe {\n            // infallible\n            // The spot to put the new value\n            {\n                let p = self.as_mut_ptr().offset(index as isize);\n                // Shift everything over to make space. (Duplicating the\n                // `index`th element into two consecutive places.)\n                ptr::copy(p, p.offset(1), len - index);\n                // Write it in, overwriting the first copy of the `index`th\n                // element.\n                ptr::write(p, element);\n            }\n            self.set_len(len + 1);\n        }\n    }\n\n    /// Removes and returns the element at position `index` within the vector,\n    /// shifting all elements after it to the left.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index` is out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    /// assert_eq!(v.remove(1), 2);\n    /// assert_eq!(v, [1, 3]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove(&mut self, index: usize) -> T {\n        let len = self.len();\n        assert!(index < len);\n        unsafe {\n            // infallible\n            let ret;\n            {\n                // the place we are taking from.\n                let ptr = self.as_mut_ptr().offset(index as isize);\n                // copy it out, unsafely having a copy of the value on\n                // the stack and in the vector at the same time.\n                ret = ptr::read(ptr);\n\n                // Shift everything down to fill in that spot.\n                ptr::copy(ptr.offset(1), ptr, len - index - 1);\n            }\n            self.set_len(len - 1);\n            ret\n        }\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n    /// This method operates in place and preserves the order of the retained\n    /// elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.retain(|&x| x%2 == 0);\n    /// assert_eq!(vec, [2, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn retain<F>(&mut self, mut f: F)\n        where F: FnMut(&T) -> bool\n    {\n        let len = self.len();\n        let mut del = 0;\n        {\n            let v = &mut **self;\n\n            for i in 0..len {\n                if !f(&v[i]) {\n                    del += 1;\n                } else if del > 0 {\n                    v.swap(i - del, i);\n                }\n            }\n        }\n        if del > 0 {\n            self.truncate(len - del);\n        }\n    }\n\n    /// Removes all but the first of consecutive elements in the vector that resolve to the same\n    /// key.\n    ///\n    /// If the vector is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![10, 20, 21, 30, 20];\n    ///\n    /// vec.dedup_by_key(|i| *i / 10);\n    ///\n    /// assert_eq!(vec, [10, 20, 30, 20]);\n    /// ```\n    #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n    #[inline]\n    pub fn dedup_by_key<F, K>(&mut self, mut key: F) where F: FnMut(&mut T) -> K, K: PartialEq {\n        self.dedup_by(|a, b| key(a) == key(b))\n    }\n\n    /// Removes all but the first of consecutive elements in the vector satisfying a given equality\n    /// relation.\n    ///\n    /// The `same_bucket` function is passed references to two elements from the vector, and\n    /// returns `true` if the elements compare equal, or `false` if they do not. The elements are\n    /// passed in opposite order from their order in the vector, so if `same_bucket(a, b)` returns\n    /// `true`, `a` is removed.\n    ///\n    /// If the vector is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n    ///\n    /// vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n    ///\n    /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n    /// ```\n    #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n    pub fn dedup_by<F>(&mut self, mut same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n        unsafe {\n            // Although we have a mutable reference to `self`, we cannot make\n            // *arbitrary* changes. The `same_bucket` calls could panic, so we\n            // must ensure that the vector is in a valid state at all time.\n            //\n            // The way that we handle this is by using swaps; we iterate\n            // over all the elements, swapping as we go so that at the end\n            // the elements we wish to keep are in the front, and those we\n            // wish to reject are at the back. We can then truncate the\n            // vector. This operation is still O(n).\n            //\n            // Example: We start in this state, where `r` represents \"next\n            // read\" and `w` represents \"next_write`.\n            //\n            //           r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //           w\n            //\n            // Comparing self[r] against self[w-1], this is not a duplicate, so\n            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n            // r and w, leaving us with:\n            //\n            //               r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //               w\n            //\n            // Comparing self[r] against self[w-1], this value is a duplicate,\n            // so we increment `r` but leave everything else unchanged:\n            //\n            //                   r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //               w\n            //\n            // Comparing self[r] against self[w-1], this is not a duplicate,\n            // so swap self[r] and self[w] and advance r and w:\n            //\n            //                       r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n            //     +---+---+---+---+---+---+\n            //                   w\n            //\n            // Not a duplicate, repeat:\n            //\n            //                           r\n            //     +---+---+---+---+---+---+\n            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n            //     +---+---+---+---+---+---+\n            //                       w\n            //\n            // Duplicate, advance r. End of vec. Truncate to w.\n\n            let ln = self.len();\n            if ln <= 1 {\n                return;\n            }\n\n            // Avoid bounds checks by using raw pointers.\n            let p = self.as_mut_ptr();\n            let mut r: usize = 1;\n            let mut w: usize = 1;\n\n            while r < ln {\n                let p_r = p.offset(r as isize);\n                let p_wm1 = p.offset((w - 1) as isize);\n                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n                    if r != w {\n                        let p_w = p_wm1.offset(1);\n                        mem::swap(&mut *p_r, &mut *p_w);\n                    }\n                    w += 1;\n                }\n                r += 1;\n            }\n\n            self.truncate(w);\n        }\n    }\n\n    /// Appends an element to the back of a collection.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the number of elements in the vector overflows a `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2];\n    /// vec.push(3);\n    /// assert_eq!(vec, [1, 2, 3]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push(&mut self, value: T) {\n        // This will panic or abort if we would allocate > isize::MAX bytes\n        // or if the length increment would overflow for zero-sized types.\n        if self.len == self.buf.cap() {\n            self.buf.double();\n        }\n        unsafe {\n            let end = self.as_mut_ptr().offset(self.len as isize);\n            ptr::write(end, value);\n            self.len += 1;\n        }\n    }\n\n    /// Returns a place for insertion at the back of the `Vec`.\n    ///\n    /// Using this method with placement syntax is equivalent to [`push`](#method.push),\n    /// but may be more efficient.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(collection_placement)]\n    /// #![feature(placement_in_syntax)]\n    ///\n    /// let mut vec = vec![1, 2];\n    /// vec.place_back() <- 3;\n    /// vec.place_back() <- 4;\n    /// assert_eq!(&vec, &[1, 2, 3, 4]);\n    /// ```\n    #[unstable(feature = \"collection_placement\",\n               reason = \"placement protocol is subject to change\",\n               issue = \"30172\")]\n    pub fn place_back(&mut self) -> PlaceBack<T> {\n        PlaceBack { vec: self }\n    }\n\n    /// Removes the last element from a vector and returns it, or [`None`] if it\n    /// is empty.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// assert_eq!(vec.pop(), Some(3));\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            unsafe {\n                self.len -= 1;\n                Some(ptr::read(self.get_unchecked(self.len())))\n            }\n        }\n    }\n\n    /// Moves all the elements of `other` into `Self`, leaving `other` empty.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the number of elements in the vector overflows a `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// let mut vec2 = vec![4, 5, 6];\n    /// vec.append(&mut vec2);\n    /// assert_eq!(vec, [1, 2, 3, 4, 5, 6]);\n    /// assert_eq!(vec2, []);\n    /// ```\n    #[inline]\n    #[stable(feature = \"append\", since = \"1.4.0\")]\n    pub fn append(&mut self, other: &mut Self) {\n        unsafe {\n            self.append_elements(other.as_slice() as _);\n            other.set_len(0);\n        }\n    }\n\n    /// Appends elements to `Self` from other buffer.\n    #[inline]\n    unsafe fn append_elements(&mut self, other: *const [T]) {\n        let count = (*other).len();\n        self.reserve(count);\n        let len = self.len();\n        ptr::copy_nonoverlapping(other as *const T, self.get_unchecked_mut(len), count);\n        self.len += count;\n    }\n\n    /// Creates a draining iterator that removes the specified range in the vector\n    /// and yields the removed items.\n    ///\n    /// Note 1: The element range is removed even if the iterator is only\n    /// partially consumed or not consumed at all.\n    ///\n    /// Note 2: It is unspecified how many elements are removed from the vector\n    /// if the `Drain` value is leaked.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    /// let u: Vec<_> = v.drain(1..).collect();\n    /// assert_eq!(v, &[1]);\n    /// assert_eq!(u, &[2, 3]);\n    ///\n    /// // A full range clears the vector\n    /// v.drain(..);\n    /// assert_eq!(v, &[]);\n    /// ```\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain<R>(&mut self, range: R) -> Drain<T>\n        where R: RangeArgument<usize>\n    {\n        // Memory safety\n        //\n        // When the Drain is first created, it shortens the length of\n        // the source vector to make sure no uninitialized or moved-from elements\n        // are accessible at all if the Drain's destructor never gets to run.\n        //\n        // Drain will ptr::read out the values to remove.\n        // When finished, remaining tail of the vec is copied back to cover\n        // the hole, and the vector length is restored to the new length.\n        //\n        let len = self.len();\n        let start = match range.start() {\n            Included(&n) => n,\n            Excluded(&n) => n + 1,\n            Unbounded    => 0,\n        };\n        let end = match range.end() {\n            Included(&n) => n + 1,\n            Excluded(&n) => n,\n            Unbounded    => len,\n        };\n        assert!(start <= end);\n        assert!(end <= len);\n\n        unsafe {\n            // set self.vec length's to start, to be safe in case Drain is leaked\n            self.set_len(start);\n            // Use the borrow in the IterMut to indicate borrowing behavior of the\n            // whole Drain iterator (like &mut T).\n            let range_slice = slice::from_raw_parts_mut(self.as_mut_ptr().offset(start as isize),\n                                                        end - start);\n            Drain {\n                tail_start: end,\n                tail_len: len - end,\n                iter: range_slice.iter(),\n                vec: NonNull::from(self),\n            }\n        }\n    }\n\n    /// Clears the vector, removing all values.\n    ///\n    /// Note that this method has no effect on the allocated capacity\n    /// of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    ///\n    /// v.clear();\n    ///\n    /// assert!(v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n        self.truncate(0)\n    }\n\n    /// Returns the number of elements in the vector, also referred to\n    /// as its 'length'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = vec![1, 2, 3];\n    /// assert_eq!(a.len(), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n        self.len\n    }\n\n    /// Returns `true` if the vector contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = Vec::new();\n    /// assert!(v.is_empty());\n    ///\n    /// v.push(1);\n    /// assert!(!v.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Splits the collection into two at the given index.\n    ///\n    /// Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n    /// and the returned `Self` contains elements `[at, len)`.\n    ///\n    /// Note that the capacity of `self` does not change.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1,2,3];\n    /// let vec2 = vec.split_off(1);\n    /// assert_eq!(vec, [1]);\n    /// assert_eq!(vec2, [2, 3]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"split_off\", since = \"1.4.0\")]\n    pub fn split_off(&mut self, at: usize) -> Self {\n        assert!(at <= self.len(), \"`at` out of bounds\");\n\n        let other_len = self.len - at;\n        let mut other = Vec::with_capacity(other_len);\n\n        // Unsafely `set_len` and copy items to `other`.\n        unsafe {\n            self.set_len(at);\n            other.set_len(other_len);\n\n            ptr::copy_nonoverlapping(self.as_ptr().offset(at as isize),\n                                     other.as_mut_ptr(),\n                                     other.len());\n        }\n        other\n    }\n}\n\nimpl<T: Clone> Vec<T> {\n    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n    ///\n    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n    /// difference, with each additional slot filled with `value`.\n    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n    ///\n    /// This method requires `Clone` to clone the passed value. If you'd\n    /// rather create a value with `Default` instead, see [`resize_default`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![\"hello\"];\n    /// vec.resize(3, \"world\");\n    /// assert_eq!(vec, [\"hello\", \"world\", \"world\"]);\n    ///\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.resize(2, 0);\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    ///\n    /// [`resize_default`]: #method.resize_default\n    #[stable(feature = \"vec_resize\", since = \"1.5.0\")]\n    pub fn resize(&mut self, new_len: usize, value: T) {\n        let len = self.len();\n\n        if new_len > len {\n            self.extend_with(new_len - len, ExtendElement(value))\n        } else {\n            self.truncate(new_len);\n        }\n    }\n\n    /// Clones and appends all elements in a slice to the `Vec`.\n    ///\n    /// Iterates over the slice `other`, clones each element, and then appends\n    /// it to this `Vec`. The `other` vector is traversed in-order.\n    ///\n    /// Note that this function is same as `extend` except that it is\n    /// specialized to work with slices instead. If and when Rust gets\n    /// specialization this function will likely be deprecated (but still\n    /// available).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.extend_from_slice(&[2, 3, 4]);\n    /// assert_eq!(vec, [1, 2, 3, 4]);\n    /// ```\n    #[stable(feature = \"vec_extend_from_slice\", since = \"1.6.0\")]\n    pub fn extend_from_slice(&mut self, other: &[T]) {\n        self.spec_extend(other.iter())\n    }\n}\n\nimpl<T: Default> Vec<T> {\n    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n    ///\n    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n    /// difference, with each additional slot filled with `Default::default()`.\n    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n    ///\n    /// This method uses `Default` to create new values on every push. If\n    /// you'd rather `Clone` a given value, use [`resize`].\n    ///\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(vec_resize_default)]\n    ///\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.resize_default(5);\n    /// assert_eq!(vec, [1, 2, 3, 0, 0]);\n    ///\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.resize_default(2);\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    ///\n    /// [`resize`]: #method.resize\n    #[unstable(feature = \"vec_resize_default\", issue = \"41758\")]\n    pub fn resize_default(&mut self, new_len: usize) {\n        let len = self.len();\n\n        if new_len > len {\n            self.extend_with(new_len - len, ExtendDefault);\n        } else {\n            self.truncate(new_len);\n        }\n    }\n}\n\n// This code generalises `extend_with_{element,default}`.\ntrait ExtendWith<T> {\n    fn next(&self) -> T;\n    fn last(self) -> T;\n}\n\nstruct ExtendElement<T>(T);\nimpl<T: Clone> ExtendWith<T> for ExtendElement<T> {\n    fn next(&self) -> T { self.0.clone() }\n    fn last(self) -> T { self.0 }\n}\n\nstruct ExtendDefault;\nimpl<T: Default> ExtendWith<T> for ExtendDefault {\n    fn next(&self) -> T { Default::default() }\n    fn last(self) -> T { Default::default() }\n}\nimpl<T> Vec<T> {\n    /// Extend the vector by `n` values, using the given generator.\n    fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, value: E) {\n        self.reserve(n);\n\n        unsafe {\n            let mut ptr = self.as_mut_ptr().offset(self.len() as isize);\n            // Use SetLenOnDrop to work around bug where compiler\n            // may not realize the store through `ptr` through self.set_len()\n            // don't alias.\n            let mut local_len = SetLenOnDrop::new(&mut self.len);\n\n            // Write all elements except the last one\n            for _ in 1..n {\n                ptr::write(ptr, value.next());\n                ptr = ptr.offset(1);\n                // Increment the length in every step in case next() panics\n                local_len.increment_len(1);\n            }\n\n            if n > 0 {\n                // We can write the last element directly without cloning needlessly\n                ptr::write(ptr, value.last());\n                local_len.increment_len(1);\n            }\n\n            // len set by scope guard\n        }\n    }\n}\n\n// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n//\n// The idea is: The length field in SetLenOnDrop is a local variable\n// that the optimizer will see does not alias with any stores through the Vec's data\n// pointer. This is a workaround for alias analysis issue #32155\nstruct SetLenOnDrop<'a> {\n    len: &'a mut usize,\n    local_len: usize,\n}\n\nimpl<'a> SetLenOnDrop<'a> {\n    #[inline]\n    fn new(len: &'a mut usize) -> Self {\n        SetLenOnDrop { local_len: *len, len: len }\n    }\n\n    #[inline]\n    fn increment_len(&mut self, increment: usize) {\n        self.local_len += increment;\n    }\n}\n\nimpl<'a> Drop for SetLenOnDrop<'a> {\n    #[inline]\n    fn drop(&mut self) {\n        *self.len = self.local_len;\n    }\n}\n\nimpl<T: PartialEq> Vec<T> {\n    /// Removes consecutive repeated elements in the vector.\n    ///\n    /// If the vector is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 2, 3, 2];\n    ///\n    /// vec.dedup();\n    ///\n    /// assert_eq!(vec, [1, 2, 3, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn dedup(&mut self) {\n        self.dedup_by(|a, b| a == b)\n    }\n\n    /// Removes the first instance of `item` from the vector if the item exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(vec_remove_item)]\n    /// let mut vec = vec![1, 2, 3, 1];\n    ///\n    /// vec.remove_item(&1);\n    ///\n    /// assert_eq!(vec, vec![2, 3, 1]);\n    /// ```\n    #[unstable(feature = \"vec_remove_item\", reason = \"recently added\", issue = \"40062\")]\n    pub fn remove_item(&mut self, item: &T) -> Option<T> {\n        let pos = self.iter().position(|x| *x == *item)?;\n        Some(self.remove(pos))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Internal methods and functions\n////////////////////////////////////////////////////////////////////////////////\n\n#[doc(hidden)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n    <T as SpecFromElem>::from_elem(elem, n)\n}\n\n// Specialization trait used for Vec::from_elem\ntrait SpecFromElem: Sized {\n    fn from_elem(elem: Self, n: usize) -> Vec<Self>;\n}\n\nimpl<T: Clone> SpecFromElem for T {\n    default fn from_elem(elem: Self, n: usize) -> Vec<Self> {\n        let mut v = Vec::with_capacity(n);\n        v.extend_with(n, ExtendElement(elem));\n        v\n    }\n}\n\nimpl SpecFromElem for u8 {\n    #[inline]\n    fn from_elem(elem: u8, n: usize) -> Vec<u8> {\n        if elem == 0 {\n            return Vec {\n                buf: RawVec::with_capacity_zeroed(n),\n                len: n,\n            }\n        }\n        unsafe {\n            let mut v = Vec::with_capacity(n);\n            ptr::write_bytes(v.as_mut_ptr(), elem, n);\n            v.set_len(n);\n            v\n        }\n    }\n}\n\nmacro_rules! impl_spec_from_elem {\n    ($t: ty, $is_zero: expr) => {\n        impl SpecFromElem for $t {\n            #[inline]\n            fn from_elem(elem: $t, n: usize) -> Vec<$t> {\n                if $is_zero(elem) {\n                    return Vec {\n                        buf: RawVec::with_capacity_zeroed(n),\n                        len: n,\n                    }\n                }\n                let mut v = Vec::with_capacity(n);\n                v.extend_with(n, ExtendElement(elem));\n                v\n            }\n        }\n    };\n}\n\nimpl_spec_from_elem!(i8, |x| x == 0);\nimpl_spec_from_elem!(i16, |x| x == 0);\nimpl_spec_from_elem!(i32, |x| x == 0);\nimpl_spec_from_elem!(i64, |x| x == 0);\nimpl_spec_from_elem!(i128, |x| x == 0);\nimpl_spec_from_elem!(isize, |x| x == 0);\n\nimpl_spec_from_elem!(u16, |x| x == 0);\nimpl_spec_from_elem!(u32, |x| x == 0);\nimpl_spec_from_elem!(u64, |x| x == 0);\nimpl_spec_from_elem!(u128, |x| x == 0);\nimpl_spec_from_elem!(usize, |x| x == 0);\n\nimpl_spec_from_elem!(f32, |x: f32| x == 0. && x.is_sign_positive());\nimpl_spec_from_elem!(f64, |x: f64| x == 0. && x.is_sign_positive());\n\n////////////////////////////////////////////////////////////////////////////////\n// Common trait implementations for Vec\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> Clone for Vec<T> {\n    #[cfg(not(test))]\n    fn clone(&self) -> Vec<T> {\n        <[T]>::to_vec(&**self)\n    }\n\n    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n    // required for this method definition, is not available. Instead use the\n    // `slice::to_vec`  function which is only available with cfg(test)\n    // NB see the slice::hack module in slice.rs for more information\n    #[cfg(test)]\n    fn clone(&self) -> Vec<T> {\n        ::slice::to_vec(&**self)\n    }\n\n    fn clone_from(&mut self, other: &Vec<T>) {\n        other.as_slice().clone_into(self);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Hash> Hash for Vec<T> {\n    #[inline]\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        Hash::hash(&**self, state)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> Index<usize> for Vec<T> {\n    type Output = T;\n\n    #[inline]\n    fn index(&self, index: usize) -> &T {\n        // NB built-in indexing via `&[T]`\n        &(**self)[index]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> IndexMut<usize> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: usize) -> &mut T {\n        // NB built-in indexing via `&mut [T]`\n        &mut (**self)[index]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n    type Output = [T];\n\n    #[inline]\n    fn index(&self, index: ops::Range<usize>) -> &[T] {\n        Index::index(&**self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n    type Output = [T];\n\n    #[inline]\n    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n        Index::index(&**self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n    type Output = [T];\n\n    #[inline]\n    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n        Index::index(&**self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> ops::Index<ops::RangeFull> for Vec<T> {\n    type Output = [T];\n\n    #[inline]\n    fn index(&self, _index: ops::RangeFull) -> &[T] {\n        self\n    }\n}\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n    type Output = [T];\n\n    #[inline]\n    fn index(&self, index: ops::RangeInclusive<usize>) -> &[T] {\n        Index::index(&**self, index)\n    }\n}\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n    type Output = [T];\n\n    #[inline]\n    fn index(&self, index: ops::RangeToInclusive<usize>) -> &[T] {\n        Index::index(&**self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n        self\n    }\n}\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> ops::IndexMut<ops::RangeInclusive<usize>> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\nimpl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::Deref for Vec<T> {\n    type Target = [T];\n\n    fn deref(&self) -> &[T] {\n        unsafe {\n            let p = self.buf.ptr();\n            assume(!p.is_null());\n            slice::from_raw_parts(p, self.len)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::DerefMut for Vec<T> {\n    fn deref_mut(&mut self) -> &mut [T] {\n        unsafe {\n            let ptr = self.buf.ptr();\n            assume(!ptr.is_null());\n            slice::from_raw_parts_mut(ptr, self.len)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> FromIterator<T> for Vec<T> {\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Vec<T> {\n        <Self as SpecExtend<T, I::IntoIter>>::from_iter(iter.into_iter())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Creates a consuming iterator, that is, one that moves each value out of\n    /// the vector (from start to end). The vector cannot be used after calling\n    /// this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n    /// for s in v.into_iter() {\n    ///     // s has type String, not &String\n    ///     println!(\"{}\", s);\n    /// }\n    /// ```\n    #[inline]\n    fn into_iter(mut self) -> IntoIter<T> {\n        unsafe {\n            let begin = self.as_mut_ptr();\n            assume(!begin.is_null());\n            let end = if mem::size_of::<T>() == 0 {\n                arith_offset(begin as *const i8, self.len() as isize) as *const T\n            } else {\n                begin.offset(self.len() as isize) as *const T\n            };\n            let cap = self.buf.cap();\n            mem::forget(self);\n            IntoIter {\n                buf: NonNull::new_unchecked(begin),\n                phantom: PhantomData,\n                cap,\n                ptr: begin,\n                end,\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a Vec<T> {\n    type Item = &'a T;\n    type IntoIter = slice::Iter<'a, T>;\n\n    fn into_iter(self) -> slice::Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a mut Vec<T> {\n    type Item = &'a mut T;\n    type IntoIter = slice::IterMut<'a, T>;\n\n    fn into_iter(self) -> slice::IterMut<'a, T> {\n        self.iter_mut()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Extend<T> for Vec<T> {\n    #[inline]\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n        <Self as SpecExtend<T, I::IntoIter>>::spec_extend(self, iter.into_iter())\n    }\n}\n\n// Specialization trait used for Vec::from_iter and Vec::extend\ntrait SpecExtend<T, I> {\n    fn from_iter(iter: I) -> Self;\n    fn spec_extend(&mut self, iter: I);\n}\n\nimpl<T, I> SpecExtend<T, I> for Vec<T>\n    where I: Iterator<Item=T>,\n{\n    default fn from_iter(mut iterator: I) -> Self {\n        // Unroll the first iteration, as the vector is going to be\n        // expanded on this iteration in every case when the iterable is not\n        // empty, but the loop in extend_desugared() is not going to see the\n        // vector being full in the few subsequent loop iterations.\n        // So we get better branch prediction.\n        let mut vector = match iterator.next() {\n            None => return Vec::new(),\n            Some(element) => {\n                let (lower, _) = iterator.size_hint();\n                let mut vector = Vec::with_capacity(lower.saturating_add(1));\n                unsafe {\n                    ptr::write(vector.get_unchecked_mut(0), element);\n                    vector.set_len(1);\n                }\n                vector\n            }\n        };\n        <Vec<T> as SpecExtend<T, I>>::spec_extend(&mut vector, iterator);\n        vector\n    }\n\n    default fn spec_extend(&mut self, iter: I) {\n        self.extend_desugared(iter)\n    }\n}\n\nimpl<T, I> SpecExtend<T, I> for Vec<T>\n    where I: TrustedLen<Item=T>,\n{\n    default fn from_iter(iterator: I) -> Self {\n        let mut vector = Vec::new();\n        vector.spec_extend(iterator);\n        vector\n    }\n\n    default fn spec_extend(&mut self, iterator: I) {\n        // This is the case for a TrustedLen iterator.\n        let (low, high) = iterator.size_hint();\n        if let Some(high_value) = high {\n            debug_assert_eq!(low, high_value,\n                             \"TrustedLen iterator's size hint is not exact: {:?}\",\n                             (low, high));\n        }\n        if let Some(additional) = high {\n            self.reserve(additional);\n            unsafe {\n                let mut ptr = self.as_mut_ptr().offset(self.len() as isize);\n                let mut local_len = SetLenOnDrop::new(&mut self.len);\n                for element in iterator {\n                    ptr::write(ptr, element);\n                    ptr = ptr.offset(1);\n                    // NB can't overflow since we would have had to alloc the address space\n                    local_len.increment_len(1);\n                }\n            }\n        } else {\n            self.extend_desugared(iterator)\n        }\n    }\n}\n\nimpl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n    fn from_iter(iterator: IntoIter<T>) -> Self {\n        // A common case is passing a vector into a function which immediately\n        // re-collects into a vector. We can short circuit this if the IntoIter\n        // has not been advanced at all.\n        if iterator.buf.as_ptr() as *const _ == iterator.ptr {\n            unsafe {\n                let vec = Vec::from_raw_parts(iterator.buf.as_ptr(),\n                                              iterator.len(),\n                                              iterator.cap);\n                mem::forget(iterator);\n                vec\n            }\n        } else {\n            let mut vector = Vec::new();\n            vector.spec_extend(iterator);\n            vector\n        }\n    }\n\n    fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n        unsafe {\n            self.append_elements(iterator.as_slice() as _);\n        }\n        iterator.ptr = iterator.end;\n    }\n}\n\nimpl<'a, T: 'a, I> SpecExtend<&'a T, I> for Vec<T>\n    where I: Iterator<Item=&'a T>,\n          T: Clone,\n{\n    default fn from_iter(iterator: I) -> Self {\n        SpecExtend::from_iter(iterator.cloned())\n    }\n\n    default fn spec_extend(&mut self, iterator: I) {\n        self.spec_extend(iterator.cloned())\n    }\n}\n\nimpl<'a, T: 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T>\n    where T: Copy,\n{\n    fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n        let slice = iterator.as_slice();\n        self.reserve(slice.len());\n        unsafe {\n            let len = self.len();\n            self.set_len(len + slice.len());\n            self.get_unchecked_mut(len..).copy_from_slice(slice);\n        }\n    }\n}\n\nimpl<T> Vec<T> {\n    fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n        // This is the case for a general iterator.\n        //\n        // This function should be the moral equivalent of:\n        //\n        //      for item in iterator {\n        //          self.push(item);\n        //      }\n        while let Some(element) = iterator.next() {\n            let len = self.len();\n            if len == self.capacity() {\n                let (lower, _) = iterator.size_hint();\n                self.reserve(lower.saturating_add(1));\n            }\n            unsafe {\n                ptr::write(self.get_unchecked_mut(len), element);\n                // NB can't overflow since we would have had to alloc the address space\n                self.set_len(len + 1);\n            }\n        }\n    }\n\n    /// Creates a splicing iterator that replaces the specified range in the vector\n    /// with the given `replace_with` iterator and yields the removed items.\n    /// `replace_with` does not need to be the same length as `range`.\n    ///\n    /// Note 1: The element range is removed even if the iterator is not\n    /// consumed until the end.\n    ///\n    /// Note 2: It is unspecified how many elements are removed from the vector,\n    /// if the `Splice` value is leaked.\n    ///\n    /// Note 3: The input iterator `replace_with` is only consumed\n    /// when the `Splice` value is dropped.\n    ///\n    /// Note 4: This is optimal if:\n    ///\n    /// * The tail (elements in the vector after `range`) is empty,\n    /// * or `replace_with` yields fewer elements than `range`’s length\n    /// * or the lower bound of its `size_hint()` is exact.\n    ///\n    /// Otherwise, a temporary vector is allocated and the tail is moved twice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    /// let new = [7, 8];\n    /// let u: Vec<_> = v.splice(..2, new.iter().cloned()).collect();\n    /// assert_eq!(v, &[7, 8, 3]);\n    /// assert_eq!(u, &[1, 2]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<I::IntoIter>\n        where R: RangeArgument<usize>, I: IntoIterator<Item=T>\n    {\n        Splice {\n            drain: self.drain(range),\n            replace_with: replace_with.into_iter(),\n        }\n    }\n\n    /// Creates an iterator which uses a closure to determine if an element should be removed.\n    ///\n    /// If the closure returns true, then the element is removed and yielded.\n    /// If the closure returns false, it will try again, and call the closure\n    /// on the next element, seeing if it passes the test.\n    ///\n    /// Using this method is equivalent to the following code:\n    ///\n    /// ```\n    /// # let some_predicate = |x: &mut i32| { *x == 2 || *x == 3 || *x == 6 };\n    /// # let mut vec = vec![1, 2, 3, 4, 5, 6];\n    /// let mut i = 0;\n    /// while i != vec.len() {\n    ///     if some_predicate(&mut vec[i]) {\n    ///         let val = vec.remove(i);\n    ///         // your code here\n    ///     } else {\n    ///         i += 1;\n    ///     }\n    /// }\n    ///\n    /// # assert_eq!(vec, vec![1, 4, 5]);\n    /// ```\n    ///\n    /// But `drain_filter` is easier to use. `drain_filter` is also more efficient,\n    /// because it can backshift the elements of the array in bulk.\n    ///\n    /// Note that `drain_filter` also lets you mutate every element in the filter closure,\n    /// regardless of whether you choose to keep or remove it.\n    ///\n    ///\n    /// # Examples\n    ///\n    /// Splitting an array into evens and odds, reusing the original allocation:\n    ///\n    /// ```\n    /// #![feature(drain_filter)]\n    /// let mut numbers = vec![1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15];\n    ///\n    /// let evens = numbers.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n    /// let odds = numbers;\n    ///\n    /// assert_eq!(evens, vec![2, 4, 6, 8, 14]);\n    /// assert_eq!(odds, vec![1, 3, 5, 9, 11, 13, 15]);\n    /// ```\n    #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<T, F>\n        where F: FnMut(&mut T) -> bool,\n    {\n        let old_len = self.len();\n\n        // Guard against us getting leaked (leak amplification)\n        unsafe { self.set_len(0); }\n\n        DrainFilter {\n            vec: self,\n            idx: 0,\n            del: 0,\n            old_len,\n            pred: filter,\n        }\n    }\n}\n\n/// Extend implementation that copies elements out of references before pushing them onto the Vec.\n///\n/// This implementation is specialized for slice iterators, where it uses [`copy_from_slice`] to\n/// append the entire slice at once.\n///\n/// [`copy_from_slice`]: ../../std/primitive.slice.html#method.copy_from_slice\n#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\nimpl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n        self.spec_extend(iter.into_iter())\n    }\n}\n\nmacro_rules! __impl_slice_eq1 {\n    ($Lhs: ty, $Rhs: ty) => {\n        __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n    };\n    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n            #[inline]\n            fn eq(&self, other: &$Rhs) -> bool { self[..] == other[..] }\n            #[inline]\n            fn ne(&self, other: &$Rhs) -> bool { self[..] != other[..] }\n        }\n    }\n}\n\n__impl_slice_eq1! { Vec<A>, Vec<B> }\n__impl_slice_eq1! { Vec<A>, &'b [B] }\n__impl_slice_eq1! { Vec<A>, &'b mut [B] }\n__impl_slice_eq1! { Cow<'a, [A]>, &'b [B], Clone }\n__impl_slice_eq1! { Cow<'a, [A]>, &'b mut [B], Clone }\n__impl_slice_eq1! { Cow<'a, [A]>, Vec<B>, Clone }\n\nmacro_rules! array_impls {\n    ($($N: expr)+) => {\n        $(\n            // NOTE: some less important impls are omitted to reduce code bloat\n            __impl_slice_eq1! { Vec<A>, [B; $N] }\n            __impl_slice_eq1! { Vec<A>, &'b [B; $N] }\n            // __impl_slice_eq1! { Vec<A>, &'b mut [B; $N] }\n            // __impl_slice_eq1! { Cow<'a, [A]>, [B; $N], Clone }\n            // __impl_slice_eq1! { Cow<'a, [A]>, &'b [B; $N], Clone }\n            // __impl_slice_eq1! { Cow<'a, [A]>, &'b mut [B; $N], Clone }\n        )+\n    }\n}\n\narray_impls! {\n     0  1  2  3  4  5  6  7  8  9\n    10 11 12 13 14 15 16 17 18 19\n    20 21 22 23 24 25 26 27 28 29\n    30 31 32\n}\n\n/// Implements comparison of vectors, lexicographically.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: PartialOrd> PartialOrd for Vec<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n        PartialOrd::partial_cmp(&**self, &**other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Eq> Eq for Vec<T> {}\n\n/// Implements ordering of vectors, lexicographically.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord> Ord for Vec<T> {\n    #[inline]\n    fn cmp(&self, other: &Vec<T>) -> Ordering {\n        Ord::cmp(&**self, &**other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T> Drop for Vec<T> {\n    fn drop(&mut self) {\n        unsafe {\n            // use drop for [T]\n            ptr::drop_in_place(&mut self[..]);\n        }\n        // RawVec handles deallocation\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for Vec<T> {\n    /// Creates an empty `Vec<T>`.\n    fn default() -> Vec<T> {\n        Vec::new()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Vec<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsRef<Vec<T>> for Vec<T> {\n    fn as_ref(&self) -> &Vec<T> {\n        self\n    }\n}\n\n#[stable(feature = \"vec_as_mut\", since = \"1.5.0\")]\nimpl<T> AsMut<Vec<T>> for Vec<T> {\n    fn as_mut(&mut self) -> &mut Vec<T> {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsRef<[T]> for Vec<T> {\n    fn as_ref(&self) -> &[T] {\n        self\n    }\n}\n\n#[stable(feature = \"vec_as_mut\", since = \"1.5.0\")]\nimpl<T> AsMut<[T]> for Vec<T> {\n    fn as_mut(&mut self) -> &mut [T] {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: Clone> From<&'a [T]> for Vec<T> {\n    #[cfg(not(test))]\n    fn from(s: &'a [T]) -> Vec<T> {\n        s.to_vec()\n    }\n    #[cfg(test)]\n    fn from(s: &'a [T]) -> Vec<T> {\n        ::slice::to_vec(s)\n    }\n}\n\n#[stable(feature = \"vec_from_mut\", since = \"1.19.0\")]\nimpl<'a, T: Clone> From<&'a mut [T]> for Vec<T> {\n    #[cfg(not(test))]\n    fn from(s: &'a mut [T]) -> Vec<T> {\n        s.to_vec()\n    }\n    #[cfg(test)]\n    fn from(s: &'a mut [T]) -> Vec<T> {\n        ::slice::to_vec(s)\n    }\n}\n\n#[stable(feature = \"vec_from_cow_slice\", since = \"1.14.0\")]\nimpl<'a, T> From<Cow<'a, [T]>> for Vec<T> where [T]: ToOwned<Owned=Vec<T>> {\n    fn from(s: Cow<'a, [T]>) -> Vec<T> {\n        s.into_owned()\n    }\n}\n\n// note: test pulls in libstd, which causes errors here\n#[cfg(not(test))]\n#[stable(feature = \"vec_from_box\", since = \"1.18.0\")]\nimpl<T> From<Box<[T]>> for Vec<T> {\n    fn from(s: Box<[T]>) -> Vec<T> {\n        s.into_vec()\n    }\n}\n\n// note: test pulls in libstd, which causes errors here\n#[cfg(not(test))]\n#[stable(feature = \"box_from_vec\", since = \"1.20.0\")]\nimpl<T> From<Vec<T>> for Box<[T]> {\n    fn from(v: Vec<T>) -> Box<[T]> {\n        v.into_boxed_slice()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<&'a str> for Vec<u8> {\n    fn from(s: &'a str) -> Vec<u8> {\n        From::from(s.as_bytes())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Clone-on-write\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\nimpl<'a, T: Clone> From<&'a [T]> for Cow<'a, [T]> {\n    fn from(s: &'a [T]) -> Cow<'a, [T]> {\n        Cow::Borrowed(s)\n    }\n}\n\n#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\nimpl<'a, T: Clone> From<Vec<T>> for Cow<'a, [T]> {\n    fn from(v: Vec<T>) -> Cow<'a, [T]> {\n        Cow::Owned(v)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n    fn from_iter<I: IntoIterator<Item = T>>(it: I) -> Cow<'a, [T]> {\n        Cow::Owned(FromIterator::from_iter(it))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Iterators\n////////////////////////////////////////////////////////////////////////////////\n\n/// An iterator that moves out of a vector.\n///\n/// This `struct` is created by the `into_iter` method on [`Vec`][`Vec`] (provided\n/// by the [`IntoIterator`] trait).\n///\n/// [`Vec`]: struct.Vec.html\n/// [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<T> {\n    buf: NonNull<T>,\n    phantom: PhantomData<T>,\n    cap: usize,\n    ptr: *const T,\n    end: *const T,\n}\n\n#[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\nimpl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"IntoIter\")\n            .field(&self.as_slice())\n            .finish()\n    }\n}\n\nimpl<T> IntoIter<T> {\n    /// Returns the remaining items of this iterator as a slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let vec = vec!['a', 'b', 'c'];\n    /// let mut into_iter = vec.into_iter();\n    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n    /// let _ = into_iter.next().unwrap();\n    /// assert_eq!(into_iter.as_slice(), &['b', 'c']);\n    /// ```\n    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n    pub fn as_slice(&self) -> &[T] {\n        unsafe {\n            slice::from_raw_parts(self.ptr, self.len())\n        }\n    }\n\n    /// Returns the remaining items of this iterator as a mutable slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let vec = vec!['a', 'b', 'c'];\n    /// let mut into_iter = vec.into_iter();\n    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n    /// into_iter.as_mut_slice()[2] = 'z';\n    /// assert_eq!(into_iter.next().unwrap(), 'a');\n    /// assert_eq!(into_iter.next().unwrap(), 'b');\n    /// assert_eq!(into_iter.next().unwrap(), 'z');\n    /// ```\n    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n        unsafe {\n            slice::from_raw_parts_mut(self.ptr as *mut T, self.len())\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Send> Send for IntoIter<T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Sync for IntoIter<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        unsafe {\n            if self.ptr as *const _ == self.end {\n                None\n            } else {\n                if mem::size_of::<T>() == 0 {\n                    // purposefully don't use 'ptr.offset' because for\n                    // vectors with 0-size elements this would return the\n                    // same pointer.\n                    self.ptr = arith_offset(self.ptr as *const i8, 1) as *mut T;\n\n                    // Use a non-null pointer value\n                    // (self.ptr might be null because of wrapping)\n                    Some(ptr::read(1 as *mut T))\n                } else {\n                    let old = self.ptr;\n                    self.ptr = self.ptr.offset(1);\n\n                    Some(ptr::read(old))\n                }\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let exact = match self.ptr.offset_to(self.end) {\n            Some(x) => x as usize,\n            None => (self.end as usize).wrapping_sub(self.ptr as usize),\n        };\n        (exact, Some(exact))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n        unsafe {\n            if self.end == self.ptr {\n                None\n            } else {\n                if mem::size_of::<T>() == 0 {\n                    // See above for why 'ptr.offset' isn't used\n                    self.end = arith_offset(self.end as *const i8, -1) as *mut T;\n\n                    // Use a non-null pointer value\n                    // (self.end might be null because of wrapping)\n                    Some(ptr::read(1 as *mut T))\n                } else {\n                    self.end = self.end.offset(-1);\n\n                    Some(ptr::read(self.end))\n                }\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for IntoIter<T> {\n    fn is_empty(&self) -> bool {\n        self.ptr == self.end\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<T> FusedIterator for IntoIter<T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for IntoIter<T> {}\n\n#[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\nimpl<T: Clone> Clone for IntoIter<T> {\n    fn clone(&self) -> IntoIter<T> {\n        self.as_slice().to_owned().into_iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        // destroy the remaining elements\n        for _x in self.by_ref() {}\n\n        // RawVec handles deallocation\n        let _ = unsafe { RawVec::from_raw_parts(self.buf.as_ptr(), self.cap) };\n    }\n}\n\n/// A draining iterator for `Vec<T>`.\n///\n/// This `struct` is created by the [`drain`] method on [`Vec`].\n///\n/// [`drain`]: struct.Vec.html#method.drain\n/// [`Vec`]: struct.Vec.html\n#[stable(feature = \"drain\", since = \"1.6.0\")]\npub struct Drain<'a, T: 'a> {\n    /// Index of tail to preserve\n    tail_start: usize,\n    /// Length of tail\n    tail_len: usize,\n    /// Current remaining range to remove\n    iter: slice::Iter<'a, T>,\n    vec: NonNull<Vec<T>>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<'a, T: 'a + fmt::Debug> fmt::Debug for Drain<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"Drain\")\n         .field(&self.iter.as_slice())\n         .finish()\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl<'a, T: Send> Send for Drain<'a, T> {}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a, T> Iterator for Drain<'a, T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a, T> Drop for Drain<'a, T> {\n    fn drop(&mut self) {\n        // exhaust self first\n        while let Some(_) = self.next() {}\n\n        if self.tail_len > 0 {\n            unsafe {\n                let source_vec = self.vec.as_mut();\n                // memmove back untouched tail, update to new length\n                let start = source_vec.len();\n                let tail = self.tail_start;\n                let src = source_vec.as_ptr().offset(tail as isize);\n                let dst = source_vec.as_mut_ptr().offset(start as isize);\n                ptr::copy(src, dst, self.tail_len);\n                source_vec.set_len(start + self.tail_len);\n            }\n        }\n    }\n}\n\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a, T> ExactSizeIterator for Drain<'a, T> {\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for Drain<'a, T> {}\n\n/// A place for insertion at the back of a `Vec`.\n///\n/// See [`Vec::place_back`](struct.Vec.html#method.place_back) for details.\n#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n#[unstable(feature = \"collection_placement\",\n           reason = \"struct name and placement protocol are subject to change\",\n           issue = \"30172\")]\n#[derive(Debug)]\npub struct PlaceBack<'a, T: 'a> {\n    vec: &'a mut Vec<T>,\n}\n\n#[unstable(feature = \"collection_placement\",\n           reason = \"placement protocol is subject to change\",\n           issue = \"30172\")]\nimpl<'a, T> Placer<T> for PlaceBack<'a, T> {\n    type Place = PlaceBack<'a, T>;\n\n    fn make_place(self) -> Self {\n        // This will panic or abort if we would allocate > isize::MAX bytes\n        // or if the length increment would overflow for zero-sized types.\n        if self.vec.len == self.vec.buf.cap() {\n            self.vec.buf.double();\n        }\n        self\n    }\n}\n\n#[unstable(feature = \"collection_placement\",\n           reason = \"placement protocol is subject to change\",\n           issue = \"30172\")]\nunsafe impl<'a, T> Place<T> for PlaceBack<'a, T> {\n    fn pointer(&mut self) -> *mut T {\n        unsafe { self.vec.as_mut_ptr().offset(self.vec.len as isize) }\n    }\n}\n\n#[unstable(feature = \"collection_placement\",\n           reason = \"placement protocol is subject to change\",\n           issue = \"30172\")]\nimpl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n    type Owner = &'a mut T;\n\n    unsafe fn finalize(mut self) -> &'a mut T {\n        let ptr = self.pointer();\n        self.vec.len += 1;\n        &mut *ptr\n    }\n}\n\n\n/// A splicing iterator for `Vec`.\n///\n/// This struct is created by the [`splice()`] method on [`Vec`]. See its\n/// documentation for more.\n///\n/// [`splice()`]: struct.Vec.html#method.splice\n/// [`Vec`]: struct.Vec.html\n#[derive(Debug)]\n#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\npub struct Splice<'a, I: Iterator + 'a> {\n    drain: Drain<'a, I::Item>,\n    replace_with: I,\n}\n\n#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\nimpl<'a, I: Iterator> Iterator for Splice<'a, I> {\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.drain.next()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.drain.size_hint()\n    }\n}\n\n#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\nimpl<'a, I: Iterator> DoubleEndedIterator for Splice<'a, I> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.drain.next_back()\n    }\n}\n\n#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\nimpl<'a, I: Iterator> ExactSizeIterator for Splice<'a, I> {}\n\n\n#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\nimpl<'a, I: Iterator> Drop for Splice<'a, I> {\n    fn drop(&mut self) {\n        // exhaust drain first\n        while let Some(_) = self.drain.next() {}\n\n\n        unsafe {\n            if self.drain.tail_len == 0 {\n                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n                return\n            }\n\n            // First fill the range left by drain().\n            if !self.drain.fill(&mut self.replace_with) {\n                return\n            }\n\n            // There may be more elements. Use the lower bound as an estimate.\n            // FIXME: Is the upper bound a better guess? Or something else?\n            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n            if lower_bound > 0  {\n                self.drain.move_tail(lower_bound);\n                if !self.drain.fill(&mut self.replace_with) {\n                    return\n                }\n            }\n\n            // Collect any remaining elements.\n            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n            let mut collected = self.replace_with.by_ref().collect::<Vec<I::Item>>().into_iter();\n            // Now we have an exact count.\n            if collected.len() > 0 {\n                self.drain.move_tail(collected.len());\n                let filled = self.drain.fill(&mut collected);\n                debug_assert!(filled);\n                debug_assert_eq!(collected.len(), 0);\n            }\n        }\n        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n    }\n}\n\n/// Private helper methods for `Splice::drop`\nimpl<'a, T> Drain<'a, T> {\n    /// The range from `self.vec.len` to `self.tail_start` contains elements\n    /// that have been moved out.\n    /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n    /// Return whether we filled the entire range. (`replace_with.next()` didn’t return `None`.)\n    unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n        let vec = self.vec.as_mut();\n        let range_start = vec.len;\n        let range_end = self.tail_start;\n        let range_slice = slice::from_raw_parts_mut(\n            vec.as_mut_ptr().offset(range_start as isize),\n            range_end - range_start);\n\n        for place in range_slice {\n            if let Some(new_item) = replace_with.next() {\n                ptr::write(place, new_item);\n                vec.len += 1;\n            } else {\n                return false\n            }\n        }\n        true\n    }\n\n    /// Make room for inserting more elements before the tail.\n    unsafe fn move_tail(&mut self, extra_capacity: usize) {\n        let vec = self.vec.as_mut();\n        let used_capacity = self.tail_start + self.tail_len;\n        vec.buf.reserve(used_capacity, extra_capacity);\n\n        let new_tail_start = self.tail_start + extra_capacity;\n        let src = vec.as_ptr().offset(self.tail_start as isize);\n        let dst = vec.as_mut_ptr().offset(new_tail_start as isize);\n        ptr::copy(src, dst, self.tail_len);\n        self.tail_start = new_tail_start;\n    }\n}\n\n/// An iterator produced by calling `drain_filter` on Vec.\n#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n#[derive(Debug)]\npub struct DrainFilter<'a, T: 'a, F>\n    where F: FnMut(&mut T) -> bool,\n{\n    vec: &'a mut Vec<T>,\n    idx: usize,\n    del: usize,\n    old_len: usize,\n    pred: F,\n}\n\n#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\nimpl<'a, T, F> Iterator for DrainFilter<'a, T, F>\n    where F: FnMut(&mut T) -> bool,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        unsafe {\n            while self.idx != self.old_len {\n                let i = self.idx;\n                self.idx += 1;\n                let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n                if (self.pred)(&mut v[i]) {\n                    self.del += 1;\n                    return Some(ptr::read(&v[i]));\n                } else if self.del > 0 {\n                    let del = self.del;\n                    let src: *const T = &v[i];\n                    let dst: *mut T = &mut v[i - del];\n                    // This is safe because self.vec has length 0\n                    // thus its elements will not have Drop::drop\n                    // called on them in the event of a panic.\n                    ptr::copy_nonoverlapping(src, dst, 1);\n                }\n            }\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, Some(self.old_len - self.idx))\n    }\n}\n\n#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\nimpl<'a, T, F> Drop for DrainFilter<'a, T, F>\n    where F: FnMut(&mut T) -> bool,\n{\n    fn drop(&mut self) {\n        for _ in self.by_ref() { }\n\n        unsafe {\n            self.vec.set_len(self.old_len - self.del);\n        }\n    }\n}\n","// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Slice management and manipulation\n//!\n//! For more details see [`std::slice`].\n//!\n//! [`std::slice`]: ../../std/slice/index.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n// How this module is organized.\n//\n// The library infrastructure for slices is fairly messy. There's\n// a lot of stuff defined here. Let's keep it clean.\n//\n// Since slices don't support inherent methods; all operations\n// on them are defined on traits, which are then re-exported from\n// the prelude for convenience. So there are a lot of traits here.\n//\n// The layout of this file is thus:\n//\n// * Slice-specific 'extension' traits and their implementations. This\n//   is where most of the slice API resides.\n// * Implementations of a few common traits with important slice ops.\n// * Definitions of a bunch of iterators.\n// * Free functions.\n// * The `raw` and `bytes` submodules.\n// * Boilerplate trait implementations.\n\nuse cmp::Ordering::{self, Less, Equal, Greater};\nuse cmp;\nuse fmt;\nuse intrinsics::assume;\nuse iter::*;\nuse ops::{FnMut, Try, self};\nuse option::Option;\nuse option::Option::{None, Some};\nuse result::Result;\nuse result::Result::{Ok, Err};\nuse ptr;\nuse mem;\nuse marker::{Copy, Send, Sync, Sized, self};\nuse iter_private::TrustedRandomAccess;\n\n#[unstable(feature = \"slice_internals\", issue = \"0\",\n           reason = \"exposed from core to be reused in std; use the memchr crate\")]\n/// Pure rust memchr implementation, taken from rust-memchr\npub mod memchr;\n\nmod rotate;\nmod sort;\n\n#[repr(C)]\nstruct Repr<T> {\n    pub data: *const T,\n    pub len: usize,\n}\n\n//\n// Extension traits\n//\n\n/// Extension methods for slices.\n#[unstable(feature = \"core_slice_ext\",\n           reason = \"stable interface provided by `impl [T]` in later crates\",\n           issue = \"32110\")]\n#[allow(missing_docs)] // documented elsewhere\npub trait SliceExt {\n    type Item;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_at(&self, mid: usize) -> (&[Self::Item], &[Self::Item]);\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn iter(&self) -> Iter<Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split<P>(&self, pred: P) -> Split<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n    fn rsplit<P>(&self, pred: P) -> RSplit<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn splitn<P>(&self, n: usize, pred: P) -> SplitN<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn rsplitn<P>(&self,  n: usize, pred: P) -> RSplitN<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn windows(&self, size: usize) -> Windows<Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn chunks(&self, size: usize) -> Chunks<Self::Item>;\n\n    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n    fn exact_chunks(&self, size: usize) -> ExactChunks<Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn get<I>(&self, index: I) -> Option<&I::Output>\n        where I: SliceIndex<Self>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn first(&self) -> Option<&Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_first(&self) -> Option<(&Self::Item, &[Self::Item])>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_last(&self) -> Option<(&Self::Item, &[Self::Item])>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn last(&self) -> Option<&Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n        where I: SliceIndex<Self>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn as_ptr(&self) -> *const Self::Item;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn binary_search(&self, x: &Self::Item) -> Result<usize, usize>\n        where Self::Item: Ord;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n        where F: FnMut(&'a Self::Item) -> Ordering;\n\n    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n    fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n        where F: FnMut(&'a Self::Item) -> B,\n              B: Ord;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn len(&self) -> usize;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_empty(&self) -> bool { self.len() == 0 }\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n        where I: SliceIndex<Self>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn iter_mut(&mut self) -> IterMut<Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn first_mut(&mut self) -> Option<&mut Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_first_mut(&mut self) -> Option<(&mut Self::Item, &mut [Self::Item])>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_last_mut(&mut self) -> Option<(&mut Self::Item, &mut [Self::Item])>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn last_mut(&mut self) -> Option<&mut Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_mut<P>(&mut self, pred: P) -> SplitMut<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n    fn rsplit_mut<P>(&mut self, pred: P) -> RSplitMut<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn rsplitn_mut<P>(&mut self,  n: usize, pred: P) -> RSplitNMut<Self::Item, P>\n        where P: FnMut(&Self::Item) -> bool;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<Self::Item>;\n\n    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n    fn exact_chunks_mut(&mut self, size: usize) -> ExactChunksMut<Self::Item>;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn swap(&mut self, a: usize, b: usize);\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn split_at_mut(&mut self, mid: usize) -> (&mut [Self::Item], &mut [Self::Item]);\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn reverse(&mut self);\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n        where I: SliceIndex<Self>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n\n    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n    fn rotate_left(&mut self, mid: usize);\n\n    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n    fn rotate_right(&mut self, k: usize);\n\n    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n    fn clone_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Clone;\n\n    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n    fn copy_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Copy;\n\n    #[unstable(feature = \"swap_with_slice\", issue = \"44030\")]\n    fn swap_with_slice(&mut self, src: &mut [Self::Item]);\n\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    fn sort_unstable(&mut self)\n        where Self::Item: Ord;\n\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    fn sort_unstable_by<F>(&mut self, compare: F)\n        where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    fn sort_unstable_by_key<B, F>(&mut self, f: F)\n        where F: FnMut(&Self::Item) -> B,\n              B: Ord;\n}\n\n// Use macros to be generic over const/mut\nmacro_rules! slice_offset {\n    ($ptr:expr, $by:expr) => {{\n        let ptr = $ptr;\n        if size_from_ptr(ptr) == 0 {\n            (ptr as *mut i8).wrapping_offset($by) as _\n        } else {\n            ptr.offset($by)\n        }\n    }};\n}\n\n// make a &T from a *const T\nmacro_rules! make_ref {\n    ($ptr:expr) => {{\n        let ptr = $ptr;\n        if size_from_ptr(ptr) == 0 {\n            // Use a non-null pointer value\n            &*(1 as *mut _)\n        } else {\n            &*ptr\n        }\n    }};\n}\n\n// make a &mut T from a *mut T\nmacro_rules! make_ref_mut {\n    ($ptr:expr) => {{\n        let ptr = $ptr;\n        if size_from_ptr(ptr) == 0 {\n            // Use a non-null pointer value\n            &mut *(1 as *mut _)\n        } else {\n            &mut *ptr\n        }\n    }};\n}\n\n#[unstable(feature = \"core_slice_ext\",\n           reason = \"stable interface provided by `impl [T]` in later crates\",\n           issue = \"32110\")]\nimpl<T> SliceExt for [T] {\n    type Item = T;\n\n    #[inline]\n    fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        (&self[..mid], &self[mid..])\n    }\n\n    #[inline]\n    fn iter(&self) -> Iter<T> {\n        unsafe {\n            let p = if mem::size_of::<T>() == 0 {\n                1 as *const _\n            } else {\n                let p = self.as_ptr();\n                assume(!p.is_null());\n                p\n            };\n\n            Iter {\n                ptr: p,\n                end: slice_offset!(p, self.len() as isize),\n                _marker: marker::PhantomData\n            }\n        }\n    }\n\n    #[inline]\n    fn split<P>(&self, pred: P) -> Split<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        Split {\n            v: self,\n            pred,\n            finished: false\n        }\n    }\n\n    #[inline]\n    fn rsplit<P>(&self, pred: P) -> RSplit<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        RSplit { inner: self.split(pred) }\n    }\n\n    #[inline]\n    fn splitn<P>(&self, n: usize, pred: P) -> SplitN<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        SplitN {\n            inner: GenericSplitN {\n                iter: self.split(pred),\n                count: n\n            }\n        }\n    }\n\n    #[inline]\n    fn rsplitn<P>(&self, n: usize, pred: P) -> RSplitN<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        RSplitN {\n            inner: GenericSplitN {\n                iter: self.rsplit(pred),\n                count: n\n            }\n        }\n    }\n\n    #[inline]\n    fn windows(&self, size: usize) -> Windows<T> {\n        assert!(size != 0);\n        Windows { v: self, size: size }\n    }\n\n    #[inline]\n    fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n        assert!(chunk_size != 0);\n        Chunks { v: self, chunk_size: chunk_size }\n    }\n\n    #[inline]\n    fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n        assert!(chunk_size != 0);\n        let rem = self.len() % chunk_size;\n        let len = self.len() - rem;\n        ExactChunks { v: &self[..len], chunk_size: chunk_size}\n    }\n\n    #[inline]\n    fn get<I>(&self, index: I) -> Option<&I::Output>\n        where I: SliceIndex<[T]>\n    {\n        index.get(self)\n    }\n\n    #[inline]\n    fn first(&self) -> Option<&T> {\n        if self.is_empty() { None } else { Some(&self[0]) }\n    }\n\n    #[inline]\n    fn split_first(&self) -> Option<(&T, &[T])> {\n        if self.is_empty() { None } else { Some((&self[0], &self[1..])) }\n    }\n\n    #[inline]\n    fn split_last(&self) -> Option<(&T, &[T])> {\n        let len = self.len();\n        if len == 0 { None } else { Some((&self[len - 1], &self[..(len - 1)])) }\n    }\n\n    #[inline]\n    fn last(&self) -> Option<&T> {\n        if self.is_empty() { None } else { Some(&self[self.len() - 1]) }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n        where I: SliceIndex<[T]>\n    {\n        index.get_unchecked(self)\n    }\n\n    #[inline]\n    fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }\n\n    fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n        where F: FnMut(&'a T) -> Ordering\n    {\n        let s = self;\n        let mut size = s.len();\n        if size == 0 {\n            return Err(0);\n        }\n        let mut base = 0usize;\n        while size > 1 {\n            let half = size / 2;\n            let mid = base + half;\n            // mid is always in [0, size), that means mid is >= 0 and < size.\n            // mid >= 0: by definition\n            // mid < size: mid = size / 2 + size / 4 + size / 8 ...\n            let cmp = f(unsafe { s.get_unchecked(mid) });\n            base = if cmp == Greater { base } else { mid };\n            size -= half;\n        }\n        // base is always in [0, size) because base <= mid.\n        let cmp = f(unsafe { s.get_unchecked(base) });\n        if cmp == Equal { Ok(base) } else { Err(base + (cmp == Less) as usize) }\n    }\n\n    #[inline]\n    fn len(&self) -> usize {\n        unsafe {\n            mem::transmute::<&[T], Repr<T>>(self).len\n        }\n    }\n\n    #[inline]\n    fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n        where I: SliceIndex<[T]>\n    {\n        index.get_mut(self)\n    }\n\n    #[inline]\n    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n        let len = self.len();\n        let ptr = self.as_mut_ptr();\n\n        unsafe {\n            assert!(mid <= len);\n\n            (from_raw_parts_mut(ptr, mid),\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n        }\n    }\n\n    #[inline]\n    fn iter_mut(&mut self) -> IterMut<T> {\n        unsafe {\n            let p = if mem::size_of::<T>() == 0 {\n                1 as *mut _\n            } else {\n                let p = self.as_mut_ptr();\n                assume(!p.is_null());\n                p\n            };\n\n            IterMut {\n                ptr: p,\n                end: slice_offset!(p, self.len() as isize),\n                _marker: marker::PhantomData\n            }\n        }\n    }\n\n    #[inline]\n    fn last_mut(&mut self) -> Option<&mut T> {\n        let len = self.len();\n        if len == 0 { return None; }\n        Some(&mut self[len - 1])\n    }\n\n    #[inline]\n    fn first_mut(&mut self) -> Option<&mut T> {\n        if self.is_empty() { None } else { Some(&mut self[0]) }\n    }\n\n    #[inline]\n    fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n        if self.is_empty() { None } else {\n            let split = self.split_at_mut(1);\n            Some((&mut split.0[0], split.1))\n        }\n    }\n\n    #[inline]\n    fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n        let len = self.len();\n        if len == 0 { None } else {\n            let split = self.split_at_mut(len - 1);\n            Some((&mut split.1[0], split.0))\n        }\n    }\n\n    #[inline]\n    fn split_mut<P>(&mut self, pred: P) -> SplitMut<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        SplitMut { v: self, pred: pred, finished: false }\n    }\n\n    #[inline]\n    fn rsplit_mut<P>(&mut self, pred: P) -> RSplitMut<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        RSplitMut { inner: self.split_mut(pred) }\n    }\n\n    #[inline]\n    fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<T, P>\n        where P: FnMut(&T) -> bool\n    {\n        SplitNMut {\n            inner: GenericSplitN {\n                iter: self.split_mut(pred),\n                count: n\n            }\n        }\n    }\n\n    #[inline]\n    fn rsplitn_mut<P>(&mut self, n: usize, pred: P) -> RSplitNMut<T, P> where\n        P: FnMut(&T) -> bool,\n    {\n        RSplitNMut {\n            inner: GenericSplitN {\n                iter: self.rsplit_mut(pred),\n                count: n\n            }\n        }\n    }\n\n    #[inline]\n    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n        assert!(chunk_size != 0);\n        ChunksMut { v: self, chunk_size: chunk_size }\n    }\n\n    #[inline]\n    fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n        assert!(chunk_size != 0);\n        let rem = self.len() % chunk_size;\n        let len = self.len() - rem;\n        ExactChunksMut { v: &mut self[..len], chunk_size: chunk_size}\n    }\n\n    #[inline]\n    fn swap(&mut self, a: usize, b: usize) {\n        unsafe {\n            // Can't take two mutable loans from one vector, so instead just cast\n            // them to their raw pointers to do the swap\n            let pa: *mut T = &mut self[a];\n            let pb: *mut T = &mut self[b];\n            ptr::swap(pa, pb);\n        }\n    }\n\n    fn reverse(&mut self) {\n        let mut i: usize = 0;\n        let ln = self.len();\n\n        // For very small types, all the individual reads in the normal\n        // path perform poorly.  We can do better, given efficient unaligned\n        // load/store, by loading a larger chunk and reversing a register.\n\n        // Ideally LLVM would do this for us, as it knows better than we do\n        // whether unaligned reads are efficient (since that changes between\n        // different ARM versions, for example) and what the best chunk size\n        // would be.  Unfortunately, as of LLVM 4.0 (2017-05) it only unrolls\n        // the loop, so we need to do this ourselves.  (Hypothesis: reverse\n        // is troublesome because the sides can be aligned differently --\n        // will be, when the length is odd -- so there's no way of emitting\n        // pre- and postludes to use fully-aligned SIMD in the middle.)\n\n        let fast_unaligned =\n            cfg!(any(target_arch = \"x86\", target_arch = \"x86_64\"));\n\n        if fast_unaligned && mem::size_of::<T>() == 1 {\n            // Use the llvm.bswap intrinsic to reverse u8s in a usize\n            let chunk = mem::size_of::<usize>();\n            while i + chunk - 1 < ln / 2 {\n                unsafe {\n                    let pa: *mut T = self.get_unchecked_mut(i);\n                    let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n                    let va = ptr::read_unaligned(pa as *mut usize);\n                    let vb = ptr::read_unaligned(pb as *mut usize);\n                    ptr::write_unaligned(pa as *mut usize, vb.swap_bytes());\n                    ptr::write_unaligned(pb as *mut usize, va.swap_bytes());\n                }\n                i += chunk;\n            }\n        }\n\n        if fast_unaligned && mem::size_of::<T>() == 2 {\n            // Use rotate-by-16 to reverse u16s in a u32\n            let chunk = mem::size_of::<u32>() / 2;\n            while i + chunk - 1 < ln / 2 {\n                unsafe {\n                    let pa: *mut T = self.get_unchecked_mut(i);\n                    let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n                    let va = ptr::read_unaligned(pa as *mut u32);\n                    let vb = ptr::read_unaligned(pb as *mut u32);\n                    ptr::write_unaligned(pa as *mut u32, vb.rotate_left(16));\n                    ptr::write_unaligned(pb as *mut u32, va.rotate_left(16));\n                }\n                i += chunk;\n            }\n        }\n\n        while i < ln / 2 {\n            // Unsafe swap to avoid the bounds check in safe swap.\n            unsafe {\n                let pa: *mut T = self.get_unchecked_mut(i);\n                let pb: *mut T = self.get_unchecked_mut(ln - i - 1);\n                ptr::swap(pa, pb);\n            }\n            i += 1;\n        }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n        where I: SliceIndex<[T]>\n    {\n        index.get_unchecked_mut(self)\n    }\n\n    #[inline]\n    fn as_mut_ptr(&mut self) -> *mut T {\n        self as *mut [T] as *mut T\n    }\n\n    #[inline]\n    fn contains(&self, x: &T) -> bool where T: PartialEq {\n        x.slice_contains(self)\n    }\n\n    #[inline]\n    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n        let n = needle.len();\n        self.len() >= n && needle == &self[..n]\n    }\n\n    #[inline]\n    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n        let (m, n) = (self.len(), needle.len());\n        m >= n && needle == &self[m-n..]\n    }\n\n    fn binary_search(&self, x: &T) -> Result<usize, usize>\n        where T: Ord\n    {\n        self.binary_search_by(|p| p.cmp(x))\n    }\n\n    fn rotate_left(&mut self, mid: usize) {\n        assert!(mid <= self.len());\n        let k = self.len() - mid;\n\n        unsafe {\n            let p = self.as_mut_ptr();\n            rotate::ptr_rotate(mid, p.offset(mid as isize), k);\n        }\n    }\n\n    fn rotate_right(&mut self, k: usize) {\n        assert!(k <= self.len());\n        let mid = self.len() - k;\n\n        unsafe {\n            let p = self.as_mut_ptr();\n            rotate::ptr_rotate(mid, p.offset(mid as isize), k);\n        }\n    }\n\n    #[inline]\n    fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n        assert!(self.len() == src.len(),\n                \"destination and source slices have different lengths\");\n        // NOTE: We need to explicitly slice them to the same length\n        // for bounds checking to be elided, and the optimizer will\n        // generate memcpy for simple cases (for example T = u8).\n        let len = self.len();\n        let src = &src[..len];\n        for i in 0..len {\n            self[i].clone_from(&src[i]);\n        }\n    }\n\n    #[inline]\n    fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n        assert!(self.len() == src.len(),\n                \"destination and source slices have different lengths\");\n        unsafe {\n            ptr::copy_nonoverlapping(\n                src.as_ptr(), self.as_mut_ptr(), self.len());\n        }\n    }\n\n    #[inline]\n    fn swap_with_slice(&mut self, src: &mut [T]) {\n        assert!(self.len() == src.len(),\n                \"destination and source slices have different lengths\");\n        unsafe {\n            ptr::swap_nonoverlapping(\n                self.as_mut_ptr(), src.as_mut_ptr(), self.len());\n        }\n    }\n\n    #[inline]\n    fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n        where F: FnMut(&'a Self::Item) -> B,\n              B: Ord\n    {\n        self.binary_search_by(|k| f(k).cmp(b))\n    }\n\n    #[inline]\n    fn sort_unstable(&mut self)\n        where Self::Item: Ord\n    {\n        sort::quicksort(self, |a, b| a.lt(b));\n    }\n\n    #[inline]\n    fn sort_unstable_by<F>(&mut self, mut compare: F)\n        where F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        sort::quicksort(self, |a, b| compare(a, b) == Ordering::Less);\n    }\n\n    #[inline]\n    fn sort_unstable_by_key<B, F>(&mut self, mut f: F)\n        where F: FnMut(&Self::Item) -> B,\n              B: Ord\n    {\n        sort::quicksort(self, |a, b| f(a).lt(&f(b)));\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\nimpl<T, I> ops::Index<I> for [T]\n    where I: SliceIndex<[T]>\n{\n    type Output = I::Output;\n\n    #[inline]\n    fn index(&self, index: I) -> &I::Output {\n        index.index(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\nimpl<T, I> ops::IndexMut<I> for [T]\n    where I: SliceIndex<[T]>\n{\n    #[inline]\n    fn index_mut(&mut self, index: I) -> &mut I::Output {\n        index.index_mut(self)\n    }\n}\n\n#[inline(never)]\n#[cold]\nfn slice_index_len_fail(index: usize, len: usize) -> ! {\n    panic!(\"index {} out of range for slice of length {}\", index, len);\n}\n\n#[inline(never)]\n#[cold]\nfn slice_index_order_fail(index: usize, end: usize) -> ! {\n    panic!(\"slice index starts at {} but ends at {}\", index, end);\n}\n\n/// A helper trait used for indexing operations.\n#[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\npub trait SliceIndex<T: ?Sized> {\n    /// The output type returned by methods.\n    type Output: ?Sized;\n\n    /// Returns a shared reference to the output at this location, if in\n    /// bounds.\n    fn get(self, slice: &T) -> Option<&Self::Output>;\n\n    /// Returns a mutable reference to the output at this location, if in\n    /// bounds.\n    fn get_mut(self, slice: &mut T) -> Option<&mut Self::Output>;\n\n    /// Returns a shared reference to the output at this location, without\n    /// performing any bounds checking.\n    unsafe fn get_unchecked(self, slice: &T) -> &Self::Output;\n\n    /// Returns a mutable reference to the output at this location, without\n    /// performing any bounds checking.\n    unsafe fn get_unchecked_mut(self, slice: &mut T) -> &mut Self::Output;\n\n    /// Returns a shared reference to the output at this location, panicking\n    /// if out of bounds.\n    fn index(self, slice: &T) -> &Self::Output;\n\n    /// Returns a mutable reference to the output at this location, panicking\n    /// if out of bounds.\n    fn index_mut(self, slice: &mut T) -> &mut Self::Output;\n}\n\n#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for usize {\n    type Output = T;\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&T> {\n        if self < slice.len() {\n            unsafe {\n                Some(self.get_unchecked(slice))\n            }\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n        if self < slice.len() {\n            unsafe {\n                Some(self.get_unchecked_mut(slice))\n            }\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &T {\n        &*slice.as_ptr().offset(self as isize)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {\n        &mut *slice.as_mut_ptr().offset(self as isize)\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &T {\n        // NB: use intrinsic indexing\n        &(*slice)[self]\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut T {\n        // NB: use intrinsic indexing\n        &mut (*slice)[self]\n    }\n}\n\n#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for  ops::Range<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        if self.start > self.end || self.end > slice.len() {\n            None\n        } else {\n            unsafe {\n                Some(self.get_unchecked(slice))\n            }\n        }\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        if self.start > self.end || self.end > slice.len() {\n            None\n        } else {\n            unsafe {\n                Some(self.get_unchecked_mut(slice))\n            }\n        }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n        from_raw_parts(slice.as_ptr().offset(self.start as isize), self.end - self.start)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n        from_raw_parts_mut(slice.as_mut_ptr().offset(self.start as isize), self.end - self.start)\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        if self.start > self.end {\n            slice_index_order_fail(self.start, self.end);\n        } else if self.end > slice.len() {\n            slice_index_len_fail(self.end, slice.len());\n        }\n        unsafe {\n            self.get_unchecked(slice)\n        }\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        if self.start > self.end {\n            slice_index_order_fail(self.start, self.end);\n        } else if self.end > slice.len() {\n            slice_index_len_fail(self.end, slice.len());\n        }\n        unsafe {\n            self.get_unchecked_mut(slice)\n        }\n    }\n}\n\n#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        (0..self.end).get(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        (0..self.end).get_mut(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n        (0..self.end).get_unchecked(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n        (0..self.end).get_unchecked_mut(slice)\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        (0..self.end).index(slice)\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        (0..self.end).index_mut(slice)\n    }\n}\n\n#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        (self.start..slice.len()).get(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        (self.start..slice.len()).get_mut(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n        (self.start..slice.len()).get_unchecked(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n        (self.start..slice.len()).get_unchecked_mut(slice)\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        (self.start..slice.len()).index(slice)\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        (self.start..slice.len()).index_mut(slice)\n    }\n}\n\n#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for ops::RangeFull {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        Some(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        Some(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n        slice\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n        slice\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        slice\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        slice\n    }\n}\n\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        if self.end == usize::max_value() { None }\n        else { (self.start..self.end + 1).get(slice) }\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        if self.end == usize::max_value() { None }\n        else { (self.start..self.end + 1).get_mut(slice) }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n        (self.start..self.end + 1).get_unchecked(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n        (self.start..self.end + 1).get_unchecked_mut(slice)\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        assert!(self.end != usize::max_value(),\n            \"attempted to index slice up to maximum usize\");\n        (self.start..self.end + 1).index(slice)\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        assert!(self.end != usize::max_value(),\n            \"attempted to index slice up to maximum usize\");\n        (self.start..self.end + 1).index_mut(slice)\n    }\n}\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        (0..=self.end).get(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        (0..=self.end).get_mut(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n        (0..=self.end).get_unchecked(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n        (0..=self.end).get_unchecked_mut(slice)\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        (0..=self.end).index(slice)\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        (0..=self.end).index_mut(slice)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Common traits\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Default for &'a [T] {\n    /// Creates an empty slice.\n    fn default() -> &'a [T] { &[] }\n}\n\n#[stable(feature = \"mut_slice_default\", since = \"1.5.0\")]\nimpl<'a, T> Default for &'a mut [T] {\n    /// Creates a mutable empty slice.\n    fn default() -> &'a mut [T] { &mut [] }\n}\n\n//\n// Iterators\n//\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a [T] {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a mut [T] {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n        self.iter_mut()\n    }\n}\n\n#[inline]\nfn size_from_ptr<T>(_: *const T) -> usize {\n    mem::size_of::<T>()\n}\n\n// The shared definition of the `Iter` and `IterMut` iterators\nmacro_rules! iterator {\n    (struct $name:ident -> $ptr:ty, $elem:ty, $mkref:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n                unsafe {\n                    if mem::size_of::<T>() != 0 {\n                        assume(!self.ptr.is_null());\n                        assume(!self.end.is_null());\n                    }\n                    if self.ptr == self.end {\n                        None\n                    } else {\n                        Some($mkref!(self.ptr.post_inc()))\n                    }\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = ptrdistance(self.ptr, self.end);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                self.len()\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                // Call helper method. Can't put the definition here because mut versus const.\n                self.iter_nth(n)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n                Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n            {\n                // manual unrolling is needed when there are conditional exits from the loop\n                let mut accum = init;\n                unsafe {\n                    while ptrdistance(self.ptr, self.end) >= 4 {\n                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n                    }\n                    while self.ptr != self.end {\n                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n                    }\n                }\n                Try::from_ok(accum)\n            }\n\n            #[inline]\n            fn fold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n                where Fold: FnMut(Acc, Self::Item) -> Acc,\n            {\n                // Let LLVM unroll this, rather than using the default\n                // impl that would force the manual unrolling above\n                let mut accum = init;\n                while let Some(x) = self.next() {\n                    accum = f(accum, x);\n                }\n                accum\n            }\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                // The addition might panic on overflow\n                let n = self.len();\n                self.try_fold(0, move |i, x| {\n                    if predicate(x) { Err(i) }\n                    else { Ok(i + 1) }\n                }).err()\n                    .map(|i| {\n                        unsafe { assume(i < n) };\n                        i\n                    })\n            }\n\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                // No need for an overflow check here, because `ExactSizeIterator`\n                // implies that the number of elements fits into a `usize`.\n                let n = self.len();\n                self.try_rfold(n, move |i, x| {\n                    let i = i - 1;\n                    if predicate(x) { Err(i) }\n                    else { Ok(i) }\n                }).err()\n                    .map(|i| {\n                        unsafe { assume(i < n) };\n                        i\n                    })\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n                unsafe {\n                    if mem::size_of::<T>() != 0 {\n                        assume(!self.ptr.is_null());\n                        assume(!self.end.is_null());\n                    }\n                    if self.end == self.ptr {\n                        None\n                    } else {\n                        Some($mkref!(self.end.pre_dec()))\n                    }\n                }\n            }\n\n            #[inline]\n            fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n                Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n            {\n                // manual unrolling is needed when there are conditional exits from the loop\n                let mut accum = init;\n                unsafe {\n                    while ptrdistance(self.ptr, self.end) >= 4 {\n                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n                    }\n                    while self.ptr != self.end {\n                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n                    }\n                }\n                Try::from_ok(accum)\n            }\n\n            #[inline]\n            fn rfold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n                where Fold: FnMut(Acc, Self::Item) -> Acc,\n            {\n                // Let LLVM unroll this, rather than using the default\n                // impl that would force the manual unrolling above\n                let mut accum = init;\n                while let Some(x) = self.next_back() {\n                    accum = f(accum, x);\n                }\n                accum\n            }\n        }\n    }\n}\n\nmacro_rules! make_slice {\n    ($start: expr, $end: expr) => {{\n        let start = $start;\n        let diff = ($end as usize).wrapping_sub(start as usize);\n        if size_from_ptr(start) == 0 {\n            // use a non-null pointer value\n            unsafe { from_raw_parts(1 as *const _, diff) }\n        } else {\n            let len = diff / size_from_ptr(start);\n            unsafe { from_raw_parts(start, len) }\n        }\n    }}\n}\n\nmacro_rules! make_mut_slice {\n    ($start: expr, $end: expr) => {{\n        let start = $start;\n        let diff = ($end as usize).wrapping_sub(start as usize);\n        if size_from_ptr(start) == 0 {\n            // use a non-null pointer value\n            unsafe { from_raw_parts_mut(1 as *mut _, diff) }\n        } else {\n            let len = diff / size_from_ptr(start);\n            unsafe { from_raw_parts_mut(start, len) }\n        }\n    }}\n}\n\n/// Immutable slice iterator\n///\n/// This struct is created by the [`iter`] method on [slices].\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // First, we declare a type which has `iter` method to get the `Iter` struct (&[usize here]):\n/// let slice = &[1, 2, 3];\n///\n/// // Then, we iterate over it:\n/// for element in slice.iter() {\n///     println!(\"{}\", element);\n/// }\n/// ```\n///\n/// [`iter`]: ../../std/primitive.slice.html#method.iter\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> {\n    ptr: *const T,\n    end: *const T,\n    _marker: marker::PhantomData<&'a T>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"Iter\")\n            .field(&self.as_slice())\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<'a, T: Sync> Send for Iter<'a, T> {}\n\nimpl<'a, T> Iter<'a, T> {\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// This has the same lifetime as the original slice, and so the\n    /// iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // First, we declare a type which has the `iter` method to get the `Iter`\n    /// // struct (&[usize here]):\n    /// let slice = &[1, 2, 3];\n    ///\n    /// // Then, we get the iterator:\n    /// let mut iter = slice.iter();\n    /// // So if we print what `as_slice` method returns here, we have \"[1, 2, 3]\":\n    /// println!(\"{:?}\", iter.as_slice());\n    ///\n    /// // Next, we move to the second element of the slice:\n    /// iter.next();\n    /// // Now `as_slice` returns \"[2, 3]\":\n    /// println!(\"{:?}\", iter.as_slice());\n    /// ```\n    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n    pub fn as_slice(&self) -> &'a [T] {\n        make_slice!(self.ptr, self.end)\n    }\n\n    // Helper function for Iter::nth\n    fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n        match self.as_slice().get(n) {\n            Some(elem_ref) => unsafe {\n                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n                Some(elem_ref)\n            },\n            None => {\n                self.ptr = self.end;\n                None\n            }\n        }\n    }\n}\n\niterator!{struct Iter -> *const T, &'a T, make_ref}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for Iter<'a, T> {\n    fn is_empty(&self) -> bool {\n        self.ptr == self.end\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for Iter<'a, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, T> TrustedLen for Iter<'a, T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Clone for Iter<'a, T> {\n    fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, _marker: self._marker } }\n}\n\n#[stable(feature = \"slice_iter_as_ref\", since = \"1.13.0\")]\nimpl<'a, T> AsRef<[T]> for Iter<'a, T> {\n    fn as_ref(&self) -> &[T] {\n        self.as_slice()\n    }\n}\n\n/// Mutable slice iterator.\n///\n/// This struct is created by the [`iter_mut`] method on [slices].\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // First, we declare a type which has `iter_mut` method to get the `IterMut`\n/// // struct (&[usize here]):\n/// let mut slice = &mut [1, 2, 3];\n///\n/// // Then, we iterate over it and increment each element value:\n/// for element in slice.iter_mut() {\n///     *element += 1;\n/// }\n///\n/// // We now have \"[2, 3, 4]\":\n/// println!(\"{:?}\", slice);\n/// ```\n///\n/// [`iter_mut`]: ../../std/primitive.slice.html#method.iter_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IterMut<'a, T: 'a> {\n    ptr: *mut T,\n    end: *mut T,\n    _marker: marker::PhantomData<&'a mut T>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug> fmt::Debug for IterMut<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"IterMut\")\n            .field(&make_slice!(self.ptr, self.end))\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<'a, T: Send> Send for IterMut<'a, T> {}\n\nimpl<'a, T> IterMut<'a, T> {\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// To avoid creating `&mut` references that alias, this is forced\n    /// to consume the iterator. Consider using the `Slice` and\n    /// `SliceMut` implementations for obtaining slices with more\n    /// restricted lifetimes that do not consume the iterator.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // First, we declare a type which has `iter_mut` method to get the `IterMut`\n    /// // struct (&[usize here]):\n    /// let mut slice = &mut [1, 2, 3];\n    ///\n    /// {\n    ///     // Then, we get the iterator:\n    ///     let mut iter = slice.iter_mut();\n    ///     // We move to next element:\n    ///     iter.next();\n    ///     // So if we print what `into_slice` method returns here, we have \"[2, 3]\":\n    ///     println!(\"{:?}\", iter.into_slice());\n    /// }\n    ///\n    /// // Now let's modify a value of the slice:\n    /// {\n    ///     // First we get back the iterator:\n    ///     let mut iter = slice.iter_mut();\n    ///     // We change the value of the first element of the slice returned by the `next` method:\n    ///     *iter.next().unwrap() += 1;\n    /// }\n    /// // Now slice is \"[2, 2, 3]\":\n    /// println!(\"{:?}\", slice);\n    /// ```\n    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n    pub fn into_slice(self) -> &'a mut [T] {\n        make_mut_slice!(self.ptr, self.end)\n    }\n\n    // Helper function for IterMut::nth\n    fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n        match make_mut_slice!(self.ptr, self.end).get_mut(n) {\n            Some(elem_ref) => unsafe {\n                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n                Some(elem_ref)\n            },\n            None => {\n                self.ptr = self.end;\n                None\n            }\n        }\n    }\n}\n\niterator!{struct IterMut -> *mut T, &'a mut T, make_ref_mut}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n    fn is_empty(&self) -> bool {\n        self.ptr == self.end\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for IterMut<'a, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, T> TrustedLen for IterMut<'a, T> {}\n\n\n// Return the number of elements of `T` from `start` to `end`.\n// Return the arithmetic difference if `T` is zero size.\n#[inline(always)]\nfn ptrdistance<T>(start: *const T, end: *const T) -> usize {\n    match start.offset_to(end) {\n        Some(x) => x as usize,\n        None => (end as usize).wrapping_sub(start as usize),\n    }\n}\n\n// Extension methods for raw pointers, used by the iterators\ntrait PointerExt : Copy {\n    unsafe fn slice_offset(self, i: isize) -> Self;\n\n    /// Increments `self` by 1, but returns the old value.\n    #[inline(always)]\n    unsafe fn post_inc(&mut self) -> Self {\n        let current = *self;\n        *self = self.slice_offset(1);\n        current\n    }\n\n    /// Decrements `self` by 1, and returns the new value.\n    #[inline(always)]\n    unsafe fn pre_dec(&mut self) -> Self {\n        *self = self.slice_offset(-1);\n        *self\n    }\n}\n\nimpl<T> PointerExt for *const T {\n    #[inline(always)]\n    unsafe fn slice_offset(self, i: isize) -> Self {\n        slice_offset!(self, i)\n    }\n}\n\nimpl<T> PointerExt for *mut T {\n    #[inline(always)]\n    unsafe fn slice_offset(self, i: isize) -> Self {\n        slice_offset!(self, i)\n    }\n}\n\n/// An internal abstraction over the splitting iterators, so that\n/// splitn, splitn_mut etc can be implemented once.\n#[doc(hidden)]\ntrait SplitIter: DoubleEndedIterator {\n    /// Marks the underlying iterator as complete, extracting the remaining\n    /// portion of the slice.\n    fn finish(&mut self) -> Option<Self::Item>;\n}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function.\n///\n/// This struct is created by the [`split`] method on [slices].\n///\n/// [`split`]: ../../std/primitive.slice.html#method.split\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool {\n    v: &'a [T],\n    pred: P,\n    finished: bool\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for Split<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Split\")\n            .field(\"v\", &self.v)\n            .field(\"finished\", &self.finished)\n            .finish()\n    }\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n    fn clone(&self) -> Split<'a, T, P> {\n        Split {\n            v: self.v,\n            pred: self.pred.clone(),\n            finished: self.finished,\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.finished { return None; }\n\n        match self.v.iter().position(|x| (self.pred)(x)) {\n            None => self.finish(),\n            Some(idx) => {\n                let ret = Some(&self.v[..idx]);\n                self.v = &self.v[idx + 1..];\n                ret\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.finished {\n            (0, Some(0))\n        } else {\n            (1, Some(self.v.len() + 1))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.finished { return None; }\n\n        match self.v.iter().rposition(|x| (self.pred)(x)) {\n            None => self.finish(),\n            Some(idx) => {\n                let ret = Some(&self.v[idx + 1..]);\n                self.v = &self.v[..idx];\n                ret\n            }\n        }\n    }\n}\n\nimpl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool {\n    #[inline]\n    fn finish(&mut self) -> Option<&'a [T]> {\n        if self.finished { None } else { self.finished = true; Some(self.v) }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T, P> FusedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over the subslices of the vector which are separated\n/// by elements that match `pred`.\n///\n/// This struct is created by the [`split_mut`] method on [slices].\n///\n/// [`split_mut`]: ../../std/primitive.slice.html#method.split_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n    v: &'a mut [T],\n    pred: P,\n    finished: bool\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"SplitMut\")\n            .field(\"v\", &self.v)\n            .field(\"finished\", &self.finished)\n            .finish()\n    }\n}\n\nimpl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n    #[inline]\n    fn finish(&mut self) -> Option<&'a mut [T]> {\n        if self.finished {\n            None\n        } else {\n            self.finished = true;\n            Some(mem::replace(&mut self.v, &mut []))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        if self.finished { return None; }\n\n        let idx_opt = { // work around borrowck limitations\n            let pred = &mut self.pred;\n            self.v.iter().position(|x| (*pred)(x))\n        };\n        match idx_opt {\n            None => self.finish(),\n            Some(idx) => {\n                let tmp = mem::replace(&mut self.v, &mut []);\n                let (head, tail) = tmp.split_at_mut(idx);\n                self.v = &mut tail[1..];\n                Some(head)\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.finished {\n            (0, Some(0))\n        } else {\n            // if the predicate doesn't match anything, we yield one slice\n            // if it matches every element, we yield len+1 empty slices.\n            (1, Some(self.v.len() + 1))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        if self.finished { return None; }\n\n        let idx_opt = { // work around borrowck limitations\n            let pred = &mut self.pred;\n            self.v.iter().rposition(|x| (*pred)(x))\n        };\n        match idx_opt {\n            None => self.finish(),\n            Some(idx) => {\n                let tmp = mem::replace(&mut self.v, &mut []);\n                let (head, tail) = tmp.split_at_mut(idx);\n                self.v = head;\n                Some(&mut tail[1..])\n            }\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T, P> FusedIterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function, starting from the end of the slice.\n///\n/// This struct is created by the [`rsplit`] method on [slices].\n///\n/// [`rsplit`]: ../../std/primitive.slice.html#method.rsplit\n/// [slices]: ../../std/primitive.slice.html\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n#[derive(Clone)] // Is this correct, or does it incorrectly require `T: Clone`?\npub struct RSplit<'a, T:'a, P> where P: FnMut(&T) -> bool {\n    inner: Split<'a, T, P>\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"RSplit\")\n            .field(\"v\", &self.inner.v)\n            .field(\"finished\", &self.inner.finished)\n            .finish()\n    }\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> Iterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        self.inner.next_back()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> DoubleEndedIterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        self.inner.next()\n    }\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> SplitIter for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n    #[inline]\n    fn finish(&mut self) -> Option<&'a [T]> {\n        self.inner.finish()\n    }\n}\n\n//#[unstable(feature = \"fused\", issue = \"35602\")]\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> FusedIterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over the subslices of the vector which are separated\n/// by elements that match `pred`, starting from the end of the slice.\n///\n/// This struct is created by the [`rsplit_mut`] method on [slices].\n///\n/// [`rsplit_mut`]: ../../std/primitive.slice.html#method.rsplit_mut\n/// [slices]: ../../std/primitive.slice.html\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\npub struct RSplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n    inner: SplitMut<'a, T, P>\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"RSplitMut\")\n            .field(\"v\", &self.inner.v)\n            .field(\"finished\", &self.inner.finished)\n            .finish()\n    }\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> SplitIter for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n    #[inline]\n    fn finish(&mut self) -> Option<&'a mut [T]> {\n        self.inner.finish()\n    }\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> Iterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        self.inner.next_back()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> DoubleEndedIterator for RSplitMut<'a, T, P> where\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        self.inner.next()\n    }\n}\n\n//#[unstable(feature = \"fused\", issue = \"35602\")]\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\nimpl<'a, T, P> FusedIterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n\n/// An private iterator over subslices separated by elements that\n/// match a predicate function, splitting at most a fixed number of\n/// times.\n#[derive(Debug)]\nstruct GenericSplitN<I> {\n    iter: I,\n    count: usize,\n}\n\nimpl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        match self.count {\n            0 => None,\n            1 => { self.count -= 1; self.iter.finish() }\n            _ => { self.count -= 1; self.iter.next() }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (lower, upper_opt) = self.iter.size_hint();\n        (lower, upper_opt.map(|upper| cmp::min(self.count, upper)))\n    }\n}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function, limited to a given number of splits.\n///\n/// This struct is created by the [`splitn`] method on [slices].\n///\n/// [`splitn`]: ../../std/primitive.slice.html#method.splitn\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n    inner: GenericSplitN<Split<'a, T, P>>\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitN<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"SplitN\")\n            .field(\"inner\", &self.inner)\n            .finish()\n    }\n}\n\n/// An iterator over subslices separated by elements that match a\n/// predicate function, limited to a given number of splits, starting\n/// from the end of the slice.\n///\n/// This struct is created by the [`rsplitn`] method on [slices].\n///\n/// [`rsplitn`]: ../../std/primitive.slice.html#method.rsplitn\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n    inner: GenericSplitN<RSplit<'a, T, P>>\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplitN<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"RSplitN\")\n            .field(\"inner\", &self.inner)\n            .finish()\n    }\n}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function, limited to a given number of splits.\n///\n/// This struct is created by the [`splitn_mut`] method on [slices].\n///\n/// [`splitn_mut`]: ../../std/primitive.slice.html#method.splitn_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n    inner: GenericSplitN<SplitMut<'a, T, P>>\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitNMut<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"SplitNMut\")\n            .field(\"inner\", &self.inner)\n            .finish()\n    }\n}\n\n/// An iterator over subslices separated by elements that match a\n/// predicate function, limited to a given number of splits, starting\n/// from the end of the slice.\n///\n/// This struct is created by the [`rsplitn_mut`] method on [slices].\n///\n/// [`rsplitn_mut`]: ../../std/primitive.slice.html#method.rsplitn_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n    inner: GenericSplitN<RSplitMut<'a, T, P>>\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplitNMut<'a, T, P> where P: FnMut(&T) -> bool {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"RSplitNMut\")\n            .field(\"inner\", &self.inner)\n            .finish()\n    }\n}\n\nmacro_rules! forward_iterator {\n    ($name:ident: $elem:ident, $iter_of:ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, $elem, P> Iterator for $name<'a, $elem, P> where\n            P: FnMut(&T) -> bool\n        {\n            type Item = $iter_of;\n\n            #[inline]\n            fn next(&mut self) -> Option<$iter_of> {\n                self.inner.next()\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.inner.size_hint()\n            }\n        }\n\n        #[unstable(feature = \"fused\", issue = \"35602\")]\n        impl<'a, $elem, P> FusedIterator for $name<'a, $elem, P>\n            where P: FnMut(&T) -> bool {}\n    }\n}\n\nforward_iterator! { SplitN: T, &'a [T] }\nforward_iterator! { RSplitN: T, &'a [T] }\nforward_iterator! { SplitNMut: T, &'a mut [T] }\nforward_iterator! { RSplitNMut: T, &'a mut [T] }\n\n/// An iterator over overlapping subslices of length `size`.\n///\n/// This struct is created by the [`windows`] method on [slices].\n///\n/// [`windows`]: ../../std/primitive.slice.html#method.windows\n/// [slices]: ../../std/primitive.slice.html\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Windows<'a, T:'a> {\n    v: &'a [T],\n    size: usize\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Clone for Windows<'a, T> {\n    fn clone(&self) -> Windows<'a, T> {\n        Windows {\n            v: self.v,\n            size: self.size,\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Windows<'a, T> {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.size > self.v.len() {\n            None\n        } else {\n            let ret = Some(&self.v[..self.size]);\n            self.v = &self.v[1..];\n            ret\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.size > self.v.len() {\n            (0, Some(0))\n        } else {\n            let size = self.v.len() - self.size + 1;\n            (size, Some(size))\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        let (end, overflow) = self.size.overflowing_add(n);\n        if end > self.v.len() || overflow {\n            self.v = &[];\n            None\n        } else {\n            let nth = &self.v[n..end];\n            self.v = &self.v[n+1..];\n            Some(nth)\n        }\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        if self.size > self.v.len() {\n            None\n        } else {\n            let start = self.v.len() - self.size;\n            Some(&self.v[start..])\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.size > self.v.len() {\n            None\n        } else {\n            let ret = Some(&self.v[self.v.len()-self.size..]);\n            self.v = &self.v[..self.v.len()-1];\n            ret\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for Windows<'a, T> {}\n\n#[doc(hidden)]\nunsafe impl<'a, T> TrustedRandomAccess for Windows<'a, T> {\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n        from_raw_parts(self.v.as_ptr().offset(i as isize), self.size)\n    }\n    fn may_have_side_effect() -> bool { false }\n}\n\n/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n/// time).\n///\n/// When the slice len is not evenly divided by the chunk size, the last slice\n/// of the iteration will be the remainder.\n///\n/// This struct is created by the [`chunks`] method on [slices].\n///\n/// [`chunks`]: ../../std/primitive.slice.html#method.chunks\n/// [slices]: ../../std/primitive.slice.html\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Chunks<'a, T:'a> {\n    v: &'a [T],\n    chunk_size: usize\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Clone for Chunks<'a, T> {\n    fn clone(&self) -> Chunks<'a, T> {\n        Chunks {\n            v: self.v,\n            chunk_size: self.chunk_size,\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Chunks<'a, T> {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n            let (fst, snd) = self.v.split_at(chunksz);\n            self.v = snd;\n            Some(fst)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.v.is_empty() {\n            (0, Some(0))\n        } else {\n            let n = self.v.len() / self.chunk_size;\n            let rem = self.v.len() % self.chunk_size;\n            let n = if rem > 0 { n+1 } else { n };\n            (n, Some(n))\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n        if start >= self.v.len() || overflow {\n            self.v = &[];\n            None\n        } else {\n            let end = match start.checked_add(self.chunk_size) {\n                Some(sum) => cmp::min(self.v.len(), sum),\n                None => self.v.len(),\n            };\n            let nth = &self.v[start..end];\n            self.v = &self.v[end..];\n            Some(nth)\n        }\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n            Some(&self.v[start..])\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let remainder = self.v.len() % self.chunk_size;\n            let chunksz = if remainder != 0 { remainder } else { self.chunk_size };\n            let (fst, snd) = self.v.split_at(self.v.len() - chunksz);\n            self.v = fst;\n            Some(snd)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for Chunks<'a, T> {}\n\n#[doc(hidden)]\nunsafe impl<'a, T> TrustedRandomAccess for Chunks<'a, T> {\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n        let start = i * self.chunk_size;\n        let end = match start.checked_add(self.chunk_size) {\n            None => self.v.len(),\n            Some(end) => cmp::min(end, self.v.len()),\n        };\n        from_raw_parts(self.v.as_ptr().offset(start as isize), end - start)\n    }\n    fn may_have_side_effect() -> bool { false }\n}\n\n/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n/// elements at a time). When the slice len is not evenly divided by the chunk\n/// size, the last slice of the iteration will be the remainder.\n///\n/// This struct is created by the [`chunks_mut`] method on [slices].\n///\n/// [`chunks_mut`]: ../../std/primitive.slice.html#method.chunks_mut\n/// [slices]: ../../std/primitive.slice.html\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ChunksMut<'a, T:'a> {\n    v: &'a mut [T],\n    chunk_size: usize\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for ChunksMut<'a, T> {\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let sz = cmp::min(self.v.len(), self.chunk_size);\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(sz);\n            self.v = tail;\n            Some(head)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.v.is_empty() {\n            (0, Some(0))\n        } else {\n            let n = self.v.len() / self.chunk_size;\n            let rem = self.v.len() % self.chunk_size;\n            let n = if rem > 0 { n + 1 } else { n };\n            (n, Some(n))\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n        if start >= self.v.len() || overflow {\n            self.v = &mut [];\n            None\n        } else {\n            let end = match start.checked_add(self.chunk_size) {\n                Some(sum) => cmp::min(self.v.len(), sum),\n                None => self.v.len(),\n            };\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(end);\n            let (_, nth) =  head.split_at_mut(start);\n            self.v = tail;\n            Some(nth)\n        }\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n            Some(&mut self.v[start..])\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let remainder = self.v.len() % self.chunk_size;\n            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let tmp_len = tmp.len();\n            let (head, tail) = tmp.split_at_mut(tmp_len - sz);\n            self.v = head;\n            Some(tail)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for ChunksMut<'a, T> {}\n\n#[doc(hidden)]\nunsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n        let start = i * self.chunk_size;\n        let end = match start.checked_add(self.chunk_size) {\n            None => self.v.len(),\n            Some(end) => cmp::min(end, self.v.len()),\n        };\n        from_raw_parts_mut(self.v.as_mut_ptr().offset(start as isize), end - start)\n    }\n    fn may_have_side_effect() -> bool { false }\n}\n\n/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n/// time).\n///\n/// When the slice len is not evenly divided by the chunk size, the last\n/// up to `chunk_size-1` elements will be omitted.\n///\n/// This struct is created by the [`exact_chunks`] method on [slices].\n///\n/// [`exact_chunks`]: ../../std/primitive.slice.html#method.exact_chunks\n/// [slices]: ../../std/primitive.slice.html\n#[derive(Debug)]\n#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\npub struct ExactChunks<'a, T:'a> {\n    v: &'a [T],\n    chunk_size: usize\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\nimpl<'a, T> Clone for ExactChunks<'a, T> {\n    fn clone(&self) -> ExactChunks<'a, T> {\n        ExactChunks {\n            v: self.v,\n            chunk_size: self.chunk_size,\n        }\n    }\n}\n\n#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\nimpl<'a, T> Iterator for ExactChunks<'a, T> {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let (fst, snd) = self.v.split_at(self.chunk_size);\n            self.v = snd;\n            Some(fst)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.v.len() / self.chunk_size;\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n        if start >= self.v.len() || overflow {\n            self.v = &[];\n            None\n        } else {\n            let (_, snd) = self.v.split_at(start);\n            self.v = snd;\n            self.next()\n        }\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n}\n\n#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\nimpl<'a, T> DoubleEndedIterator for ExactChunks<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);\n            self.v = fst;\n            Some(snd)\n        }\n    }\n}\n\n#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\nimpl<'a, T> ExactSizeIterator for ExactChunks<'a, T> {\n    fn is_empty(&self) -> bool {\n        self.v.is_empty()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for ExactChunks<'a, T> {}\n\n#[doc(hidden)]\nunsafe impl<'a, T> TrustedRandomAccess for ExactChunks<'a, T> {\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n        let start = i * self.chunk_size;\n        from_raw_parts(self.v.as_ptr().offset(start as isize), self.chunk_size)\n    }\n    fn may_have_side_effect() -> bool { false }\n}\n\n/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n/// elements at a time). When the slice len is not evenly divided by the chunk\n/// size, the last up to `chunk_size-1` elements will be omitted.\n///\n/// This struct is created by the [`exact_chunks_mut`] method on [slices].\n///\n/// [`exact_chunks_mut`]: ../../std/primitive.slice.html#method.exact_chunks_mut\n/// [slices]: ../../std/primitive.slice.html\n#[derive(Debug)]\n#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\npub struct ExactChunksMut<'a, T:'a> {\n    v: &'a mut [T],\n    chunk_size: usize\n}\n\n#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\nimpl<'a, T> Iterator for ExactChunksMut<'a, T> {\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n            self.v = tail;\n            Some(head)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.v.len() / self.chunk_size;\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n        if start >= self.v.len() || overflow {\n            self.v = &mut [];\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (_, snd) = tmp.split_at_mut(start);\n            self.v = snd;\n            self.next()\n        }\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n}\n\n#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\nimpl<'a, T> DoubleEndedIterator for ExactChunksMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let tmp_len = tmp.len();\n            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n            self.v = head;\n            Some(tail)\n        }\n    }\n}\n\n#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\nimpl<'a, T> ExactSizeIterator for ExactChunksMut<'a, T> {\n    fn is_empty(&self) -> bool {\n        self.v.is_empty()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for ExactChunksMut<'a, T> {}\n\n#[doc(hidden)]\nunsafe impl<'a, T> TrustedRandomAccess for ExactChunksMut<'a, T> {\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n        let start = i * self.chunk_size;\n        from_raw_parts_mut(self.v.as_mut_ptr().offset(start as isize), self.chunk_size)\n    }\n    fn may_have_side_effect() -> bool { false }\n}\n\n//\n// Free functions\n//\n\n/// Forms a slice from a pointer and a length.\n///\n/// The `len` argument is the number of **elements**, not the number of bytes.\n///\n/// # Safety\n///\n/// This function is unsafe as there is no guarantee that the given pointer is\n/// valid for `len` elements, nor whether the lifetime inferred is a suitable\n/// lifetime for the returned slice.\n///\n/// `p` must be non-null, even for zero-length slices, because non-zero bits\n/// are required to distinguish between a zero-length slice within `Some()`\n/// from `None`. `p` can be a bogus non-dereferencable pointer, such as `0x1`,\n/// for zero-length slices, though.\n///\n/// # Caveat\n///\n/// The lifetime for the returned slice is inferred from its usage. To\n/// prevent accidental misuse, it's suggested to tie the lifetime to whichever\n/// source lifetime is safe in the context, such as by providing a helper\n/// function taking the lifetime of a host value for the slice, or by explicit\n/// annotation.\n///\n/// # Examples\n///\n/// ```\n/// use std::slice;\n///\n/// // manifest a slice out of thin air!\n/// let ptr = 0x1234 as *const usize;\n/// let amt = 10;\n/// unsafe {\n///     let slice = slice::from_raw_parts(ptr, amt);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn from_raw_parts<'a, T>(p: *const T, len: usize) -> &'a [T] {\n    mem::transmute(Repr { data: p, len: len })\n}\n\n/// Performs the same functionality as `from_raw_parts`, except that a mutable\n/// slice is returned.\n///\n/// This function is unsafe for the same reasons as `from_raw_parts`, as well\n/// as not being able to provide a non-aliasing guarantee of the returned\n/// mutable slice. `p` must be non-null even for zero-length slices as with\n/// `from_raw_parts`.\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n    mem::transmute(Repr { data: p, len: len })\n}\n\n/// Converts a reference to T into a slice of length 1 (without copying).\n#[unstable(feature = \"from_ref\", issue = \"45703\")]\npub fn from_ref<T>(s: &T) -> &[T] {\n    unsafe {\n        from_raw_parts(s, 1)\n    }\n}\n\n/// Converts a reference to T into a slice of length 1 (without copying).\n#[unstable(feature = \"from_ref\", issue = \"45703\")]\npub fn from_ref_mut<T>(s: &mut T) -> &mut [T] {\n    unsafe {\n        from_raw_parts_mut(s, 1)\n    }\n}\n\n// This function is public only because there is no other way to unit test heapsort.\n#[unstable(feature = \"sort_internals\", reason = \"internal to sort module\", issue = \"0\")]\n#[doc(hidden)]\npub fn heapsort<T, F>(v: &mut [T], mut is_less: F)\n    where F: FnMut(&T, &T) -> bool\n{\n    sort::heapsort(v, &mut is_less);\n}\n\n//\n// Comparison traits\n//\n\nextern {\n    /// Calls implementation provided memcmp.\n    ///\n    /// Interprets the data as u8.\n    ///\n    /// Returns 0 for equal, < 0 for less than and > 0 for greater\n    /// than.\n    // FIXME(#32610): Return type should be c_int\n    fn memcmp(s1: *const u8, s2: *const u8, n: usize) -> i32;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n    fn eq(&self, other: &[B]) -> bool {\n        SlicePartialEq::equal(self, other)\n    }\n\n    fn ne(&self, other: &[B]) -> bool {\n        SlicePartialEq::not_equal(self, other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Eq> Eq for [T] {}\n\n/// Implements comparison of vectors lexicographically.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord> Ord for [T] {\n    fn cmp(&self, other: &[T]) -> Ordering {\n        SliceOrd::compare(self, other)\n    }\n}\n\n/// Implements comparison of vectors lexicographically.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: PartialOrd> PartialOrd for [T] {\n    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n        SlicePartialOrd::partial_compare(self, other)\n    }\n}\n\n#[doc(hidden)]\n// intermediate trait for specialization of slice's PartialEq\ntrait SlicePartialEq<B> {\n    fn equal(&self, other: &[B]) -> bool;\n\n    fn not_equal(&self, other: &[B]) -> bool { !self.equal(other) }\n}\n\n// Generic slice equality\nimpl<A, B> SlicePartialEq<B> for [A]\n    where A: PartialEq<B>\n{\n    default fn equal(&self, other: &[B]) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        for i in 0..self.len() {\n            if !self[i].eq(&other[i]) {\n                return false;\n            }\n        }\n\n        true\n    }\n}\n\n// Use memcmp for bytewise equality when the types allow\nimpl<A> SlicePartialEq<A> for [A]\n    where A: PartialEq<A> + BytewiseEquality\n{\n    fn equal(&self, other: &[A]) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n        if self.as_ptr() == other.as_ptr() {\n            return true;\n        }\n        unsafe {\n            let size = mem::size_of_val(self);\n            memcmp(self.as_ptr() as *const u8,\n                   other.as_ptr() as *const u8, size) == 0\n        }\n    }\n}\n\n#[doc(hidden)]\n// intermediate trait for specialization of slice's PartialOrd\ntrait SlicePartialOrd<B> {\n    fn partial_compare(&self, other: &[B]) -> Option<Ordering>;\n}\n\nimpl<A> SlicePartialOrd<A> for [A]\n    where A: PartialOrd\n{\n    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n        let l = cmp::min(self.len(), other.len());\n\n        // Slice to the loop iteration range to enable bound check\n        // elimination in the compiler\n        let lhs = &self[..l];\n        let rhs = &other[..l];\n\n        for i in 0..l {\n            match lhs[i].partial_cmp(&rhs[i]) {\n                Some(Ordering::Equal) => (),\n                non_eq => return non_eq,\n            }\n        }\n\n        self.len().partial_cmp(&other.len())\n    }\n}\n\nimpl<A> SlicePartialOrd<A> for [A]\n    where A: Ord\n{\n    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n        Some(SliceOrd::compare(self, other))\n    }\n}\n\n#[doc(hidden)]\n// intermediate trait for specialization of slice's Ord\ntrait SliceOrd<B> {\n    fn compare(&self, other: &[B]) -> Ordering;\n}\n\nimpl<A> SliceOrd<A> for [A]\n    where A: Ord\n{\n    default fn compare(&self, other: &[A]) -> Ordering {\n        let l = cmp::min(self.len(), other.len());\n\n        // Slice to the loop iteration range to enable bound check\n        // elimination in the compiler\n        let lhs = &self[..l];\n        let rhs = &other[..l];\n\n        for i in 0..l {\n            match lhs[i].cmp(&rhs[i]) {\n                Ordering::Equal => (),\n                non_eq => return non_eq,\n            }\n        }\n\n        self.len().cmp(&other.len())\n    }\n}\n\n// memcmp compares a sequence of unsigned bytes lexicographically.\n// this matches the order we want for [u8], but no others (not even [i8]).\nimpl SliceOrd<u8> for [u8] {\n    #[inline]\n    fn compare(&self, other: &[u8]) -> Ordering {\n        let order = unsafe {\n            memcmp(self.as_ptr(), other.as_ptr(),\n                   cmp::min(self.len(), other.len()))\n        };\n        if order == 0 {\n            self.len().cmp(&other.len())\n        } else if order < 0 {\n            Less\n        } else {\n            Greater\n        }\n    }\n}\n\n#[doc(hidden)]\n/// Trait implemented for types that can be compared for equality using\n/// their bytewise representation\ntrait BytewiseEquality { }\n\nmacro_rules! impl_marker_for {\n    ($traitname:ident, $($ty:ty)*) => {\n        $(\n            impl $traitname for $ty { }\n        )*\n    }\n}\n\nimpl_marker_for!(BytewiseEquality,\n                 u8 i8 u16 i16 u32 i32 u64 i64 usize isize char bool);\n\n#[doc(hidden)]\nunsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n        &*self.ptr.offset(i as isize)\n    }\n    fn may_have_side_effect() -> bool { false }\n}\n\n#[doc(hidden)]\nunsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n        &mut *self.ptr.offset(i as isize)\n    }\n    fn may_have_side_effect() -> bool { false }\n}\n\ntrait SliceContains: Sized {\n    fn slice_contains(&self, x: &[Self]) -> bool;\n}\n\nimpl<T> SliceContains for T where T: PartialEq {\n    default fn slice_contains(&self, x: &[Self]) -> bool {\n        x.iter().any(|y| *y == *self)\n    }\n}\n\nimpl SliceContains for u8 {\n    fn slice_contains(&self, x: &[Self]) -> bool {\n        memchr::memchr(*self, x).is_some()\n    }\n}\n\nimpl SliceContains for i8 {\n    fn slice_contains(&self, x: &[Self]) -> bool {\n        let byte = *self as u8;\n        let bytes: &[u8] = unsafe { from_raw_parts(x.as_ptr() as *const u8, x.len()) };\n        memchr::memchr(byte, bytes).is_some()\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Error handling with the `Result` type.\n//!\n//! [`Result<T, E>`][`Result`] is the type used for returning and propagating\n//! errors. It is an enum with the variants, [`Ok(T)`], representing\n//! success and containing a value, and [`Err(E)`], representing error\n//! and containing an error value.\n//!\n//! ```\n//! # #[allow(dead_code)]\n//! enum Result<T, E> {\n//!    Ok(T),\n//!    Err(E),\n//! }\n//! ```\n//!\n//! Functions return [`Result`] whenever errors are expected and\n//! recoverable. In the `std` crate, [`Result`] is most prominently used\n//! for [I/O](../../std/io/index.html).\n//!\n//! A simple function returning [`Result`] might be\n//! defined and used like so:\n//!\n//! ```\n//! #[derive(Debug)]\n//! enum Version { Version1, Version2 }\n//!\n//! fn parse_version(header: &[u8]) -> Result<Version, &'static str> {\n//!     match header.get(0) {\n//!         None => Err(\"invalid header length\"),\n//!         Some(&1) => Ok(Version::Version1),\n//!         Some(&2) => Ok(Version::Version2),\n//!         Some(_) => Err(\"invalid version\"),\n//!     }\n//! }\n//!\n//! let version = parse_version(&[1, 2, 3, 4]);\n//! match version {\n//!     Ok(v) => println!(\"working with version: {:?}\", v),\n//!     Err(e) => println!(\"error parsing header: {:?}\", e),\n//! }\n//! ```\n//!\n//! Pattern matching on [`Result`]s is clear and straightforward for\n//! simple cases, but [`Result`] comes with some convenience methods\n//! that make working with it more succinct.\n//!\n//! ```\n//! let good_result: Result<i32, i32> = Ok(10);\n//! let bad_result: Result<i32, i32> = Err(10);\n//!\n//! // The `is_ok` and `is_err` methods do what they say.\n//! assert!(good_result.is_ok() && !good_result.is_err());\n//! assert!(bad_result.is_err() && !bad_result.is_ok());\n//!\n//! // `map` consumes the `Result` and produces another.\n//! let good_result: Result<i32, i32> = good_result.map(|i| i + 1);\n//! let bad_result: Result<i32, i32> = bad_result.map(|i| i - 1);\n//!\n//! // Use `and_then` to continue the computation.\n//! let good_result: Result<bool, i32> = good_result.and_then(|i| Ok(i == 11));\n//!\n//! // Use `or_else` to handle the error.\n//! let bad_result: Result<i32, i32> = bad_result.or_else(|i| Ok(i + 20));\n//!\n//! // Consume the result and return the contents with `unwrap`.\n//! let final_awesome_result = good_result.unwrap();\n//! ```\n//!\n//! # Results must be used\n//!\n//! A common problem with using return values to indicate errors is\n//! that it is easy to ignore the return value, thus failing to handle\n//! the error. [`Result`] is annotated with the `#[must_use]` attribute,\n//! which will cause the compiler to issue a warning when a Result\n//! value is ignored. This makes [`Result`] especially useful with\n//! functions that may encounter errors but don't otherwise return a\n//! useful value.\n//!\n//! Consider the [`write_all`] method defined for I/O types\n//! by the [`Write`] trait:\n//!\n//! ```\n//! use std::io;\n//!\n//! trait Write {\n//!     fn write_all(&mut self, bytes: &[u8]) -> Result<(), io::Error>;\n//! }\n//! ```\n//!\n//! *Note: The actual definition of [`Write`] uses [`io::Result`], which\n//! is just a synonym for [`Result`]`<T, `[`io::Error`]`>`.*\n//!\n//! This method doesn't produce a value, but the write may\n//! fail. It's crucial to handle the error case, and *not* write\n//! something like this:\n//!\n//! ```no_run\n//! # #![allow(unused_must_use)] // \\o/\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//!\n//! let mut file = File::create(\"valuable_data.txt\").unwrap();\n//! // If `write_all` errors, then we'll never know, because the return\n//! // value is ignored.\n//! file.write_all(b\"important message\");\n//! ```\n//!\n//! If you *do* write that in Rust, the compiler will give you a\n//! warning (by default, controlled by the `unused_must_use` lint).\n//!\n//! You might instead, if you don't want to handle the error, simply\n//! assert success with [`expect`]. This will panic if the\n//! write fails, providing a marginally useful message indicating why:\n//!\n//! ```{.no_run}\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//!\n//! let mut file = File::create(\"valuable_data.txt\").unwrap();\n//! file.write_all(b\"important message\").expect(\"failed to write message\");\n//! ```\n//!\n//! You might also simply assert success:\n//!\n//! ```{.no_run}\n//! # use std::fs::File;\n//! # use std::io::prelude::*;\n//! # let mut file = File::create(\"valuable_data.txt\").unwrap();\n//! assert!(file.write_all(b\"important message\").is_ok());\n//! ```\n//!\n//! Or propagate the error up the call stack with [`?`]:\n//!\n//! ```\n//! # use std::fs::File;\n//! # use std::io::prelude::*;\n//! # use std::io;\n//! # #[allow(dead_code)]\n//! fn write_message() -> io::Result<()> {\n//!     let mut file = File::create(\"valuable_data.txt\")?;\n//!     file.write_all(b\"important message\")?;\n//!     Ok(())\n//! }\n//! ```\n//!\n//! # The question mark operator, `?`\n//!\n//! When writing code that calls many functions that return the\n//! [`Result`] type, the error handling can be tedious. The question mark\n//! operator, [`?`], hides some of the boilerplate of propagating errors\n//! up the call stack.\n//!\n//! It replaces this:\n//!\n//! ```\n//! # #![allow(dead_code)]\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//! use std::io;\n//!\n//! struct Info {\n//!     name: String,\n//!     age: i32,\n//!     rating: i32,\n//! }\n//!\n//! fn write_info(info: &Info) -> io::Result<()> {\n//!     // Early return on error\n//!     let mut file = match File::create(\"my_best_friends.txt\") {\n//!            Err(e) => return Err(e),\n//!            Ok(f) => f,\n//!     };\n//!     if let Err(e) = file.write_all(format!(\"name: {}\\n\", info.name).as_bytes()) {\n//!         return Err(e)\n//!     }\n//!     if let Err(e) = file.write_all(format!(\"age: {}\\n\", info.age).as_bytes()) {\n//!         return Err(e)\n//!     }\n//!     if let Err(e) = file.write_all(format!(\"rating: {}\\n\", info.rating).as_bytes()) {\n//!         return Err(e)\n//!     }\n//!     Ok(())\n//! }\n//! ```\n//!\n//! With this:\n//!\n//! ```\n//! # #![allow(dead_code)]\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//! use std::io;\n//!\n//! struct Info {\n//!     name: String,\n//!     age: i32,\n//!     rating: i32,\n//! }\n//!\n//! fn write_info(info: &Info) -> io::Result<()> {\n//!     let mut file = File::create(\"my_best_friends.txt\")?;\n//!     // Early return on error\n//!     file.write_all(format!(\"name: {}\\n\", info.name).as_bytes())?;\n//!     file.write_all(format!(\"age: {}\\n\", info.age).as_bytes())?;\n//!     file.write_all(format!(\"rating: {}\\n\", info.rating).as_bytes())?;\n//!     Ok(())\n//! }\n//! ```\n//!\n//! *It's much nicer!*\n//!\n//! Ending the expression with [`?`] will result in the unwrapped\n//! success ([`Ok`]) value, unless the result is [`Err`], in which case\n//! [`Err`] is returned early from the enclosing function.\n//!\n//! [`?`] can only be used in functions that return [`Result`] because of the\n//! early return of [`Err`] that it provides.\n//!\n//! [`expect`]: enum.Result.html#method.expect\n//! [`Write`]: ../../std/io/trait.Write.html\n//! [`write_all`]: ../../std/io/trait.Write.html#method.write_all\n//! [`io::Result`]: ../../std/io/type.Result.html\n//! [`?`]: ../../std/macro.try.html\n//! [`Result`]: enum.Result.html\n//! [`Ok(T)`]: enum.Result.html#variant.Ok\n//! [`Err(E)`]: enum.Result.html#variant.Err\n//! [`io::Error`]: ../../std/io/struct.Error.html\n//! [`Ok`]: enum.Result.html#variant.Ok\n//! [`Err`]: enum.Result.html#variant.Err\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse fmt;\nuse iter::{FromIterator, FusedIterator, TrustedLen};\nuse ops;\n\n/// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n///\n/// See the [`std::result`](index.html) module documentation for details.\n///\n/// [`Ok`]: enum.Result.html#variant.Ok\n/// [`Err`]: enum.Result.html#variant.Err\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n#[must_use]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Result<T, E> {\n    /// Contains the success value\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n\n    /// Contains the error value\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Type implementation\n/////////////////////////////////////////////////////////////////////////////\n\nimpl<T, E> Result<T, E> {\n    /////////////////////////////////////////////////////////////////////////\n    // Querying the contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns `true` if the result is [`Ok`].\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<i32, &str> = Ok(-3);\n    /// assert_eq!(x.is_ok(), true);\n    ///\n    /// let x: Result<i32, &str> = Err(\"Some error message\");\n    /// assert_eq!(x.is_ok(), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_ok(&self) -> bool {\n        match *self {\n            Ok(_) => true,\n            Err(_) => false\n        }\n    }\n\n    /// Returns `true` if the result is [`Err`].\n    ///\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<i32, &str> = Ok(-3);\n    /// assert_eq!(x.is_err(), false);\n    ///\n    /// let x: Result<i32, &str> = Err(\"Some error message\");\n    /// assert_eq!(x.is_err(), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_err(&self) -> bool {\n        !self.is_ok()\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Adapter for each variant\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Converts from `Result<T, E>` to [`Option<T>`].\n    ///\n    /// Converts `self` into an [`Option<T>`], consuming `self`,\n    /// and discarding the error, if any.\n    ///\n    /// [`Option<T>`]: ../../std/option/enum.Option.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.ok(), Some(2));\n    ///\n    /// let x: Result<u32, &str> = Err(\"Nothing here\");\n    /// assert_eq!(x.ok(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ok(self) -> Option<T> {\n        match self {\n            Ok(x)  => Some(x),\n            Err(_) => None,\n        }\n    }\n\n    /// Converts from `Result<T, E>` to [`Option<E>`].\n    ///\n    /// Converts `self` into an [`Option<E>`], consuming `self`,\n    /// and discarding the success value, if any.\n    ///\n    /// [`Option<E>`]: ../../std/option/enum.Option.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.err(), None);\n    ///\n    /// let x: Result<u32, &str> = Err(\"Nothing here\");\n    /// assert_eq!(x.err(), Some(\"Nothing here\"));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn err(self) -> Option<E> {\n        match self {\n            Ok(_)  => None,\n            Err(x) => Some(x),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Adapter for working with references\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Converts from `Result<T, E>` to `Result<&T, &E>`.\n    ///\n    /// Produces a new `Result`, containing a reference\n    /// into the original, leaving the original in place.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.as_ref(), Ok(&2));\n    ///\n    /// let x: Result<u32, &str> = Err(\"Error\");\n    /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_ref(&self) -> Result<&T, &E> {\n        match *self {\n            Ok(ref x) => Ok(x),\n            Err(ref x) => Err(x),\n        }\n    }\n\n    /// Converts from `Result<T, E>` to `Result<&mut T, &mut E>`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn mutate(r: &mut Result<i32, i32>) {\n    ///     match r.as_mut() {\n    ///         Ok(v) => *v = 42,\n    ///         Err(e) => *e = 0,\n    ///     }\n    /// }\n    ///\n    /// let mut x: Result<i32, i32> = Ok(2);\n    /// mutate(&mut x);\n    /// assert_eq!(x.unwrap(), 42);\n    ///\n    /// let mut x: Result<i32, i32> = Err(13);\n    /// mutate(&mut x);\n    /// assert_eq!(x.unwrap_err(), 0);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_mut(&mut self) -> Result<&mut T, &mut E> {\n        match *self {\n            Ok(ref mut x) => Ok(x),\n            Err(ref mut x) => Err(x),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Transforming contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n    /// contained [`Ok`] value, leaving an [`Err`] value untouched.\n    ///\n    /// This function can be used to compose the results of two functions.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Print the numbers on each line of a string multiplied by two.\n    ///\n    /// ```\n    /// let line = \"1\\n2\\n3\\n4\\n\";\n    ///\n    /// for num in line.lines() {\n    ///     match num.parse::<i32>().map(|i| i * 2) {\n    ///         Ok(n) => println!(\"{}\", n),\n    ///         Err(..) => {}\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U,E> {\n        match self {\n            Ok(t) => Ok(op(t)),\n            Err(e) => Err(e)\n        }\n    }\n\n    /// Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n    /// contained [`Err`] value, leaving an [`Ok`] value untouched.\n    ///\n    /// This function can be used to pass through a successful result while handling\n    /// an error.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn stringify(x: u32) -> String { format!(\"error code: {}\", x) }\n    ///\n    /// let x: Result<u32, u32> = Ok(2);\n    /// assert_eq!(x.map_err(stringify), Ok(2));\n    ///\n    /// let x: Result<u32, u32> = Err(13);\n    /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T,F> {\n        match self {\n            Ok(t) => Ok(t),\n            Err(e) => Err(op(e))\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Iterator constructors\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns an iterator over the possibly contained value.\n    ///\n    /// The iterator yields one value if the result is [`Ok`], otherwise none.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(7);\n    /// assert_eq!(x.iter().next(), Some(&7));\n    ///\n    /// let x: Result<u32, &str> = Err(\"nothing!\");\n    /// assert_eq!(x.iter().next(), None);\n    /// ```\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<T> {\n        Iter { inner: self.as_ref().ok() }\n    }\n\n    /// Returns a mutable iterator over the possibly contained value.\n    ///\n    /// The iterator yields one value if the result is [`Ok`], otherwise none.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut x: Result<u32, &str> = Ok(7);\n    /// match x.iter_mut().next() {\n    ///     Some(v) => *v = 40,\n    ///     None => {},\n    /// }\n    /// assert_eq!(x, Ok(40));\n    ///\n    /// let mut x: Result<u32, &str> = Err(\"nothing!\");\n    /// assert_eq!(x.iter_mut().next(), None);\n    /// ```\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut { inner: self.as_mut().ok() }\n    }\n\n    ////////////////////////////////////////////////////////////////////////\n    // Boolean operations on the values, eager and lazy\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// let y: Result<&str, &str> = Err(\"late error\");\n    /// assert_eq!(x.and(y), Err(\"late error\"));\n    ///\n    /// let x: Result<u32, &str> = Err(\"early error\");\n    /// let y: Result<&str, &str> = Ok(\"foo\");\n    /// assert_eq!(x.and(y), Err(\"early error\"));\n    ///\n    /// let x: Result<u32, &str> = Err(\"not a 2\");\n    /// let y: Result<&str, &str> = Err(\"late error\");\n    /// assert_eq!(x.and(y), Err(\"not a 2\"));\n    ///\n    /// let x: Result<u32, &str> = Ok(2);\n    /// let y: Result<&str, &str> = Ok(\"different result type\");\n    /// assert_eq!(x.and(y), Ok(\"different result type\"));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n        match self {\n            Ok(_) => res,\n            Err(e) => Err(e),\n        }\n    }\n\n    /// Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// This function can be used for control flow based on `Result` values.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n    ///\n    /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n    /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n    /// assert_eq!(Ok(2).and_then(err).and_then(sq), Err(2));\n    /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n        match self {\n            Ok(t) => op(t),\n            Err(e) => Err(e),\n        }\n    }\n\n    /// Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n    ///\n    /// Arguments passed to `or` are eagerly evaluated; if you are passing the\n    /// result of a function call, it is recommended to use [`or_else`], which is\n    /// lazily evaluated.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    /// [`or_else`]: #method.or_else\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// let y: Result<u32, &str> = Err(\"late error\");\n    /// assert_eq!(x.or(y), Ok(2));\n    ///\n    /// let x: Result<u32, &str> = Err(\"early error\");\n    /// let y: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.or(y), Ok(2));\n    ///\n    /// let x: Result<u32, &str> = Err(\"not a 2\");\n    /// let y: Result<u32, &str> = Err(\"late error\");\n    /// assert_eq!(x.or(y), Err(\"late error\"));\n    ///\n    /// let x: Result<u32, &str> = Ok(2);\n    /// let y: Result<u32, &str> = Ok(100);\n    /// assert_eq!(x.or(y), Ok(2));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> {\n        match self {\n            Ok(v) => Ok(v),\n            Err(_) => res,\n        }\n    }\n\n    /// Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n    ///\n    /// This function can be used for control flow based on result values.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n    ///\n    /// assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));\n    /// assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));\n    /// assert_eq!(Err(3).or_else(sq).or_else(err), Ok(9));\n    /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n        match self {\n            Ok(t) => Ok(t),\n            Err(e) => op(e),\n        }\n    }\n\n    /// Unwraps a result, yielding the content of an [`Ok`].\n    /// Else, it returns `optb`.\n    ///\n    /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n    /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n    /// which is lazily evaluated.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    /// [`unwrap_or_else`]: #method.unwrap_or_else\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let optb = 2;\n    /// let x: Result<u32, &str> = Ok(9);\n    /// assert_eq!(x.unwrap_or(optb), 9);\n    ///\n    /// let x: Result<u32, &str> = Err(\"error\");\n    /// assert_eq!(x.unwrap_or(optb), optb);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or(self, optb: T) -> T {\n        match self {\n            Ok(t) => t,\n            Err(_) => optb\n        }\n    }\n\n    /// Unwraps a result, yielding the content of an [`Ok`].\n    /// If the value is an [`Err`] then it calls `op` with its value.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn count(x: &str) -> usize { x.len() }\n    ///\n    /// assert_eq!(Ok(2).unwrap_or_else(count), 2);\n    /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n        match self {\n            Ok(t) => t,\n            Err(e) => op(e)\n        }\n    }\n}\n\nimpl<T, E: fmt::Debug> Result<T, E> {\n    /// Unwraps a result, yielding the content of an [`Ok`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is an [`Err`], with a panic message provided by the\n    /// [`Err`]'s value.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.unwrap(), 2);\n    /// ```\n    ///\n    /// ```{.should_panic}\n    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n    /// x.unwrap(); // panics with `emergency failure`\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap(self) -> T {\n        match self {\n            Ok(t) => t,\n            Err(e) => unwrap_failed(\"called `Result::unwrap()` on an `Err` value\", e),\n        }\n    }\n\n    /// Unwraps a result, yielding the content of an [`Ok`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is an [`Err`], with a panic message including the\n    /// passed message, and the content of the [`Err`].\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```{.should_panic}\n    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n    /// ```\n    #[inline]\n    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n    pub fn expect(self, msg: &str) -> T {\n        match self {\n            Ok(t) => t,\n            Err(e) => unwrap_failed(msg, e),\n        }\n    }\n}\n\nimpl<T: fmt::Debug, E> Result<T, E> {\n    /// Unwraps a result, yielding the content of an [`Err`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is an [`Ok`], with a custom panic message provided\n    /// by the [`Ok`]'s value.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    ///\n    /// # Examples\n    ///\n    /// ```{.should_panic}\n    /// let x: Result<u32, &str> = Ok(2);\n    /// x.unwrap_err(); // panics with `2`\n    /// ```\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n    /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_err(self) -> E {\n        match self {\n            Ok(t) => unwrap_failed(\"called `Result::unwrap_err()` on an `Ok` value\", t),\n            Err(e) => e,\n        }\n    }\n\n    /// Unwraps a result, yielding the content of an [`Err`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is an [`Ok`], with a panic message including the\n    /// passed message, and the content of the [`Ok`].\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```{.should_panic}\n    /// let x: Result<u32, &str> = Ok(10);\n    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n    /// ```\n    #[inline]\n    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n    pub fn expect_err(self, msg: &str) -> E {\n        match self {\n            Ok(t) => unwrap_failed(msg, t),\n            Err(e) => e,\n        }\n    }\n}\n\nimpl<T: Default, E> Result<T, E> {\n    /// Returns the contained value or a default\n    ///\n    /// Consumes the `self` argument then, if [`Ok`], returns the contained\n    /// value, otherwise if [`Err`], returns the default value for that\n    /// type.\n    ///\n    /// # Examples\n    ///\n    /// Convert a string to an integer, turning poorly-formed strings\n    /// into 0 (the default value for integers). [`parse`] converts\n    /// a string to any other type that implements [`FromStr`], returning an\n    /// [`Err`] on error.\n    ///\n    /// ```\n    /// let good_year_from_input = \"1909\";\n    /// let bad_year_from_input = \"190blarg\";\n    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n    ///\n    /// assert_eq!(1909, good_year);\n    /// assert_eq!(0, bad_year);\n    /// ```\n    ///\n    /// [`parse`]: ../../std/primitive.str.html#method.parse\n    /// [`FromStr`]: ../../std/str/trait.FromStr.html\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    #[inline]\n    #[stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")]\n    pub fn unwrap_or_default(self) -> T {\n        match self {\n            Ok(x) => x,\n            Err(_) => Default::default(),\n        }\n    }\n}\n\nimpl<T, E> Result<Option<T>, E> {\n    /// Transposes a `Result` of an `Option` into an `Option` of a `Result`.\n    ///\n    /// `Ok(None)` will be mapped to `None`.\n    /// `Ok(Some(_))` and `Err(_)` will be mapped to `Some(Ok(_))` and `Some(Err(_))`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(transpose_result)]\n    ///\n    /// #[derive(Debug, Eq, PartialEq)]\n    /// struct SomeErr;\n    ///\n    /// let x: Result<Option<i32>, SomeErr> = Ok(Some(5));\n    /// let y: Option<Result<i32, SomeErr>> = Some(Ok(5));\n    /// assert_eq!(x.transpose(), y);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"transpose_result\", issue = \"47338\")]\n    pub fn transpose(self) -> Option<Result<T, E>> {\n        match self {\n            Ok(Some(x)) => Some(Ok(x)),\n            Ok(None) => None,\n            Err(e) => Some(Err(e)),\n        }\n    }\n}\n\n// This is a separate function to reduce the code size of the methods\n#[inline(never)]\n#[cold]\nfn unwrap_failed<E: fmt::Debug>(msg: &str, error: E) -> ! {\n    panic!(\"{}: {:?}\", msg, error)\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Trait implementations\n/////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, E> IntoIterator for Result<T, E> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Returns a consuming iterator over the possibly contained value.\n    ///\n    /// The iterator yields one value if the result is [`Ok`], otherwise none.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(5);\n    /// let v: Vec<u32> = x.into_iter().collect();\n    /// assert_eq!(v, [5]);\n    ///\n    /// let x: Result<u32, &str> = Err(\"nothing!\");\n    /// let v: Vec<u32> = x.into_iter().collect();\n    /// assert_eq!(v, []);\n    /// ```\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n        IntoIter { inner: self.ok() }\n    }\n}\n\n#[stable(since = \"1.4.0\", feature = \"result_iter\")]\nimpl<'a, T, E> IntoIterator for &'a Result<T, E> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(since = \"1.4.0\", feature = \"result_iter\")]\nimpl<'a, T, E> IntoIterator for &'a mut Result<T, E> {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n        self.iter_mut()\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The Result Iterators\n/////////////////////////////////////////////////////////////////////////////\n\n/// An iterator over a reference to the [`Ok`] variant of a [`Result`].\n///\n/// The iterator yields one value if the result is [`Ok`], otherwise none.\n///\n/// Created by [`Result::iter`].\n///\n/// [`Ok`]: enum.Result.html#variant.Ok\n/// [`Result`]: enum.Result.html\n/// [`Result::iter`]: enum.Result.html#method.iter\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> { self.inner.take() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = if self.inner.is_some() {1} else {0};\n        (n, Some(n))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for Iter<'a, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, A> TrustedLen for Iter<'a, A> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Clone for Iter<'a, T> {\n    fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n}\n\n/// An iterator over a mutable reference to the [`Ok`] variant of a [`Result`].\n///\n/// Created by [`Result::iter_mut`].\n///\n/// [`Ok`]: enum.Result.html#variant.Ok\n/// [`Result`]: enum.Result.html\n/// [`Result::iter_mut`]: enum.Result.html#method.iter_mut\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut T> { self.inner.take() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = if self.inner.is_some() {1} else {0};\n        (n, Some(n))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a, T> FusedIterator for IterMut<'a, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n\n/// An iterator over the value in a [`Ok`] variant of a [`Result`].\n///\n/// The iterator yields one value if the result is [`Ok`], otherwise none.\n///\n/// This struct is created by the [`into_iter`] method on\n/// [`Result`][`Result`] (provided by the [`IntoIterator`] trait).\n///\n/// [`Ok`]: enum.Result.html#variant.Ok\n/// [`Result`]: enum.Result.html\n/// [`into_iter`]: ../iter/trait.IntoIterator.html#tymethod.into_iter\n/// [`IntoIterator`]: ../iter/trait.IntoIterator.html\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<T> { inner: Option<T> }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> { self.inner.take() }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = if self.inner.is_some() {1} else {0};\n        (n, Some(n))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> { self.inner.take() }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for IntoIter<T> {}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<T> FusedIterator for IntoIter<T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A> TrustedLen for IntoIter<A> {}\n\n/////////////////////////////////////////////////////////////////////////////\n// FromIterator\n/////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n    /// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n    /// container with the values of each `Result` is returned.\n    ///\n    /// Here is an example which increments every integer in a vector,\n    /// checking for overflow:\n    ///\n    /// ```\n    /// let v = vec![1, 2];\n    /// let res: Result<Vec<u32>, &'static str> = v.iter().map(|x: &u32|\n    ///     x.checked_add(1).ok_or(\"Overflow!\")\n    /// ).collect();\n    /// assert!(res == Ok(vec![2, 3]));\n    /// ```\n    #[inline]\n    fn from_iter<I: IntoIterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {\n        // FIXME(#11084): This could be replaced with Iterator::scan when this\n        // performance bug is closed.\n\n        struct Adapter<Iter, E> {\n            iter: Iter,\n            err: Option<E>,\n        }\n\n        impl<T, E, Iter: Iterator<Item=Result<T, E>>> Iterator for Adapter<Iter, E> {\n            type Item = T;\n\n            #[inline]\n            fn next(&mut self) -> Option<T> {\n                match self.iter.next() {\n                    Some(Ok(value)) => Some(value),\n                    Some(Err(err)) => {\n                        self.err = Some(err);\n                        None\n                    }\n                    None => None,\n                }\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let (_min, max) = self.iter.size_hint();\n                (0, max)\n            }\n        }\n\n        let mut adapter = Adapter { iter: iter.into_iter(), err: None };\n        let v: V = FromIterator::from_iter(adapter.by_ref());\n\n        match adapter.err {\n            Some(err) => Err(err),\n            None => Ok(v),\n        }\n    }\n}\n\n#[unstable(feature = \"try_trait\", issue = \"42327\")]\nimpl<T,E> ops::Try for Result<T, E> {\n    type Ok = T;\n    type Error = E;\n\n    fn into_result(self) -> Self {\n        self\n    }\n\n    fn from_ok(v: T) -> Self {\n        Ok(v)\n    }\n\n    fn from_error(v: E) -> Self {\n        Err(v)\n    }\n}\n","/* Copyright 2017 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// See https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md\n\nuse std::result;\n\nuse limits::{MAX_WASM_FUNCTION_LOCALS, MAX_WASM_FUNCTION_PARAMS, MAX_WASM_FUNCTION_RETURNS,\n             MAX_WASM_FUNCTION_SIZE, MAX_WASM_STRING_SIZE, MAX_WASM_FUNCTIONS,\n             MAX_WASM_TABLE_ENTRIES};\n\nconst MAX_WASM_BR_TABLE_SIZE: usize = MAX_WASM_FUNCTION_SIZE;\n\nconst MAX_DATA_CHUNK_SIZE: usize = MAX_WASM_STRING_SIZE;\n\n#[derive(Debug,Copy,Clone)]\npub struct BinaryReaderError {\n    pub message: &'static str,\n    pub offset: usize,\n}\n\npub type Result<T> = result::Result<T, BinaryReaderError>;\n\n#[derive(Debug,Copy,Clone,PartialEq,Eq,PartialOrd,Ord)]\npub enum CustomSectionKind {\n    Unknown,\n    Name,\n    SourceMappingURL,\n    Reloc,\n    Linking,\n}\n\n/// Section code as defined [here].\n///\n/// [here]: https://webassembly.github.io/spec/binary/modules.html#sections\n#[derive(Debug,Copy,Clone,PartialEq,Eq,PartialOrd,Ord)]\npub enum SectionCode<'a> {\n    Custom {\n        name: &'a [u8],\n        kind: CustomSectionKind,\n    },\n    Type, // Function signature declarations\n    Import, // Import declarations\n    Function, // Function declarations\n    Table, // Indirect function table and other tables\n    Memory, // Memory attributes\n    Global, // Global declarations\n    Export, // Exports\n    Start, // Start function declaration\n    Element, // Elements section\n    Code, // Function bodies (code)\n    Data, // Data segments\n}\n\n/// Types as defined [here].\n///\n/// [here]: https://webassembly.github.io/spec/syntax/types.html#types\n#[derive(Debug,Copy,Clone,PartialEq,Eq)]\npub enum Type {\n    I32,\n    I64,\n    F32,\n    F64,\n    AnyFunc,\n    Func,\n    EmptyBlockType,\n}\n\n#[derive(Debug)]\npub enum NameType {\n    Module,\n    Function,\n    Local,\n}\n\n#[derive(Debug)]\npub struct Naming<'a> {\n    pub index: u32,\n    pub name: &'a [u8],\n}\n\n#[derive(Debug)]\npub struct LocalName<'a> {\n    pub index: u32,\n    pub locals: Vec<Naming<'a>>,\n}\n\n#[derive(Debug)]\npub enum NameEntry<'a> {\n    Module(&'a [u8]),\n    Function(Vec<Naming<'a>>),\n    Local(Vec<LocalName<'a>>),\n}\n\n/// External types as defined [here].\n///\n/// [here]: https://webassembly.github.io/spec/syntax/types.html#external-types\n#[derive(Debug, Copy, Clone)]\npub enum ExternalKind {\n    Function,\n    Table,\n    Memory,\n    Global,\n}\n\n#[derive(Debug,Clone)]\npub struct FuncType {\n    pub form: Type,\n    pub params: Vec<Type>,\n    pub returns: Vec<Type>,\n}\n\n#[derive(Debug,Copy,Clone)]\npub struct ResizableLimits {\n    pub initial: u32,\n    pub maximum: Option<u32>,\n}\n\n#[derive(Debug,Copy,Clone)]\npub struct TableType {\n    pub element_type: Type,\n    pub limits: ResizableLimits,\n}\n\n#[derive(Debug,Copy,Clone)]\npub struct MemoryType {\n    pub limits: ResizableLimits,\n    pub shared: bool,\n}\n\n#[derive(Debug,Copy,Clone)]\npub struct GlobalType {\n    pub content_type: Type,\n    pub mutable: bool,\n}\n\n#[derive(Debug)]\npub struct MemoryImmediate {\n    pub flags: u32,\n    pub offset: u32,\n}\n\n/// A br_table entries representation.\n#[derive(Debug)]\npub struct BrTable<'a> {\n    pub size: usize,\n    buffer: &'a [u8],\n}\n\nimpl<'a> BrTable<'a> {\n    /// Reads br_table entries.\n    ///\n    /// # Examples\n    /// ```rust\n    /// let buf = vec![0x0e, 0x02, 0x01, 0x02, 0x00];\n    /// let mut reader = wasmparser::BinaryReader::new(&buf);\n    /// let op = reader.read_operator().unwrap();\n    /// if let wasmparser::Operator::BrTable { ref table } = op {\n    ///     let br_table_depths = table.read_table();\n    ///     assert!(br_table_depths.0 == vec![1,2] &&\n    ///             br_table_depths.1 == 0);\n    /// } else {\n    ///     unreachable!();\n    /// }\n    /// ```\n    pub fn read_table(&self) -> (Vec<u32>, u32) {\n        let mut reader = BinaryReader::new(self.buffer);\n        let mut table = Vec::with_capacity(self.size);\n        for _ in 0..self.size {\n            table.push(reader.read_var_u32().unwrap());\n        }\n        let default_target = reader.read_var_u32().unwrap();\n        assert!(reader.eof());\n        (table, default_target)\n    }\n}\n\n/// Iterator for `BrTable`.\n///\n/// #Examples\n/// ```rust\n/// let buf = vec![0x0e, 0x02, 0x01, 0x02, 0x00];\n/// let mut reader = wasmparser::BinaryReader::new(&buf);\n/// let op = reader.read_operator().unwrap();\n/// if let wasmparser::Operator::BrTable { ref table } = op {\n///     for depth in table {\n///         println!(\"BrTable depth: {}\", depth);\n///     }\n/// }\n/// ```\npub struct BrTableIterator<'a> {\n    reader: BinaryReader<'a>,\n    left: usize,\n}\n\nimpl<'a> IntoIterator for &'a BrTable<'a> {\n    type Item = u32;\n    type IntoIter = BrTableIterator<'a>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        BrTableIterator {\n            reader: BinaryReader::new(self.buffer),\n            left: self.size + 1,\n        }\n    }\n}\n\nimpl<'a> Iterator for BrTableIterator<'a> {\n    type Item = u32;\n\n    fn next(&mut self) -> Option<u32> {\n        if self.left == 0 {\n            return None;\n        }\n        self.left -= 1;\n        Some(self.reader.read_var_u32().unwrap())\n    }\n}\n\n#[derive(Debug)]\npub enum ImportSectionEntryType {\n    Function(u32),\n    Table(TableType),\n    Memory(MemoryType),\n    Global(GlobalType),\n}\n\n#[derive(Debug)]\npub enum RelocType {\n    FunctionIndexLEB,\n    TableIndexSLEB,\n    TableIndexI32,\n    GlobalAddrLEB,\n    GlobalAddrSLEB,\n    GlobalAddrI32,\n    TypeIndexLEB,\n    GlobalIndexLEB,\n}\n\n#[derive(Debug)]\npub enum LinkingType {\n    StackPointer(u32),\n}\n\n#[derive(Debug)]\npub struct RelocEntry {\n    pub ty: RelocType,\n    pub offset: u32,\n    pub index: u32,\n    pub addend: Option<u32>,\n}\n\n/// An IEEE binary32 immediate floating point value, represented as a u32\n/// containing the bitpattern.\n///\n/// All bit patterns are allowed.\n#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\npub struct Ieee32(u32);\n\nimpl Ieee32 {\n    pub fn bits(&self) -> u32 {\n        self.0\n    }\n}\n\n/// An IEEE binary64 immediate floating point value, represented as a u64\n/// containing the bitpattern.\n///\n/// All bit patterns are allowed.\n#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\npub struct Ieee64(u64);\n\nimpl Ieee64 {\n    pub fn bits(&self) -> u64 {\n        self.0\n    }\n}\n\n/// Instructions as defined [here].\n///\n/// [here]: https://webassembly.github.io/spec/binary/instructions.html\n#[derive(Debug)]\npub enum Operator<'a> {\n    Unreachable,\n    Nop,\n    Block { ty: Type },\n    Loop { ty: Type },\n    If { ty: Type },\n    Else,\n    End,\n    Br { relative_depth: u32 },\n    BrIf { relative_depth: u32 },\n    BrTable { table: BrTable<'a> },\n    Return,\n    Call { function_index: u32 },\n    CallIndirect { index: u32, table_index: u32 },\n    Drop,\n    Select,\n    GetLocal { local_index: u32 },\n    SetLocal { local_index: u32 },\n    TeeLocal { local_index: u32 },\n    GetGlobal { global_index: u32 },\n    SetGlobal { global_index: u32 },\n    I32Load { memarg: MemoryImmediate },\n    I64Load { memarg: MemoryImmediate },\n    F32Load { memarg: MemoryImmediate },\n    F64Load { memarg: MemoryImmediate },\n    I32Load8S { memarg: MemoryImmediate },\n    I32Load8U { memarg: MemoryImmediate },\n    I32Load16S { memarg: MemoryImmediate },\n    I32Load16U { memarg: MemoryImmediate },\n    I64Load8S { memarg: MemoryImmediate },\n    I64Load8U { memarg: MemoryImmediate },\n    I64Load16S { memarg: MemoryImmediate },\n    I64Load16U { memarg: MemoryImmediate },\n    I64Load32S { memarg: MemoryImmediate },\n    I64Load32U { memarg: MemoryImmediate },\n    I32Store { memarg: MemoryImmediate },\n    I64Store { memarg: MemoryImmediate },\n    F32Store { memarg: MemoryImmediate },\n    F64Store { memarg: MemoryImmediate },\n    I32Store8 { memarg: MemoryImmediate },\n    I32Store16 { memarg: MemoryImmediate },\n    I64Store8 { memarg: MemoryImmediate },\n    I64Store16 { memarg: MemoryImmediate },\n    I64Store32 { memarg: MemoryImmediate },\n    CurrentMemory { reserved: u32 },\n    GrowMemory { reserved: u32 },\n    I32Const { value: i32 },\n    I64Const { value: i64 },\n    F32Const { value: Ieee32 },\n    F64Const { value: Ieee64 },\n    I32Eqz,\n    I32Eq,\n    I32Ne,\n    I32LtS,\n    I32LtU,\n    I32GtS,\n    I32GtU,\n    I32LeS,\n    I32LeU,\n    I32GeS,\n    I32GeU,\n    I64Eqz,\n    I64Eq,\n    I64Ne,\n    I64LtS,\n    I64LtU,\n    I64GtS,\n    I64GtU,\n    I64LeS,\n    I64LeU,\n    I64GeS,\n    I64GeU,\n    F32Eq,\n    F32Ne,\n    F32Lt,\n    F32Gt,\n    F32Le,\n    F32Ge,\n    F64Eq,\n    F64Ne,\n    F64Lt,\n    F64Gt,\n    F64Le,\n    F64Ge,\n    I32Clz,\n    I32Ctz,\n    I32Popcnt,\n    I32Add,\n    I32Sub,\n    I32Mul,\n    I32DivS,\n    I32DivU,\n    I32RemS,\n    I32RemU,\n    I32And,\n    I32Or,\n    I32Xor,\n    I32Shl,\n    I32ShrS,\n    I32ShrU,\n    I32Rotl,\n    I32Rotr,\n    I64Clz,\n    I64Ctz,\n    I64Popcnt,\n    I64Add,\n    I64Sub,\n    I64Mul,\n    I64DivS,\n    I64DivU,\n    I64RemS,\n    I64RemU,\n    I64And,\n    I64Or,\n    I64Xor,\n    I64Shl,\n    I64ShrS,\n    I64ShrU,\n    I64Rotl,\n    I64Rotr,\n    F32Abs,\n    F32Neg,\n    F32Ceil,\n    F32Floor,\n    F32Trunc,\n    F32Nearest,\n    F32Sqrt,\n    F32Add,\n    F32Sub,\n    F32Mul,\n    F32Div,\n    F32Min,\n    F32Max,\n    F32Copysign,\n    F64Abs,\n    F64Neg,\n    F64Ceil,\n    F64Floor,\n    F64Trunc,\n    F64Nearest,\n    F64Sqrt,\n    F64Add,\n    F64Sub,\n    F64Mul,\n    F64Div,\n    F64Min,\n    F64Max,\n    F64Copysign,\n    I32WrapI64,\n    I32TruncSF32,\n    I32TruncUF32,\n    I32TruncSF64,\n    I32TruncUF64,\n    I64ExtendSI32,\n    I64ExtendUI32,\n    I64TruncSF32,\n    I64TruncUF32,\n    I64TruncSF64,\n    I64TruncUF64,\n    F32ConvertSI32,\n    F32ConvertUI32,\n    F32ConvertSI64,\n    F32ConvertUI64,\n    F32DemoteF64,\n    F64ConvertSI32,\n    F64ConvertUI32,\n    F64ConvertSI64,\n    F64ConvertUI64,\n    F64PromoteF32,\n    I32ReinterpretF32,\n    I64ReinterpretF64,\n    F32ReinterpretI32,\n    F64ReinterpretI64,\n    I32Extend8S,\n    I32Extend16S,\n    I64Extend8S,\n    I64Extend16S,\n    I64Extend32S,\n\n    // 0xFC operators\n    // Non-trapping Float-to-int Conversions\n    I32TruncSSatF32,\n    I32TruncUSatF32,\n    I32TruncSSatF64,\n    I32TruncUSatF64,\n    I64TruncSSatF32,\n    I64TruncUSatF32,\n    I64TruncSSatF64,\n    I64TruncUSatF64,\n\n    // 0xFE operators\n    // https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md\n    Wake { memarg: MemoryImmediate },\n    I32Wait { memarg: MemoryImmediate },\n    I64Wait { memarg: MemoryImmediate },\n    I32AtomicLoad { memarg: MemoryImmediate },\n    I64AtomicLoad { memarg: MemoryImmediate },\n    I32AtomicLoad8U { memarg: MemoryImmediate },\n    I32AtomicLoad16U { memarg: MemoryImmediate },\n    I64AtomicLoad8U { memarg: MemoryImmediate },\n    I64AtomicLoad16U { memarg: MemoryImmediate },\n    I64AtomicLoad32U { memarg: MemoryImmediate },\n    I32AtomicStore { memarg: MemoryImmediate },\n    I64AtomicStore { memarg: MemoryImmediate },\n    I32AtomicStore8 { memarg: MemoryImmediate },\n    I32AtomicStore16 { memarg: MemoryImmediate },\n    I64AtomicStore8 { memarg: MemoryImmediate },\n    I64AtomicStore16 { memarg: MemoryImmediate },\n    I64AtomicStore32 { memarg: MemoryImmediate },\n    I32AtomicRmwAdd { memarg: MemoryImmediate },\n    I64AtomicRmwAdd { memarg: MemoryImmediate },\n    I32AtomicRmw8UAdd { memarg: MemoryImmediate },\n    I32AtomicRmw16UAdd { memarg: MemoryImmediate },\n    I64AtomicRmw8UAdd { memarg: MemoryImmediate },\n    I64AtomicRmw16UAdd { memarg: MemoryImmediate },\n    I64AtomicRmw32UAdd { memarg: MemoryImmediate },\n    I32AtomicRmwSub { memarg: MemoryImmediate },\n    I64AtomicRmwSub { memarg: MemoryImmediate },\n    I32AtomicRmw8USub { memarg: MemoryImmediate },\n    I32AtomicRmw16USub { memarg: MemoryImmediate },\n    I64AtomicRmw8USub { memarg: MemoryImmediate },\n    I64AtomicRmw16USub { memarg: MemoryImmediate },\n    I64AtomicRmw32USub { memarg: MemoryImmediate },\n    I32AtomicRmwAnd { memarg: MemoryImmediate },\n    I64AtomicRmwAnd { memarg: MemoryImmediate },\n    I32AtomicRmw8UAnd { memarg: MemoryImmediate },\n    I32AtomicRmw16UAnd { memarg: MemoryImmediate },\n    I64AtomicRmw8UAnd { memarg: MemoryImmediate },\n    I64AtomicRmw16UAnd { memarg: MemoryImmediate },\n    I64AtomicRmw32UAnd { memarg: MemoryImmediate },\n    I32AtomicRmwOr { memarg: MemoryImmediate },\n    I64AtomicRmwOr { memarg: MemoryImmediate },\n    I32AtomicRmw8UOr { memarg: MemoryImmediate },\n    I32AtomicRmw16UOr { memarg: MemoryImmediate },\n    I64AtomicRmw8UOr { memarg: MemoryImmediate },\n    I64AtomicRmw16UOr { memarg: MemoryImmediate },\n    I64AtomicRmw32UOr { memarg: MemoryImmediate },\n    I32AtomicRmwXor { memarg: MemoryImmediate },\n    I64AtomicRmwXor { memarg: MemoryImmediate },\n    I32AtomicRmw8UXor { memarg: MemoryImmediate },\n    I32AtomicRmw16UXor { memarg: MemoryImmediate },\n    I64AtomicRmw8UXor { memarg: MemoryImmediate },\n    I64AtomicRmw16UXor { memarg: MemoryImmediate },\n    I64AtomicRmw32UXor { memarg: MemoryImmediate },\n    I32AtomicRmwXchg { memarg: MemoryImmediate },\n    I64AtomicRmwXchg { memarg: MemoryImmediate },\n    I32AtomicRmw8UXchg { memarg: MemoryImmediate },\n    I32AtomicRmw16UXchg { memarg: MemoryImmediate },\n    I64AtomicRmw8UXchg { memarg: MemoryImmediate },\n    I64AtomicRmw16UXchg { memarg: MemoryImmediate },\n    I64AtomicRmw32UXchg { memarg: MemoryImmediate },\n    I32AtomicRmwCmpxchg { memarg: MemoryImmediate },\n    I64AtomicRmwCmpxchg { memarg: MemoryImmediate },\n    I32AtomicRmw8UCmpxchg { memarg: MemoryImmediate },\n    I32AtomicRmw16UCmpxchg { memarg: MemoryImmediate },\n    I64AtomicRmw8UCmpxchg { memarg: MemoryImmediate },\n    I64AtomicRmw16UCmpxchg { memarg: MemoryImmediate },\n    I64AtomicRmw32UCmpxchg { memarg: MemoryImmediate },\n}\n\nfn is_name(name: &[u8], expected: &'static str) -> bool {\n    if name.len() != expected.len() {\n        return false;\n    }\n    let expected_bytes = expected.as_bytes();\n    for i in 0..name.len() {\n        if name[i] != expected_bytes[i] {\n            return false;\n        }\n    }\n    true\n}\n\nfn is_name_prefix(name: &[u8], prefix: &'static str) -> bool {\n    if name.len() < prefix.len() {\n        return false;\n    }\n    let expected_bytes = prefix.as_bytes();\n    for i in 0..expected_bytes.len() {\n        if name[i] != expected_bytes[i] {\n            return false;\n        }\n    }\n    true\n}\n\nenum InitExpressionContinuation {\n    GlobalSection,\n    ElementSection,\n    DataSection,\n}\n\n/// A binary reader of the WebAssembly structures and types.\npub struct BinaryReader<'a> {\n    buffer: &'a [u8],\n    position: usize,\n    end: usize,\n}\n\nimpl<'a> BinaryReader<'a> {\n    /// Constructs `BinaryReader` type.\n    ///\n    /// # Examples\n    /// ```\n    /// let fn_body = &vec![0x41, 0x00, 0x10, 0x00, 0x0B];\n    /// let mut reader = wasmparser::BinaryReader::new(fn_body);\n    /// while !reader.eof() {\n    ///     let op = reader.read_operator();\n    ///     println!(\"{:?}\", op)\n    /// }\n    /// ```\n    pub fn new(data: &[u8]) -> BinaryReader {\n        BinaryReader {\n            buffer: data,\n            position: 0,\n            end: data.len(),\n        }\n    }\n\n    fn ensure_has_byte(&self) -> Result<()> {\n        if self.position < self.end {\n            Ok(())\n        } else {\n            Err(BinaryReaderError {\n                    message: \"Unexpected EOF\",\n                    offset: self.position,\n                })\n        }\n    }\n\n    fn ensure_has_bytes(&self, len: usize) -> Result<()> {\n        if self.position + len <= self.end {\n            Ok(())\n        } else {\n            Err(BinaryReaderError {\n                    message: \"Unexpected EOF\",\n                    offset: self.position,\n                })\n        }\n    }\n\n    fn read_var_u1(&mut self) -> Result<u32> {\n        let b = self.read_u8()?;\n        if (b & 0xFE) != 0 {\n            return Err(BinaryReaderError {\n                           message: \"Invalid var_u1\",\n                           offset: self.position - 1,\n                       });\n        }\n        Ok(b)\n    }\n\n    fn read_var_i7(&mut self) -> Result<i32> {\n        let b = self.read_u8()?;\n        if (b & 0x80) != 0 {\n            return Err(BinaryReaderError {\n                           message: \"Invalid var_i7\",\n                           offset: self.position - 1,\n                       });\n        }\n        Ok((b << 25) as i32 >> 25)\n    }\n\n    fn read_var_u7(&mut self) -> Result<u32> {\n        let b = self.read_u8()?;\n        if (b & 0x80) != 0 {\n            return Err(BinaryReaderError {\n                           message: \"Invalid var_u7\",\n                           offset: self.position - 1,\n                       });\n        }\n        Ok(b)\n    }\n\n    fn read_type(&mut self) -> Result<Type> {\n        let code = self.read_var_i7()?;\n        match code {\n            -0x01 => Ok(Type::I32),\n            -0x02 => Ok(Type::I64),\n            -0x03 => Ok(Type::F32),\n            -0x04 => Ok(Type::F64),\n            -0x10 => Ok(Type::AnyFunc),\n            -0x20 => Ok(Type::Func),\n            -0x40 => Ok(Type::EmptyBlockType),\n            _ => {\n                Err(BinaryReaderError {\n                        message: \"Invalid type\",\n                        offset: self.position - 1,\n                    })\n            }\n        }\n    }\n\n    /// Read a `count` indicating the number of times to call `read_local_decl`.\n    pub fn read_local_count(&mut self) -> Result<usize> {\n        let local_count = self.read_var_u32()? as usize;\n        if local_count > MAX_WASM_FUNCTION_LOCALS {\n            return Err(BinaryReaderError {\n                           message: \"local_count is out of bounds\",\n                           offset: self.position - 1,\n                       });\n        }\n        Ok(local_count)\n    }\n\n    /// Read a `(count, value_type)` declaration of local variables of the same type.\n    pub fn read_local_decl(&mut self, locals_total: &mut usize) -> Result<(u32, Type)> {\n        let count = self.read_var_u32()?;\n        let value_type = self.read_type()?;\n        *locals_total = locals_total\n            .checked_add(count as usize)\n            .ok_or_else(|| {\n                            BinaryReaderError {\n                                message: \"locals_total is out of bounds\",\n                                offset: self.position - 1,\n                            }\n                        })?;\n        if *locals_total > MAX_WASM_FUNCTION_LOCALS {\n            return Err(BinaryReaderError {\n                           message: \"locals_total is out of bounds\",\n                           offset: self.position - 1,\n                       });\n        }\n        Ok((count, value_type))\n    }\n\n    fn read_external_kind(&mut self) -> Result<ExternalKind> {\n        let code = self.read_u8()?;\n        match code {\n            0 => Ok(ExternalKind::Function),\n            1 => Ok(ExternalKind::Table),\n            2 => Ok(ExternalKind::Memory),\n            3 => Ok(ExternalKind::Global),\n            _ => {\n                Err(BinaryReaderError {\n                        message: \"Invalid external kind\",\n                        offset: self.position - 1,\n                    })\n            }\n        }\n    }\n\n    fn read_func_type(&mut self) -> Result<FuncType> {\n        let form = self.read_type()?;\n        let params_len = self.read_var_u32()? as usize;\n        if params_len > MAX_WASM_FUNCTION_PARAMS {\n            return Err(BinaryReaderError {\n                           message: \"function params size is out of bound\",\n                           offset: self.position - 1,\n                       });\n        }\n        let mut params: Vec<Type> = Vec::with_capacity(params_len);\n        for _ in 0..params_len {\n            params.push(self.read_type()?);\n        }\n        let returns_len = self.read_var_u32()? as usize;\n        if returns_len > MAX_WASM_FUNCTION_RETURNS {\n            return Err(BinaryReaderError {\n                           message: \"function params size is out of bound\",\n                           offset: self.position - 1,\n                       });\n        }\n        let mut returns: Vec<Type> = Vec::with_capacity(returns_len);\n        for _ in 0..returns_len {\n            returns.push(self.read_type()?);\n        }\n        Ok(FuncType {\n               form: form,\n               params: params,\n               returns: returns,\n           })\n    }\n\n    fn read_resizable_limits(&mut self, max_present: bool) -> Result<ResizableLimits> {\n        let initial = self.read_var_u32()?;\n        let maximum = if max_present {\n            Some(self.read_var_u32()?)\n        } else {\n            None\n        };\n        Ok(ResizableLimits { initial, maximum })\n    }\n\n    fn read_table_type(&mut self) -> Result<TableType> {\n        let element_type = self.read_type()?;\n        let flags = self.read_var_u32()?;\n        if (flags & !0x1) != 0 {\n            return Err(BinaryReaderError {\n                           message: \"invalid table resizable limits flags\",\n                           offset: self.position - 1,\n                       });\n        }\n        let limits = self.read_resizable_limits((flags & 0x1) != 0)?;\n        Ok(TableType {\n               element_type,\n               limits,\n           })\n    }\n\n    fn read_memory_type(&mut self) -> Result<MemoryType> {\n        let flags = self.read_var_u32()?;\n        if (flags & !0x3) != 0 {\n            return Err(BinaryReaderError {\n                           message: \"invalid table resizable limits flags\",\n                           offset: self.position - 1,\n                       });\n        }\n        let limits = self.read_resizable_limits((flags & 0x1) != 0)?;\n        let shared = (flags & 0x2) != 0;\n        Ok(MemoryType { limits, shared })\n    }\n\n    fn read_global_type(&mut self) -> Result<GlobalType> {\n        Ok(GlobalType {\n               content_type: self.read_type()?,\n               mutable: self.read_var_u1()? != 0,\n           })\n    }\n\n    fn read_memarg(&mut self) -> Result<MemoryImmediate> {\n        Ok(MemoryImmediate {\n               flags: self.read_var_u32()?,\n               offset: self.read_var_u32()?,\n           })\n    }\n\n    fn read_section_code(&mut self, id: u32, offset: usize) -> Result<SectionCode<'a>> {\n        match id {\n            0 => {\n                let name = self.read_string()?;\n                let kind = if is_name(name, \"name\") {\n                    CustomSectionKind::Name\n                } else if is_name(name, \"sourceMappingURL\") {\n                    CustomSectionKind::SourceMappingURL\n                } else if is_name_prefix(name, \"reloc.\") {\n                    CustomSectionKind::Reloc\n                } else if is_name(name, \"linking\") {\n                    CustomSectionKind::Linking\n                } else {\n                    CustomSectionKind::Unknown\n                };\n                Ok(SectionCode::Custom {\n                       name: name,\n                       kind: kind,\n                   })\n            }\n            1 => Ok(SectionCode::Type),\n            2 => Ok(SectionCode::Import),\n            3 => Ok(SectionCode::Function),\n            4 => Ok(SectionCode::Table),\n            5 => Ok(SectionCode::Memory),\n            6 => Ok(SectionCode::Global),\n            7 => Ok(SectionCode::Export),\n            8 => Ok(SectionCode::Start),\n            9 => Ok(SectionCode::Element),\n            10 => Ok(SectionCode::Code),\n            11 => Ok(SectionCode::Data),\n            _ => {\n                Err(BinaryReaderError {\n                        message: \"Invalid section code\",\n                        offset,\n                    })\n            }\n        }\n    }\n\n    fn read_br_table(&mut self) -> Result<BrTable<'a>> {\n        let targets_len = self.read_var_u32()? as usize;\n        if targets_len > MAX_WASM_BR_TABLE_SIZE {\n            return Err(BinaryReaderError {\n                           message: \"br_table size is out of bound\",\n                           offset: self.position - 1,\n                       });\n        }\n        let start = self.position;\n        for _ in 0..targets_len {\n            self.skip_var_32()?;\n        }\n        self.skip_var_32()?;\n        Ok(BrTable {\n               size: targets_len,\n               buffer: &self.buffer[start..self.position],\n           })\n    }\n\n    fn read_name_map(&mut self, limit: usize) -> Result<Vec<Naming<'a>>> {\n        let count = self.read_var_u32()? as usize;\n        if count > limit {\n            return Err(BinaryReaderError {\n                           message: \"name map size is out of bound\",\n                           offset: self.position - 1,\n                       });\n        }\n        let mut result = Vec::with_capacity(count);\n        for _ in 0..count {\n            let index = self.read_var_u32()?;\n            let name = self.read_string()?;\n            result.push(Naming {\n                            index: index,\n                            name: name,\n                        });\n        }\n        Ok(result)\n    }\n\n    pub fn eof(&self) -> bool {\n        self.position >= self.end\n    }\n\n    pub fn current_position(&self) -> usize {\n        self.position\n    }\n\n    pub fn bytes_remaining(&self) -> usize {\n        self.end - self.position\n    }\n\n    pub fn read_bytes(&mut self, size: usize) -> Result<&'a [u8]> {\n        self.ensure_has_bytes(size)?;\n        let start = self.position;\n        self.position += size;\n        Ok(&self.buffer[start..self.position])\n    }\n\n    pub fn read_u32(&mut self) -> Result<u32> {\n        self.ensure_has_bytes(4)?;\n        let b1 = self.buffer[self.position] as u32;\n        let b2 = self.buffer[self.position + 1] as u32;\n        let b3 = self.buffer[self.position + 2] as u32;\n        let b4 = self.buffer[self.position + 3] as u32;\n        self.position += 4;\n        Ok(b1 | (b2 << 8) | (b3 << 16) | (b4 << 24))\n    }\n\n    pub fn read_u64(&mut self) -> Result<u64> {\n        let w1 = self.read_u32()? as u64;\n        let w2 = self.read_u32()? as u64;\n        Ok(w1 | (w2 << 32))\n    }\n\n    pub fn read_u8(&mut self) -> Result<u32> {\n        self.ensure_has_byte()?;\n        let b = self.buffer[self.position] as u32;\n        self.position += 1;\n        Ok(b)\n    }\n\n    pub fn read_var_u32(&mut self) -> Result<u32> {\n        // Optimization for single byte i32.\n        let byte = self.read_u8()?;\n        if (byte & 0x80) == 0 {\n            return Ok(byte);\n        }\n\n        let mut result = byte & 0x7F;\n        let mut shift = 7;\n        loop {\n            let byte = self.read_u8()?;\n            result |= ((byte & 0x7F) as u32) << shift;\n            shift += 7;\n            if (byte & 0x80) == 0 {\n                break;\n            }\n            if shift >= 32 {\n                return Err(BinaryReaderError {\n                               message: \"Invalid var_u32\",\n                               offset: self.position - 1,\n                           });\n            }\n        }\n        Ok(result)\n    }\n\n    pub fn skip_var_32(&mut self) -> Result<()> {\n        for _ in 0..5 {\n            let byte = self.read_u8()?;\n            if (byte & 0x80) == 0 {\n                return Ok(());\n            }\n        }\n        Err(BinaryReaderError {\n                message: \"Invalid var_32\",\n                offset: self.position - 1,\n            })\n    }\n\n    pub fn read_var_i32(&mut self) -> Result<i32> {\n        // Optimization for single byte i32.\n        let byte = self.read_u8()?;\n        if (byte & 0x80) == 0 {\n            return Ok(((byte as i32) << 25) >> 25);\n        }\n\n        let mut result = (byte & 0x7F) as i32;\n        let mut shift = 7;\n        loop {\n            let byte = self.read_u8()?;\n            result |= ((byte & 0x7F) as i32) << shift;\n            shift += 7;\n            if (byte & 0x80) == 0 {\n                break;\n            }\n            if shift >= 32 {\n                return Err(BinaryReaderError {\n                               message: \"Invalid var_i32\",\n                               offset: self.position,\n                           });\n            }\n        }\n        if shift >= 32 {\n            return Ok(result);\n        }\n        let ashift = 32 - shift;\n        Ok((result << ashift) >> ashift)\n    }\n\n    pub fn read_var_i64(&mut self) -> Result<i64> {\n        let mut result: i64 = 0;\n        let mut shift = 0;\n        loop {\n            let byte = self.read_u8()?;\n            result |= ((byte & 0x7F) as i64) << shift;\n            shift += 7;\n            if (byte & 0x80) == 0 {\n                break;\n            }\n            if shift >= 64 {\n                return Err(BinaryReaderError {\n                               message: \"Invalid var_i64\",\n                               offset: self.position - 1,\n                           });\n            }\n        }\n        if shift >= 64 {\n            return Ok(result);\n        }\n        let ashift = 64 - shift;\n        Ok((result << ashift) >> ashift)\n    }\n\n    pub fn read_f32(&mut self) -> Result<Ieee32> {\n        let value = self.read_u32()?;\n        Ok(Ieee32(value))\n    }\n\n    pub fn read_f64(&mut self) -> Result<Ieee64> {\n        let value = self.read_u64()?;\n        Ok(Ieee64(value))\n    }\n\n    pub fn read_string(&mut self) -> Result<&'a [u8]> {\n        let len = self.read_var_u32()? as usize;\n        if len > MAX_WASM_STRING_SIZE {\n            return Err(BinaryReaderError {\n                           message: \"string size in out of bounds\",\n                           offset: self.position - 1,\n                       });\n        }\n        self.read_bytes(len)\n    }\n\n    fn read_memarg_of_align(&mut self, align: u32) -> Result<MemoryImmediate> {\n        let imm = self.read_memarg()?;\n        if align != imm.flags {\n            return Err(BinaryReaderError {\n                           message: \"Unexpected memarg alignment\",\n                           offset: self.position - 1,\n                       });\n        }\n        Ok(imm)\n    }\n\n    fn read_0xfe_operator(&mut self) -> Result<Operator<'a>> {\n        let code = self.read_u8()? as u8;\n        Ok(match code {\n               0x00 => Operator::Wake { memarg: self.read_memarg_of_align(2)? },\n               0x01 => Operator::I32Wait { memarg: self.read_memarg_of_align(2)? },\n               0x02 => Operator::I64Wait { memarg: self.read_memarg_of_align(3)? },\n               0x10 => Operator::I32AtomicLoad { memarg: self.read_memarg_of_align(2)? },\n               0x11 => Operator::I64AtomicLoad { memarg: self.read_memarg_of_align(3)? },\n               0x12 => Operator::I32AtomicLoad8U { memarg: self.read_memarg_of_align(0)? },\n               0x13 => Operator::I32AtomicLoad16U { memarg: self.read_memarg_of_align(1)? },\n               0x14 => Operator::I64AtomicLoad8U { memarg: self.read_memarg_of_align(0)? },\n               0x15 => Operator::I64AtomicLoad16U { memarg: self.read_memarg_of_align(1)? },\n               0x16 => Operator::I64AtomicLoad32U { memarg: self.read_memarg_of_align(2)? },\n               0x17 => Operator::I32AtomicStore { memarg: self.read_memarg_of_align(2)? },\n               0x18 => Operator::I64AtomicStore { memarg: self.read_memarg_of_align(3)? },\n               0x19 => Operator::I32AtomicStore8 { memarg: self.read_memarg_of_align(0)? },\n               0x1a => Operator::I32AtomicStore16 { memarg: self.read_memarg_of_align(1)? },\n               0x1b => Operator::I64AtomicStore8 { memarg: self.read_memarg_of_align(0)? },\n               0x1c => Operator::I64AtomicStore16 { memarg: self.read_memarg_of_align(1)? },\n               0x1d => Operator::I64AtomicStore32 { memarg: self.read_memarg_of_align(2)? },\n               0x1e => Operator::I32AtomicRmwAdd { memarg: self.read_memarg_of_align(2)? },\n               0x1f => Operator::I64AtomicRmwAdd { memarg: self.read_memarg_of_align(3)? },\n               0x20 => Operator::I32AtomicRmw8UAdd { memarg: self.read_memarg_of_align(0)? },\n               0x21 => Operator::I32AtomicRmw16UAdd { memarg: self.read_memarg_of_align(1)? },\n               0x22 => Operator::I64AtomicRmw8UAdd { memarg: self.read_memarg_of_align(0)? },\n               0x23 => Operator::I64AtomicRmw16UAdd { memarg: self.read_memarg_of_align(1)? },\n               0x24 => Operator::I64AtomicRmw32UAdd { memarg: self.read_memarg_of_align(2)? },\n               0x25 => Operator::I32AtomicRmwSub { memarg: self.read_memarg_of_align(2)? },\n               0x26 => Operator::I64AtomicRmwSub { memarg: self.read_memarg_of_align(3)? },\n               0x27 => Operator::I32AtomicRmw8USub { memarg: self.read_memarg_of_align(0)? },\n               0x28 => Operator::I32AtomicRmw16USub { memarg: self.read_memarg_of_align(1)? },\n               0x29 => Operator::I64AtomicRmw8USub { memarg: self.read_memarg_of_align(0)? },\n               0x2a => Operator::I64AtomicRmw16USub { memarg: self.read_memarg_of_align(1)? },\n               0x2b => Operator::I64AtomicRmw32USub { memarg: self.read_memarg_of_align(2)? },\n               0x2c => Operator::I32AtomicRmwAnd { memarg: self.read_memarg_of_align(2)? },\n               0x2d => Operator::I64AtomicRmwAnd { memarg: self.read_memarg_of_align(3)? },\n               0x2e => Operator::I32AtomicRmw8UAnd { memarg: self.read_memarg_of_align(0)? },\n               0x2f => Operator::I32AtomicRmw16UAnd { memarg: self.read_memarg_of_align(1)? },\n               0x30 => Operator::I64AtomicRmw8UAnd { memarg: self.read_memarg_of_align(0)? },\n               0x31 => Operator::I64AtomicRmw16UAnd { memarg: self.read_memarg_of_align(1)? },\n               0x32 => Operator::I64AtomicRmw32UAnd { memarg: self.read_memarg_of_align(2)? },\n               0x33 => Operator::I32AtomicRmwOr { memarg: self.read_memarg_of_align(2)? },\n               0x34 => Operator::I64AtomicRmwOr { memarg: self.read_memarg_of_align(3)? },\n               0x35 => Operator::I32AtomicRmw8UOr { memarg: self.read_memarg_of_align(0)? },\n               0x36 => Operator::I32AtomicRmw16UOr { memarg: self.read_memarg_of_align(1)? },\n               0x37 => Operator::I64AtomicRmw8UOr { memarg: self.read_memarg_of_align(0)? },\n               0x38 => Operator::I64AtomicRmw16UOr { memarg: self.read_memarg_of_align(1)? },\n               0x39 => Operator::I64AtomicRmw32UOr { memarg: self.read_memarg_of_align(2)? },\n               0x3a => Operator::I32AtomicRmwXor { memarg: self.read_memarg_of_align(2)? },\n               0x3b => Operator::I64AtomicRmwXor { memarg: self.read_memarg_of_align(3)? },\n               0x3c => Operator::I32AtomicRmw8UXor { memarg: self.read_memarg_of_align(0)? },\n               0x3d => Operator::I32AtomicRmw16UXor { memarg: self.read_memarg_of_align(1)? },\n               0x3e => Operator::I64AtomicRmw8UXor { memarg: self.read_memarg_of_align(0)? },\n               0x3f => Operator::I64AtomicRmw16UXor { memarg: self.read_memarg_of_align(1)? },\n               0x40 => Operator::I64AtomicRmw32UXor { memarg: self.read_memarg_of_align(2)? },\n               0x41 => Operator::I32AtomicRmwXchg { memarg: self.read_memarg_of_align(2)? },\n               0x42 => Operator::I64AtomicRmwXchg { memarg: self.read_memarg_of_align(3)? },\n               0x43 => Operator::I32AtomicRmw8UXchg { memarg: self.read_memarg_of_align(0)? },\n               0x44 => Operator::I32AtomicRmw16UXchg { memarg: self.read_memarg_of_align(1)? },\n               0x45 => Operator::I64AtomicRmw8UXchg { memarg: self.read_memarg_of_align(0)? },\n               0x46 => Operator::I64AtomicRmw16UXchg { memarg: self.read_memarg_of_align(1)? },\n               0x47 => Operator::I64AtomicRmw32UXchg { memarg: self.read_memarg_of_align(2)? },\n               0x48 => Operator::I32AtomicRmwCmpxchg { memarg: self.read_memarg_of_align(2)? },\n               0x49 => Operator::I64AtomicRmwCmpxchg { memarg: self.read_memarg_of_align(3)? },\n               0x4a => Operator::I32AtomicRmw8UCmpxchg { memarg: self.read_memarg_of_align(0)? },\n               0x4b => Operator::I32AtomicRmw16UCmpxchg { memarg: self.read_memarg_of_align(1)? },\n               0x4c => Operator::I64AtomicRmw8UCmpxchg { memarg: self.read_memarg_of_align(0)? },\n               0x4d => Operator::I64AtomicRmw16UCmpxchg { memarg: self.read_memarg_of_align(1)? },\n               0x4e => Operator::I64AtomicRmw32UCmpxchg { memarg: self.read_memarg_of_align(2)? },\n\n               _ => {\n                   return Err(BinaryReaderError {\n                                  message: \"Unknown 0xFE opcode\",\n                                  offset: self.position - 1,\n                              })\n               }\n           })\n    }\n\n    pub fn read_operator(&mut self) -> Result<Operator<'a>> {\n        let code = self.read_u8()? as u8;\n        Ok(match code {\n               0x00 => Operator::Unreachable,\n               0x01 => Operator::Nop,\n               0x02 => Operator::Block { ty: self.read_type()? },\n               0x03 => Operator::Loop { ty: self.read_type()? },\n               0x04 => Operator::If { ty: self.read_type()? },\n               0x05 => Operator::Else,\n               0x0b => Operator::End,\n               0x0c => Operator::Br { relative_depth: self.read_var_u32()? },\n               0x0d => Operator::BrIf { relative_depth: self.read_var_u32()? },\n               0x0e => Operator::BrTable { table: self.read_br_table()? },\n               0x0f => Operator::Return,\n               0x10 => Operator::Call { function_index: self.read_var_u32()? },\n               0x11 => {\n                   Operator::CallIndirect {\n                       index: self.read_var_u32()?,\n                       table_index: self.read_var_u1()?,\n                   }\n               }\n               0x1a => Operator::Drop,\n               0x1b => Operator::Select,\n               0x20 => Operator::GetLocal { local_index: self.read_var_u32()? },\n               0x21 => Operator::SetLocal { local_index: self.read_var_u32()? },\n               0x22 => Operator::TeeLocal { local_index: self.read_var_u32()? },\n               0x23 => Operator::GetGlobal { global_index: self.read_var_u32()? },\n               0x24 => Operator::SetGlobal { global_index: self.read_var_u32()? },\n               0x28 => Operator::I32Load { memarg: self.read_memarg()? },\n               0x29 => Operator::I64Load { memarg: self.read_memarg()? },\n               0x2a => Operator::F32Load { memarg: self.read_memarg()? },\n               0x2b => Operator::F64Load { memarg: self.read_memarg()? },\n               0x2c => Operator::I32Load8S { memarg: self.read_memarg()? },\n               0x2d => Operator::I32Load8U { memarg: self.read_memarg()? },\n               0x2e => Operator::I32Load16S { memarg: self.read_memarg()? },\n               0x2f => Operator::I32Load16U { memarg: self.read_memarg()? },\n               0x30 => Operator::I64Load8S { memarg: self.read_memarg()? },\n               0x31 => Operator::I64Load8U { memarg: self.read_memarg()? },\n               0x32 => Operator::I64Load16S { memarg: self.read_memarg()? },\n               0x33 => Operator::I64Load16U { memarg: self.read_memarg()? },\n               0x34 => Operator::I64Load32S { memarg: self.read_memarg()? },\n               0x35 => Operator::I64Load32U { memarg: self.read_memarg()? },\n               0x36 => Operator::I32Store { memarg: self.read_memarg()? },\n               0x37 => Operator::I64Store { memarg: self.read_memarg()? },\n               0x38 => Operator::F32Store { memarg: self.read_memarg()? },\n               0x39 => Operator::F64Store { memarg: self.read_memarg()? },\n               0x3a => Operator::I32Store8 { memarg: self.read_memarg()? },\n               0x3b => Operator::I32Store16 { memarg: self.read_memarg()? },\n               0x3c => Operator::I64Store8 { memarg: self.read_memarg()? },\n               0x3d => Operator::I64Store16 { memarg: self.read_memarg()? },\n               0x3e => Operator::I64Store32 { memarg: self.read_memarg()? },\n               0x3f => Operator::CurrentMemory { reserved: self.read_var_u1()? },\n               0x40 => Operator::GrowMemory { reserved: self.read_var_u1()? },\n               0x41 => Operator::I32Const { value: self.read_var_i32()? },\n               0x42 => Operator::I64Const { value: self.read_var_i64()? },\n               0x43 => Operator::F32Const { value: self.read_f32()? },\n               0x44 => Operator::F64Const { value: self.read_f64()? },\n               0x45 => Operator::I32Eqz,\n               0x46 => Operator::I32Eq,\n               0x47 => Operator::I32Ne,\n               0x48 => Operator::I32LtS,\n               0x49 => Operator::I32LtU,\n               0x4a => Operator::I32GtS,\n               0x4b => Operator::I32GtU,\n               0x4c => Operator::I32LeS,\n               0x4d => Operator::I32LeU,\n               0x4e => Operator::I32GeS,\n               0x4f => Operator::I32GeU,\n               0x50 => Operator::I64Eqz,\n               0x51 => Operator::I64Eq,\n               0x52 => Operator::I64Ne,\n               0x53 => Operator::I64LtS,\n               0x54 => Operator::I64LtU,\n               0x55 => Operator::I64GtS,\n               0x56 => Operator::I64GtU,\n               0x57 => Operator::I64LeS,\n               0x58 => Operator::I64LeU,\n               0x59 => Operator::I64GeS,\n               0x5a => Operator::I64GeU,\n               0x5b => Operator::F32Eq,\n               0x5c => Operator::F32Ne,\n               0x5d => Operator::F32Lt,\n               0x5e => Operator::F32Gt,\n               0x5f => Operator::F32Le,\n               0x60 => Operator::F32Ge,\n               0x61 => Operator::F64Eq,\n               0x62 => Operator::F64Ne,\n               0x63 => Operator::F64Lt,\n               0x64 => Operator::F64Gt,\n               0x65 => Operator::F64Le,\n               0x66 => Operator::F64Ge,\n               0x67 => Operator::I32Clz,\n               0x68 => Operator::I32Ctz,\n               0x69 => Operator::I32Popcnt,\n               0x6a => Operator::I32Add,\n               0x6b => Operator::I32Sub,\n               0x6c => Operator::I32Mul,\n               0x6d => Operator::I32DivS,\n               0x6e => Operator::I32DivU,\n               0x6f => Operator::I32RemS,\n               0x70 => Operator::I32RemU,\n               0x71 => Operator::I32And,\n               0x72 => Operator::I32Or,\n               0x73 => Operator::I32Xor,\n               0x74 => Operator::I32Shl,\n               0x75 => Operator::I32ShrS,\n               0x76 => Operator::I32ShrU,\n               0x77 => Operator::I32Rotl,\n               0x78 => Operator::I32Rotr,\n               0x79 => Operator::I64Clz,\n               0x7a => Operator::I64Ctz,\n               0x7b => Operator::I64Popcnt,\n               0x7c => Operator::I64Add,\n               0x7d => Operator::I64Sub,\n               0x7e => Operator::I64Mul,\n               0x7f => Operator::I64DivS,\n               0x80 => Operator::I64DivU,\n               0x81 => Operator::I64RemS,\n               0x82 => Operator::I64RemU,\n               0x83 => Operator::I64And,\n               0x84 => Operator::I64Or,\n               0x85 => Operator::I64Xor,\n               0x86 => Operator::I64Shl,\n               0x87 => Operator::I64ShrS,\n               0x88 => Operator::I64ShrU,\n               0x89 => Operator::I64Rotl,\n               0x8a => Operator::I64Rotr,\n               0x8b => Operator::F32Abs,\n               0x8c => Operator::F32Neg,\n               0x8d => Operator::F32Ceil,\n               0x8e => Operator::F32Floor,\n               0x8f => Operator::F32Trunc,\n               0x90 => Operator::F32Nearest,\n               0x91 => Operator::F32Sqrt,\n               0x92 => Operator::F32Add,\n               0x93 => Operator::F32Sub,\n               0x94 => Operator::F32Mul,\n               0x95 => Operator::F32Div,\n               0x96 => Operator::F32Min,\n               0x97 => Operator::F32Max,\n               0x98 => Operator::F32Copysign,\n               0x99 => Operator::F64Abs,\n               0x9a => Operator::F64Neg,\n               0x9b => Operator::F64Ceil,\n               0x9c => Operator::F64Floor,\n               0x9d => Operator::F64Trunc,\n               0x9e => Operator::F64Nearest,\n               0x9f => Operator::F64Sqrt,\n               0xa0 => Operator::F64Add,\n               0xa1 => Operator::F64Sub,\n               0xa2 => Operator::F64Mul,\n               0xa3 => Operator::F64Div,\n               0xa4 => Operator::F64Min,\n               0xa5 => Operator::F64Max,\n               0xa6 => Operator::F64Copysign,\n               0xa7 => Operator::I32WrapI64,\n               0xa8 => Operator::I32TruncSF32,\n               0xa9 => Operator::I32TruncUF32,\n               0xaa => Operator::I32TruncSF64,\n               0xab => Operator::I32TruncUF64,\n               0xac => Operator::I64ExtendSI32,\n               0xad => Operator::I64ExtendUI32,\n               0xae => Operator::I64TruncSF32,\n               0xaf => Operator::I64TruncUF32,\n               0xb0 => Operator::I64TruncSF64,\n               0xb1 => Operator::I64TruncUF64,\n               0xb2 => Operator::F32ConvertSI32,\n               0xb3 => Operator::F32ConvertUI32,\n               0xb4 => Operator::F32ConvertSI64,\n               0xb5 => Operator::F32ConvertUI64,\n               0xb6 => Operator::F32DemoteF64,\n               0xb7 => Operator::F64ConvertSI32,\n               0xb8 => Operator::F64ConvertUI32,\n               0xb9 => Operator::F64ConvertSI64,\n               0xba => Operator::F64ConvertUI64,\n               0xbb => Operator::F64PromoteF32,\n               0xbc => Operator::I32ReinterpretF32,\n               0xbd => Operator::I64ReinterpretF64,\n               0xbe => Operator::F32ReinterpretI32,\n               0xbf => Operator::F64ReinterpretI64,\n\n               0xc0 => Operator::I32Extend8S,\n               0xc1 => Operator::I32Extend16S,\n               0xc2 => Operator::I64Extend8S,\n               0xc3 => Operator::I64Extend16S,\n               0xc4 => Operator::I64Extend32S,\n\n               0xfc => self.read_0xfc_operator()?,\n\n               0xfe => self.read_0xfe_operator()?,\n\n               _ => {\n                   return Err(BinaryReaderError {\n                                  message: \"Unknown opcode\",\n                                  offset: self.position - 1,\n                              })\n               }\n           })\n    }\n\n    fn read_0xfc_operator(&mut self) -> Result<Operator<'a>> {\n        let code = self.read_u8()? as u8;\n        Ok(match code {\n               0x00 => Operator::I32TruncSSatF32,\n               0x01 => Operator::I32TruncUSatF32,\n               0x02 => Operator::I32TruncSSatF64,\n               0x03 => Operator::I32TruncUSatF64,\n               0x04 => Operator::I64TruncSSatF32,\n               0x05 => Operator::I64TruncUSatF32,\n               0x06 => Operator::I64TruncSSatF64,\n               0x07 => Operator::I64TruncUSatF64,\n\n               _ => {\n                   return Err(BinaryReaderError {\n                                  message: \"Unknown 0xfc opcode\",\n                                  offset: self.position - 1,\n                              })\n               }\n           })\n    }\n}\n\n\n/// Bytecode range in the WebAssembly module.\n#[derive(Debug, Copy, Clone)]\npub struct Range {\n    pub start: usize,\n    pub end: usize,\n}\n\nimpl Range {\n    pub fn new(start: usize, end: usize) -> Range {\n        assert!(start <= end);\n        Range { start, end }\n    }\n\n    pub fn slice<'a>(&self, data: &'a [u8]) -> &'a [u8] {\n        &data[self.start..self.end]\n    }\n}\n\n#[derive(Debug)]\npub enum ParserState<'a> {\n    Error(BinaryReaderError),\n    Initial,\n    BeginWasm { version: u32 },\n    EndWasm,\n    BeginSection { code: SectionCode<'a>, range: Range },\n    EndSection,\n    SkippingSection,\n    ReadingCustomSection(CustomSectionKind),\n    ReadingSectionRawData,\n    SectionRawData(&'a [u8]),\n\n    TypeSectionEntry(FuncType),\n    ImportSectionEntry {\n        module: &'a [u8],\n        field: &'a [u8],\n        ty: ImportSectionEntryType,\n    },\n    FunctionSectionEntry(u32),\n    TableSectionEntry(TableType),\n    MemorySectionEntry(MemoryType),\n    ExportSectionEntry {\n        field: &'a [u8],\n        kind: ExternalKind,\n        index: u32,\n    },\n    NameSectionEntry(NameEntry<'a>),\n    StartSectionEntry(u32),\n\n    BeginInitExpressionBody,\n    InitExpressionOperator(Operator<'a>),\n    EndInitExpressionBody,\n\n    BeginFunctionBody { range: Range },\n    FunctionBodyLocals { locals: Vec<(u32, Type)> },\n    CodeOperator(Operator<'a>),\n    EndFunctionBody,\n    SkippingFunctionBody,\n\n    BeginElementSectionEntry(u32),\n    ElementSectionEntryBody(Vec<u32>),\n    EndElementSectionEntry,\n\n    BeginDataSectionEntry(u32),\n    EndDataSectionEntry,\n    BeginDataSectionEntryBody(u32),\n    DataSectionEntryBodyChunk(&'a [u8]),\n    EndDataSectionEntryBody,\n\n    BeginGlobalSectionEntry(GlobalType),\n    EndGlobalSectionEntry,\n\n    RelocSectionHeader(SectionCode<'a>),\n    RelocSectionEntry(RelocEntry),\n    LinkingSectionEntry(LinkingType),\n\n    SourceMappingURL(&'a [u8]),\n}\n\n#[derive(Debug, Copy, Clone)]\npub enum ParserInput {\n    Default,\n    SkipSection,\n    SkipFunctionBody,\n    ReadCustomSection,\n    ReadSectionRawData,\n}\n\npub trait WasmDecoder<'a> {\n    fn read(&mut self) -> &ParserState<'a>;\n    fn push_input(&mut self, input: ParserInput);\n    fn read_with_input(&mut self, input: ParserInput) -> &ParserState<'a>;\n    fn create_binary_reader<'b>(&mut self) -> BinaryReader<'b> where 'a: 'b;\n    fn last_state(&self) -> &ParserState<'a>;\n}\n\n/// The `Parser` type. A simple event-driven parser of WebAssembly binary\n/// format. The `read(&mut self)` is used to iterate through WebAssembly records.\npub struct Parser<'a> {\n    reader: BinaryReader<'a>,\n    state: ParserState<'a>,\n    section_range: Option<Range>,\n    function_range: Option<Range>,\n    init_expr_continuation: Option<InitExpressionContinuation>,\n    read_data_bytes: Option<u32>,\n    section_entries_left: u32,\n}\n\nconst WASM_MAGIC_NUMBER: u32 = 0x6d736100;\nconst WASM_EXPERIMENTAL_VERSION: u32 = 0xd;\nconst WASM_SUPPORTED_VERSION: u32 = 0x1;\n\nimpl<'a> Parser<'a> {\n    /// Constructs `Parser` type.\n    ///\n    /// # Examples\n    /// ```\n    /// let data: &[u8] = &[0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,\n    ///     0x01, 0x4, 0x01, 0x60, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00,\n    ///     0x0a, 0x05, 0x01, 0x03, 0x00, 0x01, 0x0b];\n    /// let mut parser = wasmparser::Parser::new(data);\n    /// ```\n    pub fn new(data: &[u8]) -> Parser {\n        Parser {\n            reader: BinaryReader::new(data),\n            state: ParserState::Initial,\n            section_range: None,\n            function_range: None,\n            init_expr_continuation: None,\n            read_data_bytes: None,\n            section_entries_left: 0,\n        }\n    }\n\n    pub fn eof(&self) -> bool {\n        self.reader.eof()\n    }\n\n    pub fn current_position(&self) -> usize {\n        self.reader.current_position()\n    }\n\n    fn read_header(&mut self) -> Result<()> {\n        let magic_number = self.reader.read_u32()?;\n        if magic_number != WASM_MAGIC_NUMBER {\n            return Err(BinaryReaderError {\n                           message: \"Bad magic number\",\n                           offset: self.reader.position - 4,\n                       });\n        }\n        let version = self.reader.read_u32()?;\n        if version != WASM_SUPPORTED_VERSION && version != WASM_EXPERIMENTAL_VERSION {\n            return Err(BinaryReaderError {\n                           message: \"Bad version number\",\n                           offset: self.reader.position - 4,\n                       });\n        }\n        self.state = ParserState::BeginWasm { version: version };\n        Ok(())\n    }\n\n    fn read_section_header(&mut self) -> Result<()> {\n        let id_position = self.reader.position;\n        let id = self.reader.read_var_u7()?;\n        let payload_len = self.reader.read_var_u32()? as usize;\n        let payload_end = self.reader.position + payload_len;\n        let code = self.reader.read_section_code(id, id_position)?;\n        if self.reader.end < payload_end {\n            return Err(BinaryReaderError {\n                           message: \"Section body extends past end of file\",\n                           offset: self.reader.end,\n                       });\n        }\n        if self.reader.position > payload_end {\n            return Err(BinaryReaderError {\n                           message: \"Section header is too big to fit into section body\",\n                           offset: payload_end,\n                       });\n        }\n        let range = Range {\n            start: self.reader.position,\n            end: payload_end,\n        };\n        self.state = ParserState::BeginSection { code, range };\n        self.section_range = Some(range);\n        Ok(())\n    }\n\n    fn read_type_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        self.state = ParserState::TypeSectionEntry(self.reader.read_func_type()?);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_import_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        let module = self.reader.read_string()?;\n        let field = self.reader.read_string()?;\n        let kind = self.reader.read_external_kind()?;\n        let ty: ImportSectionEntryType;\n        match kind {\n            ExternalKind::Function => {\n                ty = ImportSectionEntryType::Function(self.reader.read_var_u32()?)\n            }\n            ExternalKind::Table => {\n                ty = ImportSectionEntryType::Table(self.reader.read_table_type()?)\n            }\n            ExternalKind::Memory => {\n                ty = ImportSectionEntryType::Memory(self.reader.read_memory_type()?)\n            }\n            ExternalKind::Global => {\n                ty = ImportSectionEntryType::Global(self.reader.read_global_type()?)\n            }\n        }\n\n        self.state = ParserState::ImportSectionEntry {\n            module: module,\n            field: field,\n            ty: ty,\n        };\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_function_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        self.state = ParserState::FunctionSectionEntry(self.reader.read_var_u32()?);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_memory_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        self.state = ParserState::MemorySectionEntry(self.reader.read_memory_type()?);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_global_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        self.state = ParserState::BeginGlobalSectionEntry(self.reader.read_global_type()?);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_init_expression_body(&mut self, cont: InitExpressionContinuation) {\n        self.state = ParserState::BeginInitExpressionBody;\n        self.init_expr_continuation = Some(cont);\n    }\n\n    fn read_init_expression_operator(&mut self) -> Result<()> {\n        let op = self.reader.read_operator()?;\n        if let Operator::End = op {\n            self.state = ParserState::EndInitExpressionBody;\n            return Ok(());\n        }\n        self.state = ParserState::InitExpressionOperator(op);\n        Ok(())\n    }\n\n    fn read_export_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        let field = self.reader.read_string()?;\n        let kind = self.reader.read_external_kind()?;\n        let index = self.reader.read_var_u32()?;\n        self.state = ParserState::ExportSectionEntry {\n            field: field,\n            kind: kind,\n            index: index,\n        };\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_element_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        self.state = ParserState::BeginElementSectionEntry(self.reader.read_var_u32()?);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_element_entry_body(&mut self) -> Result<()> {\n        let num_elements = self.reader.read_var_u32()? as usize;\n        if num_elements > MAX_WASM_TABLE_ENTRIES {\n            return Err(BinaryReaderError {\n                           message: \"num_elements is out of bounds\",\n                           offset: self.reader.position - 1,\n                       });\n        }\n        let mut elements: Vec<u32> = Vec::with_capacity(num_elements);\n        for _ in 0..num_elements {\n            elements.push(self.reader.read_var_u32()?);\n        }\n        self.state = ParserState::ElementSectionEntryBody(elements);\n        Ok(())\n    }\n\n    fn read_function_body(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        let size = self.reader.read_var_u32()? as usize;\n        let body_end = self.reader.position + size;\n        let range = Range {\n            start: self.reader.position,\n            end: body_end,\n        };\n        self.state = ParserState::BeginFunctionBody { range };\n        self.function_range = Some(range);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_function_body_locals(&mut self) -> Result<()> {\n        let local_count = self.reader.read_local_count()?;\n        let mut locals: Vec<(u32, Type)> = Vec::with_capacity(local_count);\n        let mut locals_total = 0;\n        for _ in 0..local_count {\n            let (count, ty) = self.reader.read_local_decl(&mut locals_total)?;\n            locals.push((count, ty));\n        }\n        self.state = ParserState::FunctionBodyLocals { locals };\n        Ok(())\n    }\n\n    fn read_code_operator(&mut self) -> Result<()> {\n        if self.reader.position >= self.function_range.unwrap().end {\n            if let ParserState::CodeOperator(Operator::End) = self.state {\n                self.state = ParserState::EndFunctionBody;\n                self.function_range = None;\n                return Ok(());\n            }\n            return Err(BinaryReaderError {\n                           message: \"Expected end of function marker\",\n                           offset: self.function_range.unwrap().end,\n                       });\n        }\n        let op = self.reader.read_operator()?;\n        self.state = ParserState::CodeOperator(op);\n        Ok(())\n    }\n\n    fn read_table_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        self.state = ParserState::TableSectionEntry(self.reader.read_table_type()?);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_data_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        let index = self.reader.read_var_u32()?;\n        self.state = ParserState::BeginDataSectionEntry(index);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_data_entry_body(&mut self) -> Result<()> {\n        let size = self.reader.read_var_u32()?;\n        self.state = ParserState::BeginDataSectionEntryBody(size);\n        self.read_data_bytes = Some(size);\n        Ok(())\n    }\n\n    fn read_name_type(&mut self) -> Result<NameType> {\n        let code = self.reader.read_var_u7()?;\n        match code {\n            0 => Ok(NameType::Module),\n            1 => Ok(NameType::Function),\n            2 => Ok(NameType::Local),\n            _ => {\n                Err(BinaryReaderError {\n                        message: \"Invalid name type\",\n                        offset: self.reader.position - 1,\n                    })\n            }\n        }\n    }\n\n    fn read_name_entry(&mut self) -> Result<()> {\n        if self.reader.position >= self.section_range.unwrap().end {\n            return self.position_to_section_end();\n        }\n        let ty = self.read_name_type()?;\n        self.reader.read_var_u32()?; // payload_len\n        let entry = match ty {\n            NameType::Module => NameEntry::Module(self.reader.read_string()?),\n            NameType::Function => {\n                NameEntry::Function(self.reader.read_name_map(MAX_WASM_FUNCTIONS)?)\n            }\n            NameType::Local => {\n                let funcs_len = self.reader.read_var_u32()? as usize;\n                if funcs_len > MAX_WASM_FUNCTIONS {\n                    return Err(BinaryReaderError {\n                                   message: \"function count is out of bounds\",\n                                   offset: self.reader.position - 1,\n                               });\n                }\n                let mut funcs: Vec<LocalName<'a>> = Vec::with_capacity(funcs_len);\n                for _ in 0..funcs_len {\n                    funcs.push(LocalName {\n                                   index: self.reader.read_var_u32()?,\n                                   locals: self.reader.read_name_map(MAX_WASM_FUNCTION_LOCALS)?,\n                               });\n                }\n                NameEntry::Local(funcs)\n            }\n        };\n        self.state = ParserState::NameSectionEntry(entry);\n        Ok(())\n    }\n\n    fn read_source_mapping(&mut self) -> Result<()> {\n        self.state = ParserState::SourceMappingURL(self.reader.read_string()?);\n        Ok(())\n    }\n\n    // See https://github.com/WebAssembly/tool-conventions/blob/master/Linking.md\n    fn read_reloc_header(&mut self) -> Result<()> {\n        let section_id_position = self.reader.position;\n        let section_id = self.reader.read_var_u7()?;\n        let section_code = self.reader\n            .read_section_code(section_id, section_id_position)?;\n        self.state = ParserState::RelocSectionHeader(section_code);\n        Ok(())\n    }\n\n    fn read_reloc_type(&mut self) -> Result<RelocType> {\n        let code = self.reader.read_var_u7()?;\n        match code {\n            0 => Ok(RelocType::FunctionIndexLEB),\n            1 => Ok(RelocType::TableIndexSLEB),\n            2 => Ok(RelocType::TableIndexI32),\n            3 => Ok(RelocType::GlobalAddrLEB),\n            4 => Ok(RelocType::GlobalAddrSLEB),\n            5 => Ok(RelocType::GlobalAddrI32),\n            6 => Ok(RelocType::TypeIndexLEB),\n            7 => Ok(RelocType::GlobalIndexLEB),\n            _ => {\n                Err(BinaryReaderError {\n                        message: \"Invalid reloc type\",\n                        offset: self.reader.position - 1,\n                    })\n            }\n        }\n    }\n\n    fn read_reloc_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        let ty = self.read_reloc_type()?;\n        let offset = self.reader.read_var_u32()?;\n        let index = self.reader.read_var_u32()?;\n        let addend = match ty {\n            RelocType::FunctionIndexLEB |\n            RelocType::TableIndexSLEB |\n            RelocType::TableIndexI32 |\n            RelocType::TypeIndexLEB |\n            RelocType::GlobalIndexLEB => None,\n            RelocType::GlobalAddrLEB |\n            RelocType::GlobalAddrSLEB |\n            RelocType::GlobalAddrI32 => Some(self.reader.read_var_u32()?),\n        };\n        self.state = ParserState::RelocSectionEntry(RelocEntry {\n                                                        ty: ty,\n                                                        offset: offset,\n                                                        index: index,\n                                                        addend: addend,\n                                                    });\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_linking_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        let ty = self.reader.read_var_u32()?;\n        let entry = match ty {\n            1 => LinkingType::StackPointer(self.reader.read_var_u32()?),\n            _ => {\n                return Err(BinaryReaderError {\n                               message: \"Invalid linking type\",\n                               offset: self.reader.position - 1,\n                           });\n            }\n        };\n        self.state = ParserState::LinkingSectionEntry(entry);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_section_body(&mut self) -> Result<()> {\n        match self.state {\n            ParserState::BeginSection { code: SectionCode::Type, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_type_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Import, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_import_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Function, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_function_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Memory, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_memory_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Global, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_global_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Export, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_export_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Element, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_element_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Code, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_function_body()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Table, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_table_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Data, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_data_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Start, .. } => {\n                self.state = ParserState::StartSectionEntry(self.reader.read_var_u32()?);\n            }\n            ParserState::BeginSection { code: SectionCode::Custom { .. }, .. } => {\n                self.read_section_body_bytes()?;\n            }\n            _ => unreachable!(),\n        }\n        Ok(())\n    }\n\n    fn read_custom_section_body(&mut self) -> Result<()> {\n        match self.state {\n            ParserState::ReadingCustomSection(CustomSectionKind::Name) => {\n                self.read_name_entry()?;\n            }\n            ParserState::ReadingCustomSection(CustomSectionKind::SourceMappingURL) => {\n                self.read_source_mapping()?;\n            }\n            ParserState::ReadingCustomSection(CustomSectionKind::Reloc) => {\n                self.read_reloc_header()?;\n            }\n            ParserState::ReadingCustomSection(CustomSectionKind::Linking) => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_linking_entry()?;\n            }\n            ParserState::ReadingCustomSection(CustomSectionKind::Unknown) => {\n                self.read_section_body_bytes()?;\n            }\n            _ => unreachable!(),\n        }\n        Ok(())\n    }\n\n    fn ensure_reader_position_in_section_range(&self) -> Result<()> {\n        if self.section_range.unwrap().end < self.reader.position {\n            return Err(BinaryReaderError {\n                           message: \"Position past the section end\",\n                           offset: self.section_range.unwrap().end,\n                       });\n        }\n        Ok(())\n    }\n\n    fn position_to_section_end(&mut self) -> Result<()> {\n        self.ensure_reader_position_in_section_range()?;\n        self.reader.position = self.section_range.unwrap().end;\n        self.section_range = None;\n        self.state = ParserState::EndSection;\n        Ok(())\n    }\n\n    fn read_section_body_bytes(&mut self) -> Result<()> {\n        self.ensure_reader_position_in_section_range()?;\n        if self.section_range.unwrap().end == self.reader.position {\n            self.state = ParserState::EndSection;\n            self.section_range = None;\n            return Ok(());\n        }\n        let to_read = if self.section_range.unwrap().end - self.reader.position <\n                         MAX_DATA_CHUNK_SIZE {\n            self.section_range.unwrap().end - self.reader.position\n        } else {\n            MAX_DATA_CHUNK_SIZE\n        };\n        let bytes = self.reader.read_bytes(to_read)?;\n        self.state = ParserState::SectionRawData(bytes);\n        Ok(())\n    }\n\n    fn read_data_chunk(&mut self) -> Result<()> {\n        if self.read_data_bytes.unwrap() == 0 {\n            self.state = ParserState::EndDataSectionEntryBody;\n            self.read_data_bytes = None;\n            return Ok(());\n        }\n        let to_read = if self.read_data_bytes.unwrap() as usize > MAX_DATA_CHUNK_SIZE {\n            MAX_DATA_CHUNK_SIZE\n        } else {\n            self.read_data_bytes.unwrap() as usize\n        };\n        let chunk = self.reader.read_bytes(to_read)?;\n        *self.read_data_bytes.as_mut().unwrap() -= to_read as u32;\n        self.state = ParserState::DataSectionEntryBodyChunk(chunk);\n        Ok(())\n    }\n\n    fn read_next_section(&mut self) -> Result<()> {\n        if self.reader.eof() {\n            self.state = ParserState::EndWasm;\n        } else {\n            self.read_section_header()?;\n        }\n        Ok(())\n    }\n\n    fn read_wrapped(&mut self) -> Result<()> {\n        match self.state {\n            ParserState::EndWasm => panic!(\"Parser in end state\"),\n            ParserState::Error(_) => panic!(\"Parser in error state\"),\n            ParserState::Initial => self.read_header()?,\n            ParserState::BeginWasm { .. } |\n            ParserState::EndSection => self.read_next_section()?,\n            ParserState::BeginSection { .. } => self.read_section_body()?,\n            ParserState::SkippingSection => {\n                self.position_to_section_end()?;\n                self.read_next_section()?;\n            }\n            ParserState::TypeSectionEntry(_) => self.read_type_entry()?,\n            ParserState::ImportSectionEntry { .. } => self.read_import_entry()?,\n            ParserState::FunctionSectionEntry(_) => self.read_function_entry()?,\n            ParserState::MemorySectionEntry(_) => self.read_memory_entry()?,\n            ParserState::TableSectionEntry(_) => self.read_table_entry()?,\n            ParserState::ExportSectionEntry { .. } => self.read_export_entry()?,\n            ParserState::BeginGlobalSectionEntry(_) => {\n                self.read_init_expression_body(InitExpressionContinuation::GlobalSection)\n            }\n            ParserState::EndGlobalSectionEntry => self.read_global_entry()?,\n            ParserState::BeginElementSectionEntry(_) => {\n                self.read_init_expression_body(InitExpressionContinuation::ElementSection)\n            }\n            ParserState::BeginInitExpressionBody |\n            ParserState::InitExpressionOperator(_) => self.read_init_expression_operator()?,\n            ParserState::BeginDataSectionEntry(_) => {\n                self.read_init_expression_body(InitExpressionContinuation::DataSection)\n            }\n            ParserState::EndInitExpressionBody => {\n                match self.init_expr_continuation {\n                    Some(InitExpressionContinuation::GlobalSection) => {\n                        self.state = ParserState::EndGlobalSectionEntry\n                    }\n                    Some(InitExpressionContinuation::ElementSection) => {\n                        self.read_element_entry_body()?\n                    }\n                    Some(InitExpressionContinuation::DataSection) => self.read_data_entry_body()?,\n                    None => unreachable!(),\n                }\n                self.init_expr_continuation = None;\n            }\n            ParserState::BeginFunctionBody { .. } => self.read_function_body_locals()?,\n            ParserState::FunctionBodyLocals { .. } |\n            ParserState::CodeOperator(_) => self.read_code_operator()?,\n            ParserState::EndFunctionBody => self.read_function_body()?,\n            ParserState::SkippingFunctionBody => {\n                assert!(self.reader.position <= self.function_range.unwrap().end);\n                self.reader.position = self.function_range.unwrap().end;\n                self.function_range = None;\n                self.read_function_body()?;\n            }\n            ParserState::EndDataSectionEntry => self.read_data_entry()?,\n            ParserState::BeginDataSectionEntryBody(_) |\n            ParserState::DataSectionEntryBodyChunk(_) => self.read_data_chunk()?,\n            ParserState::EndDataSectionEntryBody => {\n                self.state = ParserState::EndDataSectionEntry;\n            }\n            ParserState::ElementSectionEntryBody(_) => {\n                self.state = ParserState::EndElementSectionEntry;\n            }\n            ParserState::EndElementSectionEntry => self.read_element_entry()?,\n            ParserState::StartSectionEntry(_) => self.position_to_section_end()?,\n            ParserState::NameSectionEntry(_) => self.read_name_entry()?,\n            ParserState::SourceMappingURL(_) => self.position_to_section_end()?,\n            ParserState::RelocSectionHeader(_) => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_reloc_entry()?;\n            }\n            ParserState::RelocSectionEntry(_) => self.read_reloc_entry()?,\n            ParserState::LinkingSectionEntry(_) => self.read_linking_entry()?,\n            ParserState::ReadingCustomSection(_) => self.read_custom_section_body()?,\n            ParserState::ReadingSectionRawData |\n            ParserState::SectionRawData(_) => self.read_section_body_bytes()?,\n        }\n        Ok(())\n    }\n\n    fn skip_section(&mut self) {\n        match self.state {\n            ParserState::Initial |\n            ParserState::EndWasm |\n            ParserState::Error(_) |\n            ParserState::BeginWasm { .. } |\n            ParserState::EndSection => panic!(\"Invalid reader state during skip section\"),\n            _ => self.state = ParserState::SkippingSection,\n        }\n    }\n\n    fn skip_function_body(&mut self) {\n        match self.state {\n            ParserState::BeginFunctionBody { .. } |\n            ParserState::FunctionBodyLocals { .. } |\n            ParserState::CodeOperator(_) => self.state = ParserState::SkippingFunctionBody,\n            _ => panic!(\"Invalid reader state during skip function body\"),\n        }\n    }\n\n    fn read_custom_section(&mut self) {\n        match self.state {\n            ParserState::BeginSection { code: SectionCode::Custom { kind, .. }, .. } => {\n                self.state = ParserState::ReadingCustomSection(kind);\n            }\n            _ => panic!(\"Invalid reader state during reading custom section\"),\n        }\n    }\n\n    fn read_raw_section_data(&mut self) {\n        match self.state {\n            ParserState::BeginSection { .. } => self.state = ParserState::ReadingSectionRawData,\n            _ => panic!(\"Invalid reader state during reading raw section data\"),\n        }\n    }\n}\n\nimpl<'a> WasmDecoder<'a> for Parser<'a> {\n    /// Reads next record from the WebAssembly binary data. The methods returns\n    /// reference to current state of the parser. See `ParserState` num.\n    ///\n    /// # Examples\n    /// ```\n    /// # let data: &[u8] = &[0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,\n    /// #     0x01, 0x4, 0x01, 0x60, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00,\n    /// #     0x0a, 0x05, 0x01, 0x03, 0x00, 0x01, 0x0b];\n    /// use wasmparser::WasmDecoder;\n    /// let mut parser = wasmparser::Parser::new(data);\n    /// {\n    ///     let state = parser.read();\n    ///     println!(\"First state {:?}\", state);\n    /// }\n    /// {\n    ///     let state = parser.read();\n    ///     println!(\"Second state {:?}\", state);\n    /// }\n    /// ```\n    fn read(&mut self) -> &ParserState<'a> {\n        let result = self.read_wrapped();\n        if result.is_err() {\n            self.state = ParserState::Error(result.err().unwrap());\n        }\n        &self.state\n    }\n\n    fn push_input(&mut self, input: ParserInput) {\n        match input {\n            ParserInput::Default => (),\n            ParserInput::SkipSection => self.skip_section(),\n            ParserInput::SkipFunctionBody => self.skip_function_body(),\n            ParserInput::ReadCustomSection => self.read_custom_section(),\n            ParserInput::ReadSectionRawData => self.read_raw_section_data(),\n        }\n    }\n\n    /// Creates a BinaryReader when current state is ParserState::BeginSection\n    /// or ParserState::BeginFunctionBody.\n    ///\n    /// # Examples\n    /// ```\n    /// # let data = &[0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x84,\n    /// #              0x80, 0x80, 0x80, 0x0, 0x1, 0x60, 0x0, 0x0, 0x3, 0x83,\n    /// #              0x80, 0x80, 0x80, 0x0, 0x2, 0x0, 0x0, 0x6, 0x81, 0x80,\n    /// #              0x80, 0x80, 0x0, 0x0, 0xa, 0x91, 0x80, 0x80, 0x80, 0x0,\n    /// #              0x2, 0x83, 0x80, 0x80, 0x80, 0x0, 0x0, 0x1, 0xb, 0x83,\n    /// #              0x80, 0x80, 0x80, 0x0, 0x0, 0x0, 0xb];\n    /// use wasmparser::{WasmDecoder, Parser, ParserState};\n    /// let mut parser = Parser::new(data);\n    /// let mut function_readers = Vec::new();\n    /// loop {\n    ///     match *parser.read() {\n    ///         ParserState::Error(_) |\n    ///         ParserState::EndWasm => break,\n    ///         ParserState::BeginFunctionBody {..} => {\n    ///             let reader = parser.create_binary_reader();\n    ///             function_readers.push(reader);\n    ///         }\n    ///         _ => continue\n    ///     }\n    /// }\n    /// for (i, reader) in function_readers.iter_mut().enumerate() {\n    ///     println!(\"Function {}\", i);\n    ///     while let Ok(ref op) = reader.read_operator() {\n    ///       println!(\"  {:?}\", op);\n    ///     }\n    /// }\n    /// ```\n    fn create_binary_reader<'b>(&mut self) -> BinaryReader<'b>\n        where 'a: 'b\n    {\n        let range;\n        match self.state {\n            ParserState::BeginSection { .. } => {\n                range = self.section_range.unwrap();\n                self.skip_section();\n            }\n            ParserState::BeginFunctionBody { .. } |\n            ParserState::FunctionBodyLocals { .. } => {\n                range = self.function_range.unwrap();\n                self.skip_function_body();\n            }\n            _ => panic!(\"Invalid reader state during get binary reader operation\"),\n        };\n        BinaryReader::new(range.slice(self.reader.buffer))\n    }\n\n    /// Reads next record from the WebAssembly binary data. It also allows to\n    /// control how parser will treat the next record(s). The method accepts the\n    /// `ParserInput` parameter that allows e.g. to skip section or function\n    /// operators. The methods returns reference to current state of the parser.\n    ///\n    /// # Examples\n    /// ```\n    /// # let data: &[u8] = &[0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,\n    /// #     0x01, 0x4, 0x01, 0x60, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00,\n    /// #     0x0a, 0x05, 0x01, 0x03, 0x00, 0x01, 0x0b];\n    /// use wasmparser::WasmDecoder;\n    /// let mut parser = wasmparser::Parser::new(data);\n    /// let mut next_input = wasmparser::ParserInput::Default;\n    /// loop {\n    ///     let state = parser.read_with_input(next_input);\n    ///     match *state {\n    ///         wasmparser::ParserState::EndWasm => break,\n    ///         wasmparser::ParserState::BeginWasm { .. } |\n    ///         wasmparser::ParserState::EndSection =>\n    ///             next_input = wasmparser::ParserInput::Default,\n    ///         wasmparser::ParserState::BeginSection { ref code, .. } => {\n    ///             println!(\"Found section: {:?}\", code);\n    ///             next_input = wasmparser::ParserInput::SkipSection;\n    ///         },\n    ///         _ => unreachable!()\n    ///     }\n    /// }\n    /// ```\n    fn read_with_input(&mut self, input: ParserInput) -> &ParserState<'a> {\n        self.push_input(input);\n        self.read()\n    }\n\n    fn last_state(&self) -> &ParserState<'a> {\n        &self.state\n    }\n}\n","// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A dynamically-sized view into a contiguous sequence, `[T]`.\n//!\n//! Slices are a view into a block of memory represented as a pointer and a\n//! length.\n//!\n//! ```\n//! // slicing a Vec\n//! let vec = vec![1, 2, 3];\n//! let int_slice = &vec[..];\n//! // coercing an array to a slice\n//! let str_slice: &[&str] = &[\"one\", \"two\", \"three\"];\n//! ```\n//!\n//! Slices are either mutable or shared. The shared slice type is `&[T]`,\n//! while the mutable slice type is `&mut [T]`, where `T` represents the element\n//! type. For example, you can mutate the block of memory that a mutable slice\n//! points to:\n//!\n//! ```\n//! let x = &mut [1, 2, 3];\n//! x[1] = 7;\n//! assert_eq!(x, &[1, 7, 3]);\n//! ```\n//!\n//! Here are some of the things this module contains:\n//!\n//! ## Structs\n//!\n//! There are several structs that are useful for slices, such as [`Iter`], which\n//! represents iteration over a slice.\n//!\n//! ## Trait Implementations\n//!\n//! There are several implementations of common traits for slices. Some examples\n//! include:\n//!\n//! * [`Clone`]\n//! * [`Eq`], [`Ord`] - for slices whose element type are [`Eq`] or [`Ord`].\n//! * [`Hash`] - for slices whose element type is [`Hash`].\n//!\n//! ## Iteration\n//!\n//! The slices implement `IntoIterator`. The iterator yields references to the\n//! slice elements.\n//!\n//! ```\n//! let numbers = &[0, 1, 2];\n//! for n in numbers {\n//!     println!(\"{} is a number!\", n);\n//! }\n//! ```\n//!\n//! The mutable slice yields mutable references to the elements:\n//!\n//! ```\n//! let mut scores = [7, 8, 9];\n//! for score in &mut scores[..] {\n//!     *score += 1;\n//! }\n//! ```\n//!\n//! This iterator yields mutable references to the slice's elements, so while\n//! the element type of the slice is `i32`, the element type of the iterator is\n//! `&mut i32`.\n//!\n//! * [`.iter`] and [`.iter_mut`] are the explicit methods to return the default\n//!   iterators.\n//! * Further methods that return iterators are [`.split`], [`.splitn`],\n//!   [`.chunks`], [`.windows`] and more.\n//!\n//! *[See also the slice primitive type](../../std/primitive.slice.html).*\n//!\n//! [`Clone`]: ../../std/clone/trait.Clone.html\n//! [`Eq`]: ../../std/cmp/trait.Eq.html\n//! [`Ord`]: ../../std/cmp/trait.Ord.html\n//! [`Iter`]: struct.Iter.html\n//! [`Hash`]: ../../std/hash/trait.Hash.html\n//! [`.iter`]: ../../std/primitive.slice.html#method.iter\n//! [`.iter_mut`]: ../../std/primitive.slice.html#method.iter_mut\n//! [`.split`]: ../../std/primitive.slice.html#method.split\n//! [`.splitn`]: ../../std/primitive.slice.html#method.splitn\n//! [`.chunks`]: ../../std/primitive.slice.html#method.chunks\n//! [`.windows`]: ../../std/primitive.slice.html#method.windows\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n// Many of the usings in this module are only used in the test configuration.\n// It's cleaner to just turn off the unused_imports warning than to fix them.\n#![cfg_attr(test, allow(unused_imports, dead_code))]\n\nuse core::cmp::Ordering::{self, Less};\nuse core::mem::size_of;\nuse core::mem;\nuse core::ptr;\nuse core::slice as core_slice;\n\nuse borrow::{Borrow, BorrowMut, ToOwned};\nuse boxed::Box;\nuse vec::Vec;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{Chunks, Windows};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{Iter, IterMut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{SplitMut, ChunksMut, Split};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\npub use core::slice::{RSplit, RSplitMut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{from_raw_parts, from_raw_parts_mut};\n#[unstable(feature = \"from_ref\", issue = \"45703\")]\npub use core::slice::{from_ref, from_ref_mut};\n#[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\npub use core::slice::SliceIndex;\n#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\npub use core::slice::{ExactChunks, ExactChunksMut};\n\n////////////////////////////////////////////////////////////////////////////////\n// Basic slice extension methods\n////////////////////////////////////////////////////////////////////////////////\n\n// HACK(japaric) needed for the implementation of `vec!` macro during testing\n// NB see the hack module in this file for more details\n#[cfg(test)]\npub use self::hack::into_vec;\n\n// HACK(japaric) needed for the implementation of `Vec::clone` during testing\n// NB see the hack module in this file for more details\n#[cfg(test)]\npub use self::hack::to_vec;\n\n// HACK(japaric): With cfg(test) `impl [T]` is not available, these three\n// functions are actually methods that are in `impl [T]` but not in\n// `core::slice::SliceExt` - we need to supply these functions for the\n// `test_permutations` test\nmod hack {\n    use boxed::Box;\n    use core::mem;\n\n    #[cfg(test)]\n    use string::ToString;\n    use vec::Vec;\n\n    pub fn into_vec<T>(mut b: Box<[T]>) -> Vec<T> {\n        unsafe {\n            let xs = Vec::from_raw_parts(b.as_mut_ptr(), b.len(), b.len());\n            mem::forget(b);\n            xs\n        }\n    }\n\n    #[inline]\n    pub fn to_vec<T>(s: &[T]) -> Vec<T>\n        where T: Clone\n    {\n        let mut vector = Vec::with_capacity(s.len());\n        vector.extend_from_slice(s);\n        vector\n    }\n}\n\n#[lang = \"slice\"]\n#[cfg(not(test))]\nimpl<T> [T] {\n    /// Returns the number of elements in the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert_eq!(a.len(), 3);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn len(&self) -> usize {\n        core_slice::SliceExt::len(self)\n    }\n\n    /// Returns `true` if the slice has a length of 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert!(!a.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        core_slice::SliceExt::is_empty(self)\n    }\n\n    /// Returns the first element of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert_eq!(Some(&10), v.first());\n    ///\n    /// let w: &[i32] = &[];\n    /// assert_eq!(None, w.first());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn first(&self) -> Option<&T> {\n        core_slice::SliceExt::first(self)\n    }\n\n    /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some(first) = x.first_mut() {\n    ///     *first = 5;\n    /// }\n    /// assert_eq!(x, &[5, 1, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn first_mut(&mut self) -> Option<&mut T> {\n        core_slice::SliceExt::first_mut(self)\n    }\n\n    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[0, 1, 2];\n    ///\n    /// if let Some((first, elements)) = x.split_first() {\n    ///     assert_eq!(first, &0);\n    ///     assert_eq!(elements, &[1, 2]);\n    /// }\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[inline]\n    pub fn split_first(&self) -> Option<(&T, &[T])> {\n        core_slice::SliceExt::split_first(self)\n    }\n\n    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some((first, elements)) = x.split_first_mut() {\n    ///     *first = 3;\n    ///     elements[0] = 4;\n    ///     elements[1] = 5;\n    /// }\n    /// assert_eq!(x, &[3, 4, 5]);\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[inline]\n    pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n        core_slice::SliceExt::split_first_mut(self)\n    }\n\n    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[0, 1, 2];\n    ///\n    /// if let Some((last, elements)) = x.split_last() {\n    ///     assert_eq!(last, &2);\n    ///     assert_eq!(elements, &[0, 1]);\n    /// }\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[inline]\n    pub fn split_last(&self) -> Option<(&T, &[T])> {\n        core_slice::SliceExt::split_last(self)\n\n    }\n\n    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some((last, elements)) = x.split_last_mut() {\n    ///     *last = 3;\n    ///     elements[0] = 4;\n    ///     elements[1] = 5;\n    /// }\n    /// assert_eq!(x, &[4, 5, 3]);\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[inline]\n    pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n        core_slice::SliceExt::split_last_mut(self)\n    }\n\n    /// Returns the last element of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert_eq!(Some(&30), v.last());\n    ///\n    /// let w: &[i32] = &[];\n    /// assert_eq!(None, w.last());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn last(&self) -> Option<&T> {\n        core_slice::SliceExt::last(self)\n    }\n\n    /// Returns a mutable pointer to the last item in the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some(last) = x.last_mut() {\n    ///     *last = 10;\n    /// }\n    /// assert_eq!(x, &[0, 1, 10]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn last_mut(&mut self) -> Option<&mut T> {\n        core_slice::SliceExt::last_mut(self)\n    }\n\n    /// Returns a reference to an element or subslice depending on the type of\n    /// index.\n    ///\n    /// - If given a position, returns a reference to the element at that\n    ///   position or `None` if out of bounds.\n    /// - If given a range, returns the subslice corresponding to that range,\n    ///   or `None` if out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert_eq!(Some(&40), v.get(1));\n    /// assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n    /// assert_eq!(None, v.get(3));\n    /// assert_eq!(None, v.get(0..4));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn get<I>(&self, index: I) -> Option<&I::Output>\n        where I: SliceIndex<Self>\n    {\n        core_slice::SliceExt::get(self, index)\n    }\n\n    /// Returns a mutable reference to an element or subslice depending on the\n    /// type of index (see [`get`]) or `None` if the index is out of bounds.\n    ///\n    /// [`get`]: #method.get\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some(elem) = x.get_mut(1) {\n    ///     *elem = 42;\n    /// }\n    /// assert_eq!(x, &[0, 42, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n        where I: SliceIndex<Self>\n    {\n        core_slice::SliceExt::get_mut(self, index)\n    }\n\n    /// Returns a reference to an element or subslice, without doing bounds\n    /// checking.\n    ///\n    /// This is generally not recommended, use with caution! For a safe\n    /// alternative see [`get`].\n    ///\n    /// [`get`]: #method.get\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[1, 2, 4];\n    ///\n    /// unsafe {\n    ///     assert_eq!(x.get_unchecked(1), &2);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n        where I: SliceIndex<Self>\n    {\n        core_slice::SliceExt::get_unchecked(self, index)\n    }\n\n    /// Returns a mutable reference to an element or subslice, without doing\n    /// bounds checking.\n    ///\n    /// This is generally not recommended, use with caution! For a safe\n    /// alternative see [`get_mut`].\n    ///\n    /// [`get_mut`]: #method.get_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [1, 2, 4];\n    ///\n    /// unsafe {\n    ///     let elem = x.get_unchecked_mut(1);\n    ///     *elem = 13;\n    /// }\n    /// assert_eq!(x, &[1, 13, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n        where I: SliceIndex<Self>\n    {\n        core_slice::SliceExt::get_unchecked_mut(self, index)\n    }\n\n    /// Returns a raw pointer to the slice's buffer.\n    ///\n    /// The caller must ensure that the slice outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    ///\n    /// Modifying the container referenced by this slice may cause its buffer\n    /// to be reallocated, which would also make any pointers to it invalid.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[1, 2, 4];\n    /// let x_ptr = x.as_ptr();\n    ///\n    /// unsafe {\n    ///     for i in 0..x.len() {\n    ///         assert_eq!(x.get_unchecked(i), &*x_ptr.offset(i as isize));\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn as_ptr(&self) -> *const T {\n        core_slice::SliceExt::as_ptr(self)\n    }\n\n    /// Returns an unsafe mutable pointer to the slice's buffer.\n    ///\n    /// The caller must ensure that the slice outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    ///\n    /// Modifying the container referenced by this slice may cause its buffer\n    /// to be reallocated, which would also make any pointers to it invalid.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [1, 2, 4];\n    /// let x_ptr = x.as_mut_ptr();\n    ///\n    /// unsafe {\n    ///     for i in 0..x.len() {\n    ///         *x_ptr.offset(i as isize) += 2;\n    ///     }\n    /// }\n    /// assert_eq!(x, &[3, 4, 6]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn as_mut_ptr(&mut self) -> *mut T {\n        core_slice::SliceExt::as_mut_ptr(self)\n    }\n\n    /// Swaps two elements in the slice.\n    ///\n    /// # Arguments\n    ///\n    /// * a - The index of the first element\n    /// * b - The index of the second element\n    ///\n    /// # Panics\n    ///\n    /// Panics if `a` or `b` are out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n    /// v.swap(1, 3);\n    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn swap(&mut self, a: usize, b: usize) {\n        core_slice::SliceExt::swap(self, a, b)\n    }\n\n    /// Reverses the order of elements in the slice, in place.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [1, 2, 3];\n    /// v.reverse();\n    /// assert!(v == [3, 2, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn reverse(&mut self) {\n        core_slice::SliceExt::reverse(self)\n    }\n\n    /// Returns an iterator over the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[1, 2, 4];\n    /// let mut iterator = x.iter();\n    ///\n    /// assert_eq!(iterator.next(), Some(&1));\n    /// assert_eq!(iterator.next(), Some(&2));\n    /// assert_eq!(iterator.next(), Some(&4));\n    /// assert_eq!(iterator.next(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn iter(&self) -> Iter<T> {\n        core_slice::SliceExt::iter(self)\n    }\n\n    /// Returns an iterator that allows modifying each value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [1, 2, 4];\n    /// for elem in x.iter_mut() {\n    ///     *elem += 2;\n    /// }\n    /// assert_eq!(x, &[3, 4, 6]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        core_slice::SliceExt::iter_mut(self)\n    }\n\n    /// Returns an iterator over all contiguous windows of length\n    /// `size`. The windows overlap. If the slice is shorter than\n    /// `size`, the iterator returns no values.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = ['r', 'u', 's', 't'];\n    /// let mut iter = slice.windows(2);\n    /// assert_eq!(iter.next().unwrap(), &['r', 'u']);\n    /// assert_eq!(iter.next().unwrap(), &['u', 's']);\n    /// assert_eq!(iter.next().unwrap(), &['s', 't']);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If the slice is shorter than `size`:\n    ///\n    /// ```\n    /// let slice = ['f', 'o', 'o'];\n    /// let mut iter = slice.windows(4);\n    /// assert!(iter.next().is_none());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn windows(&self, size: usize) -> Windows<T> {\n        core_slice::SliceExt::windows(self, size)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a\n    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n    /// not divide the length of the slice, then the last chunk will\n    /// not have length `chunk_size`.\n    ///\n    /// See [`exact_chunks`] for a variant of this iterator that returns chunks\n    /// of always exactly `chunk_size` elements.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let mut iter = slice.chunks(2);\n    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n    /// assert_eq!(iter.next().unwrap(), &['m']);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// [`exact_chunks`]: #method.exact_chunks\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n        core_slice::SliceExt::chunks(self, chunk_size)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a\n    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n    /// not divide the length of the slice, then the last up to `chunk_size-1`\n    /// elements will be omitted.\n    ///\n    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n    /// can often optimize the resulting code better than in the case of\n    /// [`chunks`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(exact_chunks)]\n    ///\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let mut iter = slice.exact_chunks(2);\n    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// [`chunks`]: #method.chunks\n    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n    #[inline]\n    pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n        core_slice::SliceExt::exact_chunks(self, chunk_size)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n    /// not divide the length of the slice, then the last chunk will not\n    /// have length `chunk_size`.\n    ///\n    /// See [`exact_chunks_mut`] for a variant of this iterator that returns chunks\n    /// of always exactly `chunk_size` elements.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// for chunk in v.chunks_mut(2) {\n    ///     for elem in chunk.iter_mut() {\n    ///         *elem += count;\n    ///     }\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n    /// ```\n    ///\n    /// [`exact_chunks_mut`]: #method.exact_chunks_mut\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n        core_slice::SliceExt::chunks_mut(self, chunk_size)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n    /// not divide the length of the slice, then the last up to `chunk_size-1`\n    /// elements will be omitted.\n    ///\n    ///\n    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n    /// can often optimize the resulting code better than in the case of\n    /// [`chunks_mut`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(exact_chunks)]\n    ///\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// for chunk in v.exact_chunks_mut(2) {\n    ///     for elem in chunk.iter_mut() {\n    ///         *elem += count;\n    ///     }\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n    /// ```\n    ///\n    /// [`chunks_mut`]: #method.chunks_mut\n    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n    #[inline]\n    pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n        core_slice::SliceExt::exact_chunks_mut(self, chunk_size)\n    }\n\n    /// Divides one slice into two at an index.\n    ///\n    /// The first will contain all indices from `[0, mid)` (excluding\n    /// the index `mid` itself) and the second will contain all\n    /// indices from `[mid, len)` (excluding the index `len` itself).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `mid > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [1, 2, 3, 4, 5, 6];\n    ///\n    /// {\n    ///    let (left, right) = v.split_at(0);\n    ///    assert!(left == []);\n    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n    /// }\n    ///\n    /// {\n    ///     let (left, right) = v.split_at(2);\n    ///     assert!(left == [1, 2]);\n    ///     assert!(right == [3, 4, 5, 6]);\n    /// }\n    ///\n    /// {\n    ///     let (left, right) = v.split_at(6);\n    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n    ///     assert!(right == []);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        core_slice::SliceExt::split_at(self, mid)\n    }\n\n    /// Divides one mutable slice into two at an index.\n    ///\n    /// The first will contain all indices from `[0, mid)` (excluding\n    /// the index `mid` itself) and the second will contain all\n    /// indices from `[mid, len)` (excluding the index `len` itself).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `mid > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [1, 0, 3, 0, 5, 6];\n    /// // scoped to restrict the lifetime of the borrows\n    /// {\n    ///     let (left, right) = v.split_at_mut(2);\n    ///     assert!(left == [1, 0]);\n    ///     assert!(right == [3, 0, 5, 6]);\n    ///     left[1] = 2;\n    ///     right[1] = 4;\n    /// }\n    /// assert!(v == [1, 2, 3, 4, 5, 6]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n        core_slice::SliceExt::split_at_mut(self, mid)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`. The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = [10, 40, 33, 20];\n    /// let mut iter = slice.split(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n    /// assert_eq!(iter.next().unwrap(), &[20]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If the first element is matched, an empty slice will be the first item\n    /// returned by the iterator. Similarly, if the last element in the slice\n    /// is matched, an empty slice will be the last item returned by the\n    /// iterator:\n    ///\n    /// ```\n    /// let slice = [10, 40, 33];\n    /// let mut iter = slice.split(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n    /// assert_eq!(iter.next().unwrap(), &[]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If two matched elements are directly adjacent, an empty slice will be\n    /// present between them:\n    ///\n    /// ```\n    /// let slice = [10, 6, 33, 20];\n    /// let mut iter = slice.split(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10]);\n    /// assert_eq!(iter.next().unwrap(), &[]);\n    /// assert_eq!(iter.next().unwrap(), &[20]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split<F>(&self, pred: F) -> Split<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::split(self, pred)\n    }\n\n    /// Returns an iterator over mutable subslices separated by elements that\n    /// match `pred`. The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.split_mut(|num| *num % 3 == 0) {\n    ///     group[0] = 1;\n    /// }\n    /// assert_eq!(v, [1, 40, 30, 1, 60, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::split_mut(self, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`, starting at the end of the slice and working backwards.\n    /// The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_rsplit)]\n    ///\n    /// let slice = [11, 22, 33, 0, 44, 55];\n    /// let mut iter = slice.rsplit(|num| *num == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[44, 55]);\n    /// assert_eq!(iter.next().unwrap(), &[11, 22, 33]);\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// As with `split()`, if the first or last element is matched, an empty\n    /// slice will be the first (or last) item returned by the iterator.\n    ///\n    /// ```\n    /// #![feature(slice_rsplit)]\n    ///\n    /// let v = &[0, 1, 1, 2, 3, 5, 8];\n    /// let mut it = v.rsplit(|n| *n % 2 == 0);\n    /// assert_eq!(it.next().unwrap(), &[]);\n    /// assert_eq!(it.next().unwrap(), &[3, 5]);\n    /// assert_eq!(it.next().unwrap(), &[1, 1]);\n    /// assert_eq!(it.next().unwrap(), &[]);\n    /// assert_eq!(it.next(), None);\n    /// ```\n    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n    #[inline]\n    pub fn rsplit<F>(&self, pred: F) -> RSplit<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::rsplit(self, pred)\n    }\n\n    /// Returns an iterator over mutable subslices separated by elements that\n    /// match `pred`, starting at the end of the slice and working\n    /// backwards. The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_rsplit)]\n    ///\n    /// let mut v = [100, 400, 300, 200, 600, 500];\n    ///\n    /// let mut count = 0;\n    /// for group in v.rsplit_mut(|num| *num % 3 == 0) {\n    ///     count += 1;\n    ///     group[0] = count;\n    /// }\n    /// assert_eq!(v, [3, 400, 300, 2, 600, 1]);\n    /// ```\n    ///\n    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n    #[inline]\n    pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::rsplit_mut(self, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`, limited to returning at most `n` items. The matched element is\n    /// not contained in the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n    /// `[20, 60, 50]`):\n    ///\n    /// ```\n    /// let v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.splitn(2, |num| *num % 3 == 0) {\n    ///     println!(\"{:?}\", group);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::splitn(self, n, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`, limited to returning at most `n` items. The matched element is\n    /// not contained in the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.splitn_mut(2, |num| *num % 3 == 0) {\n    ///     group[0] = 1;\n    /// }\n    /// assert_eq!(v, [1, 40, 30, 1, 60, 50]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::splitn_mut(self, n, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred` limited to returning at most `n` items. This starts at the end of\n    /// the slice and works backwards.  The matched element is not contained in\n    /// the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// Print the slice split once, starting from the end, by numbers divisible\n    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n    ///\n    /// ```\n    /// let v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n    ///     println!(\"{:?}\", group);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::rsplitn(self, n, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred` limited to returning at most `n` items. This starts at the end of\n    /// the slice and works backwards. The matched element is not contained in\n    /// the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut s = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in s.rsplitn_mut(2, |num| *num % 3 == 0) {\n    ///     group[0] = 1;\n    /// }\n    /// assert_eq!(s, [1, 40, 30, 20, 60, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<T, F>\n        where F: FnMut(&T) -> bool\n    {\n        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n    }\n\n    /// Returns `true` if the slice contains an element with the given value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert!(v.contains(&30));\n    /// assert!(!v.contains(&50));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn contains(&self, x: &T) -> bool\n        where T: PartialEq\n    {\n        core_slice::SliceExt::contains(self, x)\n    }\n\n    /// Returns `true` if `needle` is a prefix of the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert!(v.starts_with(&[10]));\n    /// assert!(v.starts_with(&[10, 40]));\n    /// assert!(!v.starts_with(&[50]));\n    /// assert!(!v.starts_with(&[10, 50]));\n    /// ```\n    ///\n    /// Always returns `true` if `needle` is an empty slice:\n    ///\n    /// ```\n    /// let v = &[10, 40, 30];\n    /// assert!(v.starts_with(&[]));\n    /// let v: &[u8] = &[];\n    /// assert!(v.starts_with(&[]));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn starts_with(&self, needle: &[T]) -> bool\n        where T: PartialEq\n    {\n        core_slice::SliceExt::starts_with(self, needle)\n    }\n\n    /// Returns `true` if `needle` is a suffix of the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert!(v.ends_with(&[30]));\n    /// assert!(v.ends_with(&[40, 30]));\n    /// assert!(!v.ends_with(&[50]));\n    /// assert!(!v.ends_with(&[50, 30]));\n    /// ```\n    ///\n    /// Always returns `true` if `needle` is an empty slice:\n    ///\n    /// ```\n    /// let v = &[10, 40, 30];\n    /// assert!(v.ends_with(&[]));\n    /// let v: &[u8] = &[];\n    /// assert!(v.ends_with(&[]));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ends_with(&self, needle: &[T]) -> bool\n        where T: PartialEq\n    {\n        core_slice::SliceExt::ends_with(self, needle)\n    }\n\n    /// Binary searches this sorted slice for a given element.\n    ///\n    /// If the value is found then `Ok` is returned, containing the\n    /// index of the matching element; if the value is not found then\n    /// `Err` is returned, containing the index where a matching\n    /// element could be inserted while maintaining sorted order.\n    ///\n    /// # Examples\n    ///\n    /// Looks up a series of four elements. The first is found, with a\n    /// uniquely determined position; the second and third are not\n    /// found; the fourth could match any position in `[1, 4]`.\n    ///\n    /// ```\n    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n    ///\n    /// assert_eq!(s.binary_search(&13),  Ok(9));\n    /// assert_eq!(s.binary_search(&4),   Err(7));\n    /// assert_eq!(s.binary_search(&100), Err(13));\n    /// let r = s.binary_search(&1);\n    /// assert!(match r { Ok(1...4) => true, _ => false, });\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n        where T: Ord\n    {\n        core_slice::SliceExt::binary_search(self, x)\n    }\n\n    /// Binary searches this sorted slice with a comparator function.\n    ///\n    /// The comparator function should implement an order consistent\n    /// with the sort order of the underlying slice, returning an\n    /// order code that indicates whether its argument is `Less`,\n    /// `Equal` or `Greater` the desired target.\n    ///\n    /// If a matching value is found then returns `Ok`, containing\n    /// the index for the matched element; if no match is found then\n    /// `Err` is returned, containing the index where a matching\n    /// element could be inserted while maintaining sorted order.\n    ///\n    /// # Examples\n    ///\n    /// Looks up a series of four elements. The first is found, with a\n    /// uniquely determined position; the second and third are not\n    /// found; the fourth could match any position in `[1, 4]`.\n    ///\n    /// ```\n    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n    ///\n    /// let seek = 13;\n    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n    /// let seek = 4;\n    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n    /// let seek = 100;\n    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n    /// let seek = 1;\n    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n    /// assert!(match r { Ok(1...4) => true, _ => false, });\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n        where F: FnMut(&'a T) -> Ordering\n    {\n        core_slice::SliceExt::binary_search_by(self, f)\n    }\n\n    /// Binary searches this sorted slice with a key extraction function.\n    ///\n    /// Assumes that the slice is sorted by the key, for instance with\n    /// [`sort_by_key`] using the same key extraction function.\n    ///\n    /// If a matching value is found then returns `Ok`, containing the\n    /// index for the matched element; if no match is found then `Err`\n    /// is returned, containing the index where a matching element could\n    /// be inserted while maintaining sorted order.\n    ///\n    /// [`sort_by_key`]: #method.sort_by_key\n    ///\n    /// # Examples\n    ///\n    /// Looks up a series of four elements in a slice of pairs sorted by\n    /// their second elements. The first is found, with a uniquely\n    /// determined position; the second and third are not found; the\n    /// fourth could match any position in `[1, 4]`.\n    ///\n    /// ```\n    /// let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n    ///          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n    ///          (1, 21), (2, 34), (4, 55)];\n    ///\n    /// assert_eq!(s.binary_search_by_key(&13, |&(a,b)| b),  Ok(9));\n    /// assert_eq!(s.binary_search_by_key(&4, |&(a,b)| b),   Err(7));\n    /// assert_eq!(s.binary_search_by_key(&100, |&(a,b)| b), Err(13));\n    /// let r = s.binary_search_by_key(&1, |&(a,b)| b);\n    /// assert!(match r { Ok(1...4) => true, _ => false, });\n    /// ```\n    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n    #[inline]\n    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n        where F: FnMut(&'a T) -> B,\n              B: Ord\n    {\n        core_slice::SliceExt::binary_search_by_key(self, b, f)\n    }\n\n    /// Sorts the slice.\n    ///\n    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n    ///\n    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n    /// sorting and it doesn't allocate auxiliary memory.\n    /// See [`sort_unstable`](#method.sort_unstable).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is an adaptive, iterative merge sort inspired by\n    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n    /// two or more sorted sequences concatenated one after another.\n    ///\n    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n    /// non-allocating insertion sort is used instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5, 4, 1, -3, 2];\n    ///\n    /// v.sort();\n    /// assert!(v == [-5, -3, 1, 2, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sort(&mut self)\n        where T: Ord\n    {\n        merge_sort(self, |a, b| a.lt(b));\n    }\n\n    /// Sorts the slice with a comparator function.\n    ///\n    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n    ///\n    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n    /// sorting and it doesn't allocate auxiliary memory.\n    /// See [`sort_unstable_by`](#method.sort_unstable_by).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is an adaptive, iterative merge sort inspired by\n    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n    /// two or more sorted sequences concatenated one after another.\n    ///\n    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n    /// non-allocating insertion sort is used instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [5, 4, 1, 3, 2];\n    /// v.sort_by(|a, b| a.cmp(b));\n    /// assert!(v == [1, 2, 3, 4, 5]);\n    ///\n    /// // reverse sorting\n    /// v.sort_by(|a, b| b.cmp(a));\n    /// assert!(v == [5, 4, 3, 2, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sort_by<F>(&mut self, mut compare: F)\n        where F: FnMut(&T, &T) -> Ordering\n    {\n        merge_sort(self, |a, b| compare(a, b) == Less);\n    }\n\n    /// Sorts the slice with a key extraction function.\n    ///\n    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n    ///\n    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n    /// sorting and it doesn't allocate auxiliary memory.\n    /// See [`sort_unstable_by_key`](#method.sort_unstable_by_key).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is an adaptive, iterative merge sort inspired by\n    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n    /// two or more sorted sequences concatenated one after another.\n    ///\n    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n    /// non-allocating insertion sort is used instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// v.sort_by_key(|k| k.abs());\n    /// assert!(v == [1, 2, -3, 4, -5]);\n    /// ```\n    #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n    #[inline]\n    pub fn sort_by_key<B, F>(&mut self, mut f: F)\n        where F: FnMut(&T) -> B, B: Ord\n    {\n        merge_sort(self, |a, b| f(a).lt(&f(b)));\n    }\n\n    /// Sorts the slice, but may not preserve the order of equal elements.\n    ///\n    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n    /// and `O(n log n)` worst-case.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n    /// which combines the fast average case of randomized quicksort with the fast worst case of\n    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n    /// deterministic behavior.\n    ///\n    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n    /// slice consists of several concatenated sorted sequences.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5, 4, 1, -3, 2];\n    ///\n    /// v.sort_unstable();\n    /// assert!(v == [-5, -3, 1, 2, 4]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    #[inline]\n    pub fn sort_unstable(&mut self)\n        where T: Ord\n    {\n        core_slice::SliceExt::sort_unstable(self);\n    }\n\n    /// Sorts the slice with a comparator function, but may not preserve the order of equal\n    /// elements.\n    ///\n    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n    /// and `O(n log n)` worst-case.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n    /// which combines the fast average case of randomized quicksort with the fast worst case of\n    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n    /// deterministic behavior.\n    ///\n    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n    /// slice consists of several concatenated sorted sequences.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [5, 4, 1, 3, 2];\n    /// v.sort_unstable_by(|a, b| a.cmp(b));\n    /// assert!(v == [1, 2, 3, 4, 5]);\n    ///\n    /// // reverse sorting\n    /// v.sort_unstable_by(|a, b| b.cmp(a));\n    /// assert!(v == [5, 4, 3, 2, 1]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    #[inline]\n    pub fn sort_unstable_by<F>(&mut self, compare: F)\n        where F: FnMut(&T, &T) -> Ordering\n    {\n        core_slice::SliceExt::sort_unstable_by(self, compare);\n    }\n\n    /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n    /// elements.\n    ///\n    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n    /// and `O(n log n)` worst-case.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n    /// which combines the fast average case of randomized quicksort with the fast worst case of\n    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n    /// deterministic behavior.\n    ///\n    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n    /// slice consists of several concatenated sorted sequences.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// v.sort_unstable_by_key(|k| k.abs());\n    /// assert!(v == [1, 2, -3, 4, -5]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    #[inline]\n    pub fn sort_unstable_by_key<B, F>(&mut self, f: F)\n        where F: FnMut(&T) -> B,\n              B: Ord\n    {\n        core_slice::SliceExt::sort_unstable_by_key(self, f);\n    }\n\n    /// Rotates the slice in-place such that the first `mid` elements of the\n    /// slice move to the end while the last `self.len() - mid` elements move to\n    /// the front. After calling `rotate_left`, the element previously at index\n    /// `mid` will become the first element in the slice.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if `mid` is greater than the length of the\n    /// slice. Note that `mid == self.len()` does _not_ panic and is a no-op\n    /// rotation.\n    ///\n    /// # Complexity\n    ///\n    /// Takes linear (in `self.len()`) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_rotate)]\n    ///\n    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n    /// a.rotate_left(2);\n    /// assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n    /// ```\n    ///\n    /// Rotating a subslice:\n    ///\n    /// ```\n    /// #![feature(slice_rotate)]\n    ///\n    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n    /// a[1..5].rotate_left(1);\n    /// assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n    /// ```\n    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n    pub fn rotate_left(&mut self, mid: usize) {\n        core_slice::SliceExt::rotate_left(self, mid);\n    }\n\n    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n    #[rustc_deprecated(since = \"\", reason = \"renamed to `rotate_left`\")]\n    pub fn rotate(&mut self, mid: usize) {\n        core_slice::SliceExt::rotate_left(self, mid);\n    }\n\n    /// Rotates the slice in-place such that the first `self.len() - k`\n    /// elements of the slice move to the end while the last `k` elements move\n    /// to the front. After calling `rotate_right`, the element previously at\n    /// index `self.len() - k` will become the first element in the slice.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if `k` is greater than the length of the\n    /// slice. Note that `k == self.len()` does _not_ panic and is a no-op\n    /// rotation.\n    ///\n    /// # Complexity\n    ///\n    /// Takes linear (in `self.len()`) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_rotate)]\n    ///\n    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n    /// a.rotate_right(2);\n    /// assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);\n    /// ```\n    ///\n    /// Rotate a subslice:\n    ///\n    /// ```\n    /// #![feature(slice_rotate)]\n    ///\n    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n    /// a[1..5].rotate_right(1);\n    /// assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);\n    /// ```\n    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n    pub fn rotate_right(&mut self, k: usize) {\n        core_slice::SliceExt::rotate_right(self, k);\n    }\n\n    /// Copies the elements from `src` into `self`.\n    ///\n    /// The length of `src` must be the same as `self`.\n    ///\n    /// If `src` implements `Copy`, it can be more performant to use\n    /// [`copy_from_slice`].\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Examples\n    ///\n    /// Cloning two elements from a slice into another:\n    ///\n    /// ```\n    /// let src = [1, 2, 3, 4];\n    /// let mut dst = [0, 0];\n    ///\n    /// dst.clone_from_slice(&src[2..]);\n    ///\n    /// assert_eq!(src, [1, 2, 3, 4]);\n    /// assert_eq!(dst, [3, 4]);\n    /// ```\n    ///\n    /// Rust enforces that there can only be one mutable reference with no\n    /// immutable references to a particular piece of data in a particular\n    /// scope. Because of this, attempting to use `clone_from_slice` on a\n    /// single slice will result in a compile failure:\n    ///\n    /// ```compile_fail\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// slice[..2].clone_from_slice(&slice[3..]); // compile fail!\n    /// ```\n    ///\n    /// To work around this, we can use [`split_at_mut`] to create two distinct\n    /// sub-slices from a slice:\n    ///\n    /// ```\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// {\n    ///     let (left, right) = slice.split_at_mut(2);\n    ///     left.clone_from_slice(&right[1..]);\n    /// }\n    ///\n    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n    /// ```\n    ///\n    /// [`copy_from_slice`]: #method.copy_from_slice\n    /// [`split_at_mut`]: #method.split_at_mut\n    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n    pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n        core_slice::SliceExt::clone_from_slice(self, src)\n    }\n\n    /// Copies all elements from `src` into `self`, using a memcpy.\n    ///\n    /// The length of `src` must be the same as `self`.\n    ///\n    /// If `src` does not implement `Copy`, use [`clone_from_slice`].\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Examples\n    ///\n    /// Copying two elements from a slice into another:\n    ///\n    /// ```\n    /// let src = [1, 2, 3, 4];\n    /// let mut dst = [0, 0];\n    ///\n    /// dst.copy_from_slice(&src[2..]);\n    ///\n    /// assert_eq!(src, [1, 2, 3, 4]);\n    /// assert_eq!(dst, [3, 4]);\n    /// ```\n    ///\n    /// Rust enforces that there can only be one mutable reference with no\n    /// immutable references to a particular piece of data in a particular\n    /// scope. Because of this, attempting to use `copy_from_slice` on a\n    /// single slice will result in a compile failure:\n    ///\n    /// ```compile_fail\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// slice[..2].copy_from_slice(&slice[3..]); // compile fail!\n    /// ```\n    ///\n    /// To work around this, we can use [`split_at_mut`] to create two distinct\n    /// sub-slices from a slice:\n    ///\n    /// ```\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// {\n    ///     let (left, right) = slice.split_at_mut(2);\n    ///     left.copy_from_slice(&right[1..]);\n    /// }\n    ///\n    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n    /// ```\n    ///\n    /// [`clone_from_slice`]: #method.clone_from_slice\n    /// [`split_at_mut`]: #method.split_at_mut\n    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n    pub fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n        core_slice::SliceExt::copy_from_slice(self, src)\n    }\n\n    /// Swaps all elements in `self` with those in `other`.\n    ///\n    /// The length of `other` must be the same as `self`.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Example\n    ///\n    /// Swapping two elements across slices:\n    ///\n    /// ```\n    /// #![feature(swap_with_slice)]\n    ///\n    /// let mut slice1 = [0, 0];\n    /// let mut slice2 = [1, 2, 3, 4];\n    ///\n    /// slice1.swap_with_slice(&mut slice2[2..]);\n    ///\n    /// assert_eq!(slice1, [3, 4]);\n    /// assert_eq!(slice2, [1, 2, 0, 0]);\n    /// ```\n    ///\n    /// Rust enforces that there can only be one mutable reference to a\n    /// particular piece of data in a particular scope. Because of this,\n    /// attempting to use `swap_with_slice` on a single slice will result in\n    /// a compile failure:\n    ///\n    /// ```compile_fail\n    /// #![feature(swap_with_slice)]\n    ///\n    /// let mut slice = [1, 2, 3, 4, 5];\n    /// slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!\n    /// ```\n    ///\n    /// To work around this, we can use [`split_at_mut`] to create two distinct\n    /// mutable sub-slices from a slice:\n    ///\n    /// ```\n    /// #![feature(swap_with_slice)]\n    ///\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// {\n    ///     let (left, right) = slice.split_at_mut(2);\n    ///     left.swap_with_slice(&mut right[1..]);\n    /// }\n    ///\n    /// assert_eq!(slice, [4, 5, 3, 1, 2]);\n    /// ```\n    ///\n    /// [`split_at_mut`]: #method.split_at_mut\n    #[unstable(feature = \"swap_with_slice\", issue = \"44030\")]\n    pub fn swap_with_slice(&mut self, other: &mut [T]) {\n        core_slice::SliceExt::swap_with_slice(self, other)\n    }\n\n    /// Copies `self` into a new `Vec`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s = [10, 40, 30];\n    /// let x = s.to_vec();\n    /// // Here, `s` and `x` can be modified independently.\n    /// ```\n    #[rustc_conversion_suggestion]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_vec(&self) -> Vec<T>\n        where T: Clone\n    {\n        // NB see hack module in this file\n        hack::to_vec(self)\n    }\n\n    /// Converts `self` into a vector without clones or allocation.\n    ///\n    /// The resulting vector can be converted back into a box via\n    /// `Vec<T>`'s `into_boxed_slice` method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s: Box<[i32]> = Box::new([10, 40, 30]);\n    /// let x = s.into_vec();\n    /// // `s` cannot be used anymore because it has been converted into `x`.\n    ///\n    /// assert_eq!(x, vec![10, 40, 30]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn into_vec(self: Box<Self>) -> Vec<T> {\n        // NB see hack module in this file\n        hack::into_vec(self)\n    }\n}\n\n#[lang = \"slice_u8\"]\n#[cfg(not(test))]\nimpl [u8] {\n    /// Checks if all bytes in this slice are within the ASCII range.\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn is_ascii(&self) -> bool {\n        self.iter().all(|b| b.is_ascii())\n    }\n\n    /// Returns a vector containing a copy of this slice where each byte\n    /// is mapped to its ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n    ///\n    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_uppercase(&self) -> Vec<u8> {\n        let mut me = self.to_vec();\n        me.make_ascii_uppercase();\n        me\n    }\n\n    /// Returns a vector containing a copy of this slice where each byte\n    /// is mapped to its ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n    ///\n    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_lowercase(&self) -> Vec<u8> {\n        let mut me = self.to_vec();\n        me.make_ascii_lowercase();\n        me\n    }\n\n    /// Checks that two slices are an ASCII case-insensitive match.\n    ///\n    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n    /// but without allocating and copying temporaries.\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n        self.len() == other.len() &&\n            self.iter().zip(other).all(|(a, b)| {\n                a.eq_ignore_ascii_case(b)\n            })\n    }\n\n    /// Converts this slice to its ASCII upper case equivalent in-place.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new uppercased value without modifying the existing one, use\n    /// [`to_ascii_uppercase`].\n    ///\n    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n        for byte in self {\n            byte.make_ascii_uppercase();\n        }\n    }\n\n    /// Converts this slice to its ASCII lower case equivalent in-place.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new lowercased value without modifying the existing one, use\n    /// [`to_ascii_lowercase`].\n    ///\n    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n        for byte in self {\n            byte.make_ascii_lowercase();\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Extension traits for slices over specific kinds of data\n////////////////////////////////////////////////////////////////////////////////\n#[unstable(feature = \"slice_concat_ext\",\n           reason = \"trait should not have to exist\",\n           issue = \"27747\")]\n/// An extension trait for concatenating slices\n///\n/// While this trait is unstable, the methods are stable. `SliceConcatExt` is\n/// included in the [standard library prelude], so you can use [`join()`] and\n/// [`concat()`] as if they existed on `[T]` itself.\n///\n/// [standard library prelude]: ../../std/prelude/index.html\n/// [`join()`]: #tymethod.join\n/// [`concat()`]: #tymethod.concat\npub trait SliceConcatExt<T: ?Sized> {\n    #[unstable(feature = \"slice_concat_ext\",\n               reason = \"trait should not have to exist\",\n               issue = \"27747\")]\n    /// The resulting type after concatenation\n    type Output;\n\n    /// Flattens a slice of `T` into a single value `Self::Output`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n    /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn concat(&self) -> Self::Output;\n\n    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n    /// given separator between each.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n    /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n    /// ```\n    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n    fn join(&self, sep: &T) -> Self::Output;\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n    fn connect(&self, sep: &T) -> Self::Output;\n}\n\n#[unstable(feature = \"slice_concat_ext\",\n           reason = \"trait should not have to exist\",\n           issue = \"27747\")]\nimpl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n    type Output = Vec<T>;\n\n    fn concat(&self) -> Vec<T> {\n        let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n        let mut result = Vec::with_capacity(size);\n        for v in self {\n            result.extend_from_slice(v.borrow())\n        }\n        result\n    }\n\n    fn join(&self, sep: &T) -> Vec<T> {\n        let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n        let mut result = Vec::with_capacity(size + self.len());\n        let mut first = true;\n        for v in self {\n            if first {\n                first = false\n            } else {\n                result.push(sep.clone())\n            }\n            result.extend_from_slice(v.borrow())\n        }\n        result\n    }\n\n    fn connect(&self, sep: &T) -> Vec<T> {\n        self.join(sep)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Standard trait implementations for slices\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Borrow<[T]> for Vec<T> {\n    fn borrow(&self) -> &[T] {\n        &self[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> BorrowMut<[T]> for Vec<T> {\n    fn borrow_mut(&mut self) -> &mut [T] {\n        &mut self[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> ToOwned for [T] {\n    type Owned = Vec<T>;\n    #[cfg(not(test))]\n    fn to_owned(&self) -> Vec<T> {\n        self.to_vec()\n    }\n\n    #[cfg(test)]\n    fn to_owned(&self) -> Vec<T> {\n        hack::to_vec(self)\n    }\n\n    fn clone_into(&self, target: &mut Vec<T>) {\n        // drop anything in target that will not be overwritten\n        target.truncate(self.len());\n        let len = target.len();\n\n        // reuse the contained values' allocations/resources.\n        target.clone_from_slice(&self[..len]);\n\n        // target.len <= self.len due to the truncate above, so the\n        // slice here is always in-bounds.\n        target.extend_from_slice(&self[len..]);\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Sorting\n////////////////////////////////////////////////////////////////////////////////\n\n/// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n///\n/// This is the integral subroutine of insertion sort.\nfn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n    where F: FnMut(&T, &T) -> bool\n{\n    if v.len() >= 2 && is_less(&v[1], &v[0]) {\n        unsafe {\n            // There are three ways to implement insertion here:\n            //\n            // 1. Swap adjacent elements until the first one gets to its final destination.\n            //    However, this way we copy data around more than is necessary. If elements are big\n            //    structures (costly to copy), this method will be slow.\n            //\n            // 2. Iterate until the right place for the first element is found. Then shift the\n            //    elements succeeding it to make room for it and finally place it into the\n            //    remaining hole. This is a good method.\n            //\n            // 3. Copy the first element into a temporary variable. Iterate until the right place\n            //    for it is found. As we go along, copy every traversed element into the slot\n            //    preceding it. Finally, copy data from the temporary variable into the remaining\n            //    hole. This method is very good. Benchmarks demonstrated slightly better\n            //    performance than with the 2nd method.\n            //\n            // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n            let mut tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n\n            // Intermediate state of the insertion process is always tracked by `hole`, which\n            // serves two purposes:\n            // 1. Protects integrity of `v` from panics in `is_less`.\n            // 2. Fills the remaining hole in `v` in the end.\n            //\n            // Panic safety:\n            //\n            // If `is_less` panics at any point during the process, `hole` will get dropped and\n            // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n            // initially held exactly once.\n            let mut hole = InsertionHole {\n                src: &mut *tmp,\n                dest: &mut v[1],\n            };\n            ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n\n            for i in 2..v.len() {\n                if !is_less(&v[i], &*tmp) {\n                    break;\n                }\n                ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n                hole.dest = &mut v[i];\n            }\n            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n        }\n    }\n\n    // When dropped, copies from `src` into `dest`.\n    struct InsertionHole<T> {\n        src: *mut T,\n        dest: *mut T,\n    }\n\n    impl<T> Drop for InsertionHole<T> {\n        fn drop(&mut self) {\n            unsafe { ptr::copy_nonoverlapping(self.src, self.dest, 1); }\n        }\n    }\n}\n\n/// Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `buf` as temporary storage, and\n/// stores the result into `v[..]`.\n///\n/// # Safety\n///\n/// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n/// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\nunsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n    where F: FnMut(&T, &T) -> bool\n{\n    let len = v.len();\n    let v = v.as_mut_ptr();\n    let v_mid = v.offset(mid as isize);\n    let v_end = v.offset(len as isize);\n\n    // The merge process first copies the shorter run into `buf`. Then it traces the newly copied\n    // run and the longer run forwards (or backwards), comparing their next unconsumed elements and\n    // copying the lesser (or greater) one into `v`.\n    //\n    // As soon as the shorter run is fully consumed, the process is done. If the longer run gets\n    // consumed first, then we must copy whatever is left of the shorter run into the remaining\n    // hole in `v`.\n    //\n    // Intermediate state of the process is always tracked by `hole`, which serves two purposes:\n    // 1. Protects integrity of `v` from panics in `is_less`.\n    // 2. Fills the remaining hole in `v` if the longer run gets consumed first.\n    //\n    // Panic safety:\n    //\n    // If `is_less` panics at any point during the process, `hole` will get dropped and fill the\n    // hole in `v` with the unconsumed range in `buf`, thus ensuring that `v` still holds every\n    // object it initially held exactly once.\n    let mut hole;\n\n    if mid <= len - mid {\n        // The left run is shorter.\n        ptr::copy_nonoverlapping(v, buf, mid);\n        hole = MergeHole {\n            start: buf,\n            end: buf.offset(mid as isize),\n            dest: v,\n        };\n\n        // Initially, these pointers point to the beginnings of their arrays.\n        let left = &mut hole.start;\n        let mut right = v_mid;\n        let out = &mut hole.dest;\n\n        while *left < hole.end && right < v_end {\n            // Consume the lesser side.\n            // If equal, prefer the left run to maintain stability.\n            let to_copy = if is_less(&*right, &**left) {\n                get_and_increment(&mut right)\n            } else {\n                get_and_increment(left)\n            };\n            ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n        }\n    } else {\n        // The right run is shorter.\n        ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n        hole = MergeHole {\n            start: buf,\n            end: buf.offset((len - mid) as isize),\n            dest: v_mid,\n        };\n\n        // Initially, these pointers point past the ends of their arrays.\n        let left = &mut hole.dest;\n        let right = &mut hole.end;\n        let mut out = v_end;\n\n        while v < *left && buf < *right {\n            // Consume the greater side.\n            // If equal, prefer the right run to maintain stability.\n            let to_copy = if is_less(&*right.offset(-1), &*left.offset(-1)) {\n                decrement_and_get(left)\n            } else {\n                decrement_and_get(right)\n            };\n            ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n        }\n    }\n    // Finally, `hole` gets dropped. If the shorter run was not fully consumed, whatever remains of\n    // it will now be copied into the hole in `v`.\n\n    unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n        let old = *ptr;\n        *ptr = ptr.offset(1);\n        old\n    }\n\n    unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n        *ptr = ptr.offset(-1);\n        *ptr\n    }\n\n    // When dropped, copies the range `start..end` into `dest..`.\n    struct MergeHole<T> {\n        start: *mut T,\n        end: *mut T,\n        dest: *mut T,\n    }\n\n    impl<T> Drop for MergeHole<T> {\n        fn drop(&mut self) {\n            // `T` is not a zero-sized type, so it's okay to divide by its size.\n            let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n            unsafe { ptr::copy_nonoverlapping(self.start, self.dest, len); }\n        }\n    }\n}\n\n/// This merge sort borrows some (but not all) ideas from TimSort, which is described in detail\n/// [here](http://svn.python.org/projects/python/trunk/Objects/listsort.txt).\n///\n/// The algorithm identifies strictly descending and non-descending subsequences, which are called\n/// natural runs. There is a stack of pending runs yet to be merged. Each newly found run is pushed\n/// onto the stack, and then some pairs of adjacent runs are merged until these two invariants are\n/// satisfied:\n///\n/// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n/// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n///\n/// The invariants ensure that the total running time is `O(n log n)` worst-case.\nfn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n    where F: FnMut(&T, &T) -> bool\n{\n    // Slices of up to this length get sorted using insertion sort.\n    const MAX_INSERTION: usize = 20;\n    // Very short runs are extended using insertion sort to span at least this many elements.\n    const MIN_RUN: usize = 10;\n\n    // Sorting has no meaningful behavior on zero-sized types.\n    if size_of::<T>() == 0 {\n        return;\n    }\n\n    let len = v.len();\n\n    // Short arrays get sorted in-place via insertion sort to avoid allocations.\n    if len <= MAX_INSERTION {\n        if len >= 2 {\n            for i in (0..len-1).rev() {\n                insert_head(&mut v[i..], &mut is_less);\n            }\n        }\n        return;\n    }\n\n    // Allocate a buffer to use as scratch memory. We keep the length 0 so we can keep in it\n    // shallow copies of the contents of `v` without risking the dtors running on copies if\n    // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n    // which will always have length at most `len / 2`.\n    let mut buf = Vec::with_capacity(len / 2);\n\n    // In order to identify natural runs in `v`, we traverse it backwards. That might seem like a\n    // strange decision, but consider the fact that merges more often go in the opposite direction\n    // (forwards). According to benchmarks, merging forwards is slightly faster than merging\n    // backwards. To conclude, identifying runs by traversing backwards improves performance.\n    let mut runs = vec![];\n    let mut end = len;\n    while end > 0 {\n        // Find the next natural run, and reverse it if it's strictly descending.\n        let mut start = end - 1;\n        if start > 0 {\n            start -= 1;\n            unsafe {\n                if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n                    while start > 0 && is_less(v.get_unchecked(start),\n                                               v.get_unchecked(start - 1)) {\n                        start -= 1;\n                    }\n                    v[start..end].reverse();\n                } else {\n                    while start > 0 && !is_less(v.get_unchecked(start),\n                                                v.get_unchecked(start - 1)) {\n                        start -= 1;\n                    }\n                }\n            }\n        }\n\n        // Insert some more elements into the run if it's too short. Insertion sort is faster than\n        // merge sort on short sequences, so this significantly improves performance.\n        while start > 0 && end - start < MIN_RUN {\n            start -= 1;\n            insert_head(&mut v[start..end], &mut is_less);\n        }\n\n        // Push this run onto the stack.\n        runs.push(Run {\n            start,\n            len: end - start,\n        });\n        end = start;\n\n        // Merge some pairs of adjacent runs to satisfy the invariants.\n        while let Some(r) = collapse(&runs) {\n            let left = runs[r + 1];\n            let right = runs[r];\n            unsafe {\n                merge(&mut v[left.start .. right.start + right.len], left.len, buf.as_mut_ptr(),\n                      &mut is_less);\n            }\n            runs[r] = Run {\n                start: left.start,\n                len: left.len + right.len,\n            };\n            runs.remove(r + 1);\n        }\n    }\n\n    // Finally, exactly one run must remain in the stack.\n    debug_assert!(runs.len() == 1 && runs[0].start == 0 && runs[0].len == len);\n\n    // Examines the stack of runs and identifies the next pair of runs to merge. More specifically,\n    // if `Some(r)` is returned, that means `runs[r]` and `runs[r + 1]` must be merged next. If the\n    // algorithm should continue building a new run instead, `None` is returned.\n    //\n    // TimSort is infamous for its buggy implementations, as described here:\n    // http://envisage-project.eu/timsort-specification-and-verification/\n    //\n    // The gist of the story is: we must enforce the invariants on the top four runs on the stack.\n    // Enforcing them on just top three is not sufficient to ensure that the invariants will still\n    // hold for *all* runs in the stack.\n    //\n    // This function correctly checks invariants for the top four runs. Additionally, if the top\n    // run starts at index 0, it will always demand a merge operation until the stack is fully\n    // collapsed, in order to complete the sort.\n    #[inline]\n    fn collapse(runs: &[Run]) -> Option<usize> {\n        let n = runs.len();\n        if n >= 2 && (runs[n - 1].start == 0 ||\n                      runs[n - 2].len <= runs[n - 1].len ||\n                      (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len) ||\n                      (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len)) {\n            if n >= 3 && runs[n - 3].len < runs[n - 1].len {\n                Some(n - 3)\n            } else {\n                Some(n - 2)\n            }\n        } else {\n            None\n        }\n    }\n\n    #[derive(Clone, Copy)]\n    struct Run {\n        start: usize,\n        len: usize,\n    }\n}\n","// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse convert::TryFrom;\nuse mem;\nuse ops::{self, Add, Sub};\nuse usize;\n\nuse super::{FusedIterator, TrustedLen};\n\n/// Objects that can be stepped over in both directions.\n///\n/// The `steps_between` function provides a way to efficiently compare\n/// two `Step` objects.\n#[unstable(feature = \"step_trait\",\n           reason = \"likely to be replaced by finer-grained traits\",\n           issue = \"42168\")]\npub trait Step: Clone + PartialOrd + Sized {\n    /// Returns the number of steps between two step objects. The count is\n    /// inclusive of `start` and exclusive of `end`.\n    ///\n    /// Returns `None` if it is not possible to calculate `steps_between`\n    /// without overflow.\n    fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n\n    /// Replaces this step with `1`, returning itself\n    fn replace_one(&mut self) -> Self;\n\n    /// Replaces this step with `0`, returning itself\n    fn replace_zero(&mut self) -> Self;\n\n    /// Adds one to this step, returning the result\n    fn add_one(&self) -> Self;\n\n    /// Subtracts one to this step, returning the result\n    fn sub_one(&self) -> Self;\n\n    /// Add an usize, returning None on overflow\n    fn add_usize(&self, n: usize) -> Option<Self>;\n}\n\n// These are still macro-generated because the integer literals resolve to different types.\nmacro_rules! step_identical_methods {\n    () => {\n        #[inline]\n        fn replace_one(&mut self) -> Self {\n            mem::replace(self, 1)\n        }\n\n        #[inline]\n        fn replace_zero(&mut self) -> Self {\n            mem::replace(self, 0)\n        }\n\n        #[inline]\n        fn add_one(&self) -> Self {\n            Add::add(*self, 1)\n        }\n\n        #[inline]\n        fn sub_one(&self) -> Self {\n            Sub::sub(*self, 1)\n        }\n    }\n}\n\nmacro_rules! step_impl_unsigned {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"step_trait\",\n                   reason = \"likely to be replaced by finer-grained traits\",\n                   issue = \"42168\")]\n        impl Step for $t {\n            #[inline]\n            #[allow(trivial_numeric_casts)]\n            fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n                if *start < *end {\n                    // Note: We assume $t <= usize here\n                    Some((*end - *start) as usize)\n                } else {\n                    Some(0)\n                }\n            }\n\n            #[inline]\n            #[allow(unreachable_patterns)]\n            fn add_usize(&self, n: usize) -> Option<Self> {\n                match <$t>::try_from(n) {\n                    Ok(n_as_t) => self.checked_add(n_as_t),\n                    Err(_) => None,\n                }\n            }\n\n            step_identical_methods!();\n        }\n    )*)\n}\nmacro_rules! step_impl_signed {\n    ($( [$t:ty : $unsigned:ty] )*) => ($(\n        #[unstable(feature = \"step_trait\",\n                   reason = \"likely to be replaced by finer-grained traits\",\n                   issue = \"42168\")]\n        impl Step for $t {\n            #[inline]\n            #[allow(trivial_numeric_casts)]\n            fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n                if *start < *end {\n                    // Note: We assume $t <= isize here\n                    // Use .wrapping_sub and cast to usize to compute the\n                    // difference that may not fit inside the range of isize.\n                    Some((*end as isize).wrapping_sub(*start as isize) as usize)\n                } else {\n                    Some(0)\n                }\n            }\n\n            #[inline]\n            #[allow(unreachable_patterns)]\n            fn add_usize(&self, n: usize) -> Option<Self> {\n                match <$unsigned>::try_from(n) {\n                    Ok(n_as_unsigned) => {\n                        // Wrapping in unsigned space handles cases like\n                        // `-120_i8.add_usize(200) == Some(80_i8)`,\n                        // even though 200_usize is out of range for i8.\n                        let wrapped = (*self as $unsigned).wrapping_add(n_as_unsigned) as $t;\n                        if wrapped >= *self {\n                            Some(wrapped)\n                        } else {\n                            None  // Addition overflowed\n                        }\n                    }\n                    Err(_) => None,\n                }\n            }\n\n            step_identical_methods!();\n        }\n    )*)\n}\n\nmacro_rules! step_impl_no_between {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"step_trait\",\n                   reason = \"likely to be replaced by finer-grained traits\",\n                   issue = \"42168\")]\n        impl Step for $t {\n            #[inline]\n            fn steps_between(_start: &Self, _end: &Self) -> Option<usize> {\n                None\n            }\n\n            #[inline]\n            fn add_usize(&self, n: usize) -> Option<Self> {\n                self.checked_add(n as $t)\n            }\n\n            step_identical_methods!();\n        }\n    )*)\n}\n\nstep_impl_unsigned!(usize u8 u16 u32);\nstep_impl_signed!([isize: usize] [i8: u8] [i16: u16] [i32: u32]);\n#[cfg(target_pointer_width = \"64\")]\nstep_impl_unsigned!(u64);\n#[cfg(target_pointer_width = \"64\")]\nstep_impl_signed!([i64: u64]);\n// If the target pointer width is not 64-bits, we\n// assume here that it is less than 64-bits.\n#[cfg(not(target_pointer_width = \"64\"))]\nstep_impl_no_between!(u64 i64);\nstep_impl_no_between!(u128 i128);\n\nmacro_rules! range_exact_iter_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl ExactSizeIterator for ops::Range<$t> { }\n    )*)\n}\n\nmacro_rules! range_incl_exact_iter_impl {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"inclusive_range\",\n                   reason = \"recently added, follows RFC\",\n                   issue = \"28237\")]\n        impl ExactSizeIterator for ops::RangeInclusive<$t> { }\n    )*)\n}\n\nmacro_rules! range_trusted_len_impl {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl TrustedLen for ops::Range<$t> { }\n    )*)\n}\n\nmacro_rules! range_incl_trusted_len_impl {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"inclusive_range\",\n                   reason = \"recently added, follows RFC\",\n                   issue = \"28237\")]\n        unsafe impl TrustedLen for ops::RangeInclusive<$t> { }\n    )*)\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Step> Iterator for ops::Range<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        if self.start < self.end {\n            // We check for overflow here, even though it can't actually\n            // happen. Adding this check does however help llvm vectorize loops\n            // for some ranges that don't get vectorized otherwise,\n            // and this won't actually result in an extra check in an optimized build.\n            if let Some(mut n) = self.start.add_usize(1) {\n                mem::swap(&mut n, &mut self.start);\n                Some(n)\n            } else {\n                None\n            }\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match Step::steps_between(&self.start, &self.end) {\n            Some(hint) => (hint, Some(hint)),\n            None => (0, None)\n        }\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<A> {\n        if let Some(plus_n) = self.start.add_usize(n) {\n            if plus_n < self.end {\n                self.start = plus_n.add_one();\n                return Some(plus_n)\n            }\n        }\n\n        self.start = self.end.clone();\n        None\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<A> {\n        self.next_back()\n    }\n\n    #[inline]\n    fn min(mut self) -> Option<A> {\n        self.next()\n    }\n\n    #[inline]\n    fn max(mut self) -> Option<A> {\n        self.next_back()\n    }\n}\n\n// These macros generate `ExactSizeIterator` impls for various range types.\n// Range<{u,i}64> and RangeInclusive<{u,i}{32,64,size}> are excluded\n// because they cannot guarantee having a length <= usize::MAX, which is\n// required by ExactSizeIterator.\nrange_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\nrange_incl_exact_iter_impl!(u8 u16 i8 i16);\n\n// These macros generate `TrustedLen` impls.\n//\n// They need to guarantee that .size_hint() is either exact, or that\n// the upper bound is None when it does not fit the type limits.\nrange_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 i64 u64);\nrange_incl_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 i64 u64);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Step> DoubleEndedIterator for ops::Range<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A> {\n        if self.start < self.end {\n            self.end = self.end.sub_one();\n            Some(self.end.clone())\n        } else {\n            None\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<A: Step> FusedIterator for ops::Range<A> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Step> Iterator for ops::RangeFrom<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        let mut n = self.start.add_one();\n        mem::swap(&mut n, &mut self.start);\n        Some(n)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::MAX, None)\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<A> {\n        let plus_n = self.start.add_usize(n).expect(\"overflow in RangeFrom::nth\");\n        self.start = plus_n.add_one();\n        Some(plus_n)\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<A: Step> FusedIterator for ops::RangeFrom<A> {}\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<A: Step> Iterator for ops::RangeInclusive<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        use cmp::Ordering::*;\n\n        match self.start.partial_cmp(&self.end) {\n            Some(Less) => {\n                let n = self.start.add_one();\n                Some(mem::replace(&mut self.start, n))\n            },\n            Some(Equal) => {\n                let last = self.start.replace_one();\n                self.end.replace_zero();\n                Some(last)\n            },\n            _ => None,\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if !(self.start <= self.end) {\n            return (0, Some(0));\n        }\n\n        match Step::steps_between(&self.start, &self.end) {\n            Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n            None => (0, None),\n        }\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<A> {\n        if let Some(plus_n) = self.start.add_usize(n) {\n            use cmp::Ordering::*;\n\n            match plus_n.partial_cmp(&self.end) {\n                Some(Less) => {\n                    self.start = plus_n.add_one();\n                    return Some(plus_n)\n                }\n                Some(Equal) => {\n                    self.start.replace_one();\n                    self.end.replace_zero();\n                    return Some(plus_n)\n                }\n                _ => {}\n            }\n        }\n\n        self.start.replace_one();\n        self.end.replace_zero();\n        None\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<A> {\n        self.next_back()\n    }\n\n    #[inline]\n    fn min(mut self) -> Option<A> {\n        self.next()\n    }\n\n    #[inline]\n    fn max(mut self) -> Option<A> {\n        self.next_back()\n    }\n}\n\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A> {\n        use cmp::Ordering::*;\n\n        match self.start.partial_cmp(&self.end) {\n            Some(Less) => {\n                let n = self.end.sub_one();\n                Some(mem::replace(&mut self.end, n))\n            },\n            Some(Equal) => {\n                let last = self.end.replace_zero();\n                self.start.replace_one();\n                Some(last)\n            },\n            _ => None,\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<A: Step> FusedIterator for ops::RangeInclusive<A> {}\n","// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Utilities for formatting and printing strings.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse cell::{UnsafeCell, Cell, RefCell, Ref, RefMut};\nuse marker::PhantomData;\nuse mem;\nuse num::flt2dec;\nuse ops::Deref;\nuse result;\nuse slice;\nuse str;\n\nmod float;\nmod num;\nmod builders;\n\n#[unstable(feature = \"fmt_flags_align\", issue = \"27726\")]\n/// Possible alignments returned by `Formatter::align`\n#[derive(Debug)]\npub enum Alignment {\n    /// Indication that contents should be left-aligned.\n    Left,\n    /// Indication that contents should be right-aligned.\n    Right,\n    /// Indication that contents should be center-aligned.\n    Center,\n    /// No alignment was requested.\n    Unknown,\n}\n\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap};\n\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n           issue = \"0\")]\n#[doc(hidden)]\npub mod rt {\n    pub mod v1;\n}\n\n/// The type returned by formatter methods.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// #[derive(Debug)]\n/// struct Triangle {\n///     a: f32,\n///     b: f32,\n///     c: f32\n/// }\n///\n/// impl fmt::Display for Triangle {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         write!(f, \"({}, {}, {})\", self.a, self.b, self.c)\n///     }\n/// }\n///\n/// let pythagorean_triple = Triangle { a: 3.0, b: 4.0, c: 5.0 };\n///\n/// println!(\"{}\", pythagorean_triple);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result = result::Result<(), Error>;\n\n/// The error type which is returned from formatting a message into a stream.\n///\n/// This type does not support transmission of an error other than that an error\n/// occurred. Any extra information must be arranged to be transmitted through\n/// some other means.\n///\n/// An important thing to remember is that the type `fmt::Error` should not be\n/// confused with [`std::io::Error`] or [`std::error::Error`], which you may also\n/// have in scope.\n///\n/// [`std::io::Error`]: ../../std/io/struct.Error.html\n/// [`std::error::Error`]: ../../std/error/trait.Error.html\n///\n/// # Examples\n///\n/// ```rust\n/// use std::fmt::{self, write};\n///\n/// let mut output = String::new();\n/// match write(&mut output, format_args!(\"Hello {}!\", \"world\")) {\n///     Err(fmt::Error) => panic!(\"An error occurred\"),\n///     _ => (),\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct Error;\n\n/// A collection of methods that are required to format a message into a stream.\n///\n/// This trait is the type which this modules requires when formatting\n/// information. This is similar to the standard library's [`io::Write`] trait,\n/// but it is only intended for use in libcore.\n///\n/// This trait should generally not be implemented by consumers of the standard\n/// library. The [`write!`] macro accepts an instance of [`io::Write`], and the\n/// [`io::Write`] trait is favored over implementing this trait.\n///\n/// [`write!`]: ../../std/macro.write.html\n/// [`io::Write`]: ../../std/io/trait.Write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Write {\n    /// Writes a slice of bytes into this writer, returning whether the write\n    /// succeeded.\n    ///\n    /// This method can only succeed if the entire byte slice was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// [`Error`]: struct.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n    ///     f.write_str(s)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, \"hola\").unwrap();\n    /// assert_eq!(&buf, \"hola\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_str(&mut self, s: &str) -> Result;\n\n    /// Writes a [`char`] into this writer, returning whether the write succeeded.\n    ///\n    /// A single [`char`] may be encoded as more than one byte.\n    /// This method can only succeed if the entire byte sequence was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    /// [`Error`]: struct.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n    ///     f.write_char(c)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, 'a').unwrap();\n    /// writer(&mut buf, 'b').unwrap();\n    /// assert_eq!(&buf, \"ab\");\n    /// ```\n    #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n    fn write_char(&mut self, c: char) -> Result {\n        self.write_str(c.encode_utf8(&mut [0; 4]))\n    }\n\n    /// Glue for usage of the [`write!`] macro with implementors of this trait.\n    ///\n    /// This method should generally not be invoked manually, but rather through\n    /// the [`write!`] macro itself.\n    ///\n    /// [`write!`]: ../../std/macro.write.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n    ///     f.write_fmt(format_args!(\"{}\", s))\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, \"world\").unwrap();\n    /// assert_eq!(&buf, \"world\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(&mut self, args: Arguments) -> Result {\n        // This Adapter is needed to allow `self` (of type `&mut\n        // Self`) to be cast to a Write (below) without\n        // requiring a `Sized` bound.\n        struct Adapter<'a,T: ?Sized +'a>(&'a mut T);\n\n        impl<'a, T: ?Sized> Write for Adapter<'a, T>\n            where T: Write\n        {\n            fn write_str(&mut self, s: &str) -> Result {\n                self.0.write_str(s)\n            }\n\n            fn write_char(&mut self, c: char) -> Result {\n                self.0.write_char(c)\n            }\n\n            fn write_fmt(&mut self, args: Arguments) -> Result {\n                self.0.write_fmt(args)\n            }\n        }\n\n        write(&mut Adapter(self), args)\n    }\n}\n\n#[stable(feature = \"fmt_write_blanket_impl\", since = \"1.4.0\")]\nimpl<'a, W: Write + ?Sized> Write for &'a mut W {\n    fn write_str(&mut self, s: &str) -> Result {\n        (**self).write_str(s)\n    }\n\n    fn write_char(&mut self, c: char) -> Result {\n        (**self).write_char(c)\n    }\n\n    fn write_fmt(&mut self, args: Arguments) -> Result {\n        (**self).write_fmt(args)\n    }\n}\n\n/// A struct to represent both where to emit formatting strings to and how they\n/// should be formatted. A mutable version of this is passed to all formatting\n/// traits.\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Formatter<'a> {\n    flags: u32,\n    fill: char,\n    align: rt::v1::Alignment,\n    width: Option<usize>,\n    precision: Option<usize>,\n\n    buf: &'a mut (Write+'a),\n    curarg: slice::Iter<'a, ArgumentV1<'a>>,\n    args: &'a [ArgumentV1<'a>],\n}\n\n// NB. Argument is essentially an optimized partially applied formatting function,\n// equivalent to `exists T.(&T, fn(&T, &mut Formatter) -> Result`.\n\nstruct Void {\n    _priv: (),\n    /// Erases all oibits, because `Void` erases the type of the object that\n    /// will be used to produce formatted output. Since we do not know what\n    /// oibits the real types have (and they can have any or none), we need to\n    /// take the most conservative approach and forbid all oibits.\n    ///\n    /// It was added after #45197 showed that one could share a `!Sync`\n    /// object across threads by passing it into `format_args!`.\n    _oibit_remover: PhantomData<*mut Fn()>,\n}\n\n/// This struct represents the generic \"argument\" which is taken by the Xprintf\n/// family of functions. It contains a function to format the given value. At\n/// compile time it is ensured that the function and the value have the correct\n/// types, and then this struct is used to canonicalize arguments to one type.\n#[derive(Copy)]\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n           issue = \"0\")]\n#[doc(hidden)]\npub struct ArgumentV1<'a> {\n    value: &'a Void,\n    formatter: fn(&Void, &mut Formatter) -> Result,\n}\n\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n           issue = \"0\")]\nimpl<'a> Clone for ArgumentV1<'a> {\n    fn clone(&self) -> ArgumentV1<'a> {\n        *self\n    }\n}\n\nimpl<'a> ArgumentV1<'a> {\n    #[inline(never)]\n    fn show_usize(x: &usize, f: &mut Formatter) -> Result {\n        Display::fmt(x, f)\n    }\n\n    #[doc(hidden)]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n               issue = \"0\")]\n    pub fn new<'b, T>(x: &'b T,\n                      f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {\n        unsafe {\n            ArgumentV1 {\n                formatter: mem::transmute(f),\n                value: mem::transmute(x)\n            }\n        }\n    }\n\n    #[doc(hidden)]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n               issue = \"0\")]\n    pub fn from_usize(x: &usize) -> ArgumentV1 {\n        ArgumentV1::new(x, ArgumentV1::show_usize)\n    }\n\n    fn as_usize(&self) -> Option<usize> {\n        if self.formatter as usize == ArgumentV1::show_usize as usize {\n            Some(unsafe { *(self.value as *const _ as *const usize) })\n        } else {\n            None\n        }\n    }\n}\n\n// flags available in the v1 format of format_args\n#[derive(Copy, Clone)]\nenum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, }\n\nimpl<'a> Arguments<'a> {\n    /// When using the format_args!() macro, this function is used to generate the\n    /// Arguments structure.\n    #[doc(hidden)] #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n               issue = \"0\")]\n    pub fn new_v1(pieces: &'a [&'a str],\n                  args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n        Arguments {\n            pieces,\n            fmt: None,\n            args,\n        }\n    }\n\n    /// This function is used to specify nonstandard formatting parameters.\n    /// The `pieces` array must be at least as long as `fmt` to construct\n    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n    /// created with `argumentusize`. However, failing to do so doesn't cause\n    /// unsafety, but will ignore invalid .\n    #[doc(hidden)] #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n               issue = \"0\")]\n    pub fn new_v1_formatted(pieces: &'a [&'a str],\n                            args: &'a [ArgumentV1<'a>],\n                            fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {\n        Arguments {\n            pieces,\n            fmt: Some(fmt),\n            args,\n        }\n    }\n\n    /// Estimates the length of the formatted text.\n    ///\n    /// This is intended to be used for setting initial `String` capacity\n    /// when using `format!`. Note: this is neither the lower nor upper bound.\n    #[doc(hidden)] #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n               issue = \"0\")]\n    pub fn estimated_capacity(&self) -> usize {\n        let pieces_length: usize = self.pieces.iter()\n            .map(|x| x.len()).sum();\n\n        if self.args.is_empty() {\n            pieces_length\n        } else if self.pieces[0] == \"\" && pieces_length < 16 {\n            // If the format string starts with an argument,\n            // don't preallocate anything, unless length\n            // of pieces is significant.\n            0\n        } else {\n            // There are some arguments, so any additional push\n            // will reallocate the string. To avoid that,\n            // we're \"pre-doubling\" the capacity here.\n            pieces_length.checked_mul(2).unwrap_or(0)\n        }\n    }\n}\n\n/// This structure represents a safely precompiled version of a format string\n/// and its arguments. This cannot be generated at runtime because it cannot\n/// safely be done, so no constructors are given and the fields are private\n/// to prevent modification.\n///\n/// The [`format_args!`] macro will safely create an instance of this structure\n/// and pass it to a function or closure, passed as the first argument. The\n/// macro validates the format string at compile-time so usage of the [`write`]\n/// and [`format`] functions can be safely performed.\n///\n/// [`format_args!`]: ../../std/macro.format_args.html\n/// [`format`]: ../../std/fmt/fn.format.html\n/// [`write`]: ../../std/fmt/fn.write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone)]\npub struct Arguments<'a> {\n    // Format string pieces to print.\n    pieces: &'a [&'a str],\n\n    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n    fmt: Option<&'a [rt::v1::Argument]>,\n\n    // Dynamic arguments for interpolation, to be interleaved with string\n    // pieces. (Every argument is preceded by a string piece.)\n    args: &'a [ArgumentV1<'a>],\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Debug for Arguments<'a> {\n    fn fmt(&self, fmt: &mut Formatter) -> Result {\n        Display::fmt(self, fmt)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Display for Arguments<'a> {\n    fn fmt(&self, fmt: &mut Formatter) -> Result {\n        write(fmt.buf, *self)\n    }\n}\n\n/// `?` formatting.\n///\n/// `Debug` should format the output in a programmer-facing, debugging context.\n///\n/// Generally speaking, you should just `derive` a `Debug` implementation.\n///\n/// When used with the alternate format specifier `#?`, the output is pretty-printed.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// This trait can be used with `#[derive]` if all fields implement `Debug`. When\n/// `derive`d for structs, it will use the name of the `struct`, then `{`, then a\n/// comma-separated list of each field's name and `Debug` value, then `}`. For\n/// `enum`s, it will use the name of the variant and, if applicable, `(`, then the\n/// `Debug` values of the fields, then `)`.\n///\n/// # Examples\n///\n/// Deriving an implementation:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// println!(\"The origin is: {:?}\", origin);\n/// ```\n///\n/// Manually implementing:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl fmt::Debug for Point {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         write!(f, \"Point {{ x: {}, y: {} }}\", self.x, self.y)\n///     }\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// println!(\"The origin is: {:?}\", origin);\n/// ```\n///\n/// This outputs:\n///\n/// ```text\n/// The origin is: Point { x: 0, y: 0 }\n/// ```\n///\n/// There are a number of `debug_*` methods on [`Formatter`] to help you with manual\n/// implementations, such as [`debug_struct`][debug_struct].\n///\n/// `Debug` implementations using either `derive` or the debug builder API\n/// on [`Formatter`] support pretty printing using the alternate flag: `{:#?}`.\n///\n/// [debug_struct]: ../../std/fmt/struct.Formatter.html#method.debug_struct\n/// [`Formatter`]: ../../std/fmt/struct.Formatter.html\n///\n/// Pretty printing with `#?`:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// println!(\"The origin is: {:#?}\", origin);\n/// ```\n///\n/// This outputs:\n///\n/// ```text\n/// The origin is: Point {\n///     x: 0,\n///     y: 0\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented = \"`{Self}` cannot be formatted using `:?`; if it is \\\n                            defined in your crate, add `#[derive(Debug)]` or \\\n                            manually implement it\"]\n#[lang = \"debug_trait\"]\npub trait Debug {\n    /// Formats the value using the given formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Position {\n    ///     longitude: f32,\n    ///     latitude: f32,\n    /// }\n    ///\n    /// impl fmt::Debug for Position {\n    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    ///         write!(f, \"({:?}, {:?})\", self.longitude, self.latitude)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\"(1.987, 2.983)\".to_owned(),\n    ///            format!(\"{:?}\", Position { longitude: 1.987, latitude: 2.983, }));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// Format trait for an empty format, `{}`.\n///\n/// `Display` is similar to [`Debug`][debug], but `Display` is for user-facing\n/// output, and so cannot be derived.\n///\n/// [debug]: trait.Debug.html\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Implementing `Display` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl fmt::Display for Point {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         write!(f, \"({}, {})\", self.x, self.y)\n///     }\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// println!(\"The origin is: {}\", origin);\n/// ```\n#[rustc_on_unimplemented = \"`{Self}` cannot be formatted with the default \\\n                            formatter; try using `:?` instead if you are using \\\n                            a format string\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Display {\n    /// Formats the value using the given formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Position {\n    ///     longitude: f32,\n    ///     latitude: f32,\n    /// }\n    ///\n    /// impl fmt::Display for Position {\n    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    ///         write!(f, \"({}, {})\", self.longitude, self.latitude)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\"(1.987, 2.983)\".to_owned(),\n    ///            format!(\"{}\", Position { longitude: 1.987, latitude: 2.983, }));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// `o` formatting.\n///\n/// The `Octal` trait should format its output as a number in base-8.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0o` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '52' in octal\n///\n/// assert_eq!(format!(\"{:o}\", x), \"52\");\n/// assert_eq!(format!(\"{:#o}\", x), \"0o52\");\n///\n/// assert_eq!(format!(\"{:o}\", -16), \"37777777760\");\n/// ```\n///\n/// Implementing `Octal` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Octal for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         let val = self.0;\n///\n///         write!(f, \"{:o}\", val) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// println!(\"l as octal is: {:o}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Octal {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// `b` formatting.\n///\n/// The `Binary` trait should format its output as a number in binary.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0b` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '101010' in binary\n///\n/// assert_eq!(format!(\"{:b}\", x), \"101010\");\n/// assert_eq!(format!(\"{:#b}\", x), \"0b101010\");\n///\n/// assert_eq!(format!(\"{:b}\", -16), \"11111111111111111111111111110000\");\n/// ```\n///\n/// Implementing `Binary` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Binary for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         let val = self.0;\n///\n///         write!(f, \"{:b}\", val) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(107);\n///\n/// println!(\"l as binary is: {:b}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Binary {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// `x` formatting.\n///\n/// The `LowerHex` trait should format its output as a number in hexadecimal, with `a` through `f`\n/// in lower case.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0x` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '2a' in hex\n///\n/// assert_eq!(format!(\"{:x}\", x), \"2a\");\n/// assert_eq!(format!(\"{:#x}\", x), \"0x2a\");\n///\n/// assert_eq!(format!(\"{:x}\", -16), \"fffffff0\");\n/// ```\n///\n/// Implementing `LowerHex` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::LowerHex for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         let val = self.0;\n///\n///         write!(f, \"{:x}\", val) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// println!(\"l as hex is: {:x}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait LowerHex {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// `X` formatting.\n///\n/// The `UpperHex` trait should format its output as a number in hexadecimal, with `A` through `F`\n/// in upper case.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0x` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '2A' in hex\n///\n/// assert_eq!(format!(\"{:X}\", x), \"2A\");\n/// assert_eq!(format!(\"{:#X}\", x), \"0x2A\");\n///\n/// assert_eq!(format!(\"{:X}\", -16), \"FFFFFFF0\");\n/// ```\n///\n/// Implementing `UpperHex` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::UpperHex for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         let val = self.0;\n///\n///         write!(f, \"{:X}\", val) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// println!(\"l as hex is: {:X}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait UpperHex {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// `p` formatting.\n///\n/// The `Pointer` trait should format its output as a memory location. This is commonly presented\n/// as hexadecimal.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `&i32`:\n///\n/// ```\n/// let x = &42;\n///\n/// let address = format!(\"{:p}\", x); // this produces something like '0x7f06092ac6d0'\n/// ```\n///\n/// Implementing `Pointer` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Pointer for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         // use `as` to convert to a `*const T`, which implements Pointer, which we can use\n///\n///         write!(f, \"{:p}\", self as *const Length)\n///     }\n/// }\n///\n/// let l = Length(42);\n///\n/// println!(\"l is in memory here: {:p}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Pointer {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// `e` formatting.\n///\n/// The `LowerExp` trait should format its output in scientific notation with a lower-case `e`.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42.0; // 42.0 is '4.2e1' in scientific notation\n///\n/// assert_eq!(format!(\"{:e}\", x), \"4.2e1\");\n/// ```\n///\n/// Implementing `LowerExp` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::LowerExp for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         let val = self.0;\n///         write!(f, \"{}e1\", val / 10)\n///     }\n/// }\n///\n/// let l = Length(100);\n///\n/// println!(\"l in scientific notation is: {:e}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait LowerExp {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// `E` formatting.\n///\n/// The `UpperExp` trait should format its output in scientific notation with an upper-case `E`.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `f32`:\n///\n/// ```\n/// let x = 42.0; // 42.0 is '4.2E1' in scientific notation\n///\n/// assert_eq!(format!(\"{:E}\", x), \"4.2E1\");\n/// ```\n///\n/// Implementing `UpperExp` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::UpperExp for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n///         let val = self.0;\n///         write!(f, \"{}E1\", val / 10)\n///     }\n/// }\n///\n/// let l = Length(100);\n///\n/// println!(\"l in scientific notation is: {:E}\", l);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait UpperExp {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter) -> Result;\n}\n\n/// The `write` function takes an output stream, and an `Arguments` struct\n/// that can be precompiled with the `format_args!` macro.\n///\n/// The arguments will be formatted according to the specified format string\n/// into the output stream provided.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::fmt;\n///\n/// let mut output = String::new();\n/// fmt::write(&mut output, format_args!(\"Hello {}!\", \"world\"))\n///     .expect(\"Error occurred while trying to write in String\");\n/// assert_eq!(output, \"Hello world!\");\n/// ```\n///\n/// Please note that using [`write!`] might be preferable. Example:\n///\n/// ```\n/// use std::fmt::Write;\n///\n/// let mut output = String::new();\n/// write!(&mut output, \"Hello {}!\", \"world\")\n///     .expect(\"Error occurred while trying to write in String\");\n/// assert_eq!(output, \"Hello world!\");\n/// ```\n///\n/// [`write!`]: ../../std/macro.write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn write(output: &mut Write, args: Arguments) -> Result {\n    let mut formatter = Formatter {\n        flags: 0,\n        width: None,\n        precision: None,\n        buf: output,\n        align: rt::v1::Alignment::Unknown,\n        fill: ' ',\n        args: args.args,\n        curarg: args.args.iter(),\n    };\n\n    let mut pieces = args.pieces.iter();\n\n    match args.fmt {\n        None => {\n            // We can use default formatting parameters for all arguments.\n            for (arg, piece) in args.args.iter().zip(pieces.by_ref()) {\n                formatter.buf.write_str(*piece)?;\n                (arg.formatter)(arg.value, &mut formatter)?;\n            }\n        }\n        Some(fmt) => {\n            // Every spec has a corresponding argument that is preceded by\n            // a string piece.\n            for (arg, piece) in fmt.iter().zip(pieces.by_ref()) {\n                formatter.buf.write_str(*piece)?;\n                formatter.run(arg)?;\n            }\n        }\n    }\n\n    // There can be only one trailing string piece left.\n    if let Some(piece) = pieces.next() {\n        formatter.buf.write_str(*piece)?;\n    }\n\n    Ok(())\n}\n\nimpl<'a> Formatter<'a> {\n    fn wrap_buf<'b, 'c, F>(&'b mut self, wrap: F) -> Formatter<'c>\n        where 'b: 'c, F: FnOnce(&'b mut (Write+'b)) -> &'c mut (Write+'c)\n    {\n        Formatter {\n            // We want to change this\n            buf: wrap(self.buf),\n\n            // And preserve these\n            flags: self.flags,\n            fill: self.fill,\n            align: self.align,\n            width: self.width,\n            precision: self.precision,\n\n            // These only exist in the struct for the `run` method,\n            // which won’t be used together with this method.\n            curarg: self.curarg.clone(),\n            args: self.args,\n        }\n    }\n\n    // First up is the collection of functions used to execute a format string\n    // at runtime. This consumes all of the compile-time statics generated by\n    // the format! syntax extension.\n    fn run(&mut self, arg: &rt::v1::Argument) -> Result {\n        // Fill in the format parameters into the formatter\n        self.fill = arg.format.fill;\n        self.align = arg.format.align;\n        self.flags = arg.format.flags;\n        self.width = self.getcount(&arg.format.width);\n        self.precision = self.getcount(&arg.format.precision);\n\n        // Extract the correct argument\n        let value = match arg.position {\n            rt::v1::Position::Next => { *self.curarg.next().unwrap() }\n            rt::v1::Position::At(i) => self.args[i],\n        };\n\n        // Then actually do some printing\n        (value.formatter)(value.value, self)\n    }\n\n    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<usize> {\n        match *cnt {\n            rt::v1::Count::Is(n) => Some(n),\n            rt::v1::Count::Implied => None,\n            rt::v1::Count::Param(i) => {\n                self.args[i].as_usize()\n            }\n            rt::v1::Count::NextParam => {\n                self.curarg.next().and_then(|arg| arg.as_usize())\n            }\n        }\n    }\n\n    // Helper methods used for padding and processing formatting arguments that\n    // all formatting traits can use.\n\n    /// Performs the correct padding for an integer which has already been\n    /// emitted into a str. The str should *not* contain the sign for the\n    /// integer, that will be added by this method.\n    ///\n    /// # Arguments\n    ///\n    /// * is_nonnegative - whether the original integer was either positive or zero.\n    /// * prefix - if the '#' character (Alternate) is provided, this\n    ///   is the prefix to put in front of the number.\n    /// * buf - the byte array that the number has been formatted into\n    ///\n    /// This function will correctly account for the flags provided as well as\n    /// the minimum width. It will not take precision into account.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pad_integral(&mut self,\n                        is_nonnegative: bool,\n                        prefix: &str,\n                        buf: &str)\n                        -> Result {\n        let mut width = buf.len();\n\n        let mut sign = None;\n        if !is_nonnegative {\n            sign = Some('-'); width += 1;\n        } else if self.sign_plus() {\n            sign = Some('+'); width += 1;\n        }\n\n        let mut prefixed = false;\n        if self.alternate() {\n            prefixed = true; width += prefix.chars().count();\n        }\n\n        // Writes the sign if it exists, and then the prefix if it was requested\n        let write_prefix = |f: &mut Formatter| {\n            if let Some(c) = sign {\n                f.buf.write_str(c.encode_utf8(&mut [0; 4]))?;\n            }\n            if prefixed { f.buf.write_str(prefix) }\n            else { Ok(()) }\n        };\n\n        // The `width` field is more of a `min-width` parameter at this point.\n        match self.width {\n            // If there's no minimum length requirements then we can just\n            // write the bytes.\n            None => {\n                write_prefix(self)?; self.buf.write_str(buf)\n            }\n            // Check if we're over the minimum width, if so then we can also\n            // just write the bytes.\n            Some(min) if width >= min => {\n                write_prefix(self)?; self.buf.write_str(buf)\n            }\n            // The sign and prefix goes before the padding if the fill character\n            // is zero\n            Some(min) if self.sign_aware_zero_pad() => {\n                self.fill = '0';\n                self.align = rt::v1::Alignment::Right;\n                write_prefix(self)?;\n                self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n                    f.buf.write_str(buf)\n                })\n            }\n            // Otherwise, the sign and prefix goes after the padding\n            Some(min) => {\n                self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n                    write_prefix(f)?; f.buf.write_str(buf)\n                })\n            }\n        }\n    }\n\n    /// This function takes a string slice and emits it to the internal buffer\n    /// after applying the relevant formatting flags specified. The flags\n    /// recognized for generic strings are:\n    ///\n    /// * width - the minimum width of what to emit\n    /// * fill/align - what to emit and where to emit it if the string\n    ///                provided needs to be padded\n    /// * precision - the maximum length to emit, the string is truncated if it\n    ///               is longer than this length\n    ///\n    /// Notably this function ignores the `flag` parameters.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pad(&mut self, s: &str) -> Result {\n        // Make sure there's a fast path up front\n        if self.width.is_none() && self.precision.is_none() {\n            return self.buf.write_str(s);\n        }\n        // The `precision` field can be interpreted as a `max-width` for the\n        // string being formatted.\n        let s = if let Some(max) = self.precision {\n            // If our string is longer that the precision, then we must have\n            // truncation. However other flags like `fill`, `width` and `align`\n            // must act as always.\n            if let Some((i, _)) = s.char_indices().skip(max).next() {\n                &s[..i]\n            } else {\n                &s\n            }\n        } else {\n            &s\n        };\n        // The `width` field is more of a `min-width` parameter at this point.\n        match self.width {\n            // If we're under the maximum length, and there's no minimum length\n            // requirements, then we can just emit the string\n            None => self.buf.write_str(s),\n            // If we're under the maximum width, check if we're over the minimum\n            // width, if so it's as easy as just emitting the string.\n            Some(width) if s.chars().count() >= width => {\n                self.buf.write_str(s)\n            }\n            // If we're under both the maximum and the minimum width, then fill\n            // up the minimum width with the specified string + some alignment.\n            Some(width) => {\n                let align = rt::v1::Alignment::Left;\n                self.with_padding(width - s.chars().count(), align, |me| {\n                    me.buf.write_str(s)\n                })\n            }\n        }\n    }\n\n    /// Runs a callback, emitting the correct padding either before or\n    /// afterwards depending on whether right or left alignment is requested.\n    fn with_padding<F>(&mut self, padding: usize, default: rt::v1::Alignment,\n                       f: F) -> Result\n        where F: FnOnce(&mut Formatter) -> Result,\n    {\n        let align = match self.align {\n            rt::v1::Alignment::Unknown => default,\n            _ => self.align\n        };\n\n        let (pre_pad, post_pad) = match align {\n            rt::v1::Alignment::Left => (0, padding),\n            rt::v1::Alignment::Right |\n            rt::v1::Alignment::Unknown => (padding, 0),\n            rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n        };\n\n        let mut fill = [0; 4];\n        let fill = self.fill.encode_utf8(&mut fill);\n\n        for _ in 0..pre_pad {\n            self.buf.write_str(fill)?;\n        }\n\n        f(self)?;\n\n        for _ in 0..post_pad {\n            self.buf.write_str(fill)?;\n        }\n\n        Ok(())\n    }\n\n    /// Takes the formatted parts and applies the padding.\n    /// Assumes that the caller already has rendered the parts with required precision,\n    /// so that `self.precision` can be ignored.\n    fn pad_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result {\n        if let Some(mut width) = self.width {\n            // for the sign-aware zero padding, we render the sign first and\n            // behave as if we had no sign from the beginning.\n            let mut formatted = formatted.clone();\n            let old_fill = self.fill;\n            let old_align = self.align;\n            let mut align = old_align;\n            if self.sign_aware_zero_pad() {\n                // a sign always goes first\n                let sign = unsafe { str::from_utf8_unchecked(formatted.sign) };\n                self.buf.write_str(sign)?;\n\n                // remove the sign from the formatted parts\n                formatted.sign = b\"\";\n                width = if width < sign.len() { 0 } else { width - sign.len() };\n                align = rt::v1::Alignment::Right;\n                self.fill = '0';\n                self.align = rt::v1::Alignment::Right;\n            }\n\n            // remaining parts go through the ordinary padding process.\n            let len = formatted.len();\n            let ret = if width <= len { // no padding\n                self.write_formatted_parts(&formatted)\n            } else {\n                self.with_padding(width - len, align, |f| {\n                    f.write_formatted_parts(&formatted)\n                })\n            };\n            self.fill = old_fill;\n            self.align = old_align;\n            ret\n        } else {\n            // this is the common case and we take a shortcut\n            self.write_formatted_parts(formatted)\n        }\n    }\n\n    fn write_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result {\n        fn write_bytes(buf: &mut Write, s: &[u8]) -> Result {\n            buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n        }\n\n        if !formatted.sign.is_empty() {\n            write_bytes(self.buf, formatted.sign)?;\n        }\n        for part in formatted.parts {\n            match *part {\n                flt2dec::Part::Zero(mut nzeroes) => {\n                    const ZEROES: &'static str = // 64 zeroes\n                        \"0000000000000000000000000000000000000000000000000000000000000000\";\n                    while nzeroes > ZEROES.len() {\n                        self.buf.write_str(ZEROES)?;\n                        nzeroes -= ZEROES.len();\n                    }\n                    if nzeroes > 0 {\n                        self.buf.write_str(&ZEROES[..nzeroes])?;\n                    }\n                }\n                flt2dec::Part::Num(mut v) => {\n                    let mut s = [0; 5];\n                    let len = part.len();\n                    for c in s[..len].iter_mut().rev() {\n                        *c = b'0' + (v % 10) as u8;\n                        v /= 10;\n                    }\n                    write_bytes(self.buf, &s[..len])?;\n                }\n                flt2dec::Part::Copy(buf) => {\n                    write_bytes(self.buf, buf)?;\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Writes some data to the underlying buffer contained within this\n    /// formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write_str(&mut self, data: &str) -> Result {\n        self.buf.write_str(data)\n    }\n\n    /// Writes some formatted information into this instance\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n        write(self.buf, fmt)\n    }\n\n    /// Flags for formatting\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.24.0\",\n                       reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n                                 or `sign_aware_zero_pad` methods instead\")]\n    pub fn flags(&self) -> u32 { self.flags }\n\n    /// Character used as 'fill' whenever there is alignment\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn fill(&self) -> char { self.fill }\n\n    /// Flag indicating what form of alignment was requested\n    #[unstable(feature = \"fmt_flags_align\", reason = \"method was just created\",\n               issue = \"27726\")]\n    pub fn align(&self) -> Alignment {\n        match self.align {\n            rt::v1::Alignment::Left => Alignment::Left,\n            rt::v1::Alignment::Right => Alignment::Right,\n            rt::v1::Alignment::Center => Alignment::Center,\n            rt::v1::Alignment::Unknown => Alignment::Unknown,\n        }\n    }\n\n    /// Optionally specified integer width that the output should be\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn width(&self) -> Option<usize> { self.width }\n\n    /// Optionally specified precision for numeric types\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn precision(&self) -> Option<usize> { self.precision }\n\n    /// Determines if the `+` flag was specified.\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_plus(&self) -> bool { self.flags & (1 << FlagV1::SignPlus as u32) != 0 }\n\n    /// Determines if the `-` flag was specified.\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_minus(&self) -> bool { self.flags & (1 << FlagV1::SignMinus as u32) != 0 }\n\n    /// Determines if the `#` flag was specified.\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn alternate(&self) -> bool { self.flags & (1 << FlagV1::Alternate as u32) != 0 }\n\n    /// Determines if the `0` flag was specified.\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_aware_zero_pad(&self) -> bool {\n        self.flags & (1 << FlagV1::SignAwareZeroPad as u32) != 0\n    }\n\n    /// Creates a [`DebugStruct`] builder designed to assist with creation of\n    /// [`fmt::Debug`] implementations for structs.\n    ///\n    /// [`DebugStruct`]: ../../std/fmt/struct.DebugStruct.html\n    /// [`fmt::Debug`]: ../../std/fmt/trait.Debug.html\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo {\n    ///     bar: i32,\n    ///     baz: String,\n    /// }\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_struct(\"Foo\")\n    ///             .field(\"bar\", &self.bar)\n    ///             .field(\"baz\", &self.baz)\n    ///             .finish()\n    ///     }\n    /// }\n    ///\n    /// // prints \"Foo { bar: 10, baz: \"Hello World\" }\"\n    /// println!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() });\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> {\n        builders::debug_struct_new(self, name)\n    }\n\n    /// Creates a `DebugTuple` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for tuple structs.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32, String);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_tuple(\"Foo\")\n    ///             .field(&self.0)\n    ///             .field(&self.1)\n    ///             .finish()\n    ///     }\n    /// }\n    ///\n    /// // prints \"Foo(10, \"Hello World\")\"\n    /// println!(\"{:?}\", Foo(10, \"Hello World\".to_string()));\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> {\n        builders::debug_tuple_new(self, name)\n    }\n\n    /// Creates a `DebugList` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for list-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_list().entries(self.0.iter()).finish()\n    ///     }\n    /// }\n    ///\n    /// // prints \"[10, 11]\"\n    /// println!(\"{:?}\", Foo(vec![10, 11]));\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_list<'b>(&'b mut self) -> DebugList<'b, 'a> {\n        builders::debug_list_new(self)\n    }\n\n    /// Creates a `DebugSet` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for set-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_set().entries(self.0.iter()).finish()\n    ///     }\n    /// }\n    ///\n    /// // prints \"{10, 11}\"\n    /// println!(\"{:?}\", Foo(vec![10, 11]));\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_set<'b>(&'b mut self) -> DebugSet<'b, 'a> {\n        builders::debug_set_new(self)\n    }\n\n    /// Creates a `DebugMap` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for map-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<(String, i32)>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref v)| (k, v))).finish()\n    ///     }\n    /// }\n    ///\n    /// // prints \"{\"A\": 10, \"B\": 11}\"\n    /// println!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)]));\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_map<'b>(&'b mut self) -> DebugMap<'b, 'a> {\n        builders::debug_map_new(self)\n    }\n}\n\n#[stable(since = \"1.2.0\", feature = \"formatter_write\")]\nimpl<'a> Write for Formatter<'a> {\n    fn write_str(&mut self, s: &str) -> Result {\n        self.buf.write_str(s)\n    }\n\n    fn write_char(&mut self, c: char) -> Result {\n        self.buf.write_char(c)\n    }\n\n    fn write_fmt(&mut self, args: Arguments) -> Result {\n        write(self.buf, args)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for Error {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Display::fmt(\"an error occurred when formatting an argument\", f)\n    }\n}\n\n// Implementations of the core formatting traits\n\nmacro_rules! fmt_refs {\n    ($($tr:ident),*) => {\n        $(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T: ?Sized + $tr> $tr for &'a T {\n            fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n        }\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T: ?Sized + $tr> $tr for &'a mut T {\n            fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n        }\n        )*\n    }\n}\n\nfmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl Debug for ! {\n    fn fmt(&self, _: &mut Formatter) -> Result {\n        *self\n    }\n}\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl Display for ! {\n    fn fmt(&self, _: &mut Formatter) -> Result {\n        *self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for bool {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Display::fmt(self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for bool {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Display::fmt(if *self { \"true\" } else { \"false\" }, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for str {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.write_char('\"')?;\n        let mut from = 0;\n        for (i, c) in self.char_indices() {\n            let esc = c.escape_debug();\n            // If char needs escaping, flush backlog so far and write, else skip\n            if esc.len() != 1 {\n                f.write_str(&self[from..i])?;\n                for c in esc {\n                    f.write_char(c)?;\n                }\n                from = i + c.len_utf8();\n            }\n        }\n        f.write_str(&self[from..])?;\n        f.write_char('\"')\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for str {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.pad(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for char {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.write_char('\\'')?;\n        for c in self.escape_debug() {\n            f.write_char(c)?\n        }\n        f.write_char('\\'')\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for char {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        if f.width.is_none() && f.precision.is_none() {\n            f.write_char(*self)\n        } else {\n            f.pad(self.encode_utf8(&mut [0; 4]))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Pointer for *const T {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        let old_width = f.width;\n        let old_flags = f.flags;\n\n        // The alternate flag is already treated by LowerHex as being special-\n        // it denotes whether to prefix with 0x. We use it to work out whether\n        // or not to zero extend, and then unconditionally set it to get the\n        // prefix.\n        if f.alternate() {\n            f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n\n            if let None = f.width {\n                f.width = Some(((mem::size_of::<usize>() * 8) / 4) + 2);\n            }\n        }\n        f.flags |= 1 << (FlagV1::Alternate as u32);\n\n        let ret = LowerHex::fmt(&(*self as *const () as usize), f);\n\n        f.width = old_width;\n        f.flags = old_flags;\n\n        ret\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Pointer for *mut T {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Pointer::fmt(&(*self as *const T), f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized> Pointer for &'a T {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Pointer::fmt(&(*self as *const T), f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized> Pointer for &'a mut T {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Pointer::fmt(&(&**self as *const T), f)\n    }\n}\n\n// Implementation of Display/Debug for various core types\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Debug for *const T {\n    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Debug for *mut T {\n    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n}\n\nmacro_rules! peel {\n    ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n}\n\nmacro_rules! tuple {\n    () => ();\n    ( $($name:ident,)+ ) => (\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<$($name:Debug),*> Debug for ($($name,)*) where last_type!($($name,)+): ?Sized {\n            #[allow(non_snake_case, unused_assignments, deprecated)]\n            fn fmt(&self, f: &mut Formatter) -> Result {\n                let mut builder = f.debug_tuple(\"\");\n                let ($(ref $name,)*) = *self;\n                $(\n                    builder.field(&$name);\n                )*\n\n                builder.finish()\n            }\n        }\n        peel! { $($name,)* }\n    )\n}\n\nmacro_rules! last_type {\n    ($a:ident,) => { $a };\n    ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n}\n\ntuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Debug> Debug for [T] {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for () {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.pad(\"()\")\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Debug for PhantomData<T> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.pad(\"PhantomData\")\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Copy + Debug> Debug for Cell<T> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.debug_struct(\"Cell\")\n            .field(\"value\", &self.get())\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Debug> Debug for RefCell<T> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        match self.try_borrow() {\n            Ok(borrow) => {\n                f.debug_struct(\"RefCell\")\n                    .field(\"value\", &borrow)\n                    .finish()\n            }\n            Err(_) => {\n                // The RefCell is mutably borrowed so we can't look at its value\n                // here. Show a placeholder instead.\n                struct BorrowedPlaceholder;\n\n                impl Debug for BorrowedPlaceholder {\n                    fn fmt(&self, f: &mut Formatter) -> Result {\n                        f.write_str(\"<borrowed>\")\n                    }\n                }\n\n                f.debug_struct(\"RefCell\")\n                    .field(\"value\", &BorrowedPlaceholder)\n                    .finish()\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'b, T: ?Sized + Debug> Debug for Ref<'b, T> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'b, T: ?Sized + Debug> Debug for RefMut<'b, T> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        Debug::fmt(&*(self.deref()), f)\n    }\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: ?Sized + Debug> Debug for UnsafeCell<T> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        f.pad(\"UnsafeCell\")\n    }\n}\n\n// If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n// it's a lot easier than creating all of the rt::Piece structures here.\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A UTF-8 encoded, growable string.\n//!\n//! This module contains the [`String`] type, a trait for converting\n//! [`ToString`]s, and several error types that may result from working with\n//! [`String`]s.\n//!\n//! [`ToString`]: trait.ToString.html\n//!\n//! # Examples\n//!\n//! There are multiple ways to create a new [`String`] from a string literal:\n//!\n//! ```\n//! let s = \"Hello\".to_string();\n//!\n//! let s = String::from(\"world\");\n//! let s: String = \"also this\".into();\n//! ```\n//!\n//! You can create a new [`String`] from an existing one by concatenating with\n//! `+`:\n//!\n//! [`String`]: struct.String.html\n//!\n//! ```\n//! let s = \"Hello\".to_string();\n//!\n//! let message = s + \" world!\";\n//! ```\n//!\n//! If you have a vector of valid UTF-8 bytes, you can make a [`String`] out of\n//! it. You can do the reverse too.\n//!\n//! ```\n//! let sparkle_heart = vec![240, 159, 146, 150];\n//!\n//! // We know these bytes are valid, so we'll use `unwrap()`.\n//! let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n//!\n//! assert_eq!(\"💖\", sparkle_heart);\n//!\n//! let bytes = sparkle_heart.into_bytes();\n//!\n//! assert_eq!(bytes, [240, 159, 146, 150]);\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::fmt;\nuse core::hash;\nuse core::iter::{FromIterator, FusedIterator};\nuse core::ops::{self, Add, AddAssign, Index, IndexMut};\nuse core::ptr;\nuse core::str::pattern::Pattern;\nuse std_unicode::lossy;\nuse std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n\nuse borrow::{Cow, ToOwned};\nuse range::RangeArgument;\nuse Bound::{Excluded, Included, Unbounded};\nuse str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\nuse vec::Vec;\nuse boxed::Box;\n\n/// A UTF-8 encoded, growable string.\n///\n/// The `String` type is the most common string type that has ownership over the\n/// contents of the string. It has a close relationship with its borrowed\n/// counterpart, the primitive [`str`].\n///\n/// [`str`]: ../../std/primitive.str.html\n///\n/// # Examples\n///\n/// You can create a `String` from a literal string with [`String::from`]:\n///\n/// ```\n/// let hello = String::from(\"Hello, world!\");\n/// ```\n///\n/// You can append a [`char`] to a `String` with the [`push`] method, and\n/// append a [`&str`] with the [`push_str`] method:\n///\n/// ```\n/// let mut hello = String::from(\"Hello, \");\n///\n/// hello.push('w');\n/// hello.push_str(\"orld!\");\n/// ```\n///\n/// [`String::from`]: #method.from\n/// [`char`]: ../../std/primitive.char.html\n/// [`push`]: #method.push\n/// [`push_str`]: #method.push_str\n///\n/// If you have a vector of UTF-8 bytes, you can create a `String` from it with\n/// the [`from_utf8`] method:\n///\n/// ```\n/// // some bytes, in a vector\n/// let sparkle_heart = vec![240, 159, 146, 150];\n///\n/// // We know these bytes are valid, so we'll use `unwrap()`.\n/// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n///\n/// assert_eq!(\"💖\", sparkle_heart);\n/// ```\n///\n/// [`from_utf8`]: #method.from_utf8\n///\n/// # UTF-8\n///\n/// `String`s are always valid UTF-8. This has a few implications, the first of\n/// which is that if you need a non-UTF-8 string, consider [`OsString`]. It is\n/// similar, but without the UTF-8 constraint. The second implication is that\n/// you cannot index into a `String`:\n///\n/// ```compile_fail,E0277\n/// let s = \"hello\";\n///\n/// println!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n/// ```\n///\n/// [`OsString`]: ../../std/ffi/struct.OsString.html\n///\n/// Indexing is intended to be a constant-time operation, but UTF-8 encoding\n/// does not allow us to do this. Furthermore, it's not clear what sort of\n/// thing the index should return: a byte, a codepoint, or a grapheme cluster.\n/// The [`bytes`] and [`chars`] methods return iterators over the first\n/// two, respectively.\n///\n/// [`bytes`]: #method.bytes\n/// [`chars`]: #method.chars\n///\n/// # Deref\n///\n/// `String`s implement [`Deref`]`<Target=str>`, and so inherit all of [`str`]'s\n/// methods. In addition, this means that you can pass a `String` to a\n/// function which takes a [`&str`] by using an ampersand (`&`):\n///\n/// ```\n/// fn takes_str(s: &str) { }\n///\n/// let s = String::from(\"Hello\");\n///\n/// takes_str(&s);\n/// ```\n///\n/// This will create a [`&str`] from the `String` and pass it in. This\n/// conversion is very inexpensive, and so generally, functions will accept\n/// [`&str`]s as arguments unless they need a `String` for some specific\n/// reason.\n///\n/// In certain cases Rust doesn't have enough information to make this\n/// conversion, known as [`Deref`] coercion. In the following example a string\n/// slice [`&'a str`][`&str`] implements the trait `TraitExample`, and the function\n/// `example_func` takes anything that implements the trait. In this case Rust\n/// would need to make two implicit conversions, which Rust doesn't have the\n/// means to do. For that reason, the following example will not compile.\n///\n/// ```compile_fail,E0277\n/// trait TraitExample {}\n///\n/// impl<'a> TraitExample for &'a str {}\n///\n/// fn example_func<A: TraitExample>(example_arg: A) {}\n///\n/// fn main() {\n///     let example_string = String::from(\"example_string\");\n///     example_func(&example_string);\n/// }\n/// ```\n///\n/// There are two options that would work instead. The first would be to\n/// change the line `example_func(&example_string);` to\n/// `example_func(example_string.as_str());`, using the method [`as_str()`]\n/// to explicitly extract the string slice containing the string. The second\n/// way changes `example_func(&example_string);` to\n/// `example_func(&*example_string);`. In this case we are dereferencing a\n/// `String` to a [`str`][`&str`], then referencing the [`str`][`&str`] back to\n/// [`&str`]. The second way is more idiomatic, however both work to do the\n/// conversion explicitly rather than relying on the implicit conversion.\n///\n/// # Representation\n///\n/// A `String` is made up of three components: a pointer to some bytes, a\n/// length, and a capacity. The pointer points to an internal buffer `String`\n/// uses to store its data. The length is the number of bytes currently stored\n/// in the buffer, and the capacity is the size of the buffer in bytes. As such,\n/// the length will always be less than or equal to the capacity.\n///\n/// This buffer is always stored on the heap.\n///\n/// You can look at these with the [`as_ptr`], [`len`], and [`capacity`]\n/// methods:\n///\n/// ```\n/// use std::mem;\n///\n/// let story = String::from(\"Once upon a time...\");\n///\n/// let ptr = story.as_ptr();\n/// let len = story.len();\n/// let capacity = story.capacity();\n///\n/// // story has nineteen bytes\n/// assert_eq!(19, len);\n///\n/// // Now that we have our parts, we throw the story away.\n/// mem::forget(story);\n///\n/// // We can re-build a String out of ptr, len, and capacity. This is all\n/// // unsafe because we are responsible for making sure the components are\n/// // valid:\n/// let s = unsafe { String::from_raw_parts(ptr as *mut _, len, capacity) } ;\n///\n/// assert_eq!(String::from(\"Once upon a time...\"), s);\n/// ```\n///\n/// [`as_ptr`]: #method.as_ptr\n/// [`len`]: #method.len\n/// [`capacity`]: #method.capacity\n///\n/// If a `String` has enough capacity, adding elements to it will not\n/// re-allocate. For example, consider this program:\n///\n/// ```\n/// let mut s = String::new();\n///\n/// println!(\"{}\", s.capacity());\n///\n/// for _ in 0..5 {\n///     s.push_str(\"hello\");\n///     println!(\"{}\", s.capacity());\n/// }\n/// ```\n///\n/// This will output the following:\n///\n/// ```text\n/// 0\n/// 5\n/// 10\n/// 20\n/// 20\n/// 40\n/// ```\n///\n/// At first, we have no memory allocated at all, but as we append to the\n/// string, it increases its capacity appropriately. If we instead use the\n/// [`with_capacity`] method to allocate the correct capacity initially:\n///\n/// ```\n/// let mut s = String::with_capacity(25);\n///\n/// println!(\"{}\", s.capacity());\n///\n/// for _ in 0..5 {\n///     s.push_str(\"hello\");\n///     println!(\"{}\", s.capacity());\n/// }\n/// ```\n///\n/// [`with_capacity`]: #method.with_capacity\n///\n/// We end up with a different output:\n///\n/// ```text\n/// 25\n/// 25\n/// 25\n/// 25\n/// 25\n/// 25\n/// ```\n///\n/// Here, there's no need to allocate more memory inside the loop.\n///\n/// [`&str`]: ../../std/primitive.str.html\n/// [`Deref`]: ../../std/ops/trait.Deref.html\n/// [`as_str()`]: struct.String.html#method.as_str\n#[derive(PartialOrd, Eq, Ord)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct String {\n    vec: Vec<u8>,\n}\n\n/// A possible error value when converting a `String` from a UTF-8 byte vector.\n///\n/// This type is the error type for the [`from_utf8`] method on [`String`]. It\n/// is designed in such a way to carefully avoid reallocations: the\n/// [`into_bytes`] method will give back the byte vector that was used in the\n/// conversion attempt.\n///\n/// [`from_utf8`]: struct.String.html#method.from_utf8\n/// [`String`]: struct.String.html\n/// [`into_bytes`]: struct.FromUtf8Error.html#method.into_bytes\n///\n/// The [`Utf8Error`] type provided by [`std::str`] represents an error that may\n/// occur when converting a slice of [`u8`]s to a [`&str`]. In this sense, it's\n/// an analogue to `FromUtf8Error`, and you can get one from a `FromUtf8Error`\n/// through the [`utf8_error`] method.\n///\n/// [`Utf8Error`]: ../../std/str/struct.Utf8Error.html\n/// [`std::str`]: ../../std/str/index.html\n/// [`u8`]: ../../std/primitive.u8.html\n/// [`&str`]: ../../std/primitive.str.html\n/// [`utf8_error`]: #method.utf8_error\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // some invalid bytes, in a vector\n/// let bytes = vec![0, 159];\n///\n/// let value = String::from_utf8(bytes);\n///\n/// assert!(value.is_err());\n/// assert_eq!(vec![0, 159], value.unwrap_err().into_bytes());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct FromUtf8Error {\n    bytes: Vec<u8>,\n    error: Utf8Error,\n}\n\n/// A possible error value when converting a `String` from a UTF-16 byte slice.\n///\n/// This type is the error type for the [`from_utf16`] method on [`String`].\n///\n/// [`from_utf16`]: struct.String.html#method.from_utf16\n/// [`String`]: struct.String.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // 𝄞mu<invalid>ic\n/// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n///           0xD800, 0x0069, 0x0063];\n///\n/// assert!(String::from_utf16(v).is_err());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct FromUtf16Error(());\n\nimpl String {\n    /// Creates a new empty `String`.\n    ///\n    /// Given that the `String` is empty, this will not allocate any initial\n    /// buffer. While that means that this initial operation is very\n    /// inexpensive, but may cause excessive allocation later, when you add\n    /// data. If you have an idea of how much data the `String` will hold,\n    /// consider the [`with_capacity`] method to prevent excessive\n    /// re-allocation.\n    ///\n    /// [`with_capacity`]: #method.with_capacity\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::new();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> String {\n        String { vec: Vec::new() }\n    }\n\n    /// Creates a new empty `String` with a particular capacity.\n    ///\n    /// `String`s have an internal buffer to hold their data. The capacity is\n    /// the length of that buffer, and can be queried with the [`capacity`]\n    /// method. This method creates an empty `String`, but one with an initial\n    /// buffer that can hold `capacity` bytes. This is useful when you may be\n    /// appending a bunch of data to the `String`, reducing the number of\n    /// reallocations it needs to do.\n    ///\n    /// [`capacity`]: #method.capacity\n    ///\n    /// If the given capacity is `0`, no allocation will occur, and this method\n    /// is identical to the [`new`] method.\n    ///\n    /// [`new`]: #method.new\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::with_capacity(10);\n    ///\n    /// // The String contains no chars, even though it has capacity for more\n    /// assert_eq!(s.len(), 0);\n    ///\n    /// // These are all done without reallocating...\n    /// let cap = s.capacity();\n    /// for i in 0..10 {\n    ///     s.push('a');\n    /// }\n    ///\n    /// assert_eq!(s.capacity(), cap);\n    ///\n    /// // ...but this may make the vector reallocate\n    /// s.push('a');\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> String {\n        String { vec: Vec::with_capacity(capacity) }\n    }\n\n    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n    // required for this method definition, is not available. Since we don't\n    // require this method for testing purposes, I'll just stub it\n    // NB see the slice::hack module in slice.rs for more information\n    #[inline]\n    #[cfg(test)]\n    pub fn from_str(_: &str) -> String {\n        panic!(\"not available with cfg(test)\");\n    }\n\n    /// Converts a vector of bytes to a `String`.\n    ///\n    /// A string slice ([`&str`]) is made of bytes ([`u8`]), and a vector of bytes\n    /// ([`Vec<u8>`]) is made of bytes, so this function converts between the\n    /// two. Not all byte slices are valid `String`s, however: `String`\n    /// requires that it is valid UTF-8. `from_utf8()` checks to ensure that\n    /// the bytes are valid UTF-8, and then does the conversion.\n    ///\n    /// If you are sure that the byte slice is valid UTF-8, and you don't want\n    /// to incur the overhead of the validity check, there is an unsafe version\n    /// of this function, [`from_utf8_unchecked`], which has the same behavior\n    /// but skips the check.\n    ///\n    /// This method will take care to not copy the vector, for efficiency's\n    /// sake.\n    ///\n    /// If you need a [`&str`] instead of a `String`, consider\n    /// [`str::from_utf8`].\n    ///\n    /// The inverse of this method is [`as_bytes`].\n    ///\n    /// # Errors\n    ///\n    /// Returns [`Err`] if the slice is not UTF-8 with a description as to why the\n    /// provided bytes are not UTF-8. The vector you moved in is also included.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some bytes, in a vector\n    /// let sparkle_heart = vec![240, 159, 146, 150];\n    ///\n    /// // We know these bytes are valid, so we'll use `unwrap()`.\n    /// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n    ///\n    /// assert_eq!(\"💖\", sparkle_heart);\n    /// ```\n    ///\n    /// Incorrect bytes:\n    ///\n    /// ```\n    /// // some invalid bytes, in a vector\n    /// let sparkle_heart = vec![0, 159, 146, 150];\n    ///\n    /// assert!(String::from_utf8(sparkle_heart).is_err());\n    /// ```\n    ///\n    /// See the docs for [`FromUtf8Error`] for more details on what you can do\n    /// with this error.\n    ///\n    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n    /// [`&str`]: ../../std/primitive.str.html\n    /// [`u8`]: ../../std/primitive.u8.html\n    /// [`Vec<u8>`]: ../../std/vec/struct.Vec.html\n    /// [`str::from_utf8`]: ../../std/str/fn.from_utf8.html\n    /// [`as_bytes`]: struct.String.html#method.as_bytes\n    /// [`FromUtf8Error`]: struct.FromUtf8Error.html\n    /// [`Err`]: ../../stdresult/enum.Result.html#variant.Err\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n        match str::from_utf8(&vec) {\n            Ok(..) => Ok(String { vec: vec }),\n            Err(e) => {\n                Err(FromUtf8Error {\n                    bytes: vec,\n                    error: e,\n                })\n            }\n        }\n    }\n\n    /// Converts a slice of bytes to a string, including invalid characters.\n    ///\n    /// Strings are made of bytes ([`u8`]), and a slice of bytes\n    /// ([`&[u8]`][byteslice]) is made of bytes, so this function converts\n    /// between the two. Not all byte slices are valid strings, however: strings\n    /// are required to be valid UTF-8. During this conversion,\n    /// `from_utf8_lossy()` will replace any invalid UTF-8 sequences with\n    /// `U+FFFD REPLACEMENT CHARACTER`, which looks like this: �\n    ///\n    /// [`u8`]: ../../std/primitive.u8.html\n    /// [byteslice]: ../../std/primitive.slice.html\n    ///\n    /// If you are sure that the byte slice is valid UTF-8, and you don't want\n    /// to incur the overhead of the conversion, there is an unsafe version\n    /// of this function, [`from_utf8_unchecked`], which has the same behavior\n    /// but skips the checks.\n    ///\n    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n    ///\n    /// This function returns a [`Cow<'a, str>`]. If our byte slice is invalid\n    /// UTF-8, then we need to insert the replacement characters, which will\n    /// change the size of the string, and hence, require a `String`. But if\n    /// it's already valid UTF-8, we don't need a new allocation. This return\n    /// type allows us to handle both cases.\n    ///\n    /// [`Cow<'a, str>`]: ../../std/borrow/enum.Cow.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some bytes, in a vector\n    /// let sparkle_heart = vec![240, 159, 146, 150];\n    ///\n    /// let sparkle_heart = String::from_utf8_lossy(&sparkle_heart);\n    ///\n    /// assert_eq!(\"💖\", sparkle_heart);\n    /// ```\n    ///\n    /// Incorrect bytes:\n    ///\n    /// ```\n    /// // some invalid bytes\n    /// let input = b\"Hello \\xF0\\x90\\x80World\";\n    /// let output = String::from_utf8_lossy(input);\n    ///\n    /// assert_eq!(\"Hello �World\", output);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> Cow<'a, str> {\n        let mut iter = lossy::Utf8Lossy::from_bytes(v).chunks();\n\n        let (first_valid, first_broken) = if let Some(chunk) = iter.next() {\n            let lossy::Utf8LossyChunk { valid, broken } = chunk;\n            if valid.len() == v.len() {\n                debug_assert!(broken.is_empty());\n                return Cow::Borrowed(valid);\n            }\n            (valid, broken)\n        } else {\n            return Cow::Borrowed(\"\");\n        };\n\n        const REPLACEMENT: &'static str = \"\\u{FFFD}\";\n\n        let mut res = String::with_capacity(v.len());\n        res.push_str(first_valid);\n        if !first_broken.is_empty() {\n            res.push_str(REPLACEMENT);\n        }\n\n        for lossy::Utf8LossyChunk { valid, broken } in iter {\n            res.push_str(valid);\n            if !broken.is_empty() {\n                res.push_str(REPLACEMENT);\n            }\n        }\n\n        Cow::Owned(res)\n    }\n\n    /// Decode a UTF-16 encoded vector `v` into a `String`, returning [`Err`]\n    /// if `v` contains any invalid data.\n    ///\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // 𝄞music\n    /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n    ///           0x0073, 0x0069, 0x0063];\n    /// assert_eq!(String::from(\"𝄞music\"),\n    ///            String::from_utf16(v).unwrap());\n    ///\n    /// // 𝄞mu<invalid>ic\n    /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n    ///           0xD800, 0x0069, 0x0063];\n    /// assert!(String::from_utf16(v).is_err());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n        decode_utf16(v.iter().cloned()).collect::<Result<_, _>>().map_err(|_| FromUtf16Error(()))\n    }\n\n    /// Decode a UTF-16 encoded slice `v` into a `String`, replacing\n    /// invalid data with the replacement character (U+FFFD).\n    ///\n    /// Unlike [`from_utf8_lossy`] which returns a [`Cow<'a, str>`],\n    /// `from_utf16_lossy` returns a `String` since the UTF-16 to UTF-8\n    /// conversion requires a memory allocation.\n    ///\n    /// [`from_utf8_lossy`]: #method.from_utf8_lossy\n    /// [`Cow<'a, str>`]: ../borrow/enum.Cow.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // 𝄞mus<invalid>ic<invalid>\n    /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n    ///           0x0073, 0xDD1E, 0x0069, 0x0063,\n    ///           0xD834];\n    ///\n    /// assert_eq!(String::from(\"𝄞mus\\u{FFFD}ic\\u{FFFD}\"),\n    ///            String::from_utf16_lossy(v));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_utf16_lossy(v: &[u16]) -> String {\n        decode_utf16(v.iter().cloned()).map(|r| r.unwrap_or(REPLACEMENT_CHARACTER)).collect()\n    }\n\n    /// Creates a new `String` from a length, capacity, and pointer.\n    ///\n    /// # Safety\n    ///\n    /// This is highly unsafe, due to the number of invariants that aren't\n    /// checked:\n    ///\n    /// * The memory at `ptr` needs to have been previously allocated by the\n    ///   same allocator the standard library uses.\n    /// * `length` needs to be less than or equal to `capacity`.\n    /// * `capacity` needs to be the correct value.\n    ///\n    /// Violating these may cause problems like corrupting the allocator's\n    /// internal data structures.\n    ///\n    /// The ownership of `ptr` is effectively transferred to the\n    /// `String` which may then deallocate, reallocate or change the\n    /// contents of memory pointed to by the pointer at will. Ensure\n    /// that nothing else uses the pointer after calling this\n    /// function.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::mem;\n    ///\n    /// unsafe {\n    ///     let s = String::from(\"hello\");\n    ///     let ptr = s.as_ptr();\n    ///     let len = s.len();\n    ///     let capacity = s.capacity();\n    ///\n    ///     mem::forget(s);\n    ///\n    ///     let s = String::from_raw_parts(ptr as *mut _, len, capacity);\n    ///\n    ///     assert_eq!(String::from(\"hello\"), s);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_raw_parts(buf: *mut u8, length: usize, capacity: usize) -> String {\n        String { vec: Vec::from_raw_parts(buf, length, capacity) }\n    }\n\n    /// Converts a vector of bytes to a `String` without checking that the\n    /// string contains valid UTF-8.\n    ///\n    /// See the safe version, [`from_utf8`], for more details.\n    ///\n    /// [`from_utf8`]: struct.String.html#method.from_utf8\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because it does not check that the bytes passed\n    /// to it are valid UTF-8. If this constraint is violated, it may cause\n    /// memory unsafety issues with future users of the `String`, as the rest of\n    /// the standard library assumes that `String`s are valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some bytes, in a vector\n    /// let sparkle_heart = vec![240, 159, 146, 150];\n    ///\n    /// let sparkle_heart = unsafe {\n    ///     String::from_utf8_unchecked(sparkle_heart)\n    /// };\n    ///\n    /// assert_eq!(\"💖\", sparkle_heart);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {\n        String { vec: bytes }\n    }\n\n    /// Converts a `String` into a byte vector.\n    ///\n    /// This consumes the `String`, so we do not need to copy its contents.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::from(\"hello\");\n    /// let bytes = s.into_bytes();\n    ///\n    /// assert_eq!(&[104, 101, 108, 108, 111][..], &bytes[..]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_bytes(self) -> Vec<u8> {\n        self.vec\n    }\n\n    /// Extracts a string slice containing the entire string.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::from(\"foo\");\n    ///\n    /// assert_eq!(\"foo\", s.as_str());\n    /// ```\n    #[inline]\n    #[stable(feature = \"string_as_str\", since = \"1.7.0\")]\n    pub fn as_str(&self) -> &str {\n        self\n    }\n\n    /// Converts a `String` into a mutable string slice.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foobar\");\n    /// let s_mut_str = s.as_mut_str();\n    ///\n    /// s_mut_str.make_ascii_uppercase();\n    ///\n    /// assert_eq!(\"FOOBAR\", s_mut_str);\n    /// ```\n    #[inline]\n    #[stable(feature = \"string_as_str\", since = \"1.7.0\")]\n    pub fn as_mut_str(&mut self) -> &mut str {\n        self\n    }\n\n    /// Appends a given string slice onto the end of this `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// s.push_str(\"bar\");\n    ///\n    /// assert_eq!(\"foobar\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push_str(&mut self, string: &str) {\n        self.vec.extend_from_slice(string.as_bytes())\n    }\n\n    /// Returns this `String`'s capacity, in bytes.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::with_capacity(10);\n    ///\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n        self.vec.capacity()\n    }\n\n    /// Ensures that this `String`'s capacity is at least `additional` bytes\n    /// larger than its length.\n    ///\n    /// The capacity may be increased by more than `additional` bytes if it\n    /// chooses, to prevent frequent reallocations.\n    ///\n    /// If you do not want this \"at least\" behavior, see the [`reserve_exact`]\n    /// method.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows [`usize`].\n    ///\n    /// [`reserve_exact`]: struct.String.html#method.reserve_exact\n    /// [`usize`]: ../../std/primitive.usize.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::new();\n    ///\n    /// s.reserve(10);\n    ///\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    ///\n    /// This may not actually increase the capacity:\n    ///\n    /// ```\n    /// let mut s = String::with_capacity(10);\n    /// s.push('a');\n    /// s.push('b');\n    ///\n    /// // s now has a length of 2 and a capacity of 10\n    /// assert_eq!(2, s.len());\n    /// assert_eq!(10, s.capacity());\n    ///\n    /// // Since we already have an extra 8 capacity, calling this...\n    /// s.reserve(8);\n    ///\n    /// // ... doesn't actually increase.\n    /// assert_eq!(10, s.capacity());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n        self.vec.reserve(additional)\n    }\n\n    /// Ensures that this `String`'s capacity is `additional` bytes\n    /// larger than its length.\n    ///\n    /// Consider using the [`reserve`] method unless you absolutely know\n    /// better than the allocator.\n    ///\n    /// [`reserve`]: #method.reserve\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::new();\n    ///\n    /// s.reserve_exact(10);\n    ///\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    ///\n    /// This may not actually increase the capacity:\n    ///\n    /// ```\n    /// let mut s = String::with_capacity(10);\n    /// s.push('a');\n    /// s.push('b');\n    ///\n    /// // s now has a length of 2 and a capacity of 10\n    /// assert_eq!(2, s.len());\n    /// assert_eq!(10, s.capacity());\n    ///\n    /// // Since we already have an extra 8 capacity, calling this...\n    /// s.reserve_exact(8);\n    ///\n    /// // ... doesn't actually increase.\n    /// assert_eq!(10, s.capacity());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.vec.reserve_exact(additional)\n    }\n\n    /// Shrinks the capacity of this `String` to match its length.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// s.reserve(100);\n    /// assert!(s.capacity() >= 100);\n    ///\n    /// s.shrink_to_fit();\n    /// assert_eq!(3, s.capacity());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n        self.vec.shrink_to_fit()\n    }\n\n    /// Appends the given [`char`] to the end of this `String`.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"abc\");\n    ///\n    /// s.push('1');\n    /// s.push('2');\n    /// s.push('3');\n    ///\n    /// assert_eq!(\"abc123\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push(&mut self, ch: char) {\n        match ch.len_utf8() {\n            1 => self.vec.push(ch as u8),\n            _ => self.vec.extend_from_slice(ch.encode_utf8(&mut [0; 4]).as_bytes()),\n        }\n    }\n\n    /// Returns a byte slice of this `String`'s contents.\n    ///\n    /// The inverse of this method is [`from_utf8`].\n    ///\n    /// [`from_utf8`]: #method.from_utf8\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::from(\"hello\");\n    ///\n    /// assert_eq!(&[104, 101, 108, 108, 111], s.as_bytes());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_bytes(&self) -> &[u8] {\n        &self.vec\n    }\n\n    /// Shortens this `String` to the specified length.\n    ///\n    /// If `new_len` is greater than the string's current length, this has no\n    /// effect.\n    ///\n    /// Note that this method has no effect on the allocated capacity\n    /// of the string\n    ///\n    /// # Panics\n    ///\n    /// Panics if `new_len` does not lie on a [`char`] boundary.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"hello\");\n    ///\n    /// s.truncate(2);\n    ///\n    /// assert_eq!(\"he\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn truncate(&mut self, new_len: usize) {\n        if new_len <= self.len() {\n            assert!(self.is_char_boundary(new_len));\n            self.vec.truncate(new_len)\n        }\n    }\n\n    /// Removes the last character from the string buffer and returns it.\n    ///\n    /// Returns [`None`] if this `String` is empty.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// assert_eq!(s.pop(), Some('o'));\n    /// assert_eq!(s.pop(), Some('o'));\n    /// assert_eq!(s.pop(), Some('f'));\n    ///\n    /// assert_eq!(s.pop(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop(&mut self) -> Option<char> {\n        let ch = self.chars().rev().next()?;\n        let newlen = self.len() - ch.len_utf8();\n        unsafe {\n            self.vec.set_len(newlen);\n        }\n        Some(ch)\n    }\n\n    /// Removes a [`char`] from this `String` at a byte position and returns it.\n    ///\n    /// This is an `O(n)` operation, as it requires copying every element in the\n    /// buffer.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `idx` is larger than or equal to the `String`'s length,\n    /// or if it does not lie on a [`char`] boundary.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// assert_eq!(s.remove(0), 'f');\n    /// assert_eq!(s.remove(1), 'o');\n    /// assert_eq!(s.remove(0), 'o');\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove(&mut self, idx: usize) -> char {\n        let ch = match self[idx..].chars().next() {\n            Some(ch) => ch,\n            None => panic!(\"cannot remove a char from the end of a string\"),\n        };\n\n        let next = idx + ch.len_utf8();\n        let len = self.len();\n        unsafe {\n            ptr::copy(self.vec.as_ptr().offset(next as isize),\n                      self.vec.as_mut_ptr().offset(idx as isize),\n                      len - next);\n            self.vec.set_len(len - (next - idx));\n        }\n        ch\n    }\n\n    /// Retains only the characters specified by the predicate.\n    ///\n    /// In other words, remove all characters `c` such that `f(c)` returns `false`.\n    /// This method operates in place and preserves the order of the retained\n    /// characters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(string_retain)]\n    ///\n    /// let mut s = String::from(\"f_o_ob_ar\");\n    ///\n    /// s.retain(|c| c != '_');\n    ///\n    /// assert_eq!(s, \"foobar\");\n    /// ```\n    #[inline]\n    #[unstable(feature = \"string_retain\", issue = \"43874\")]\n    pub fn retain<F>(&mut self, mut f: F)\n        where F: FnMut(char) -> bool\n    {\n        let len = self.len();\n        let mut del_bytes = 0;\n        let mut idx = 0;\n\n        while idx < len {\n            let ch = unsafe {\n                self.slice_unchecked(idx, len).chars().next().unwrap()\n            };\n            let ch_len = ch.len_utf8();\n\n            if !f(ch) {\n                del_bytes += ch_len;\n            } else if del_bytes > 0 {\n                unsafe {\n                    ptr::copy(self.vec.as_ptr().offset(idx as isize),\n                              self.vec.as_mut_ptr().offset((idx - del_bytes) as isize),\n                              ch_len);\n                }\n            }\n\n            // Point idx to the next char\n            idx += ch_len;\n        }\n\n        if del_bytes > 0 {\n            unsafe { self.vec.set_len(len - del_bytes); }\n        }\n    }\n\n    /// Inserts a character into this `String` at a byte position.\n    ///\n    /// This is an `O(n)` operation as it requires copying every element in the\n    /// buffer.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `idx` is larger than the `String`'s length, or if it does not\n    /// lie on a [`char`] boundary.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::with_capacity(3);\n    ///\n    /// s.insert(0, 'f');\n    /// s.insert(1, 'o');\n    /// s.insert(2, 'o');\n    ///\n    /// assert_eq!(\"foo\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, idx: usize, ch: char) {\n        assert!(self.is_char_boundary(idx));\n        let mut bits = [0; 4];\n        let bits = ch.encode_utf8(&mut bits).as_bytes();\n\n        unsafe {\n            self.insert_bytes(idx, bits);\n        }\n    }\n\n    unsafe fn insert_bytes(&mut self, idx: usize, bytes: &[u8]) {\n        let len = self.len();\n        let amt = bytes.len();\n        self.vec.reserve(amt);\n\n        ptr::copy(self.vec.as_ptr().offset(idx as isize),\n                  self.vec.as_mut_ptr().offset((idx + amt) as isize),\n                  len - idx);\n        ptr::copy(bytes.as_ptr(),\n                  self.vec.as_mut_ptr().offset(idx as isize),\n                  amt);\n        self.vec.set_len(len + amt);\n    }\n\n    /// Inserts a string slice into this `String` at a byte position.\n    ///\n    /// This is an `O(n)` operation as it requires copying every element in the\n    /// buffer.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `idx` is larger than the `String`'s length, or if it does not\n    /// lie on a [`char`] boundary.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"bar\");\n    ///\n    /// s.insert_str(0, \"foo\");\n    ///\n    /// assert_eq!(\"foobar\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"insert_str\", since = \"1.16.0\")]\n    pub fn insert_str(&mut self, idx: usize, string: &str) {\n        assert!(self.is_char_boundary(idx));\n\n        unsafe {\n            self.insert_bytes(idx, string.as_bytes());\n        }\n    }\n\n    /// Returns a mutable reference to the contents of this `String`.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because it does not check that the bytes passed\n    /// to it are valid UTF-8. If this constraint is violated, it may cause\n    /// memory unsafety issues with future users of the `String`, as the rest of\n    /// the standard library assumes that `String`s are valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"hello\");\n    ///\n    /// unsafe {\n    ///     let vec = s.as_mut_vec();\n    ///     assert_eq!(&[104, 101, 108, 108, 111][..], &vec[..]);\n    ///\n    ///     vec.reverse();\n    /// }\n    /// assert_eq!(s, \"olleh\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn as_mut_vec(&mut self) -> &mut Vec<u8> {\n        &mut self.vec\n    }\n\n    /// Returns the length of this `String`, in bytes.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = String::from(\"foo\");\n    ///\n    /// assert_eq!(a.len(), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n        self.vec.len()\n    }\n\n    /// Returns `true` if this `String` has a length of zero.\n    ///\n    /// Returns `false` otherwise.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut v = String::new();\n    /// assert!(v.is_empty());\n    ///\n    /// v.push('a');\n    /// assert!(!v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Splits the string into two at the given index.\n    ///\n    /// Returns a newly allocated `String`. `self` contains bytes `[0, at)`, and\n    /// the returned `String` contains bytes `[at, len)`. `at` must be on the\n    /// boundary of a UTF-8 code point.\n    ///\n    /// Note that the capacity of `self` does not change.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at` is not on a `UTF-8` code point boundary, or if it is beyond the last\n    /// code point of the string.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # fn main() {\n    /// let mut hello = String::from(\"Hello, World!\");\n    /// let world = hello.split_off(7);\n    /// assert_eq!(hello, \"Hello, \");\n    /// assert_eq!(world, \"World!\");\n    /// # }\n    /// ```\n    #[inline]\n    #[stable(feature = \"string_split_off\", since = \"1.16.0\")]\n    pub fn split_off(&mut self, at: usize) -> String {\n        assert!(self.is_char_boundary(at));\n        let other = self.vec.split_off(at);\n        unsafe { String::from_utf8_unchecked(other) }\n    }\n\n    /// Truncates this `String`, removing all contents.\n    ///\n    /// While this means the `String` will have a length of zero, it does not\n    /// touch its capacity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// s.clear();\n    ///\n    /// assert!(s.is_empty());\n    /// assert_eq!(0, s.len());\n    /// assert_eq!(3, s.capacity());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n        self.vec.clear()\n    }\n\n    /// Creates a draining iterator that removes the specified range in the string\n    /// and yields the removed chars.\n    ///\n    /// Note: The element range is removed even if the iterator is not\n    /// consumed until the end.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point or end point do not lie on a [`char`]\n    /// boundary, or if they're out of bounds.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"α is alpha, β is beta\");\n    /// let beta_offset = s.find('β').unwrap_or(s.len());\n    ///\n    /// // Remove the range up until the β from the string\n    /// let t: String = s.drain(..beta_offset).collect();\n    /// assert_eq!(t, \"α is alpha, \");\n    /// assert_eq!(s, \"β is beta\");\n    ///\n    /// // A full range clears the string\n    /// s.drain(..);\n    /// assert_eq!(s, \"\");\n    /// ```\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain<R>(&mut self, range: R) -> Drain\n        where R: RangeArgument<usize>\n    {\n        // Memory safety\n        //\n        // The String version of Drain does not have the memory safety issues\n        // of the vector version. The data is just plain bytes.\n        // Because the range removal happens in Drop, if the Drain iterator is leaked,\n        // the removal will not happen.\n        let len = self.len();\n        let start = match range.start() {\n            Included(&n) => n,\n            Excluded(&n) => n + 1,\n            Unbounded => 0,\n        };\n        let end = match range.end() {\n            Included(&n) => n + 1,\n            Excluded(&n) => n,\n            Unbounded => len,\n        };\n\n        // Take out two simultaneous borrows. The &mut String won't be accessed\n        // until iteration is over, in Drop.\n        let self_ptr = self as *mut _;\n        // slicing does the appropriate bounds checks\n        let chars_iter = self[start..end].chars();\n\n        Drain {\n            start,\n            end,\n            iter: chars_iter,\n            string: self_ptr,\n        }\n    }\n\n    /// Creates a splicing iterator that removes the specified range in the string,\n    /// and replaces it with the given string.\n    /// The given string doesn't need to be the same length as the range.\n    ///\n    /// Note: Unlike [`Vec::splice`], the replacement happens eagerly, and this\n    /// method does not return the removed chars.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point or end point do not lie on a [`char`]\n    /// boundary, or if they're out of bounds.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    /// [`Vec::splice`]: ../../std/vec/struct.Vec.html#method.splice\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(splice)]\n    /// let mut s = String::from(\"α is alpha, β is beta\");\n    /// let beta_offset = s.find('β').unwrap_or(s.len());\n    ///\n    /// // Replace the range up until the β from the string\n    /// s.splice(..beta_offset, \"Α is capital alpha; \");\n    /// assert_eq!(s, \"Α is capital alpha; β is beta\");\n    /// ```\n    #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"44643\")]\n    pub fn splice<R>(&mut self, range: R, replace_with: &str)\n        where R: RangeArgument<usize>\n    {\n        // Memory safety\n        //\n        // The String version of Splice does not have the memory safety issues\n        // of the vector version. The data is just plain bytes.\n\n        match range.start() {\n             Included(&n) => assert!(self.is_char_boundary(n)),\n             Excluded(&n) => assert!(self.is_char_boundary(n + 1)),\n             Unbounded => {},\n        };\n        match range.end() {\n             Included(&n) => assert!(self.is_char_boundary(n + 1)),\n             Excluded(&n) => assert!(self.is_char_boundary(n)),\n             Unbounded => {},\n        };\n\n        unsafe {\n            self.as_mut_vec()\n        }.splice(range, replace_with.bytes());\n    }\n\n    /// Converts this `String` into a [`Box`]`<`[`str`]`>`.\n    ///\n    /// This will drop any excess capacity.\n    ///\n    /// [`Box`]: ../../std/boxed/struct.Box.html\n    /// [`str`]: ../../std/primitive.str.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::from(\"hello\");\n    ///\n    /// let b = s.into_boxed_str();\n    /// ```\n    #[stable(feature = \"box_str\", since = \"1.4.0\")]\n    pub fn into_boxed_str(self) -> Box<str> {\n        let slice = self.vec.into_boxed_slice();\n        unsafe { from_boxed_utf8_unchecked(slice) }\n    }\n}\n\nimpl FromUtf8Error {\n    /// Returns a slice of [`u8`]s bytes that were attempted to convert to a `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(from_utf8_error_as_bytes)]\n    /// // some invalid bytes, in a vector\n    /// let bytes = vec![0, 159];\n    ///\n    /// let value = String::from_utf8(bytes);\n    ///\n    /// assert_eq!(&[0, 159], value.unwrap_err().as_bytes());\n    /// ```\n    #[unstable(feature = \"from_utf8_error_as_bytes\", reason = \"recently added\", issue = \"40895\")]\n    pub fn as_bytes(&self) -> &[u8] {\n        &self.bytes[..]\n    }\n\n    /// Returns the bytes that were attempted to convert to a `String`.\n    ///\n    /// This method is carefully constructed to avoid allocation. It will\n    /// consume the error, moving out the bytes, so that a copy of the bytes\n    /// does not need to be made.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some invalid bytes, in a vector\n    /// let bytes = vec![0, 159];\n    ///\n    /// let value = String::from_utf8(bytes);\n    ///\n    /// assert_eq!(vec![0, 159], value.unwrap_err().into_bytes());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_bytes(self) -> Vec<u8> {\n        self.bytes\n    }\n\n    /// Fetch a `Utf8Error` to get more details about the conversion failure.\n    ///\n    /// The [`Utf8Error`] type provided by [`std::str`] represents an error that may\n    /// occur when converting a slice of [`u8`]s to a [`&str`]. In this sense, it's\n    /// an analogue to `FromUtf8Error`. See its documentation for more details\n    /// on using it.\n    ///\n    /// [`Utf8Error`]: ../../std/str/struct.Utf8Error.html\n    /// [`std::str`]: ../../std/str/index.html\n    /// [`u8`]: ../../std/primitive.u8.html\n    /// [`&str`]: ../../std/primitive.str.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some invalid bytes, in a vector\n    /// let bytes = vec![0, 159];\n    ///\n    /// let error = String::from_utf8(bytes).unwrap_err().utf8_error();\n    ///\n    /// // the first byte is invalid here\n    /// assert_eq!(1, error.valid_up_to());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn utf8_error(&self) -> Utf8Error {\n        self.error\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for FromUtf8Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&self.error, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for FromUtf16Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(\"invalid utf-16: lone surrogate found\", f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for String {\n    fn clone(&self) -> Self {\n        String { vec: self.vec.clone() }\n    }\n\n    fn clone_from(&mut self, source: &Self) {\n        self.vec.clone_from(&source.vec);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromIterator<char> for String {\n    fn from_iter<I: IntoIterator<Item = char>>(iter: I) -> String {\n        let mut buf = String::new();\n        buf.extend(iter);\n        buf\n    }\n}\n\n#[stable(feature = \"string_from_iter_by_ref\", since = \"1.17.0\")]\nimpl<'a> FromIterator<&'a char> for String {\n    fn from_iter<I: IntoIterator<Item = &'a char>>(iter: I) -> String {\n        let mut buf = String::new();\n        buf.extend(iter);\n        buf\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> FromIterator<&'a str> for String {\n    fn from_iter<I: IntoIterator<Item = &'a str>>(iter: I) -> String {\n        let mut buf = String::new();\n        buf.extend(iter);\n        buf\n    }\n}\n\n#[stable(feature = \"extend_string\", since = \"1.4.0\")]\nimpl FromIterator<String> for String {\n    fn from_iter<I: IntoIterator<Item = String>>(iter: I) -> String {\n        let mut buf = String::new();\n        buf.extend(iter);\n        buf\n    }\n}\n\n#[stable(feature = \"herd_cows\", since = \"1.19.0\")]\nimpl<'a> FromIterator<Cow<'a, str>> for String {\n    fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> String {\n        let mut buf = String::new();\n        buf.extend(iter);\n        buf\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Extend<char> for String {\n    fn extend<I: IntoIterator<Item = char>>(&mut self, iter: I) {\n        let iterator = iter.into_iter();\n        let (lower_bound, _) = iterator.size_hint();\n        self.reserve(lower_bound);\n        for ch in iterator {\n            self.push(ch)\n        }\n    }\n}\n\n#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\nimpl<'a> Extend<&'a char> for String {\n    fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iter: I) {\n        self.extend(iter.into_iter().cloned());\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Extend<&'a str> for String {\n    fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I) {\n        for s in iter {\n            self.push_str(s)\n        }\n    }\n}\n\n#[stable(feature = \"extend_string\", since = \"1.4.0\")]\nimpl Extend<String> for String {\n    fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I) {\n        for s in iter {\n            self.push_str(&s)\n        }\n    }\n}\n\n#[stable(feature = \"herd_cows\", since = \"1.19.0\")]\nimpl<'a> Extend<Cow<'a, str>> for String {\n    fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I) {\n        for s in iter {\n            self.push_str(&s)\n        }\n    }\n}\n\n/// A convenience impl that delegates to the impl for `&str`\n#[unstable(feature = \"pattern\",\n           reason = \"API not fully fleshed out and ready to be stabilized\",\n           issue = \"27721\")]\nimpl<'a, 'b> Pattern<'a> for &'b String {\n    type Searcher = <&'b str as Pattern<'a>>::Searcher;\n\n    fn into_searcher(self, haystack: &'a str) -> <&'b str as Pattern<'a>>::Searcher {\n        self[..].into_searcher(haystack)\n    }\n\n    #[inline]\n    fn is_contained_in(self, haystack: &'a str) -> bool {\n        self[..].is_contained_in(haystack)\n    }\n\n    #[inline]\n    fn is_prefix_of(self, haystack: &'a str) -> bool {\n        self[..].is_prefix_of(haystack)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for String {\n    #[inline]\n    fn eq(&self, other: &String) -> bool {\n        PartialEq::eq(&self[..], &other[..])\n    }\n    #[inline]\n    fn ne(&self, other: &String) -> bool {\n        PartialEq::ne(&self[..], &other[..])\n    }\n}\n\nmacro_rules! impl_eq {\n    ($lhs:ty, $rhs: ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, 'b> PartialEq<$rhs> for $lhs {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&self[..], &other[..]) }\n            #[inline]\n            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&self[..], &other[..]) }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&self[..], &other[..]) }\n            #[inline]\n            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&self[..], &other[..]) }\n        }\n\n    }\n}\n\nimpl_eq! { String, str }\nimpl_eq! { String, &'a str }\nimpl_eq! { Cow<'a, str>, str }\nimpl_eq! { Cow<'a, str>, &'b str }\nimpl_eq! { Cow<'a, str>, String }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Default for String {\n    /// Creates an empty `String`.\n    #[inline]\n    fn default() -> String {\n        String::new()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for String {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for String {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl hash::Hash for String {\n    #[inline]\n    fn hash<H: hash::Hasher>(&self, hasher: &mut H) {\n        (**self).hash(hasher)\n    }\n}\n\n/// Implements the `+` operator for concatenating two strings.\n///\n/// This consumes the `String` on the left-hand side and re-uses its buffer (growing it if\n/// necessary). This is done to avoid allocating a new `String` and copying the entire contents on\n/// every operation, which would lead to `O(n^2)` running time when building an `n`-byte string by\n/// repeated concatenation.\n///\n/// The string on the right-hand side is only borrowed; its contents are copied into the returned\n/// `String`.\n///\n/// # Examples\n///\n/// Concatenating two `String`s takes the first by value and borrows the second:\n///\n/// ```\n/// let a = String::from(\"hello\");\n/// let b = String::from(\" world\");\n/// let c = a + &b;\n/// // `a` is moved and can no longer be used here.\n/// ```\n///\n/// If you want to keep using the first `String`, you can clone it and append to the clone instead:\n///\n/// ```\n/// let a = String::from(\"hello\");\n/// let b = String::from(\" world\");\n/// let c = a.clone() + &b;\n/// // `a` is still valid here.\n/// ```\n///\n/// Concatenating `&str` slices can be done by converting the first to a `String`:\n///\n/// ```\n/// let a = \"hello\";\n/// let b = \" world\";\n/// let c = a.to_string() + b;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Add<&'a str> for String {\n    type Output = String;\n\n    #[inline]\n    fn add(mut self, other: &str) -> String {\n        self.push_str(other);\n        self\n    }\n}\n\n/// Implements the `+=` operator for appending to a `String`.\n///\n/// This has the same behavior as the [`push_str`] method.\n///\n/// [`push_str`]: struct.String.html#method.push_str\n#[stable(feature = \"stringaddassign\", since = \"1.12.0\")]\nimpl<'a> AddAssign<&'a str> for String {\n    #[inline]\n    fn add_assign(&mut self, other: &str) {\n        self.push_str(other);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::Range<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::Range<usize>) -> &str {\n        &self[..][index]\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::RangeTo<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::RangeTo<usize>) -> &str {\n        &self[..][index]\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::RangeFrom<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n        &self[..][index]\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::RangeFull> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, _index: ops::RangeFull) -> &str {\n        unsafe { str::from_utf8_unchecked(&self.vec) }\n    }\n}\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl ops::Index<ops::RangeInclusive<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n        Index::index(&**self, index)\n    }\n}\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl ops::Index<ops::RangeToInclusive<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n        Index::index(&**self, index)\n    }\n}\n\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::IndexMut<ops::Range<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str {\n        &mut self[..][index]\n    }\n}\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::IndexMut<ops::RangeTo<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str {\n        &mut self[..][index]\n    }\n}\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::IndexMut<ops::RangeFrom<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str {\n        &mut self[..][index]\n    }\n}\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::IndexMut<ops::RangeFull> for String {\n    #[inline]\n    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut str {\n        unsafe { str::from_utf8_unchecked_mut(&mut *self.vec) }\n    }\n}\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl ops::IndexMut<ops::RangeInclusive<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\nimpl ops::IndexMut<ops::RangeToInclusive<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Deref for String {\n    type Target = str;\n\n    #[inline]\n    fn deref(&self) -> &str {\n        unsafe { str::from_utf8_unchecked(&self.vec) }\n    }\n}\n\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::DerefMut for String {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut str {\n        unsafe { str::from_utf8_unchecked_mut(&mut *self.vec) }\n    }\n}\n\n/// An error when parsing a `String`.\n///\n/// This `enum` is slightly awkward: it will never actually exist. This error is\n/// part of the type signature of the implementation of [`FromStr`] on\n/// [`String`]. The return type of [`from_str`], requires that an error be\n/// defined, but, given that a [`String`] can always be made into a new\n/// [`String`] without error, this type will never actually be returned. As\n/// such, it is only here to satisfy said signature, and is useless otherwise.\n///\n/// [`FromStr`]: ../../std/str/trait.FromStr.html\n/// [`String`]: struct.String.html\n/// [`from_str`]: ../../std/str/trait.FromStr.html#tymethod.from_str\n#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n#[derive(Copy)]\npub enum ParseError {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromStr for String {\n    type Err = ParseError;\n    #[inline]\n    fn from_str(s: &str) -> Result<String, ParseError> {\n        Ok(String::from(s))\n    }\n}\n\n#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\nimpl Clone for ParseError {\n    fn clone(&self) -> ParseError {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\nimpl fmt::Debug for ParseError {\n    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"str_parse_error2\", since = \"1.8.0\")]\nimpl fmt::Display for ParseError {\n    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\nimpl PartialEq for ParseError {\n    fn eq(&self, _: &ParseError) -> bool {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\nimpl Eq for ParseError {}\n\n/// A trait for converting a value to a `String`.\n///\n/// This trait is automatically implemented for any type which implements the\n/// [`Display`] trait. As such, `ToString` shouldn't be implemented directly:\n/// [`Display`] should be implemented instead, and you get the `ToString`\n/// implementation for free.\n///\n/// [`Display`]: ../../std/fmt/trait.Display.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait ToString {\n    /// Converts the given value to a `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let i = 5;\n    /// let five = String::from(\"5\");\n    ///\n    /// assert_eq!(five, i.to_string());\n    /// ```\n    #[rustc_conversion_suggestion]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn to_string(&self) -> String;\n}\n\n/// # Panics\n///\n/// In this implementation, the `to_string` method panics\n/// if the `Display` implementation returns an error.\n/// This indicates an incorrect `Display` implementation\n/// since `fmt::Write for String` never returns an error itself.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Display + ?Sized> ToString for T {\n    #[inline]\n    default fn to_string(&self) -> String {\n        use core::fmt::Write;\n        let mut buf = String::new();\n        buf.write_fmt(format_args!(\"{}\", self))\n           .expect(\"a Display implementation return an error unexpectedly\");\n        buf.shrink_to_fit();\n        buf\n    }\n}\n\n#[stable(feature = \"str_to_string_specialization\", since = \"1.9.0\")]\nimpl ToString for str {\n    #[inline]\n    fn to_string(&self) -> String {\n        String::from(self)\n    }\n}\n\n#[stable(feature = \"cow_str_to_string_specialization\", since = \"1.17.0\")]\nimpl<'a> ToString for Cow<'a, str> {\n    #[inline]\n    fn to_string(&self) -> String {\n        self[..].to_owned()\n    }\n}\n\n#[stable(feature = \"string_to_string_specialization\", since = \"1.17.0\")]\nimpl ToString for String {\n    #[inline]\n    fn to_string(&self) -> String {\n        self.to_owned()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<str> for String {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<[u8]> for String {\n    #[inline]\n    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<&'a str> for String {\n    fn from(s: &'a str) -> String {\n        s.to_owned()\n    }\n}\n\n// note: test pulls in libstd, which causes errors here\n#[cfg(not(test))]\n#[stable(feature = \"string_from_box\", since = \"1.18.0\")]\nimpl From<Box<str>> for String {\n    fn from(s: Box<str>) -> String {\n        s.into_string()\n    }\n}\n\n#[stable(feature = \"box_from_str\", since = \"1.20.0\")]\nimpl From<String> for Box<str> {\n    fn from(s: String) -> Box<str> {\n        s.into_boxed_str()\n    }\n}\n\n#[stable(feature = \"string_from_cow_str\", since = \"1.14.0\")]\nimpl<'a> From<Cow<'a, str>> for String {\n    fn from(s: Cow<'a, str>) -> String {\n        s.into_owned()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<&'a str> for Cow<'a, str> {\n    #[inline]\n    fn from(s: &'a str) -> Cow<'a, str> {\n        Cow::Borrowed(s)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<String> for Cow<'a, str> {\n    #[inline]\n    fn from(s: String) -> Cow<'a, str> {\n        Cow::Owned(s)\n    }\n}\n\n#[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\nimpl<'a> FromIterator<char> for Cow<'a, str> {\n    fn from_iter<I: IntoIterator<Item = char>>(it: I) -> Cow<'a, str> {\n        Cow::Owned(FromIterator::from_iter(it))\n    }\n}\n\n#[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\nimpl<'a, 'b> FromIterator<&'b str> for Cow<'a, str> {\n    fn from_iter<I: IntoIterator<Item = &'b str>>(it: I) -> Cow<'a, str> {\n        Cow::Owned(FromIterator::from_iter(it))\n    }\n}\n\n#[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\nimpl<'a> FromIterator<String> for Cow<'a, str> {\n    fn from_iter<I: IntoIterator<Item = String>>(it: I) -> Cow<'a, str> {\n        Cow::Owned(FromIterator::from_iter(it))\n    }\n}\n\n#[stable(feature = \"from_string_for_vec_u8\", since = \"1.14.0\")]\nimpl From<String> for Vec<u8> {\n    fn from(string: String) -> Vec<u8> {\n        string.into_bytes()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Write for String {\n    #[inline]\n    fn write_str(&mut self, s: &str) -> fmt::Result {\n        self.push_str(s);\n        Ok(())\n    }\n\n    #[inline]\n    fn write_char(&mut self, c: char) -> fmt::Result {\n        self.push(c);\n        Ok(())\n    }\n}\n\n/// A draining iterator for `String`.\n///\n/// This struct is created by the [`drain`] method on [`String`]. See its\n/// documentation for more.\n///\n/// [`drain`]: struct.String.html#method.drain\n/// [`String`]: struct.String.html\n#[stable(feature = \"drain\", since = \"1.6.0\")]\npub struct Drain<'a> {\n    /// Will be used as &'a mut String in the destructor\n    string: *mut String,\n    /// Start of part to remove\n    start: usize,\n    /// End of part to remove\n    end: usize,\n    /// Current remaining range to remove\n    iter: Chars<'a>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<'a> fmt::Debug for Drain<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"Drain { .. }\")\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl<'a> Sync for Drain<'a> {}\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl<'a> Send for Drain<'a> {}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a> Drop for Drain<'a> {\n    fn drop(&mut self) {\n        unsafe {\n            // Use Vec::drain. \"Reaffirm\" the bounds checks to avoid\n            // panic code being inserted again.\n            let self_vec = (*self.string).as_mut_vec();\n            if self.start <= self.end && self.end <= self_vec.len() {\n                self_vec.drain(self.start..self.end);\n            }\n        }\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a> Iterator for Drain<'a> {\n    type Item = char;\n\n    #[inline]\n    fn next(&mut self) -> Option<char> {\n        self.iter.next()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a> DoubleEndedIterator for Drain<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<char> {\n        self.iter.next_back()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<'a> FusedIterator for Drain<'a> {}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n/// Entry point of thread panic, for details, see std::macros\n#[macro_export]\n#[allow_internal_unstable]\n#[stable(feature = \"core\", since = \"1.6.0\")]\nmacro_rules! panic {\n    () => (\n        panic!(\"explicit panic\")\n    );\n    ($msg:expr) => ({\n        $crate::panicking::panic(&($msg, file!(), line!(), __rust_unstable_column!()))\n    });\n    ($fmt:expr, $($arg:tt)*) => ({\n        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*),\n                                     &(file!(), line!(), __rust_unstable_column!()))\n    });\n}\n\n/// Ensure that a boolean expression is `true` at runtime.\n///\n/// This will invoke the [`panic!`] macro if the provided expression cannot be\n/// evaluated to `true` at runtime.\n///\n/// # Uses\n///\n/// Assertions are always checked in both debug and release builds, and cannot\n/// be disabled. See [`debug_assert!`] for assertions that are not enabled in\n/// release builds by default.\n///\n/// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n/// violated could lead to unsafety.\n///\n/// Other use-cases of `assert!` include [testing] and enforcing run-time\n/// invariants in safe code (whose violation cannot result in unsafety).\n///\n/// # Custom Messages\n///\n/// This macro has a second form, where a custom panic message can\n/// be provided with or without arguments for formatting.  See [`std::fmt`]\n/// for syntax for this form.\n///\n/// [`panic!`]: macro.panic.html\n/// [`debug_assert!`]: macro.debug_assert.html\n/// [testing]: ../book/second-edition/ch11-01-writing-tests.html#checking-results-with-the-assert-macro\n/// [`std::fmt`]: ../std/fmt/index.html\n///\n/// # Examples\n///\n/// ```\n/// // the panic message for these assertions is the stringified value of the\n/// // expression given.\n/// assert!(true);\n///\n/// fn some_computation() -> bool { true } // a very simple function\n///\n/// assert!(some_computation());\n///\n/// // assert with a custom message\n/// let x = true;\n/// assert!(x, \"x wasn't true!\");\n///\n/// let a = 3; let b = 27;\n/// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! assert {\n    ($cond:expr) => (\n        if !$cond {\n            panic!(concat!(\"assertion failed: \", stringify!($cond)))\n        }\n    );\n    ($cond:expr, $($arg:tt)+) => (\n        if !$cond {\n            panic!($($arg)+)\n        }\n    );\n}\n\n/// Asserts that two expressions are equal to each other (using [`PartialEq`]).\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Like [`assert!`], this macro has a second form, where a custom\n/// panic message can be provided.\n///\n/// [`PartialEq`]: cmp/trait.PartialEq.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 1 + 2;\n/// assert_eq!(a, b);\n///\n/// assert_eq!(a, b, \"we are testing addition with {} and {}\", a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! assert_eq {\n    ($left:expr, $right:expr) => ({\n        match (&$left, &$right) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    panic!(r#\"assertion failed: `(left == right)`\n  left: `{:?}`,\n right: `{:?}`\"#, left_val, right_val)\n                }\n            }\n        }\n    });\n    ($left:expr, $right:expr,) => ({\n        assert_eq!($left, $right)\n    });\n    ($left:expr, $right:expr, $($arg:tt)+) => ({\n        match (&($left), &($right)) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    panic!(r#\"assertion failed: `(left == right)`\n  left: `{:?}`,\n right: `{:?}`: {}\"#, left_val, right_val,\n                           format_args!($($arg)+))\n                }\n            }\n        }\n    });\n}\n\n/// Asserts that two expressions are not equal to each other (using [`PartialEq`]).\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Like [`assert!`], this macro has a second form, where a custom\n/// panic message can be provided.\n///\n/// [`PartialEq`]: cmp/trait.PartialEq.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 2;\n/// assert_ne!(a, b);\n///\n/// assert_ne!(a, b, \"we are testing that the values are not equal\");\n/// ```\n#[macro_export]\n#[stable(feature = \"assert_ne\", since = \"1.13.0\")]\nmacro_rules! assert_ne {\n    ($left:expr, $right:expr) => ({\n        match (&$left, &$right) {\n            (left_val, right_val) => {\n                if *left_val == *right_val {\n                    panic!(r#\"assertion failed: `(left != right)`\n  left: `{:?}`,\n right: `{:?}`\"#, left_val, right_val)\n                }\n            }\n        }\n    });\n    ($left:expr, $right:expr,) => {\n        assert_ne!($left, $right)\n    };\n    ($left:expr, $right:expr, $($arg:tt)+) => ({\n        match (&($left), &($right)) {\n            (left_val, right_val) => {\n                if *left_val == *right_val {\n                    panic!(r#\"assertion failed: `(left != right)`\n  left: `{:?}`,\n right: `{:?}`: {}\"#, left_val, right_val,\n                           format_args!($($arg)+))\n                }\n            }\n        }\n    });\n}\n\n/// Ensure that a boolean expression is `true` at runtime.\n///\n/// This will invoke the [`panic!`] macro if the provided expression cannot be\n/// evaluated to `true` at runtime.\n///\n/// Like [`assert!`], this macro also has a second version, where a custom panic\n/// message can be provided.\n///\n/// # Uses\n///\n/// Unlike [`assert!`], `debug_assert!` statements are only enabled in non\n/// optimized builds by default. An optimized build will omit all\n/// `debug_assert!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development.\n///\n/// An unchecked assertion allows a program in an inconsistent state to keep\n/// running, which might have unexpected consequences but does not introduce\n/// unsafety as long as this only happens in safe code. The performance cost\n/// of assertions, is however, not measurable in general. Replacing [`assert!`]\n/// with `debug_assert!` is thus only encouraged after thorough profiling, and\n/// more importantly, only in safe code!\n///\n/// [`panic!`]: macro.panic.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// // the panic message for these assertions is the stringified value of the\n/// // expression given.\n/// debug_assert!(true);\n///\n/// fn some_expensive_computation() -> bool { true } // a very simple function\n/// debug_assert!(some_expensive_computation());\n///\n/// // assert with a custom message\n/// let x = true;\n/// debug_assert!(x, \"x wasn't true!\");\n///\n/// let a = 3; let b = 27;\n/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! debug_assert {\n    ($($arg:tt)*) => (if cfg!(debug_assertions) { assert!($($arg)*); })\n}\n\n/// Asserts that two expressions are equal to each other.\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Unlike [`assert_eq!`], `debug_assert_eq!` statements are only enabled in non\n/// optimized builds by default. An optimized build will omit all\n/// `debug_assert_eq!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert_eq!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development.\n///\n/// [`assert_eq!`]: ../std/macro.assert_eq.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 1 + 2;\n/// debug_assert_eq!(a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! debug_assert_eq {\n    ($($arg:tt)*) => (if cfg!(debug_assertions) { assert_eq!($($arg)*); })\n}\n\n/// Asserts that two expressions are not equal to each other.\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Unlike [`assert_ne!`], `debug_assert_ne!` statements are only enabled in non\n/// optimized builds by default. An optimized build will omit all\n/// `debug_assert_ne!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert_ne!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development.\n///\n/// [`assert_ne!`]: ../std/macro.assert_ne.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 2;\n/// debug_assert_ne!(a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"assert_ne\", since = \"1.13.0\")]\nmacro_rules! debug_assert_ne {\n    ($($arg:tt)*) => (if cfg!(debug_assertions) { assert_ne!($($arg)*); })\n}\n\n/// Helper macro for reducing boilerplate code for matching `Result` together\n/// with converting downstream errors.\n///\n/// The `?` operator was added to replace `try!` and should be used instead.\n///\n/// `try!` matches the given [`Result`]. In case of the `Ok` variant, the\n/// expression has the value of the wrapped value.\n///\n/// In case of the `Err` variant, it retrieves the inner error. `try!` then\n/// performs conversion using `From`. This provides automatic conversion\n/// between specialized errors and more general ones. The resulting\n/// error is then immediately returned.\n///\n/// Because of the early return, `try!` can only be used in functions that\n/// return [`Result`].\n///\n/// [`Result`]: ../std/result/enum.Result.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io;\n/// use std::fs::File;\n/// use std::io::prelude::*;\n///\n/// enum MyError {\n///     FileWriteError\n/// }\n///\n/// impl From<io::Error> for MyError {\n///     fn from(e: io::Error) -> MyError {\n///         MyError::FileWriteError\n///     }\n/// }\n///\n/// // The prefered method of quick returning Errors\n/// fn write_to_file_question() -> Result<(), MyError> {\n///     let mut file = File::create(\"my_best_friends.txt\")?;\n///     file.write_all(b\"This is a list of my best friends.\")?;\n///     Ok(())\n/// }\n///\n/// // The previous method of quick returning Errors\n/// fn write_to_file_using_try() -> Result<(), MyError> {\n///     let mut file = try!(File::create(\"my_best_friends.txt\"));\n///     try!(file.write_all(b\"This is a list of my best friends.\"));\n///     Ok(())\n/// }\n///\n/// // This is equivalent to:\n/// fn write_to_file_using_match() -> Result<(), MyError> {\n///     let mut file = try!(File::create(\"my_best_friends.txt\"));\n///     match file.write_all(b\"This is a list of my best friends.\") {\n///         Ok(v) => v,\n///         Err(e) => return Err(From::from(e)),\n///     }\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! try {\n    ($expr:expr) => (match $expr {\n        $crate::result::Result::Ok(val) => val,\n        $crate::result::Result::Err(err) => {\n            return $crate::result::Result::Err($crate::convert::From::from(err))\n        }\n    })\n}\n\n/// Write formatted data into a buffer.\n///\n/// This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be\n/// formatted according to the specified format string and the result will be passed to the writer.\n/// The writer may be any value with a `write_fmt` method; generally this comes from an\n/// implementation of either the [`std::fmt::Write`] or the [`std::io::Write`] trait. The macro\n/// returns whatever the `write_fmt` method returns; commonly a [`std::fmt::Result`], or an\n/// [`io::Result`].\n///\n/// See [`std::fmt`] for more information on the format string syntax.\n///\n/// [`std::fmt`]: ../std/fmt/index.html\n/// [`std::fmt::Write`]: ../std/fmt/trait.Write.html\n/// [`std::io::Write`]: ../std/io/trait.Write.html\n/// [`std::fmt::Result`]: ../std/fmt/type.Result.html\n/// [`io::Result`]: ../std/io/type.Result.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::Write;\n///\n/// let mut w = Vec::new();\n/// write!(&mut w, \"test\").unwrap();\n/// write!(&mut w, \"formatted {}\", \"arguments\").unwrap();\n///\n/// assert_eq!(w, b\"testformatted arguments\");\n/// ```\n///\n/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n/// implementing either, as objects do not typically implement both. However, the module must\n/// import the traits qualified so their names do not conflict:\n///\n/// ```\n/// use std::fmt::Write as FmtWrite;\n/// use std::io::Write as IoWrite;\n///\n/// let mut s = String::new();\n/// let mut v = Vec::new();\n/// write!(&mut s, \"{} {}\", \"abc\", 123).unwrap(); // uses fmt::Write::write_fmt\n/// write!(&mut v, \"s = {:?}\", s).unwrap(); // uses io::Write::write_fmt\n/// assert_eq!(v, b\"s = \\\"abc 123\\\"\");\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! write {\n    ($dst:expr, $($arg:tt)*) => ($dst.write_fmt(format_args!($($arg)*)))\n}\n\n/// Write formatted data into a buffer, with a newline appended.\n///\n/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n///\n/// For more information, see [`write!`]. For information on the format string syntax, see\n/// [`std::fmt`].\n///\n/// [`write!`]: macro.write.html\n/// [`std::fmt`]: ../std/fmt/index.html\n///\n///\n/// # Examples\n///\n/// ```\n/// use std::io::Write;\n///\n/// let mut w = Vec::new();\n/// writeln!(&mut w).unwrap();\n/// writeln!(&mut w, \"test\").unwrap();\n/// writeln!(&mut w, \"formatted {}\", \"arguments\").unwrap();\n///\n/// assert_eq!(&w[..], \"\\ntest\\nformatted arguments\\n\".as_bytes());\n/// ```\n///\n/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n/// implementing either, as objects do not typically implement both. However, the module must\n/// import the traits qualified so their names do not conflict:\n///\n/// ```\n/// use std::fmt::Write as FmtWrite;\n/// use std::io::Write as IoWrite;\n///\n/// let mut s = String::new();\n/// let mut v = Vec::new();\n/// writeln!(&mut s, \"{} {}\", \"abc\", 123).unwrap(); // uses fmt::Write::write_fmt\n/// writeln!(&mut v, \"s = {:?}\", s).unwrap(); // uses io::Write::write_fmt\n/// assert_eq!(v, b\"s = \\\"abc 123\\\\n\\\"\\n\");\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! writeln {\n    ($dst:expr) => (\n        write!($dst, \"\\n\")\n    );\n    ($dst:expr, $fmt:expr) => (\n        write!($dst, concat!($fmt, \"\\n\"))\n    );\n    ($dst:expr, $fmt:expr, $($arg:tt)*) => (\n        write!($dst, concat!($fmt, \"\\n\"), $($arg)*)\n    );\n}\n\n/// A utility macro for indicating unreachable code.\n///\n/// This is useful any time that the compiler can't determine that some code is unreachable. For\n/// example:\n///\n/// * Match arms with guard conditions.\n/// * Loops that dynamically terminate.\n/// * Iterators that dynamically terminate.\n///\n/// If the determination that the code is unreachable proves incorrect, the\n/// program immediately terminates with a [`panic!`].  The function [`unreachable`],\n/// which belongs to the [`std::intrinsics`] module, informs the compilier to\n/// optimize the code out of the release version entirely.\n///\n/// [`panic!`]:  ../std/macro.panic.html\n/// [`unreachable`]: ../std/intrinsics/fn.unreachable.html\n/// [`std::intrinsics`]: ../std/intrinsics/index.html\n///\n/// # Panics\n///\n/// This will always [`panic!`]\n///\n/// [`panic!`]: ../std/macro.panic.html\n/// # Examples\n///\n/// Match arms:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// fn foo(x: Option<i32>) {\n///     match x {\n///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n///         Some(n) if n <  0 => println!(\"Some(Negative)\"),\n///         Some(_)           => unreachable!(), // compile error if commented out\n///         None              => println!(\"None\")\n///     }\n/// }\n/// ```\n///\n/// Iterators:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n///     for i in 0.. {\n///         if 3*i < i { panic!(\"u32 overflow\"); }\n///         if x < 3*i { return i-1; }\n///     }\n///     unreachable!();\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! unreachable {\n    () => ({\n        panic!(\"internal error: entered unreachable code\")\n    });\n    ($msg:expr) => ({\n        unreachable!(\"{}\", $msg)\n    });\n    ($fmt:expr, $($arg:tt)*) => ({\n        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n    });\n}\n\n/// A standardized placeholder for marking unfinished code.\n///\n/// This can be useful if you are prototyping and are just looking to have your\n/// code typecheck, or if you're implementing a trait that requires multiple\n/// methods, and you're only planning on using one of them.\n///\n/// # Panics\n///\n/// This will always [panic!](macro.panic.html)\n///\n/// # Examples\n///\n/// Here's an example of some in-progress code. We have a trait `Foo`:\n///\n/// ```\n/// trait Foo {\n///     fn bar(&self);\n///     fn baz(&self);\n/// }\n/// ```\n///\n/// We want to implement `Foo` on one of our types, but we also want to work on\n/// just `bar()` first. In order for our code to compile, we need to implement\n/// `baz()`, so we can use `unimplemented!`:\n///\n/// ```\n/// # trait Foo {\n/// #     fn bar(&self);\n/// #     fn baz(&self);\n/// # }\n/// struct MyStruct;\n///\n/// impl Foo for MyStruct {\n///     fn bar(&self) {\n///         // implementation goes here\n///     }\n///\n///     fn baz(&self) {\n///         // let's not worry about implementing baz() for now\n///         unimplemented!();\n///     }\n/// }\n///\n/// fn main() {\n///     let s = MyStruct;\n///     s.bar();\n///\n///     // we aren't even using baz() yet, so this is fine.\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! unimplemented {\n    () => (panic!(\"not yet implemented\"));\n    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)*)));\n}\n\n/// Built-in macros to the compiler itself.\n///\n/// These macros do not have any corresponding definition with a `macro_rules!`\n/// macro, but are documented here. Their implementations can be found hardcoded\n/// into libsyntax itself.\n///\n/// For more information, see documentation for `std`'s macros.\nmod builtin {\n\n    /// Unconditionally causes compilation to fail with the given error message when encountered.\n    ///\n    /// For more information, see the documentation for [`std::compile_error!`].\n    ///\n    /// [`std::compile_error!`]: ../std/macro.compile_error.html\n    #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! compile_error { ($msg:expr) => ({ /* compiler built-in */ }) }\n\n    /// The core macro for formatted string creation & output.\n    ///\n    /// For more information, see the documentation for [`std::format_args!`].\n    ///\n    /// [`std::format_args!`]: ../std/macro.format_args.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! format_args {\n        ($fmt:expr) => ({ /* compiler built-in */ });\n        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ });\n    }\n\n    /// Inspect an environment variable at compile time.\n    ///\n    /// For more information, see the documentation for [`std::env!`].\n    ///\n    /// [`std::env!`]: ../std/macro.env.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! env {\n        ($name:expr) => ({ /* compiler built-in */ });\n        ($name:expr,) => ({ /* compiler built-in */ });\n    }\n\n    /// Optionally inspect an environment variable at compile time.\n    ///\n    /// For more information, see the documentation for [`std::option_env!`].\n    ///\n    /// [`std::option_env!`]: ../std/macro.option_env.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n\n    /// Concatenate identifiers into one identifier.\n    ///\n    /// For more information, see the documentation for [`std::concat_idents!`].\n    ///\n    /// [`std::concat_idents!`]: ../std/macro.concat_idents.html\n    #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! concat_idents {\n        ($($e:ident),*) => ({ /* compiler built-in */ });\n        ($($e:ident,)*) => ({ /* compiler built-in */ });\n    }\n\n    /// Concatenates literals into a static string slice.\n    ///\n    /// For more information, see the documentation for [`std::concat!`].\n    ///\n    /// [`std::concat!`]: ../std/macro.concat.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! concat {\n        ($($e:expr),*) => ({ /* compiler built-in */ });\n        ($($e:expr,)*) => ({ /* compiler built-in */ });\n    }\n\n    /// A macro which expands to the line number on which it was invoked.\n    ///\n    /// For more information, see the documentation for [`std::line!`].\n    ///\n    /// [`std::line!`]: ../std/macro.line.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! line { () => ({ /* compiler built-in */ }) }\n\n    /// A macro which expands to the column number on which it was invoked.\n    ///\n    /// For more information, see the documentation for [`std::column!`].\n    ///\n    /// [`std::column!`]: ../std/macro.column.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! column { () => ({ /* compiler built-in */ }) }\n\n    /// A macro which expands to the file name from which it was invoked.\n    ///\n    /// For more information, see the documentation for [`std::file!`].\n    ///\n    /// [`std::file!`]: ../std/macro.file.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! file { () => ({ /* compiler built-in */ }) }\n\n    /// A macro which stringifies its arguments.\n    ///\n    /// For more information, see the documentation for [`std::stringify!`].\n    ///\n    /// [`std::stringify!`]: ../std/macro.stringify.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! stringify { ($($t:tt)*) => ({ /* compiler built-in */ }) }\n\n    /// Includes a utf8-encoded file as a string.\n    ///\n    /// For more information, see the documentation for [`std::include_str!`].\n    ///\n    /// [`std::include_str!`]: ../std/macro.include_str.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n\n    /// Includes a file as a reference to a byte array.\n    ///\n    /// For more information, see the documentation for [`std::include_bytes!`].\n    ///\n    /// [`std::include_bytes!`]: ../std/macro.include_bytes.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n\n    /// Expands to a string that represents the current module path.\n    ///\n    /// For more information, see the documentation for [`std::module_path!`].\n    ///\n    /// [`std::module_path!`]: ../std/macro.module_path.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n\n    /// Boolean evaluation of configuration flags, at compile-time.\n    ///\n    /// For more information, see the documentation for [`std::cfg!`].\n    ///\n    /// [`std::cfg!`]: ../std/macro.cfg.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n\n    /// Parse a file as an expression or an item according to the context.\n    ///\n    /// For more information, see the documentation for [`std::include!`].\n    ///\n    /// [`std::include!`]: ../std/macro.include.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[macro_export]\n    #[cfg(dox)]\n    macro_rules! include { ($file:expr) => ({ /* compiler built-in */ }) }\n}\n","/* Copyright 2017 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// See https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md\n\nuse std::result;\n\nuse limits::{MAX_WASM_FUNCTION_LOCALS, MAX_WASM_FUNCTION_PARAMS, MAX_WASM_FUNCTION_RETURNS,\n             MAX_WASM_FUNCTION_SIZE, MAX_WASM_STRING_SIZE, MAX_WASM_FUNCTIONS,\n             MAX_WASM_TABLE_ENTRIES};\n\nconst MAX_WASM_BR_TABLE_SIZE: usize = MAX_WASM_FUNCTION_SIZE;\n\nconst MAX_DATA_CHUNK_SIZE: usize = MAX_WASM_STRING_SIZE;\n\n#[derive(Debug,Copy,Clone)]\npub struct BinaryReaderError {\n    pub message: &'static str,\n    pub offset: usize,\n}\n\npub type Result<T> = result::Result<T, BinaryReaderError>;\n\n#[derive(Debug,Copy,Clone,PartialEq,Eq,PartialOrd,Ord)]\npub enum CustomSectionKind {\n    Unknown,\n    Name,\n    SourceMappingURL,\n    Reloc,\n    Linking,\n}\n\n/// Section code as defined [here].\n///\n/// [here]: https://webassembly.github.io/spec/binary/modules.html#sections\n#[derive(Debug,Copy,Clone,PartialEq,Eq,PartialOrd,Ord)]\npub enum SectionCode<'a> {\n    Custom {\n        name: &'a [u8],\n        kind: CustomSectionKind,\n    },\n    Type, // Function signature declarations\n    Import, // Import declarations\n    Function, // Function declarations\n    Table, // Indirect function table and other tables\n    Memory, // Memory attributes\n    Global, // Global declarations\n    Export, // Exports\n    Start, // Start function declaration\n    Element, // Elements section\n    Code, // Function bodies (code)\n    Data, // Data segments\n}\n\n/// Types as defined [here].\n///\n/// [here]: https://webassembly.github.io/spec/syntax/types.html#types\n#[derive(Debug,Copy,Clone,PartialEq,Eq)]\npub enum Type {\n    I32,\n    I64,\n    F32,\n    F64,\n    AnyFunc,\n    Func,\n    EmptyBlockType,\n}\n\n#[derive(Debug)]\npub enum NameType {\n    Module,\n    Function,\n    Local,\n}\n\n#[derive(Debug)]\npub struct Naming<'a> {\n    pub index: u32,\n    pub name: &'a [u8],\n}\n\n#[derive(Debug)]\npub struct LocalName<'a> {\n    pub index: u32,\n    pub locals: Vec<Naming<'a>>,\n}\n\n#[derive(Debug)]\npub enum NameEntry<'a> {\n    Module(&'a [u8]),\n    Function(Vec<Naming<'a>>),\n    Local(Vec<LocalName<'a>>),\n}\n\n/// External types as defined [here].\n///\n/// [here]: https://webassembly.github.io/spec/syntax/types.html#external-types\n#[derive(Debug, Copy, Clone)]\npub enum ExternalKind {\n    Function,\n    Table,\n    Memory,\n    Global,\n}\n\n#[derive(Debug,Clone)]\npub struct FuncType {\n    pub form: Type,\n    pub params: Vec<Type>,\n    pub returns: Vec<Type>,\n}\n\n#[derive(Debug,Copy,Clone)]\npub struct ResizableLimits {\n    pub initial: u32,\n    pub maximum: Option<u32>,\n}\n\n#[derive(Debug,Copy,Clone)]\npub struct TableType {\n    pub element_type: Type,\n    pub limits: ResizableLimits,\n}\n\n#[derive(Debug,Copy,Clone)]\npub struct MemoryType {\n    pub limits: ResizableLimits,\n    pub shared: bool,\n}\n\n#[derive(Debug,Copy,Clone)]\npub struct GlobalType {\n    pub content_type: Type,\n    pub mutable: bool,\n}\n\n#[derive(Debug)]\npub struct MemoryImmediate {\n    pub flags: u32,\n    pub offset: u32,\n}\n\n/// A br_table entries representation.\n#[derive(Debug)]\npub struct BrTable<'a> {\n    pub size: usize,\n    buffer: &'a [u8],\n}\n\nimpl<'a> BrTable<'a> {\n    /// Reads br_table entries.\n    ///\n    /// # Examples\n    /// ```rust\n    /// let buf = vec![0x0e, 0x02, 0x01, 0x02, 0x00];\n    /// let mut reader = wasmparser::BinaryReader::new(&buf);\n    /// let op = reader.read_operator().unwrap();\n    /// if let wasmparser::Operator::BrTable { ref table } = op {\n    ///     let br_table_depths = table.read_table();\n    ///     assert!(br_table_depths.0 == vec![1,2] &&\n    ///             br_table_depths.1 == 0);\n    /// } else {\n    ///     unreachable!();\n    /// }\n    /// ```\n    pub fn read_table(&self) -> (Vec<u32>, u32) {\n        let mut reader = BinaryReader::new(self.buffer);\n        let mut table = Vec::with_capacity(self.size);\n        for _ in 0..self.size {\n            table.push(reader.read_var_u32().unwrap());\n        }\n        let default_target = reader.read_var_u32().unwrap();\n        assert!(reader.eof());\n        (table, default_target)\n    }\n}\n\n/// Iterator for `BrTable`.\n///\n/// #Examples\n/// ```rust\n/// let buf = vec![0x0e, 0x02, 0x01, 0x02, 0x00];\n/// let mut reader = wasmparser::BinaryReader::new(&buf);\n/// let op = reader.read_operator().unwrap();\n/// if let wasmparser::Operator::BrTable { ref table } = op {\n///     for depth in table {\n///         println!(\"BrTable depth: {}\", depth);\n///     }\n/// }\n/// ```\npub struct BrTableIterator<'a> {\n    reader: BinaryReader<'a>,\n    left: usize,\n}\n\nimpl<'a> IntoIterator for &'a BrTable<'a> {\n    type Item = u32;\n    type IntoIter = BrTableIterator<'a>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        BrTableIterator {\n            reader: BinaryReader::new(self.buffer),\n            left: self.size + 1,\n        }\n    }\n}\n\nimpl<'a> Iterator for BrTableIterator<'a> {\n    type Item = u32;\n\n    fn next(&mut self) -> Option<u32> {\n        if self.left == 0 {\n            return None;\n        }\n        self.left -= 1;\n        Some(self.reader.read_var_u32().unwrap())\n    }\n}\n\n#[derive(Debug)]\npub enum ImportSectionEntryType {\n    Function(u32),\n    Table(TableType),\n    Memory(MemoryType),\n    Global(GlobalType),\n}\n\n#[derive(Debug)]\npub enum RelocType {\n    FunctionIndexLEB,\n    TableIndexSLEB,\n    TableIndexI32,\n    GlobalAddrLEB,\n    GlobalAddrSLEB,\n    GlobalAddrI32,\n    TypeIndexLEB,\n    GlobalIndexLEB,\n}\n\n#[derive(Debug)]\npub enum LinkingType {\n    StackPointer(u32),\n}\n\n#[derive(Debug)]\npub struct RelocEntry {\n    pub ty: RelocType,\n    pub offset: u32,\n    pub index: u32,\n    pub addend: Option<u32>,\n}\n\n/// An IEEE binary32 immediate floating point value, represented as a u32\n/// containing the bitpattern.\n///\n/// All bit patterns are allowed.\n#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\npub struct Ieee32(u32);\n\nimpl Ieee32 {\n    pub fn bits(&self) -> u32 {\n        self.0\n    }\n}\n\n/// An IEEE binary64 immediate floating point value, represented as a u64\n/// containing the bitpattern.\n///\n/// All bit patterns are allowed.\n#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\npub struct Ieee64(u64);\n\nimpl Ieee64 {\n    pub fn bits(&self) -> u64 {\n        self.0\n    }\n}\n\n/// Instructions as defined [here].\n///\n/// [here]: https://webassembly.github.io/spec/binary/instructions.html\n#[derive(Debug)]\npub enum Operator<'a> {\n    Unreachable,\n    Nop,\n    Block { ty: Type },\n    Loop { ty: Type },\n    If { ty: Type },\n    Else,\n    End,\n    Br { relative_depth: u32 },\n    BrIf { relative_depth: u32 },\n    BrTable { table: BrTable<'a> },\n    Return,\n    Call { function_index: u32 },\n    CallIndirect { index: u32, table_index: u32 },\n    Drop,\n    Select,\n    GetLocal { local_index: u32 },\n    SetLocal { local_index: u32 },\n    TeeLocal { local_index: u32 },\n    GetGlobal { global_index: u32 },\n    SetGlobal { global_index: u32 },\n    I32Load { memarg: MemoryImmediate },\n    I64Load { memarg: MemoryImmediate },\n    F32Load { memarg: MemoryImmediate },\n    F64Load { memarg: MemoryImmediate },\n    I32Load8S { memarg: MemoryImmediate },\n    I32Load8U { memarg: MemoryImmediate },\n    I32Load16S { memarg: MemoryImmediate },\n    I32Load16U { memarg: MemoryImmediate },\n    I64Load8S { memarg: MemoryImmediate },\n    I64Load8U { memarg: MemoryImmediate },\n    I64Load16S { memarg: MemoryImmediate },\n    I64Load16U { memarg: MemoryImmediate },\n    I64Load32S { memarg: MemoryImmediate },\n    I64Load32U { memarg: MemoryImmediate },\n    I32Store { memarg: MemoryImmediate },\n    I64Store { memarg: MemoryImmediate },\n    F32Store { memarg: MemoryImmediate },\n    F64Store { memarg: MemoryImmediate },\n    I32Store8 { memarg: MemoryImmediate },\n    I32Store16 { memarg: MemoryImmediate },\n    I64Store8 { memarg: MemoryImmediate },\n    I64Store16 { memarg: MemoryImmediate },\n    I64Store32 { memarg: MemoryImmediate },\n    CurrentMemory { reserved: u32 },\n    GrowMemory { reserved: u32 },\n    I32Const { value: i32 },\n    I64Const { value: i64 },\n    F32Const { value: Ieee32 },\n    F64Const { value: Ieee64 },\n    I32Eqz,\n    I32Eq,\n    I32Ne,\n    I32LtS,\n    I32LtU,\n    I32GtS,\n    I32GtU,\n    I32LeS,\n    I32LeU,\n    I32GeS,\n    I32GeU,\n    I64Eqz,\n    I64Eq,\n    I64Ne,\n    I64LtS,\n    I64LtU,\n    I64GtS,\n    I64GtU,\n    I64LeS,\n    I64LeU,\n    I64GeS,\n    I64GeU,\n    F32Eq,\n    F32Ne,\n    F32Lt,\n    F32Gt,\n    F32Le,\n    F32Ge,\n    F64Eq,\n    F64Ne,\n    F64Lt,\n    F64Gt,\n    F64Le,\n    F64Ge,\n    I32Clz,\n    I32Ctz,\n    I32Popcnt,\n    I32Add,\n    I32Sub,\n    I32Mul,\n    I32DivS,\n    I32DivU,\n    I32RemS,\n    I32RemU,\n    I32And,\n    I32Or,\n    I32Xor,\n    I32Shl,\n    I32ShrS,\n    I32ShrU,\n    I32Rotl,\n    I32Rotr,\n    I64Clz,\n    I64Ctz,\n    I64Popcnt,\n    I64Add,\n    I64Sub,\n    I64Mul,\n    I64DivS,\n    I64DivU,\n    I64RemS,\n    I64RemU,\n    I64And,\n    I64Or,\n    I64Xor,\n    I64Shl,\n    I64ShrS,\n    I64ShrU,\n    I64Rotl,\n    I64Rotr,\n    F32Abs,\n    F32Neg,\n    F32Ceil,\n    F32Floor,\n    F32Trunc,\n    F32Nearest,\n    F32Sqrt,\n    F32Add,\n    F32Sub,\n    F32Mul,\n    F32Div,\n    F32Min,\n    F32Max,\n    F32Copysign,\n    F64Abs,\n    F64Neg,\n    F64Ceil,\n    F64Floor,\n    F64Trunc,\n    F64Nearest,\n    F64Sqrt,\n    F64Add,\n    F64Sub,\n    F64Mul,\n    F64Div,\n    F64Min,\n    F64Max,\n    F64Copysign,\n    I32WrapI64,\n    I32TruncSF32,\n    I32TruncUF32,\n    I32TruncSF64,\n    I32TruncUF64,\n    I64ExtendSI32,\n    I64ExtendUI32,\n    I64TruncSF32,\n    I64TruncUF32,\n    I64TruncSF64,\n    I64TruncUF64,\n    F32ConvertSI32,\n    F32ConvertUI32,\n    F32ConvertSI64,\n    F32ConvertUI64,\n    F32DemoteF64,\n    F64ConvertSI32,\n    F64ConvertUI32,\n    F64ConvertSI64,\n    F64ConvertUI64,\n    F64PromoteF32,\n    I32ReinterpretF32,\n    I64ReinterpretF64,\n    F32ReinterpretI32,\n    F64ReinterpretI64,\n    I32Extend8S,\n    I32Extend16S,\n    I64Extend8S,\n    I64Extend16S,\n    I64Extend32S,\n\n    // 0xFC operators\n    // Non-trapping Float-to-int Conversions\n    I32TruncSSatF32,\n    I32TruncUSatF32,\n    I32TruncSSatF64,\n    I32TruncUSatF64,\n    I64TruncSSatF32,\n    I64TruncUSatF32,\n    I64TruncSSatF64,\n    I64TruncUSatF64,\n\n    // 0xFE operators\n    // https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md\n    Wake { memarg: MemoryImmediate },\n    I32Wait { memarg: MemoryImmediate },\n    I64Wait { memarg: MemoryImmediate },\n    I32AtomicLoad { memarg: MemoryImmediate },\n    I64AtomicLoad { memarg: MemoryImmediate },\n    I32AtomicLoad8U { memarg: MemoryImmediate },\n    I32AtomicLoad16U { memarg: MemoryImmediate },\n    I64AtomicLoad8U { memarg: MemoryImmediate },\n    I64AtomicLoad16U { memarg: MemoryImmediate },\n    I64AtomicLoad32U { memarg: MemoryImmediate },\n    I32AtomicStore { memarg: MemoryImmediate },\n    I64AtomicStore { memarg: MemoryImmediate },\n    I32AtomicStore8 { memarg: MemoryImmediate },\n    I32AtomicStore16 { memarg: MemoryImmediate },\n    I64AtomicStore8 { memarg: MemoryImmediate },\n    I64AtomicStore16 { memarg: MemoryImmediate },\n    I64AtomicStore32 { memarg: MemoryImmediate },\n    I32AtomicRmwAdd { memarg: MemoryImmediate },\n    I64AtomicRmwAdd { memarg: MemoryImmediate },\n    I32AtomicRmw8UAdd { memarg: MemoryImmediate },\n    I32AtomicRmw16UAdd { memarg: MemoryImmediate },\n    I64AtomicRmw8UAdd { memarg: MemoryImmediate },\n    I64AtomicRmw16UAdd { memarg: MemoryImmediate },\n    I64AtomicRmw32UAdd { memarg: MemoryImmediate },\n    I32AtomicRmwSub { memarg: MemoryImmediate },\n    I64AtomicRmwSub { memarg: MemoryImmediate },\n    I32AtomicRmw8USub { memarg: MemoryImmediate },\n    I32AtomicRmw16USub { memarg: MemoryImmediate },\n    I64AtomicRmw8USub { memarg: MemoryImmediate },\n    I64AtomicRmw16USub { memarg: MemoryImmediate },\n    I64AtomicRmw32USub { memarg: MemoryImmediate },\n    I32AtomicRmwAnd { memarg: MemoryImmediate },\n    I64AtomicRmwAnd { memarg: MemoryImmediate },\n    I32AtomicRmw8UAnd { memarg: MemoryImmediate },\n    I32AtomicRmw16UAnd { memarg: MemoryImmediate },\n    I64AtomicRmw8UAnd { memarg: MemoryImmediate },\n    I64AtomicRmw16UAnd { memarg: MemoryImmediate },\n    I64AtomicRmw32UAnd { memarg: MemoryImmediate },\n    I32AtomicRmwOr { memarg: MemoryImmediate },\n    I64AtomicRmwOr { memarg: MemoryImmediate },\n    I32AtomicRmw8UOr { memarg: MemoryImmediate },\n    I32AtomicRmw16UOr { memarg: MemoryImmediate },\n    I64AtomicRmw8UOr { memarg: MemoryImmediate },\n    I64AtomicRmw16UOr { memarg: MemoryImmediate },\n    I64AtomicRmw32UOr { memarg: MemoryImmediate },\n    I32AtomicRmwXor { memarg: MemoryImmediate },\n    I64AtomicRmwXor { memarg: MemoryImmediate },\n    I32AtomicRmw8UXor { memarg: MemoryImmediate },\n    I32AtomicRmw16UXor { memarg: MemoryImmediate },\n    I64AtomicRmw8UXor { memarg: MemoryImmediate },\n    I64AtomicRmw16UXor { memarg: MemoryImmediate },\n    I64AtomicRmw32UXor { memarg: MemoryImmediate },\n    I32AtomicRmwXchg { memarg: MemoryImmediate },\n    I64AtomicRmwXchg { memarg: MemoryImmediate },\n    I32AtomicRmw8UXchg { memarg: MemoryImmediate },\n    I32AtomicRmw16UXchg { memarg: MemoryImmediate },\n    I64AtomicRmw8UXchg { memarg: MemoryImmediate },\n    I64AtomicRmw16UXchg { memarg: MemoryImmediate },\n    I64AtomicRmw32UXchg { memarg: MemoryImmediate },\n    I32AtomicRmwCmpxchg { memarg: MemoryImmediate },\n    I64AtomicRmwCmpxchg { memarg: MemoryImmediate },\n    I32AtomicRmw8UCmpxchg { memarg: MemoryImmediate },\n    I32AtomicRmw16UCmpxchg { memarg: MemoryImmediate },\n    I64AtomicRmw8UCmpxchg { memarg: MemoryImmediate },\n    I64AtomicRmw16UCmpxchg { memarg: MemoryImmediate },\n    I64AtomicRmw32UCmpxchg { memarg: MemoryImmediate },\n}\n\nfn is_name(name: &[u8], expected: &'static str) -> bool {\n    if name.len() != expected.len() {\n        return false;\n    }\n    let expected_bytes = expected.as_bytes();\n    for i in 0..name.len() {\n        if name[i] != expected_bytes[i] {\n            return false;\n        }\n    }\n    true\n}\n\nfn is_name_prefix(name: &[u8], prefix: &'static str) -> bool {\n    if name.len() < prefix.len() {\n        return false;\n    }\n    let expected_bytes = prefix.as_bytes();\n    for i in 0..expected_bytes.len() {\n        if name[i] != expected_bytes[i] {\n            return false;\n        }\n    }\n    true\n}\n\nenum InitExpressionContinuation {\n    GlobalSection,\n    ElementSection,\n    DataSection,\n}\n\n/// A binary reader of the WebAssembly structures and types.\npub struct BinaryReader<'a> {\n    buffer: &'a [u8],\n    position: usize,\n    end: usize,\n}\n\nimpl<'a> BinaryReader<'a> {\n    /// Constructs `BinaryReader` type.\n    ///\n    /// # Examples\n    /// ```\n    /// let fn_body = &vec![0x41, 0x00, 0x10, 0x00, 0x0B];\n    /// let mut reader = wasmparser::BinaryReader::new(fn_body);\n    /// while !reader.eof() {\n    ///     let op = reader.read_operator();\n    ///     println!(\"{:?}\", op)\n    /// }\n    /// ```\n    pub fn new(data: &[u8]) -> BinaryReader {\n        BinaryReader {\n            buffer: data,\n            position: 0,\n            end: data.len(),\n        }\n    }\n\n    fn ensure_has_byte(&self) -> Result<()> {\n        if self.position < self.end {\n            Ok(())\n        } else {\n            Err(BinaryReaderError {\n                    message: \"Unexpected EOF\",\n                    offset: self.position,\n                })\n        }\n    }\n\n    fn ensure_has_bytes(&self, len: usize) -> Result<()> {\n        if self.position + len <= self.end {\n            Ok(())\n        } else {\n            Err(BinaryReaderError {\n                    message: \"Unexpected EOF\",\n                    offset: self.position,\n                })\n        }\n    }\n\n    fn read_var_u1(&mut self) -> Result<u32> {\n        let b = self.read_u8()?;\n        if (b & 0xFE) != 0 {\n            return Err(BinaryReaderError {\n                           message: \"Invalid var_u1\",\n                           offset: self.position - 1,\n                       });\n        }\n        Ok(b)\n    }\n\n    fn read_var_i7(&mut self) -> Result<i32> {\n        let b = self.read_u8()?;\n        if (b & 0x80) != 0 {\n            return Err(BinaryReaderError {\n                           message: \"Invalid var_i7\",\n                           offset: self.position - 1,\n                       });\n        }\n        Ok((b << 25) as i32 >> 25)\n    }\n\n    fn read_var_u7(&mut self) -> Result<u32> {\n        let b = self.read_u8()?;\n        if (b & 0x80) != 0 {\n            return Err(BinaryReaderError {\n                           message: \"Invalid var_u7\",\n                           offset: self.position - 1,\n                       });\n        }\n        Ok(b)\n    }\n\n    fn read_type(&mut self) -> Result<Type> {\n        let code = self.read_var_i7()?;\n        match code {\n            -0x01 => Ok(Type::I32),\n            -0x02 => Ok(Type::I64),\n            -0x03 => Ok(Type::F32),\n            -0x04 => Ok(Type::F64),\n            -0x10 => Ok(Type::AnyFunc),\n            -0x20 => Ok(Type::Func),\n            -0x40 => Ok(Type::EmptyBlockType),\n            _ => {\n                Err(BinaryReaderError {\n                        message: \"Invalid type\",\n                        offset: self.position - 1,\n                    })\n            }\n        }\n    }\n\n    /// Read a `count` indicating the number of times to call `read_local_decl`.\n    pub fn read_local_count(&mut self) -> Result<usize> {\n        let local_count = self.read_var_u32()? as usize;\n        if local_count > MAX_WASM_FUNCTION_LOCALS {\n            return Err(BinaryReaderError {\n                           message: \"local_count is out of bounds\",\n                           offset: self.position - 1,\n                       });\n        }\n        Ok(local_count)\n    }\n\n    /// Read a `(count, value_type)` declaration of local variables of the same type.\n    pub fn read_local_decl(&mut self, locals_total: &mut usize) -> Result<(u32, Type)> {\n        let count = self.read_var_u32()?;\n        let value_type = self.read_type()?;\n        *locals_total = locals_total\n            .checked_add(count as usize)\n            .ok_or_else(|| {\n                            BinaryReaderError {\n                                message: \"locals_total is out of bounds\",\n                                offset: self.position - 1,\n                            }\n                        })?;\n        if *locals_total > MAX_WASM_FUNCTION_LOCALS {\n            return Err(BinaryReaderError {\n                           message: \"locals_total is out of bounds\",\n                           offset: self.position - 1,\n                       });\n        }\n        Ok((count, value_type))\n    }\n\n    fn read_external_kind(&mut self) -> Result<ExternalKind> {\n        let code = self.read_u8()?;\n        match code {\n            0 => Ok(ExternalKind::Function),\n            1 => Ok(ExternalKind::Table),\n            2 => Ok(ExternalKind::Memory),\n            3 => Ok(ExternalKind::Global),\n            _ => {\n                Err(BinaryReaderError {\n                        message: \"Invalid external kind\",\n                        offset: self.position - 1,\n                    })\n            }\n        }\n    }\n\n    fn read_func_type(&mut self) -> Result<FuncType> {\n        let form = self.read_type()?;\n        let params_len = self.read_var_u32()? as usize;\n        if params_len > MAX_WASM_FUNCTION_PARAMS {\n            return Err(BinaryReaderError {\n                           message: \"function params size is out of bound\",\n                           offset: self.position - 1,\n                       });\n        }\n        let mut params: Vec<Type> = Vec::with_capacity(params_len);\n        for _ in 0..params_len {\n            params.push(self.read_type()?);\n        }\n        let returns_len = self.read_var_u32()? as usize;\n        if returns_len > MAX_WASM_FUNCTION_RETURNS {\n            return Err(BinaryReaderError {\n                           message: \"function params size is out of bound\",\n                           offset: self.position - 1,\n                       });\n        }\n        let mut returns: Vec<Type> = Vec::with_capacity(returns_len);\n        for _ in 0..returns_len {\n            returns.push(self.read_type()?);\n        }\n        Ok(FuncType {\n               form: form,\n               params: params,\n               returns: returns,\n           })\n    }\n\n    fn read_resizable_limits(&mut self, max_present: bool) -> Result<ResizableLimits> {\n        let initial = self.read_var_u32()?;\n        let maximum = if max_present {\n            Some(self.read_var_u32()?)\n        } else {\n            None\n        };\n        Ok(ResizableLimits { initial, maximum })\n    }\n\n    fn read_table_type(&mut self) -> Result<TableType> {\n        let element_type = self.read_type()?;\n        let flags = self.read_var_u32()?;\n        if (flags & !0x1) != 0 {\n            return Err(BinaryReaderError {\n                           message: \"invalid table resizable limits flags\",\n                           offset: self.position - 1,\n                       });\n        }\n        let limits = self.read_resizable_limits((flags & 0x1) != 0)?;\n        Ok(TableType {\n               element_type,\n               limits,\n           })\n    }\n\n    fn read_memory_type(&mut self) -> Result<MemoryType> {\n        let flags = self.read_var_u32()?;\n        if (flags & !0x3) != 0 {\n            return Err(BinaryReaderError {\n                           message: \"invalid table resizable limits flags\",\n                           offset: self.position - 1,\n                       });\n        }\n        let limits = self.read_resizable_limits((flags & 0x1) != 0)?;\n        let shared = (flags & 0x2) != 0;\n        Ok(MemoryType { limits, shared })\n    }\n\n    fn read_global_type(&mut self) -> Result<GlobalType> {\n        Ok(GlobalType {\n               content_type: self.read_type()?,\n               mutable: self.read_var_u1()? != 0,\n           })\n    }\n\n    fn read_memarg(&mut self) -> Result<MemoryImmediate> {\n        Ok(MemoryImmediate {\n               flags: self.read_var_u32()?,\n               offset: self.read_var_u32()?,\n           })\n    }\n\n    fn read_section_code(&mut self, id: u32, offset: usize) -> Result<SectionCode<'a>> {\n        match id {\n            0 => {\n                let name = self.read_string()?;\n                let kind = if is_name(name, \"name\") {\n                    CustomSectionKind::Name\n                } else if is_name(name, \"sourceMappingURL\") {\n                    CustomSectionKind::SourceMappingURL\n                } else if is_name_prefix(name, \"reloc.\") {\n                    CustomSectionKind::Reloc\n                } else if is_name(name, \"linking\") {\n                    CustomSectionKind::Linking\n                } else {\n                    CustomSectionKind::Unknown\n                };\n                Ok(SectionCode::Custom {\n                       name: name,\n                       kind: kind,\n                   })\n            }\n            1 => Ok(SectionCode::Type),\n            2 => Ok(SectionCode::Import),\n            3 => Ok(SectionCode::Function),\n            4 => Ok(SectionCode::Table),\n            5 => Ok(SectionCode::Memory),\n            6 => Ok(SectionCode::Global),\n            7 => Ok(SectionCode::Export),\n            8 => Ok(SectionCode::Start),\n            9 => Ok(SectionCode::Element),\n            10 => Ok(SectionCode::Code),\n            11 => Ok(SectionCode::Data),\n            _ => {\n                Err(BinaryReaderError {\n                        message: \"Invalid section code\",\n                        offset,\n                    })\n            }\n        }\n    }\n\n    fn read_br_table(&mut self) -> Result<BrTable<'a>> {\n        let targets_len = self.read_var_u32()? as usize;\n        if targets_len > MAX_WASM_BR_TABLE_SIZE {\n            return Err(BinaryReaderError {\n                           message: \"br_table size is out of bound\",\n                           offset: self.position - 1,\n                       });\n        }\n        let start = self.position;\n        for _ in 0..targets_len {\n            self.skip_var_32()?;\n        }\n        self.skip_var_32()?;\n        Ok(BrTable {\n               size: targets_len,\n               buffer: &self.buffer[start..self.position],\n           })\n    }\n\n    fn read_name_map(&mut self, limit: usize) -> Result<Vec<Naming<'a>>> {\n        let count = self.read_var_u32()? as usize;\n        if count > limit {\n            return Err(BinaryReaderError {\n                           message: \"name map size is out of bound\",\n                           offset: self.position - 1,\n                       });\n        }\n        let mut result = Vec::with_capacity(count);\n        for _ in 0..count {\n            let index = self.read_var_u32()?;\n            let name = self.read_string()?;\n            result.push(Naming {\n                            index: index,\n                            name: name,\n                        });\n        }\n        Ok(result)\n    }\n\n    pub fn eof(&self) -> bool {\n        self.position >= self.end\n    }\n\n    pub fn current_position(&self) -> usize {\n        self.position\n    }\n\n    pub fn bytes_remaining(&self) -> usize {\n        self.end - self.position\n    }\n\n    pub fn read_bytes(&mut self, size: usize) -> Result<&'a [u8]> {\n        self.ensure_has_bytes(size)?;\n        let start = self.position;\n        self.position += size;\n        Ok(&self.buffer[start..self.position])\n    }\n\n    pub fn read_u32(&mut self) -> Result<u32> {\n        self.ensure_has_bytes(4)?;\n        let b1 = self.buffer[self.position] as u32;\n        let b2 = self.buffer[self.position + 1] as u32;\n        let b3 = self.buffer[self.position + 2] as u32;\n        let b4 = self.buffer[self.position + 3] as u32;\n        self.position += 4;\n        Ok(b1 | (b2 << 8) | (b3 << 16) | (b4 << 24))\n    }\n\n    pub fn read_u64(&mut self) -> Result<u64> {\n        let w1 = self.read_u32()? as u64;\n        let w2 = self.read_u32()? as u64;\n        Ok(w1 | (w2 << 32))\n    }\n\n    pub fn read_u8(&mut self) -> Result<u32> {\n        self.ensure_has_byte()?;\n        let b = self.buffer[self.position] as u32;\n        self.position += 1;\n        Ok(b)\n    }\n\n    pub fn read_var_u32(&mut self) -> Result<u32> {\n        // Optimization for single byte i32.\n        let byte = self.read_u8()?;\n        if (byte & 0x80) == 0 {\n            return Ok(byte);\n        }\n\n        let mut result = byte & 0x7F;\n        let mut shift = 7;\n        loop {\n            let byte = self.read_u8()?;\n            result |= ((byte & 0x7F) as u32) << shift;\n            shift += 7;\n            if (byte & 0x80) == 0 {\n                break;\n            }\n            if shift >= 32 {\n                return Err(BinaryReaderError {\n                               message: \"Invalid var_u32\",\n                               offset: self.position - 1,\n                           });\n            }\n        }\n        Ok(result)\n    }\n\n    pub fn skip_var_32(&mut self) -> Result<()> {\n        for _ in 0..5 {\n            let byte = self.read_u8()?;\n            if (byte & 0x80) == 0 {\n                return Ok(());\n            }\n        }\n        Err(BinaryReaderError {\n                message: \"Invalid var_32\",\n                offset: self.position - 1,\n            })\n    }\n\n    pub fn read_var_i32(&mut self) -> Result<i32> {\n        // Optimization for single byte i32.\n        let byte = self.read_u8()?;\n        if (byte & 0x80) == 0 {\n            return Ok(((byte as i32) << 25) >> 25);\n        }\n\n        let mut result = (byte & 0x7F) as i32;\n        let mut shift = 7;\n        loop {\n            let byte = self.read_u8()?;\n            result |= ((byte & 0x7F) as i32) << shift;\n            shift += 7;\n            if (byte & 0x80) == 0 {\n                break;\n            }\n            if shift >= 32 {\n                return Err(BinaryReaderError {\n                               message: \"Invalid var_i32\",\n                               offset: self.position,\n                           });\n            }\n        }\n        if shift >= 32 {\n            return Ok(result);\n        }\n        let ashift = 32 - shift;\n        Ok((result << ashift) >> ashift)\n    }\n\n    pub fn read_var_i64(&mut self) -> Result<i64> {\n        let mut result: i64 = 0;\n        let mut shift = 0;\n        loop {\n            let byte = self.read_u8()?;\n            result |= ((byte & 0x7F) as i64) << shift;\n            shift += 7;\n            if (byte & 0x80) == 0 {\n                break;\n            }\n            if shift >= 64 {\n                return Err(BinaryReaderError {\n                               message: \"Invalid var_i64\",\n                               offset: self.position - 1,\n                           });\n            }\n        }\n        if shift >= 64 {\n            return Ok(result);\n        }\n        let ashift = 64 - shift;\n        Ok((result << ashift) >> ashift)\n    }\n\n    pub fn read_f32(&mut self) -> Result<Ieee32> {\n        let value = self.read_u32()?;\n        Ok(Ieee32(value))\n    }\n\n    pub fn read_f64(&mut self) -> Result<Ieee64> {\n        let value = self.read_u64()?;\n        Ok(Ieee64(value))\n    }\n\n    pub fn read_string(&mut self) -> Result<&'a [u8]> {\n        let len = self.read_var_u32()? as usize;\n        if len > MAX_WASM_STRING_SIZE {\n            return Err(BinaryReaderError {\n                           message: \"string size in out of bounds\",\n                           offset: self.position - 1,\n                       });\n        }\n        self.read_bytes(len)\n    }\n\n    fn read_memarg_of_align(&mut self, align: u32) -> Result<MemoryImmediate> {\n        let imm = self.read_memarg()?;\n        if align != imm.flags {\n            return Err(BinaryReaderError {\n                           message: \"Unexpected memarg alignment\",\n                           offset: self.position - 1,\n                       });\n        }\n        Ok(imm)\n    }\n\n    fn read_0xfe_operator(&mut self) -> Result<Operator<'a>> {\n        let code = self.read_u8()? as u8;\n        Ok(match code {\n               0x00 => Operator::Wake { memarg: self.read_memarg_of_align(2)? },\n               0x01 => Operator::I32Wait { memarg: self.read_memarg_of_align(2)? },\n               0x02 => Operator::I64Wait { memarg: self.read_memarg_of_align(3)? },\n               0x10 => Operator::I32AtomicLoad { memarg: self.read_memarg_of_align(2)? },\n               0x11 => Operator::I64AtomicLoad { memarg: self.read_memarg_of_align(3)? },\n               0x12 => Operator::I32AtomicLoad8U { memarg: self.read_memarg_of_align(0)? },\n               0x13 => Operator::I32AtomicLoad16U { memarg: self.read_memarg_of_align(1)? },\n               0x14 => Operator::I64AtomicLoad8U { memarg: self.read_memarg_of_align(0)? },\n               0x15 => Operator::I64AtomicLoad16U { memarg: self.read_memarg_of_align(1)? },\n               0x16 => Operator::I64AtomicLoad32U { memarg: self.read_memarg_of_align(2)? },\n               0x17 => Operator::I32AtomicStore { memarg: self.read_memarg_of_align(2)? },\n               0x18 => Operator::I64AtomicStore { memarg: self.read_memarg_of_align(3)? },\n               0x19 => Operator::I32AtomicStore8 { memarg: self.read_memarg_of_align(0)? },\n               0x1a => Operator::I32AtomicStore16 { memarg: self.read_memarg_of_align(1)? },\n               0x1b => Operator::I64AtomicStore8 { memarg: self.read_memarg_of_align(0)? },\n               0x1c => Operator::I64AtomicStore16 { memarg: self.read_memarg_of_align(1)? },\n               0x1d => Operator::I64AtomicStore32 { memarg: self.read_memarg_of_align(2)? },\n               0x1e => Operator::I32AtomicRmwAdd { memarg: self.read_memarg_of_align(2)? },\n               0x1f => Operator::I64AtomicRmwAdd { memarg: self.read_memarg_of_align(3)? },\n               0x20 => Operator::I32AtomicRmw8UAdd { memarg: self.read_memarg_of_align(0)? },\n               0x21 => Operator::I32AtomicRmw16UAdd { memarg: self.read_memarg_of_align(1)? },\n               0x22 => Operator::I64AtomicRmw8UAdd { memarg: self.read_memarg_of_align(0)? },\n               0x23 => Operator::I64AtomicRmw16UAdd { memarg: self.read_memarg_of_align(1)? },\n               0x24 => Operator::I64AtomicRmw32UAdd { memarg: self.read_memarg_of_align(2)? },\n               0x25 => Operator::I32AtomicRmwSub { memarg: self.read_memarg_of_align(2)? },\n               0x26 => Operator::I64AtomicRmwSub { memarg: self.read_memarg_of_align(3)? },\n               0x27 => Operator::I32AtomicRmw8USub { memarg: self.read_memarg_of_align(0)? },\n               0x28 => Operator::I32AtomicRmw16USub { memarg: self.read_memarg_of_align(1)? },\n               0x29 => Operator::I64AtomicRmw8USub { memarg: self.read_memarg_of_align(0)? },\n               0x2a => Operator::I64AtomicRmw16USub { memarg: self.read_memarg_of_align(1)? },\n               0x2b => Operator::I64AtomicRmw32USub { memarg: self.read_memarg_of_align(2)? },\n               0x2c => Operator::I32AtomicRmwAnd { memarg: self.read_memarg_of_align(2)? },\n               0x2d => Operator::I64AtomicRmwAnd { memarg: self.read_memarg_of_align(3)? },\n               0x2e => Operator::I32AtomicRmw8UAnd { memarg: self.read_memarg_of_align(0)? },\n               0x2f => Operator::I32AtomicRmw16UAnd { memarg: self.read_memarg_of_align(1)? },\n               0x30 => Operator::I64AtomicRmw8UAnd { memarg: self.read_memarg_of_align(0)? },\n               0x31 => Operator::I64AtomicRmw16UAnd { memarg: self.read_memarg_of_align(1)? },\n               0x32 => Operator::I64AtomicRmw32UAnd { memarg: self.read_memarg_of_align(2)? },\n               0x33 => Operator::I32AtomicRmwOr { memarg: self.read_memarg_of_align(2)? },\n               0x34 => Operator::I64AtomicRmwOr { memarg: self.read_memarg_of_align(3)? },\n               0x35 => Operator::I32AtomicRmw8UOr { memarg: self.read_memarg_of_align(0)? },\n               0x36 => Operator::I32AtomicRmw16UOr { memarg: self.read_memarg_of_align(1)? },\n               0x37 => Operator::I64AtomicRmw8UOr { memarg: self.read_memarg_of_align(0)? },\n               0x38 => Operator::I64AtomicRmw16UOr { memarg: self.read_memarg_of_align(1)? },\n               0x39 => Operator::I64AtomicRmw32UOr { memarg: self.read_memarg_of_align(2)? },\n               0x3a => Operator::I32AtomicRmwXor { memarg: self.read_memarg_of_align(2)? },\n               0x3b => Operator::I64AtomicRmwXor { memarg: self.read_memarg_of_align(3)? },\n               0x3c => Operator::I32AtomicRmw8UXor { memarg: self.read_memarg_of_align(0)? },\n               0x3d => Operator::I32AtomicRmw16UXor { memarg: self.read_memarg_of_align(1)? },\n               0x3e => Operator::I64AtomicRmw8UXor { memarg: self.read_memarg_of_align(0)? },\n               0x3f => Operator::I64AtomicRmw16UXor { memarg: self.read_memarg_of_align(1)? },\n               0x40 => Operator::I64AtomicRmw32UXor { memarg: self.read_memarg_of_align(2)? },\n               0x41 => Operator::I32AtomicRmwXchg { memarg: self.read_memarg_of_align(2)? },\n               0x42 => Operator::I64AtomicRmwXchg { memarg: self.read_memarg_of_align(3)? },\n               0x43 => Operator::I32AtomicRmw8UXchg { memarg: self.read_memarg_of_align(0)? },\n               0x44 => Operator::I32AtomicRmw16UXchg { memarg: self.read_memarg_of_align(1)? },\n               0x45 => Operator::I64AtomicRmw8UXchg { memarg: self.read_memarg_of_align(0)? },\n               0x46 => Operator::I64AtomicRmw16UXchg { memarg: self.read_memarg_of_align(1)? },\n               0x47 => Operator::I64AtomicRmw32UXchg { memarg: self.read_memarg_of_align(2)? },\n               0x48 => Operator::I32AtomicRmwCmpxchg { memarg: self.read_memarg_of_align(2)? },\n               0x49 => Operator::I64AtomicRmwCmpxchg { memarg: self.read_memarg_of_align(3)? },\n               0x4a => Operator::I32AtomicRmw8UCmpxchg { memarg: self.read_memarg_of_align(0)? },\n               0x4b => Operator::I32AtomicRmw16UCmpxchg { memarg: self.read_memarg_of_align(1)? },\n               0x4c => Operator::I64AtomicRmw8UCmpxchg { memarg: self.read_memarg_of_align(0)? },\n               0x4d => Operator::I64AtomicRmw16UCmpxchg { memarg: self.read_memarg_of_align(1)? },\n               0x4e => Operator::I64AtomicRmw32UCmpxchg { memarg: self.read_memarg_of_align(2)? },\n\n               _ => {\n                   return Err(BinaryReaderError {\n                                  message: \"Unknown 0xFE opcode\",\n                                  offset: self.position - 1,\n                              })\n               }\n           })\n    }\n\n    pub fn read_operator(&mut self) -> Result<Operator<'a>> {\n        let code = self.read_u8()? as u8;\n        Ok(match code {\n               0x00 => Operator::Unreachable,\n               0x01 => Operator::Nop,\n               0x02 => Operator::Block { ty: self.read_type()? },\n               0x03 => Operator::Loop { ty: self.read_type()? },\n               0x04 => Operator::If { ty: self.read_type()? },\n               0x05 => Operator::Else,\n               0x0b => Operator::End,\n               0x0c => Operator::Br { relative_depth: self.read_var_u32()? },\n               0x0d => Operator::BrIf { relative_depth: self.read_var_u32()? },\n               0x0e => Operator::BrTable { table: self.read_br_table()? },\n               0x0f => Operator::Return,\n               0x10 => Operator::Call { function_index: self.read_var_u32()? },\n               0x11 => {\n                   Operator::CallIndirect {\n                       index: self.read_var_u32()?,\n                       table_index: self.read_var_u1()?,\n                   }\n               }\n               0x1a => Operator::Drop,\n               0x1b => Operator::Select,\n               0x20 => Operator::GetLocal { local_index: self.read_var_u32()? },\n               0x21 => Operator::SetLocal { local_index: self.read_var_u32()? },\n               0x22 => Operator::TeeLocal { local_index: self.read_var_u32()? },\n               0x23 => Operator::GetGlobal { global_index: self.read_var_u32()? },\n               0x24 => Operator::SetGlobal { global_index: self.read_var_u32()? },\n               0x28 => Operator::I32Load { memarg: self.read_memarg()? },\n               0x29 => Operator::I64Load { memarg: self.read_memarg()? },\n               0x2a => Operator::F32Load { memarg: self.read_memarg()? },\n               0x2b => Operator::F64Load { memarg: self.read_memarg()? },\n               0x2c => Operator::I32Load8S { memarg: self.read_memarg()? },\n               0x2d => Operator::I32Load8U { memarg: self.read_memarg()? },\n               0x2e => Operator::I32Load16S { memarg: self.read_memarg()? },\n               0x2f => Operator::I32Load16U { memarg: self.read_memarg()? },\n               0x30 => Operator::I64Load8S { memarg: self.read_memarg()? },\n               0x31 => Operator::I64Load8U { memarg: self.read_memarg()? },\n               0x32 => Operator::I64Load16S { memarg: self.read_memarg()? },\n               0x33 => Operator::I64Load16U { memarg: self.read_memarg()? },\n               0x34 => Operator::I64Load32S { memarg: self.read_memarg()? },\n               0x35 => Operator::I64Load32U { memarg: self.read_memarg()? },\n               0x36 => Operator::I32Store { memarg: self.read_memarg()? },\n               0x37 => Operator::I64Store { memarg: self.read_memarg()? },\n               0x38 => Operator::F32Store { memarg: self.read_memarg()? },\n               0x39 => Operator::F64Store { memarg: self.read_memarg()? },\n               0x3a => Operator::I32Store8 { memarg: self.read_memarg()? },\n               0x3b => Operator::I32Store16 { memarg: self.read_memarg()? },\n               0x3c => Operator::I64Store8 { memarg: self.read_memarg()? },\n               0x3d => Operator::I64Store16 { memarg: self.read_memarg()? },\n               0x3e => Operator::I64Store32 { memarg: self.read_memarg()? },\n               0x3f => Operator::CurrentMemory { reserved: self.read_var_u1()? },\n               0x40 => Operator::GrowMemory { reserved: self.read_var_u1()? },\n               0x41 => Operator::I32Const { value: self.read_var_i32()? },\n               0x42 => Operator::I64Const { value: self.read_var_i64()? },\n               0x43 => Operator::F32Const { value: self.read_f32()? },\n               0x44 => Operator::F64Const { value: self.read_f64()? },\n               0x45 => Operator::I32Eqz,\n               0x46 => Operator::I32Eq,\n               0x47 => Operator::I32Ne,\n               0x48 => Operator::I32LtS,\n               0x49 => Operator::I32LtU,\n               0x4a => Operator::I32GtS,\n               0x4b => Operator::I32GtU,\n               0x4c => Operator::I32LeS,\n               0x4d => Operator::I32LeU,\n               0x4e => Operator::I32GeS,\n               0x4f => Operator::I32GeU,\n               0x50 => Operator::I64Eqz,\n               0x51 => Operator::I64Eq,\n               0x52 => Operator::I64Ne,\n               0x53 => Operator::I64LtS,\n               0x54 => Operator::I64LtU,\n               0x55 => Operator::I64GtS,\n               0x56 => Operator::I64GtU,\n               0x57 => Operator::I64LeS,\n               0x58 => Operator::I64LeU,\n               0x59 => Operator::I64GeS,\n               0x5a => Operator::I64GeU,\n               0x5b => Operator::F32Eq,\n               0x5c => Operator::F32Ne,\n               0x5d => Operator::F32Lt,\n               0x5e => Operator::F32Gt,\n               0x5f => Operator::F32Le,\n               0x60 => Operator::F32Ge,\n               0x61 => Operator::F64Eq,\n               0x62 => Operator::F64Ne,\n               0x63 => Operator::F64Lt,\n               0x64 => Operator::F64Gt,\n               0x65 => Operator::F64Le,\n               0x66 => Operator::F64Ge,\n               0x67 => Operator::I32Clz,\n               0x68 => Operator::I32Ctz,\n               0x69 => Operator::I32Popcnt,\n               0x6a => Operator::I32Add,\n               0x6b => Operator::I32Sub,\n               0x6c => Operator::I32Mul,\n               0x6d => Operator::I32DivS,\n               0x6e => Operator::I32DivU,\n               0x6f => Operator::I32RemS,\n               0x70 => Operator::I32RemU,\n               0x71 => Operator::I32And,\n               0x72 => Operator::I32Or,\n               0x73 => Operator::I32Xor,\n               0x74 => Operator::I32Shl,\n               0x75 => Operator::I32ShrS,\n               0x76 => Operator::I32ShrU,\n               0x77 => Operator::I32Rotl,\n               0x78 => Operator::I32Rotr,\n               0x79 => Operator::I64Clz,\n               0x7a => Operator::I64Ctz,\n               0x7b => Operator::I64Popcnt,\n               0x7c => Operator::I64Add,\n               0x7d => Operator::I64Sub,\n               0x7e => Operator::I64Mul,\n               0x7f => Operator::I64DivS,\n               0x80 => Operator::I64DivU,\n               0x81 => Operator::I64RemS,\n               0x82 => Operator::I64RemU,\n               0x83 => Operator::I64And,\n               0x84 => Operator::I64Or,\n               0x85 => Operator::I64Xor,\n               0x86 => Operator::I64Shl,\n               0x87 => Operator::I64ShrS,\n               0x88 => Operator::I64ShrU,\n               0x89 => Operator::I64Rotl,\n               0x8a => Operator::I64Rotr,\n               0x8b => Operator::F32Abs,\n               0x8c => Operator::F32Neg,\n               0x8d => Operator::F32Ceil,\n               0x8e => Operator::F32Floor,\n               0x8f => Operator::F32Trunc,\n               0x90 => Operator::F32Nearest,\n               0x91 => Operator::F32Sqrt,\n               0x92 => Operator::F32Add,\n               0x93 => Operator::F32Sub,\n               0x94 => Operator::F32Mul,\n               0x95 => Operator::F32Div,\n               0x96 => Operator::F32Min,\n               0x97 => Operator::F32Max,\n               0x98 => Operator::F32Copysign,\n               0x99 => Operator::F64Abs,\n               0x9a => Operator::F64Neg,\n               0x9b => Operator::F64Ceil,\n               0x9c => Operator::F64Floor,\n               0x9d => Operator::F64Trunc,\n               0x9e => Operator::F64Nearest,\n               0x9f => Operator::F64Sqrt,\n               0xa0 => Operator::F64Add,\n               0xa1 => Operator::F64Sub,\n               0xa2 => Operator::F64Mul,\n               0xa3 => Operator::F64Div,\n               0xa4 => Operator::F64Min,\n               0xa5 => Operator::F64Max,\n               0xa6 => Operator::F64Copysign,\n               0xa7 => Operator::I32WrapI64,\n               0xa8 => Operator::I32TruncSF32,\n               0xa9 => Operator::I32TruncUF32,\n               0xaa => Operator::I32TruncSF64,\n               0xab => Operator::I32TruncUF64,\n               0xac => Operator::I64ExtendSI32,\n               0xad => Operator::I64ExtendUI32,\n               0xae => Operator::I64TruncSF32,\n               0xaf => Operator::I64TruncUF32,\n               0xb0 => Operator::I64TruncSF64,\n               0xb1 => Operator::I64TruncUF64,\n               0xb2 => Operator::F32ConvertSI32,\n               0xb3 => Operator::F32ConvertUI32,\n               0xb4 => Operator::F32ConvertSI64,\n               0xb5 => Operator::F32ConvertUI64,\n               0xb6 => Operator::F32DemoteF64,\n               0xb7 => Operator::F64ConvertSI32,\n               0xb8 => Operator::F64ConvertUI32,\n               0xb9 => Operator::F64ConvertSI64,\n               0xba => Operator::F64ConvertUI64,\n               0xbb => Operator::F64PromoteF32,\n               0xbc => Operator::I32ReinterpretF32,\n               0xbd => Operator::I64ReinterpretF64,\n               0xbe => Operator::F32ReinterpretI32,\n               0xbf => Operator::F64ReinterpretI64,\n\n               0xc0 => Operator::I32Extend8S,\n               0xc1 => Operator::I32Extend16S,\n               0xc2 => Operator::I64Extend8S,\n               0xc3 => Operator::I64Extend16S,\n               0xc4 => Operator::I64Extend32S,\n\n               0xfc => self.read_0xfc_operator()?,\n\n               0xfe => self.read_0xfe_operator()?,\n\n               _ => {\n                   return Err(BinaryReaderError {\n                                  message: \"Unknown opcode\",\n                                  offset: self.position - 1,\n                              })\n               }\n           })\n    }\n\n    fn read_0xfc_operator(&mut self) -> Result<Operator<'a>> {\n        let code = self.read_u8()? as u8;\n        Ok(match code {\n               0x00 => Operator::I32TruncSSatF32,\n               0x01 => Operator::I32TruncUSatF32,\n               0x02 => Operator::I32TruncSSatF64,\n               0x03 => Operator::I32TruncUSatF64,\n               0x04 => Operator::I64TruncSSatF32,\n               0x05 => Operator::I64TruncUSatF32,\n               0x06 => Operator::I64TruncSSatF64,\n               0x07 => Operator::I64TruncUSatF64,\n\n               _ => {\n                   return Err(BinaryReaderError {\n                                  message: \"Unknown 0xfc opcode\",\n                                  offset: self.position - 1,\n                              })\n               }\n           })\n    }\n}\n\n\n/// Bytecode range in the WebAssembly module.\n#[derive(Debug, Copy, Clone)]\npub struct Range {\n    pub start: usize,\n    pub end: usize,\n}\n\nimpl Range {\n    pub fn new(start: usize, end: usize) -> Range {\n        assert!(start <= end);\n        Range { start, end }\n    }\n\n    pub fn slice<'a>(&self, data: &'a [u8]) -> &'a [u8] {\n        &data[self.start..self.end]\n    }\n}\n\n#[derive(Debug)]\npub enum ParserState<'a> {\n    Error(BinaryReaderError),\n    Initial,\n    BeginWasm { version: u32 },\n    EndWasm,\n    BeginSection { code: SectionCode<'a>, range: Range },\n    EndSection,\n    SkippingSection,\n    ReadingCustomSection(CustomSectionKind),\n    ReadingSectionRawData,\n    SectionRawData(&'a [u8]),\n\n    TypeSectionEntry(FuncType),\n    ImportSectionEntry {\n        module: &'a [u8],\n        field: &'a [u8],\n        ty: ImportSectionEntryType,\n    },\n    FunctionSectionEntry(u32),\n    TableSectionEntry(TableType),\n    MemorySectionEntry(MemoryType),\n    ExportSectionEntry {\n        field: &'a [u8],\n        kind: ExternalKind,\n        index: u32,\n    },\n    NameSectionEntry(NameEntry<'a>),\n    StartSectionEntry(u32),\n\n    BeginInitExpressionBody,\n    InitExpressionOperator(Operator<'a>),\n    EndInitExpressionBody,\n\n    BeginFunctionBody { range: Range },\n    FunctionBodyLocals { locals: Vec<(u32, Type)> },\n    CodeOperator(Operator<'a>),\n    EndFunctionBody,\n    SkippingFunctionBody,\n\n    BeginElementSectionEntry(u32),\n    ElementSectionEntryBody(Vec<u32>),\n    EndElementSectionEntry,\n\n    BeginDataSectionEntry(u32),\n    EndDataSectionEntry,\n    BeginDataSectionEntryBody(u32),\n    DataSectionEntryBodyChunk(&'a [u8]),\n    EndDataSectionEntryBody,\n\n    BeginGlobalSectionEntry(GlobalType),\n    EndGlobalSectionEntry,\n\n    RelocSectionHeader(SectionCode<'a>),\n    RelocSectionEntry(RelocEntry),\n    LinkingSectionEntry(LinkingType),\n\n    SourceMappingURL(&'a [u8]),\n}\n\n#[derive(Debug, Copy, Clone)]\npub enum ParserInput {\n    Default,\n    SkipSection,\n    SkipFunctionBody,\n    ReadCustomSection,\n    ReadSectionRawData,\n}\n\npub trait WasmDecoder<'a> {\n    fn read(&mut self) -> &ParserState<'a>;\n    fn push_input(&mut self, input: ParserInput);\n    fn read_with_input(&mut self, input: ParserInput) -> &ParserState<'a>;\n    fn create_binary_reader<'b>(&mut self) -> BinaryReader<'b> where 'a: 'b;\n    fn last_state(&self) -> &ParserState<'a>;\n}\n\n/// The `Parser` type. A simple event-driven parser of WebAssembly binary\n/// format. The `read(&mut self)` is used to iterate through WebAssembly records.\npub struct Parser<'a> {\n    reader: BinaryReader<'a>,\n    state: ParserState<'a>,\n    section_range: Option<Range>,\n    function_range: Option<Range>,\n    init_expr_continuation: Option<InitExpressionContinuation>,\n    read_data_bytes: Option<u32>,\n    section_entries_left: u32,\n}\n\nconst WASM_MAGIC_NUMBER: u32 = 0x6d736100;\nconst WASM_EXPERIMENTAL_VERSION: u32 = 0xd;\nconst WASM_SUPPORTED_VERSION: u32 = 0x1;\n\nimpl<'a> Parser<'a> {\n    /// Constructs `Parser` type.\n    ///\n    /// # Examples\n    /// ```\n    /// let data: &[u8] = &[0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,\n    ///     0x01, 0x4, 0x01, 0x60, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00,\n    ///     0x0a, 0x05, 0x01, 0x03, 0x00, 0x01, 0x0b];\n    /// let mut parser = wasmparser::Parser::new(data);\n    /// ```\n    pub fn new(data: &[u8]) -> Parser {\n        Parser {\n            reader: BinaryReader::new(data),\n            state: ParserState::Initial,\n            section_range: None,\n            function_range: None,\n            init_expr_continuation: None,\n            read_data_bytes: None,\n            section_entries_left: 0,\n        }\n    }\n\n    pub fn eof(&self) -> bool {\n        self.reader.eof()\n    }\n\n    pub fn current_position(&self) -> usize {\n        self.reader.current_position()\n    }\n\n    fn read_header(&mut self) -> Result<()> {\n        let magic_number = self.reader.read_u32()?;\n        if magic_number != WASM_MAGIC_NUMBER {\n            return Err(BinaryReaderError {\n                           message: \"Bad magic number\",\n                           offset: self.reader.position - 4,\n                       });\n        }\n        let version = self.reader.read_u32()?;\n        if version != WASM_SUPPORTED_VERSION && version != WASM_EXPERIMENTAL_VERSION {\n            return Err(BinaryReaderError {\n                           message: \"Bad version number\",\n                           offset: self.reader.position - 4,\n                       });\n        }\n        self.state = ParserState::BeginWasm { version: version };\n        Ok(())\n    }\n\n    fn read_section_header(&mut self) -> Result<()> {\n        let id_position = self.reader.position;\n        let id = self.reader.read_var_u7()?;\n        let payload_len = self.reader.read_var_u32()? as usize;\n        let payload_end = self.reader.position + payload_len;\n        let code = self.reader.read_section_code(id, id_position)?;\n        if self.reader.end < payload_end {\n            return Err(BinaryReaderError {\n                           message: \"Section body extends past end of file\",\n                           offset: self.reader.end,\n                       });\n        }\n        if self.reader.position > payload_end {\n            return Err(BinaryReaderError {\n                           message: \"Section header is too big to fit into section body\",\n                           offset: payload_end,\n                       });\n        }\n        let range = Range {\n            start: self.reader.position,\n            end: payload_end,\n        };\n        self.state = ParserState::BeginSection { code, range };\n        self.section_range = Some(range);\n        Ok(())\n    }\n\n    fn read_type_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        self.state = ParserState::TypeSectionEntry(self.reader.read_func_type()?);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_import_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        let module = self.reader.read_string()?;\n        let field = self.reader.read_string()?;\n        let kind = self.reader.read_external_kind()?;\n        let ty: ImportSectionEntryType;\n        match kind {\n            ExternalKind::Function => {\n                ty = ImportSectionEntryType::Function(self.reader.read_var_u32()?)\n            }\n            ExternalKind::Table => {\n                ty = ImportSectionEntryType::Table(self.reader.read_table_type()?)\n            }\n            ExternalKind::Memory => {\n                ty = ImportSectionEntryType::Memory(self.reader.read_memory_type()?)\n            }\n            ExternalKind::Global => {\n                ty = ImportSectionEntryType::Global(self.reader.read_global_type()?)\n            }\n        }\n\n        self.state = ParserState::ImportSectionEntry {\n            module: module,\n            field: field,\n            ty: ty,\n        };\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_function_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        self.state = ParserState::FunctionSectionEntry(self.reader.read_var_u32()?);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_memory_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        self.state = ParserState::MemorySectionEntry(self.reader.read_memory_type()?);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_global_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        self.state = ParserState::BeginGlobalSectionEntry(self.reader.read_global_type()?);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_init_expression_body(&mut self, cont: InitExpressionContinuation) {\n        self.state = ParserState::BeginInitExpressionBody;\n        self.init_expr_continuation = Some(cont);\n    }\n\n    fn read_init_expression_operator(&mut self) -> Result<()> {\n        let op = self.reader.read_operator()?;\n        if let Operator::End = op {\n            self.state = ParserState::EndInitExpressionBody;\n            return Ok(());\n        }\n        self.state = ParserState::InitExpressionOperator(op);\n        Ok(())\n    }\n\n    fn read_export_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        let field = self.reader.read_string()?;\n        let kind = self.reader.read_external_kind()?;\n        let index = self.reader.read_var_u32()?;\n        self.state = ParserState::ExportSectionEntry {\n            field: field,\n            kind: kind,\n            index: index,\n        };\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_element_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        self.state = ParserState::BeginElementSectionEntry(self.reader.read_var_u32()?);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_element_entry_body(&mut self) -> Result<()> {\n        let num_elements = self.reader.read_var_u32()? as usize;\n        if num_elements > MAX_WASM_TABLE_ENTRIES {\n            return Err(BinaryReaderError {\n                           message: \"num_elements is out of bounds\",\n                           offset: self.reader.position - 1,\n                       });\n        }\n        let mut elements: Vec<u32> = Vec::with_capacity(num_elements);\n        for _ in 0..num_elements {\n            elements.push(self.reader.read_var_u32()?);\n        }\n        self.state = ParserState::ElementSectionEntryBody(elements);\n        Ok(())\n    }\n\n    fn read_function_body(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        let size = self.reader.read_var_u32()? as usize;\n        let body_end = self.reader.position + size;\n        let range = Range {\n            start: self.reader.position,\n            end: body_end,\n        };\n        self.state = ParserState::BeginFunctionBody { range };\n        self.function_range = Some(range);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_function_body_locals(&mut self) -> Result<()> {\n        let local_count = self.reader.read_local_count()?;\n        let mut locals: Vec<(u32, Type)> = Vec::with_capacity(local_count);\n        let mut locals_total = 0;\n        for _ in 0..local_count {\n            let (count, ty) = self.reader.read_local_decl(&mut locals_total)?;\n            locals.push((count, ty));\n        }\n        self.state = ParserState::FunctionBodyLocals { locals };\n        Ok(())\n    }\n\n    fn read_code_operator(&mut self) -> Result<()> {\n        if self.reader.position >= self.function_range.unwrap().end {\n            if let ParserState::CodeOperator(Operator::End) = self.state {\n                self.state = ParserState::EndFunctionBody;\n                self.function_range = None;\n                return Ok(());\n            }\n            return Err(BinaryReaderError {\n                           message: \"Expected end of function marker\",\n                           offset: self.function_range.unwrap().end,\n                       });\n        }\n        let op = self.reader.read_operator()?;\n        self.state = ParserState::CodeOperator(op);\n        Ok(())\n    }\n\n    fn read_table_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        self.state = ParserState::TableSectionEntry(self.reader.read_table_type()?);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_data_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        let index = self.reader.read_var_u32()?;\n        self.state = ParserState::BeginDataSectionEntry(index);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_data_entry_body(&mut self) -> Result<()> {\n        let size = self.reader.read_var_u32()?;\n        self.state = ParserState::BeginDataSectionEntryBody(size);\n        self.read_data_bytes = Some(size);\n        Ok(())\n    }\n\n    fn read_name_type(&mut self) -> Result<NameType> {\n        let code = self.reader.read_var_u7()?;\n        match code {\n            0 => Ok(NameType::Module),\n            1 => Ok(NameType::Function),\n            2 => Ok(NameType::Local),\n            _ => {\n                Err(BinaryReaderError {\n                        message: \"Invalid name type\",\n                        offset: self.reader.position - 1,\n                    })\n            }\n        }\n    }\n\n    fn read_name_entry(&mut self) -> Result<()> {\n        if self.reader.position >= self.section_range.unwrap().end {\n            return self.position_to_section_end();\n        }\n        let ty = self.read_name_type()?;\n        self.reader.read_var_u32()?; // payload_len\n        let entry = match ty {\n            NameType::Module => NameEntry::Module(self.reader.read_string()?),\n            NameType::Function => {\n                NameEntry::Function(self.reader.read_name_map(MAX_WASM_FUNCTIONS)?)\n            }\n            NameType::Local => {\n                let funcs_len = self.reader.read_var_u32()? as usize;\n                if funcs_len > MAX_WASM_FUNCTIONS {\n                    return Err(BinaryReaderError {\n                                   message: \"function count is out of bounds\",\n                                   offset: self.reader.position - 1,\n                               });\n                }\n                let mut funcs: Vec<LocalName<'a>> = Vec::with_capacity(funcs_len);\n                for _ in 0..funcs_len {\n                    funcs.push(LocalName {\n                                   index: self.reader.read_var_u32()?,\n                                   locals: self.reader.read_name_map(MAX_WASM_FUNCTION_LOCALS)?,\n                               });\n                }\n                NameEntry::Local(funcs)\n            }\n        };\n        self.state = ParserState::NameSectionEntry(entry);\n        Ok(())\n    }\n\n    fn read_source_mapping(&mut self) -> Result<()> {\n        self.state = ParserState::SourceMappingURL(self.reader.read_string()?);\n        Ok(())\n    }\n\n    // See https://github.com/WebAssembly/tool-conventions/blob/master/Linking.md\n    fn read_reloc_header(&mut self) -> Result<()> {\n        let section_id_position = self.reader.position;\n        let section_id = self.reader.read_var_u7()?;\n        let section_code = self.reader\n            .read_section_code(section_id, section_id_position)?;\n        self.state = ParserState::RelocSectionHeader(section_code);\n        Ok(())\n    }\n\n    fn read_reloc_type(&mut self) -> Result<RelocType> {\n        let code = self.reader.read_var_u7()?;\n        match code {\n            0 => Ok(RelocType::FunctionIndexLEB),\n            1 => Ok(RelocType::TableIndexSLEB),\n            2 => Ok(RelocType::TableIndexI32),\n            3 => Ok(RelocType::GlobalAddrLEB),\n            4 => Ok(RelocType::GlobalAddrSLEB),\n            5 => Ok(RelocType::GlobalAddrI32),\n            6 => Ok(RelocType::TypeIndexLEB),\n            7 => Ok(RelocType::GlobalIndexLEB),\n            _ => {\n                Err(BinaryReaderError {\n                        message: \"Invalid reloc type\",\n                        offset: self.reader.position - 1,\n                    })\n            }\n        }\n    }\n\n    fn read_reloc_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        let ty = self.read_reloc_type()?;\n        let offset = self.reader.read_var_u32()?;\n        let index = self.reader.read_var_u32()?;\n        let addend = match ty {\n            RelocType::FunctionIndexLEB |\n            RelocType::TableIndexSLEB |\n            RelocType::TableIndexI32 |\n            RelocType::TypeIndexLEB |\n            RelocType::GlobalIndexLEB => None,\n            RelocType::GlobalAddrLEB |\n            RelocType::GlobalAddrSLEB |\n            RelocType::GlobalAddrI32 => Some(self.reader.read_var_u32()?),\n        };\n        self.state = ParserState::RelocSectionEntry(RelocEntry {\n                                                        ty: ty,\n                                                        offset: offset,\n                                                        index: index,\n                                                        addend: addend,\n                                                    });\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_linking_entry(&mut self) -> Result<()> {\n        if self.section_entries_left == 0 {\n            return self.position_to_section_end();\n        }\n        let ty = self.reader.read_var_u32()?;\n        let entry = match ty {\n            1 => LinkingType::StackPointer(self.reader.read_var_u32()?),\n            _ => {\n                return Err(BinaryReaderError {\n                               message: \"Invalid linking type\",\n                               offset: self.reader.position - 1,\n                           });\n            }\n        };\n        self.state = ParserState::LinkingSectionEntry(entry);\n        self.section_entries_left -= 1;\n        Ok(())\n    }\n\n    fn read_section_body(&mut self) -> Result<()> {\n        match self.state {\n            ParserState::BeginSection { code: SectionCode::Type, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_type_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Import, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_import_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Function, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_function_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Memory, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_memory_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Global, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_global_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Export, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_export_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Element, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_element_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Code, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_function_body()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Table, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_table_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Data, .. } => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_data_entry()?;\n            }\n            ParserState::BeginSection { code: SectionCode::Start, .. } => {\n                self.state = ParserState::StartSectionEntry(self.reader.read_var_u32()?);\n            }\n            ParserState::BeginSection { code: SectionCode::Custom { .. }, .. } => {\n                self.read_section_body_bytes()?;\n            }\n            _ => unreachable!(),\n        }\n        Ok(())\n    }\n\n    fn read_custom_section_body(&mut self) -> Result<()> {\n        match self.state {\n            ParserState::ReadingCustomSection(CustomSectionKind::Name) => {\n                self.read_name_entry()?;\n            }\n            ParserState::ReadingCustomSection(CustomSectionKind::SourceMappingURL) => {\n                self.read_source_mapping()?;\n            }\n            ParserState::ReadingCustomSection(CustomSectionKind::Reloc) => {\n                self.read_reloc_header()?;\n            }\n            ParserState::ReadingCustomSection(CustomSectionKind::Linking) => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_linking_entry()?;\n            }\n            ParserState::ReadingCustomSection(CustomSectionKind::Unknown) => {\n                self.read_section_body_bytes()?;\n            }\n            _ => unreachable!(),\n        }\n        Ok(())\n    }\n\n    fn ensure_reader_position_in_section_range(&self) -> Result<()> {\n        if self.section_range.unwrap().end < self.reader.position {\n            return Err(BinaryReaderError {\n                           message: \"Position past the section end\",\n                           offset: self.section_range.unwrap().end,\n                       });\n        }\n        Ok(())\n    }\n\n    fn position_to_section_end(&mut self) -> Result<()> {\n        self.ensure_reader_position_in_section_range()?;\n        self.reader.position = self.section_range.unwrap().end;\n        self.section_range = None;\n        self.state = ParserState::EndSection;\n        Ok(())\n    }\n\n    fn read_section_body_bytes(&mut self) -> Result<()> {\n        self.ensure_reader_position_in_section_range()?;\n        if self.section_range.unwrap().end == self.reader.position {\n            self.state = ParserState::EndSection;\n            self.section_range = None;\n            return Ok(());\n        }\n        let to_read = if self.section_range.unwrap().end - self.reader.position <\n                         MAX_DATA_CHUNK_SIZE {\n            self.section_range.unwrap().end - self.reader.position\n        } else {\n            MAX_DATA_CHUNK_SIZE\n        };\n        let bytes = self.reader.read_bytes(to_read)?;\n        self.state = ParserState::SectionRawData(bytes);\n        Ok(())\n    }\n\n    fn read_data_chunk(&mut self) -> Result<()> {\n        if self.read_data_bytes.unwrap() == 0 {\n            self.state = ParserState::EndDataSectionEntryBody;\n            self.read_data_bytes = None;\n            return Ok(());\n        }\n        let to_read = if self.read_data_bytes.unwrap() as usize > MAX_DATA_CHUNK_SIZE {\n            MAX_DATA_CHUNK_SIZE\n        } else {\n            self.read_data_bytes.unwrap() as usize\n        };\n        let chunk = self.reader.read_bytes(to_read)?;\n        *self.read_data_bytes.as_mut().unwrap() -= to_read as u32;\n        self.state = ParserState::DataSectionEntryBodyChunk(chunk);\n        Ok(())\n    }\n\n    fn read_next_section(&mut self) -> Result<()> {\n        if self.reader.eof() {\n            self.state = ParserState::EndWasm;\n        } else {\n            self.read_section_header()?;\n        }\n        Ok(())\n    }\n\n    fn read_wrapped(&mut self) -> Result<()> {\n        match self.state {\n            ParserState::EndWasm => panic!(\"Parser in end state\"),\n            ParserState::Error(_) => panic!(\"Parser in error state\"),\n            ParserState::Initial => self.read_header()?,\n            ParserState::BeginWasm { .. } |\n            ParserState::EndSection => self.read_next_section()?,\n            ParserState::BeginSection { .. } => self.read_section_body()?,\n            ParserState::SkippingSection => {\n                self.position_to_section_end()?;\n                self.read_next_section()?;\n            }\n            ParserState::TypeSectionEntry(_) => self.read_type_entry()?,\n            ParserState::ImportSectionEntry { .. } => self.read_import_entry()?,\n            ParserState::FunctionSectionEntry(_) => self.read_function_entry()?,\n            ParserState::MemorySectionEntry(_) => self.read_memory_entry()?,\n            ParserState::TableSectionEntry(_) => self.read_table_entry()?,\n            ParserState::ExportSectionEntry { .. } => self.read_export_entry()?,\n            ParserState::BeginGlobalSectionEntry(_) => {\n                self.read_init_expression_body(InitExpressionContinuation::GlobalSection)\n            }\n            ParserState::EndGlobalSectionEntry => self.read_global_entry()?,\n            ParserState::BeginElementSectionEntry(_) => {\n                self.read_init_expression_body(InitExpressionContinuation::ElementSection)\n            }\n            ParserState::BeginInitExpressionBody |\n            ParserState::InitExpressionOperator(_) => self.read_init_expression_operator()?,\n            ParserState::BeginDataSectionEntry(_) => {\n                self.read_init_expression_body(InitExpressionContinuation::DataSection)\n            }\n            ParserState::EndInitExpressionBody => {\n                match self.init_expr_continuation {\n                    Some(InitExpressionContinuation::GlobalSection) => {\n                        self.state = ParserState::EndGlobalSectionEntry\n                    }\n                    Some(InitExpressionContinuation::ElementSection) => {\n                        self.read_element_entry_body()?\n                    }\n                    Some(InitExpressionContinuation::DataSection) => self.read_data_entry_body()?,\n                    None => unreachable!(),\n                }\n                self.init_expr_continuation = None;\n            }\n            ParserState::BeginFunctionBody { .. } => self.read_function_body_locals()?,\n            ParserState::FunctionBodyLocals { .. } |\n            ParserState::CodeOperator(_) => self.read_code_operator()?,\n            ParserState::EndFunctionBody => self.read_function_body()?,\n            ParserState::SkippingFunctionBody => {\n                assert!(self.reader.position <= self.function_range.unwrap().end);\n                self.reader.position = self.function_range.unwrap().end;\n                self.function_range = None;\n                self.read_function_body()?;\n            }\n            ParserState::EndDataSectionEntry => self.read_data_entry()?,\n            ParserState::BeginDataSectionEntryBody(_) |\n            ParserState::DataSectionEntryBodyChunk(_) => self.read_data_chunk()?,\n            ParserState::EndDataSectionEntryBody => {\n                self.state = ParserState::EndDataSectionEntry;\n            }\n            ParserState::ElementSectionEntryBody(_) => {\n                self.state = ParserState::EndElementSectionEntry;\n            }\n            ParserState::EndElementSectionEntry => self.read_element_entry()?,\n            ParserState::StartSectionEntry(_) => self.position_to_section_end()?,\n            ParserState::NameSectionEntry(_) => self.read_name_entry()?,\n            ParserState::SourceMappingURL(_) => self.position_to_section_end()?,\n            ParserState::RelocSectionHeader(_) => {\n                self.section_entries_left = self.reader.read_var_u32()?;\n                self.read_reloc_entry()?;\n            }\n            ParserState::RelocSectionEntry(_) => self.read_reloc_entry()?,\n            ParserState::LinkingSectionEntry(_) => self.read_linking_entry()?,\n            ParserState::ReadingCustomSection(_) => self.read_custom_section_body()?,\n            ParserState::ReadingSectionRawData |\n            ParserState::SectionRawData(_) => self.read_section_body_bytes()?,\n        }\n        Ok(())\n    }\n\n    fn skip_section(&mut self) {\n        match self.state {\n            ParserState::Initial |\n            ParserState::EndWasm |\n            ParserState::Error(_) |\n            ParserState::BeginWasm { .. } |\n            ParserState::EndSection => panic!(\"Invalid reader state during skip section\"),\n            _ => self.state = ParserState::SkippingSection,\n        }\n    }\n\n    fn skip_function_body(&mut self) {\n        match self.state {\n            ParserState::BeginFunctionBody { .. } |\n            ParserState::FunctionBodyLocals { .. } |\n            ParserState::CodeOperator(_) => self.state = ParserState::SkippingFunctionBody,\n            _ => panic!(\"Invalid reader state during skip function body\"),\n        }\n    }\n\n    fn read_custom_section(&mut self) {\n        match self.state {\n            ParserState::BeginSection { code: SectionCode::Custom { kind, .. }, .. } => {\n                self.state = ParserState::ReadingCustomSection(kind);\n            }\n            _ => panic!(\"Invalid reader state during reading custom section\"),\n        }\n    }\n\n    fn read_raw_section_data(&mut self) {\n        match self.state {\n            ParserState::BeginSection { .. } => self.state = ParserState::ReadingSectionRawData,\n            _ => panic!(\"Invalid reader state during reading raw section data\"),\n        }\n    }\n}\n\nimpl<'a> WasmDecoder<'a> for Parser<'a> {\n    /// Reads next record from the WebAssembly binary data. The methods returns\n    /// reference to current state of the parser. See `ParserState` num.\n    ///\n    /// # Examples\n    /// ```\n    /// # let data: &[u8] = &[0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,\n    /// #     0x01, 0x4, 0x01, 0x60, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00,\n    /// #     0x0a, 0x05, 0x01, 0x03, 0x00, 0x01, 0x0b];\n    /// use wasmparser::WasmDecoder;\n    /// let mut parser = wasmparser::Parser::new(data);\n    /// {\n    ///     let state = parser.read();\n    ///     println!(\"First state {:?}\", state);\n    /// }\n    /// {\n    ///     let state = parser.read();\n    ///     println!(\"Second state {:?}\", state);\n    /// }\n    /// ```\n    fn read(&mut self) -> &ParserState<'a> {\n        let result = self.read_wrapped();\n        if result.is_err() {\n            self.state = ParserState::Error(result.err().unwrap());\n        }\n        &self.state\n    }\n\n    fn push_input(&mut self, input: ParserInput) {\n        match input {\n            ParserInput::Default => (),\n            ParserInput::SkipSection => self.skip_section(),\n            ParserInput::SkipFunctionBody => self.skip_function_body(),\n            ParserInput::ReadCustomSection => self.read_custom_section(),\n            ParserInput::ReadSectionRawData => self.read_raw_section_data(),\n        }\n    }\n\n    /// Creates a BinaryReader when current state is ParserState::BeginSection\n    /// or ParserState::BeginFunctionBody.\n    ///\n    /// # Examples\n    /// ```\n    /// # let data = &[0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x84,\n    /// #              0x80, 0x80, 0x80, 0x0, 0x1, 0x60, 0x0, 0x0, 0x3, 0x83,\n    /// #              0x80, 0x80, 0x80, 0x0, 0x2, 0x0, 0x0, 0x6, 0x81, 0x80,\n    /// #              0x80, 0x80, 0x0, 0x0, 0xa, 0x91, 0x80, 0x80, 0x80, 0x0,\n    /// #              0x2, 0x83, 0x80, 0x80, 0x80, 0x0, 0x0, 0x1, 0xb, 0x83,\n    /// #              0x80, 0x80, 0x80, 0x0, 0x0, 0x0, 0xb];\n    /// use wasmparser::{WasmDecoder, Parser, ParserState};\n    /// let mut parser = Parser::new(data);\n    /// let mut function_readers = Vec::new();\n    /// loop {\n    ///     match *parser.read() {\n    ///         ParserState::Error(_) |\n    ///         ParserState::EndWasm => break,\n    ///         ParserState::BeginFunctionBody {..} => {\n    ///             let reader = parser.create_binary_reader();\n    ///             function_readers.push(reader);\n    ///         }\n    ///         _ => continue\n    ///     }\n    /// }\n    /// for (i, reader) in function_readers.iter_mut().enumerate() {\n    ///     println!(\"Function {}\", i);\n    ///     while let Ok(ref op) = reader.read_operator() {\n    ///       println!(\"  {:?}\", op);\n    ///     }\n    /// }\n    /// ```\n    fn create_binary_reader<'b>(&mut self) -> BinaryReader<'b>\n        where 'a: 'b\n    {\n        let range;\n        match self.state {\n            ParserState::BeginSection { .. } => {\n                range = self.section_range.unwrap();\n                self.skip_section();\n            }\n            ParserState::BeginFunctionBody { .. } |\n            ParserState::FunctionBodyLocals { .. } => {\n                range = self.function_range.unwrap();\n                self.skip_function_body();\n            }\n            _ => panic!(\"Invalid reader state during get binary reader operation\"),\n        };\n        BinaryReader::new(range.slice(self.reader.buffer))\n    }\n\n    /// Reads next record from the WebAssembly binary data. It also allows to\n    /// control how parser will treat the next record(s). The method accepts the\n    /// `ParserInput` parameter that allows e.g. to skip section or function\n    /// operators. The methods returns reference to current state of the parser.\n    ///\n    /// # Examples\n    /// ```\n    /// # let data: &[u8] = &[0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,\n    /// #     0x01, 0x4, 0x01, 0x60, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00,\n    /// #     0x0a, 0x05, 0x01, 0x03, 0x00, 0x01, 0x0b];\n    /// use wasmparser::WasmDecoder;\n    /// let mut parser = wasmparser::Parser::new(data);\n    /// let mut next_input = wasmparser::ParserInput::Default;\n    /// loop {\n    ///     let state = parser.read_with_input(next_input);\n    ///     match *state {\n    ///         wasmparser::ParserState::EndWasm => break,\n    ///         wasmparser::ParserState::BeginWasm { .. } |\n    ///         wasmparser::ParserState::EndSection =>\n    ///             next_input = wasmparser::ParserInput::Default,\n    ///         wasmparser::ParserState::BeginSection { ref code, .. } => {\n    ///             println!(\"Found section: {:?}\", code);\n    ///             next_input = wasmparser::ParserInput::SkipSection;\n    ///         },\n    ///         _ => unreachable!()\n    ///     }\n    /// }\n    /// ```\n    fn read_with_input(&mut self, input: ParserInput) -> &ParserState<'a> {\n        self.push_input(input);\n        self.read()\n    }\n\n    fn last_state(&self) -> &ParserState<'a> {\n        &self.state\n    }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse cmp;\nuse io::{self, SeekFrom, Read, Initializer, Write, Seek, BufRead, Error, ErrorKind};\nuse fmt;\nuse mem;\n\n// =============================================================================\n// Forwarding implementations\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, R: Read + ?Sized> Read for &'a mut R {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        (**self).initializer()\n    }\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_to_end(buf)\n    }\n\n    #[inline]\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_to_string(buf)\n    }\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        (**self).read_exact(buf)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, W: Write + ?Sized> Write for &'a mut W {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        (**self).write_all(buf)\n    }\n\n    #[inline]\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> {\n        (**self).write_fmt(fmt)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, S: Seek + ?Sized> Seek for &'a mut S {\n    #[inline]\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, B: BufRead + ?Sized> BufRead for &'a mut B {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n\n    #[inline]\n    fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n\n    #[inline]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_until(byte, buf)\n    }\n\n    #[inline]\n    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_line(buf)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read + ?Sized> Read for Box<R> {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        (**self).initializer()\n    }\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_to_end(buf)\n    }\n\n    #[inline]\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_to_string(buf)\n    }\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        (**self).read_exact(buf)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write + ?Sized> Write for Box<W> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        (**self).write_all(buf)\n    }\n\n    #[inline]\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> {\n        (**self).write_fmt(fmt)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<S: Seek + ?Sized> Seek for Box<S> {\n    #[inline]\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead + ?Sized> BufRead for Box<B> {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n\n    #[inline]\n    fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n\n    #[inline]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_until(byte, buf)\n    }\n\n    #[inline]\n    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_line(buf)\n    }\n}\n\n// =============================================================================\n// In-memory buffer implementations\n\n/// Read is implemented for `&[u8]` by copying from the slice.\n///\n/// Note that reading updates the slice to point to the yet unread part.\n/// The slice will be empty when EOF is reached.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Read for &'a [u8] {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let amt = cmp::min(buf.len(), self.len());\n        let (a, b) = self.split_at(amt);\n\n        // First check if the amount of bytes we want to read is small:\n        // `copy_from_slice` will generally expand to a call to `memcpy`, and\n        // for a single byte the overhead is significant.\n        if amt == 1 {\n            buf[0] = a[0];\n        } else {\n            buf[..amt].copy_from_slice(a);\n        }\n\n        *self = b;\n        Ok(amt)\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        if buf.len() > self.len() {\n            return Err(Error::new(ErrorKind::UnexpectedEof,\n                                  \"failed to fill whole buffer\"));\n        }\n        let (a, b) = self.split_at(buf.len());\n\n        // First check if the amount of bytes we want to read is small:\n        // `copy_from_slice` will generally expand to a call to `memcpy`, and\n        // for a single byte the overhead is significant.\n        if buf.len() == 1 {\n            buf[0] = a[0];\n        } else {\n            buf.copy_from_slice(a);\n        }\n\n        *self = b;\n        Ok(())\n    }\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        buf.extend_from_slice(*self);\n        let len = self.len();\n        *self = &self[len..];\n        Ok(len)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> BufRead for &'a [u8] {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(*self) }\n\n    #[inline]\n    fn consume(&mut self, amt: usize) { *self = &self[amt..]; }\n}\n\n/// Write is implemented for `&mut [u8]` by copying into the slice, overwriting\n/// its data.\n///\n/// Note that writing updates the slice to point to the yet unwritten part.\n/// The slice will be empty when it has been completely overwritten.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Write for &'a mut [u8] {\n    #[inline]\n    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n        let amt = cmp::min(data.len(), self.len());\n        let (a, b) = mem::replace(self, &mut []).split_at_mut(amt);\n        a.copy_from_slice(&data[..amt]);\n        *self = b;\n        Ok(amt)\n    }\n\n    #[inline]\n    fn write_all(&mut self, data: &[u8]) -> io::Result<()> {\n        if self.write(data)? == data.len() {\n            Ok(())\n        } else {\n            Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\"))\n        }\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n}\n\n/// Write is implemented for `Vec<u8>` by appending to the vector.\n/// The vector will grow as needed.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Vec<u8> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.extend_from_slice(buf);\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.extend_from_slice(buf);\n        Ok(())\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n}\n\n#[cfg(test)]\nmod tests {\n    use io::prelude::*;\n    use test;\n\n    #[bench]\n    fn bench_read_slice(b: &mut test::Bencher) {\n        let buf = [5; 1024];\n        let mut dst = [0; 128];\n\n        b.iter(|| {\n            let mut rd = &buf[..];\n            for _ in 0..8 {\n                let _ = rd.read(&mut dst);\n                test::black_box(&dst);\n            }\n        })\n    }\n\n    #[bench]\n    fn bench_write_slice(b: &mut test::Bencher) {\n        let mut buf = [0; 1024];\n        let src = [5; 128];\n\n        b.iter(|| {\n            let mut wr = &mut buf[..];\n            for _ in 0..8 {\n                let _ = wr.write_all(&src);\n                test::black_box(&wr);\n            }\n        })\n    }\n\n    #[bench]\n    fn bench_read_vec(b: &mut test::Bencher) {\n        let buf = vec![5; 1024];\n        let mut dst = [0; 128];\n\n        b.iter(|| {\n            let mut rd = &buf[..];\n            for _ in 0..8 {\n                let _ = rd.read(&mut dst);\n                test::black_box(&dst);\n            }\n        })\n    }\n\n    #[bench]\n    fn bench_write_vec(b: &mut test::Bencher) {\n        let mut buf = Vec::with_capacity(1024);\n        let src = [5; 128];\n\n        b.iter(|| {\n            let mut wr = &mut buf[..];\n            for _ in 0..8 {\n                let _ = wr.write_all(&src);\n                test::black_box(&wr);\n            }\n        })\n    }\n}\n","// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Character manipulation.\n//!\n//! For more details, see ::std_unicode::char (a.k.a. std::char)\n\n#![allow(non_snake_case)]\n#![stable(feature = \"core_char\", since = \"1.2.0\")]\n\nuse char_private::is_printable;\nuse convert::TryFrom;\nuse fmt::{self, Write};\nuse slice;\nuse str::{from_utf8_unchecked_mut, FromStr};\nuse iter::FusedIterator;\nuse mem::transmute;\n\n// UTF-8 ranges and tags for encoding characters\nconst TAG_CONT: u8    = 0b1000_0000;\nconst TAG_TWO_B: u8   = 0b1100_0000;\nconst TAG_THREE_B: u8 = 0b1110_0000;\nconst TAG_FOUR_B: u8  = 0b1111_0000;\nconst MAX_ONE_B: u32   =     0x80;\nconst MAX_TWO_B: u32   =    0x800;\nconst MAX_THREE_B: u32 =  0x10000;\n\n/*\n    Lu  Uppercase_Letter        an uppercase letter\n    Ll  Lowercase_Letter        a lowercase letter\n    Lt  Titlecase_Letter        a digraphic character, with first part uppercase\n    Lm  Modifier_Letter         a modifier letter\n    Lo  Other_Letter            other letters, including syllables and ideographs\n    Mn  Nonspacing_Mark         a nonspacing combining mark (zero advance width)\n    Mc  Spacing_Mark            a spacing combining mark (positive advance width)\n    Me  Enclosing_Mark          an enclosing combining mark\n    Nd  Decimal_Number          a decimal digit\n    Nl  Letter_Number           a letterlike numeric character\n    No  Other_Number            a numeric character of other type\n    Pc  Connector_Punctuation   a connecting punctuation mark, like a tie\n    Pd  Dash_Punctuation        a dash or hyphen punctuation mark\n    Ps  Open_Punctuation        an opening punctuation mark (of a pair)\n    Pe  Close_Punctuation       a closing punctuation mark (of a pair)\n    Pi  Initial_Punctuation     an initial quotation mark\n    Pf  Final_Punctuation       a final quotation mark\n    Po  Other_Punctuation       a punctuation mark of other type\n    Sm  Math_Symbol             a symbol of primarily mathematical use\n    Sc  Currency_Symbol         a currency sign\n    Sk  Modifier_Symbol         a non-letterlike modifier symbol\n    So  Other_Symbol            a symbol of other type\n    Zs  Space_Separator         a space character (of various non-zero widths)\n    Zl  Line_Separator          U+2028 LINE SEPARATOR only\n    Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only\n    Cc  Control                 a C0 or C1 control code\n    Cf  Format                  a format control character\n    Cs  Surrogate               a surrogate code point\n    Co  Private_Use             a private-use character\n    Cn  Unassigned              a reserved unassigned code point or a noncharacter\n*/\n\n/// The highest valid code point a `char` can have.\n///\n/// A [`char`] is a [Unicode Scalar Value], which means that it is a [Code\n/// Point], but only ones within a certain range. `MAX` is the highest valid\n/// code point that's a valid [Unicode Scalar Value].\n///\n/// [`char`]: ../../std/primitive.char.html\n/// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n/// [Code Point]: http://www.unicode.org/glossary/#code_point\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MAX: char = '\\u{10ffff}';\n\n/// Converts a `u32` to a `char`.\n///\n/// Note that all [`char`]s are valid [`u32`]s, and can be casted to one with\n/// [`as`]:\n///\n/// ```\n/// let c = '💯';\n/// let i = c as u32;\n///\n/// assert_eq!(128175, i);\n/// ```\n///\n/// However, the reverse is not true: not all valid [`u32`]s are valid\n/// [`char`]s. `from_u32()` will return `None` if the input is not a valid value\n/// for a [`char`].\n///\n/// [`char`]: ../../std/primitive.char.html\n/// [`u32`]: ../../std/primitive.u32.html\n/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n///\n/// For an unsafe version of this function which ignores these checks, see\n/// [`from_u32_unchecked`].\n///\n/// [`from_u32_unchecked`]: fn.from_u32_unchecked.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::char;\n///\n/// let c = char::from_u32(0x2764);\n///\n/// assert_eq!(Some('❤'), c);\n/// ```\n///\n/// Returning `None` when the input is not a valid [`char`]:\n///\n/// ```\n/// use std::char;\n///\n/// let c = char::from_u32(0x110000);\n///\n/// assert_eq!(None, c);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn from_u32(i: u32) -> Option<char> {\n    char::try_from(i).ok()\n}\n\n/// Converts a `u32` to a `char`, ignoring validity.\n///\n/// Note that all [`char`]s are valid [`u32`]s, and can be casted to one with\n/// [`as`]:\n///\n/// ```\n/// let c = '💯';\n/// let i = c as u32;\n///\n/// assert_eq!(128175, i);\n/// ```\n///\n/// However, the reverse is not true: not all valid [`u32`]s are valid\n/// [`char`]s. `from_u32_unchecked()` will ignore this, and blindly cast to\n/// [`char`], possibly creating an invalid one.\n///\n/// [`char`]: ../../std/primitive.char.html\n/// [`u32`]: ../../std/primitive.u32.html\n/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n///\n/// # Safety\n///\n/// This function is unsafe, as it may construct invalid `char` values.\n///\n/// For a safe version of this function, see the [`from_u32`] function.\n///\n/// [`from_u32`]: fn.from_u32.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::char;\n///\n/// let c = unsafe { char::from_u32_unchecked(0x2764) };\n///\n/// assert_eq!('❤', c);\n/// ```\n#[inline]\n#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\npub unsafe fn from_u32_unchecked(i: u32) -> char {\n    transmute(i)\n}\n\n#[stable(feature = \"char_convert\", since = \"1.13.0\")]\nimpl From<char> for u32 {\n    #[inline]\n    fn from(c: char) -> Self {\n        c as u32\n    }\n}\n\n/// Maps a byte in 0x00...0xFF to a `char` whose code point has the same value, in U+0000 to U+00FF.\n///\n/// Unicode is designed such that this effectively decodes bytes\n/// with the character encoding that IANA calls ISO-8859-1.\n/// This encoding is compatible with ASCII.\n///\n/// Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen),\n/// which leaves some \"blanks\", byte values that are not assigned to any character.\n/// ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.\n///\n/// Note that this is *also* different from Windows-1252 a.k.a. code page 1252,\n/// which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks\n/// to punctuation and various Latin characters.\n///\n/// To confuse things further, [on the Web](https://encoding.spec.whatwg.org/)\n/// `ascii`, `iso-8859-1`, and `windows-1252` are all aliases\n/// for a superset of Windows-1252 that fills the remaining blanks with corresponding\n/// C0 and C1 control codes.\n#[stable(feature = \"char_convert\", since = \"1.13.0\")]\nimpl From<u8> for char {\n    #[inline]\n    fn from(i: u8) -> Self {\n        i as char\n    }\n}\n\n\n/// An error which can be returned when parsing a char.\n#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n#[derive(Clone, Debug)]\npub struct ParseCharError {\n    kind: CharErrorKind,\n}\n\nimpl ParseCharError {\n    #[unstable(feature = \"char_error_internals\",\n               reason = \"this method should not be available publicly\",\n               issue = \"0\")]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n        match self.kind {\n            CharErrorKind::EmptyString => {\n                \"cannot parse char from empty string\"\n            },\n            CharErrorKind::TooManyChars => \"too many characters in string\"\n        }\n    }\n}\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\nenum CharErrorKind {\n    EmptyString,\n    TooManyChars,\n}\n\n#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\nimpl fmt::Display for ParseCharError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.__description().fmt(f)\n    }\n}\n\n\n#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\nimpl FromStr for char {\n    type Err = ParseCharError;\n\n    #[inline]\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let mut chars = s.chars();\n        match (chars.next(), chars.next()) {\n            (None, _) => {\n                Err(ParseCharError { kind: CharErrorKind::EmptyString })\n            },\n            (Some(c), None) => Ok(c),\n            _ => {\n                Err(ParseCharError { kind: CharErrorKind::TooManyChars })\n            }\n        }\n    }\n}\n\n\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl TryFrom<u32> for char {\n    type Error = CharTryFromError;\n\n    #[inline]\n    fn try_from(i: u32) -> Result<Self, Self::Error> {\n        if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n            Err(CharTryFromError(()))\n        } else {\n            Ok(unsafe { from_u32_unchecked(i) })\n        }\n    }\n}\n\n/// The error type returned when a conversion from u32 to char fails.\n#[unstable(feature = \"try_from\", issue = \"33417\")]\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub struct CharTryFromError(());\n\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl fmt::Display for CharTryFromError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        \"converted integer out of range for `char`\".fmt(f)\n    }\n}\n\n/// Converts a digit in the given radix to a `char`.\n///\n/// A 'radix' here is sometimes also called a 'base'. A radix of two\n/// indicates a binary number, a radix of ten, decimal, and a radix of\n/// sixteen, hexadecimal, to give some common values. Arbitrary\n/// radices are supported.\n///\n/// `from_digit()` will return `None` if the input is not a digit in\n/// the given radix.\n///\n/// # Panics\n///\n/// Panics if given a radix larger than 36.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::char;\n///\n/// let c = char::from_digit(4, 10);\n///\n/// assert_eq!(Some('4'), c);\n///\n/// // Decimal 11 is a single digit in base 16\n/// let c = char::from_digit(11, 16);\n///\n/// assert_eq!(Some('b'), c);\n/// ```\n///\n/// Returning `None` when the input is not a digit:\n///\n/// ```\n/// use std::char;\n///\n/// let c = char::from_digit(20, 10);\n///\n/// assert_eq!(None, c);\n/// ```\n///\n/// Passing a large radix, causing a panic:\n///\n/// ```\n/// use std::thread;\n/// use std::char;\n///\n/// let result = thread::spawn(|| {\n///     // this panics\n///     let c = char::from_digit(1, 37);\n/// }).join();\n///\n/// assert!(result.is_err());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn from_digit(num: u32, radix: u32) -> Option<char> {\n    if radix > 36 {\n        panic!(\"from_digit: radix is too high (maximum 36)\");\n    }\n    if num < radix {\n        let num = num as u8;\n        if num < 10 {\n            Some((b'0' + num) as char)\n        } else {\n            Some((b'a' + num - 10) as char)\n        }\n    } else {\n        None\n    }\n}\n\n// NB: the stabilization and documentation for this trait is in\n// unicode/char.rs, not here\n#[allow(missing_docs)] // docs in libunicode/u_char.rs\n#[doc(hidden)]\n#[unstable(feature = \"core_char_ext\",\n           reason = \"the stable interface is `impl char` in later crate\",\n           issue = \"32110\")]\npub trait CharExt {\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn is_digit(self, radix: u32) -> bool;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn to_digit(self, radix: u32) -> Option<u32>;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn escape_unicode(self) -> EscapeUnicode;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn escape_default(self) -> EscapeDefault;\n    #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n    fn escape_debug(self) -> EscapeDebug;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn len_utf8(self) -> usize;\n    #[stable(feature = \"core\", since = \"1.6.0\")]\n    fn len_utf16(self) -> usize;\n    #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n    fn encode_utf8(self, dst: &mut [u8]) -> &mut str;\n    #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n    fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16];\n}\n\n#[stable(feature = \"core\", since = \"1.6.0\")]\nimpl CharExt for char {\n    #[inline]\n    fn is_digit(self, radix: u32) -> bool {\n        self.to_digit(radix).is_some()\n    }\n\n    #[inline]\n    fn to_digit(self, radix: u32) -> Option<u32> {\n        if radix > 36 {\n            panic!(\"to_digit: radix is too high (maximum 36)\");\n        }\n        let val = match self {\n          '0' ... '9' => self as u32 - '0' as u32,\n          'a' ... 'z' => self as u32 - 'a' as u32 + 10,\n          'A' ... 'Z' => self as u32 - 'A' as u32 + 10,\n          _ => return None,\n        };\n        if val < radix { Some(val) }\n        else { None }\n    }\n\n    #[inline]\n    fn escape_unicode(self) -> EscapeUnicode {\n        let c = self as u32;\n\n        // or-ing 1 ensures that for c==0 the code computes that one\n        // digit should be printed and (which is the same) avoids the\n        // (31 - 32) underflow\n        let msb = 31 - (c | 1).leading_zeros();\n\n        // the index of the most significant hex digit\n        let ms_hex_digit = msb / 4;\n        EscapeUnicode {\n            c: self,\n            state: EscapeUnicodeState::Backslash,\n            hex_digit_idx: ms_hex_digit as usize,\n        }\n    }\n\n    #[inline]\n    fn escape_default(self) -> EscapeDefault {\n        let init_state = match self {\n            '\\t' => EscapeDefaultState::Backslash('t'),\n            '\\r' => EscapeDefaultState::Backslash('r'),\n            '\\n' => EscapeDefaultState::Backslash('n'),\n            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n            '\\x20' ... '\\x7e' => EscapeDefaultState::Char(self),\n            _ => EscapeDefaultState::Unicode(self.escape_unicode())\n        };\n        EscapeDefault { state: init_state }\n    }\n\n    #[inline]\n    fn escape_debug(self) -> EscapeDebug {\n        let init_state = match self {\n            '\\t' => EscapeDefaultState::Backslash('t'),\n            '\\r' => EscapeDefaultState::Backslash('r'),\n            '\\n' => EscapeDefaultState::Backslash('n'),\n            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n            c if is_printable(c) => EscapeDefaultState::Char(c),\n            c => EscapeDefaultState::Unicode(c.escape_unicode()),\n        };\n        EscapeDebug(EscapeDefault { state: init_state })\n    }\n\n    #[inline]\n    fn len_utf8(self) -> usize {\n        let code = self as u32;\n        if code < MAX_ONE_B {\n            1\n        } else if code < MAX_TWO_B {\n            2\n        } else if code < MAX_THREE_B {\n            3\n        } else {\n            4\n        }\n    }\n\n    #[inline]\n    fn len_utf16(self) -> usize {\n        let ch = self as u32;\n        if (ch & 0xFFFF) == ch { 1 } else { 2 }\n    }\n\n    #[inline]\n    fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n        let code = self as u32;\n        unsafe {\n            let len =\n            if code < MAX_ONE_B && !dst.is_empty() {\n                *dst.get_unchecked_mut(0) = code as u8;\n                1\n            } else if code < MAX_TWO_B && dst.len() >= 2 {\n                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;\n                2\n            } else if code < MAX_THREE_B && dst.len() >= 3  {\n                *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n                *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;\n                3\n            } else if dst.len() >= 4 {\n                *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n                *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;\n                4\n            } else {\n                panic!(\"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n                    from_u32_unchecked(code).len_utf8(),\n                    code,\n                    dst.len())\n            };\n            from_utf8_unchecked_mut(dst.get_unchecked_mut(..len))\n        }\n    }\n\n    #[inline]\n    fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n        let mut code = self as u32;\n        unsafe {\n            if (code & 0xFFFF) == code && !dst.is_empty() {\n                // The BMP falls through (assuming non-surrogate, as it should)\n                *dst.get_unchecked_mut(0) = code as u16;\n                slice::from_raw_parts_mut(dst.as_mut_ptr(), 1)\n            } else if dst.len() >= 2 {\n                // Supplementary planes break into surrogates.\n                code -= 0x1_0000;\n                *dst.get_unchecked_mut(0) = 0xD800 | ((code >> 10) as u16);\n                *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n                slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n            } else {\n                panic!(\"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n                    from_u32_unchecked(code).len_utf16(),\n                    code,\n                    dst.len())\n            }\n        }\n    }\n}\n\n/// Returns an iterator that yields the hexadecimal Unicode escape of a\n/// character, as `char`s.\n///\n/// This `struct` is created by the [`escape_unicode`] method on [`char`]. See\n/// its documentation for more.\n///\n/// [`escape_unicode`]: ../../std/primitive.char.html#method.escape_unicode\n/// [`char`]: ../../std/primitive.char.html\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct EscapeUnicode {\n    c: char,\n    state: EscapeUnicodeState,\n\n    // The index of the next hex digit to be printed (0 if none),\n    // i.e. the number of remaining hex digits to be printed;\n    // increasing from the least significant digit: 0x543210\n    hex_digit_idx: usize,\n}\n\n// The enum values are ordered so that their representation is the\n// same as the remaining length (besides the hexadecimal digits). This\n// likely makes `len()` a single load from memory) and inline-worth.\n#[derive(Clone, Debug)]\nenum EscapeUnicodeState {\n    Done,\n    RightBrace,\n    Value,\n    LeftBrace,\n    Type,\n    Backslash,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for EscapeUnicode {\n    type Item = char;\n\n    fn next(&mut self) -> Option<char> {\n        match self.state {\n            EscapeUnicodeState::Backslash => {\n                self.state = EscapeUnicodeState::Type;\n                Some('\\\\')\n            }\n            EscapeUnicodeState::Type => {\n                self.state = EscapeUnicodeState::LeftBrace;\n                Some('u')\n            }\n            EscapeUnicodeState::LeftBrace => {\n                self.state = EscapeUnicodeState::Value;\n                Some('{')\n            }\n            EscapeUnicodeState::Value => {\n                let hex_digit = ((self.c as u32) >> (self.hex_digit_idx * 4)) & 0xf;\n                let c = from_digit(hex_digit, 16).unwrap();\n                if self.hex_digit_idx == 0 {\n                    self.state = EscapeUnicodeState::RightBrace;\n                } else {\n                    self.hex_digit_idx -= 1;\n                }\n                Some(c)\n            }\n            EscapeUnicodeState::RightBrace => {\n                self.state = EscapeUnicodeState::Done;\n                Some('}')\n            }\n            EscapeUnicodeState::Done => None,\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.len();\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    fn last(self) -> Option<char> {\n        match self.state {\n            EscapeUnicodeState::Done => None,\n\n            EscapeUnicodeState::RightBrace |\n            EscapeUnicodeState::Value |\n            EscapeUnicodeState::LeftBrace |\n            EscapeUnicodeState::Type |\n            EscapeUnicodeState::Backslash => Some('}'),\n        }\n    }\n}\n\n#[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\nimpl ExactSizeIterator for EscapeUnicode {\n    #[inline]\n    fn len(&self) -> usize {\n        // The match is a single memory access with no branching\n        self.hex_digit_idx + match self.state {\n            EscapeUnicodeState::Done => 0,\n            EscapeUnicodeState::RightBrace => 1,\n            EscapeUnicodeState::Value => 2,\n            EscapeUnicodeState::LeftBrace => 3,\n            EscapeUnicodeState::Type => 4,\n            EscapeUnicodeState::Backslash => 5,\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl FusedIterator for EscapeUnicode {}\n\n#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\nimpl fmt::Display for EscapeUnicode {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for c in self.clone() {\n            f.write_char(c)?;\n        }\n        Ok(())\n    }\n}\n\n/// An iterator that yields the literal escape code of a `char`.\n///\n/// This `struct` is created by the [`escape_default`] method on [`char`]. See\n/// its documentation for more.\n///\n/// [`escape_default`]: ../../std/primitive.char.html#method.escape_default\n/// [`char`]: ../../std/primitive.char.html\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct EscapeDefault {\n    state: EscapeDefaultState\n}\n\n#[derive(Clone, Debug)]\nenum EscapeDefaultState {\n    Done,\n    Char(char),\n    Backslash(char),\n    Unicode(EscapeUnicode),\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for EscapeDefault {\n    type Item = char;\n\n    fn next(&mut self) -> Option<char> {\n        match self.state {\n            EscapeDefaultState::Backslash(c) => {\n                self.state = EscapeDefaultState::Char(c);\n                Some('\\\\')\n            }\n            EscapeDefaultState::Char(c) => {\n                self.state = EscapeDefaultState::Done;\n                Some(c)\n            }\n            EscapeDefaultState::Done => None,\n            EscapeDefaultState::Unicode(ref mut iter) => iter.next(),\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.len();\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    fn nth(&mut self, n: usize) -> Option<char> {\n        match self.state {\n            EscapeDefaultState::Backslash(c) if n == 0 => {\n                self.state = EscapeDefaultState::Char(c);\n                Some('\\\\')\n            },\n            EscapeDefaultState::Backslash(c) if n == 1 => {\n                self.state = EscapeDefaultState::Done;\n                Some(c)\n            },\n            EscapeDefaultState::Backslash(_) => {\n                self.state = EscapeDefaultState::Done;\n                None\n            },\n            EscapeDefaultState::Char(c) => {\n                self.state = EscapeDefaultState::Done;\n\n                if n == 0 {\n                    Some(c)\n                } else {\n                    None\n                }\n            },\n            EscapeDefaultState::Done => return None,\n            EscapeDefaultState::Unicode(ref mut i) => return i.nth(n),\n        }\n    }\n\n    fn last(self) -> Option<char> {\n        match self.state {\n            EscapeDefaultState::Unicode(iter) => iter.last(),\n            EscapeDefaultState::Done => None,\n            EscapeDefaultState::Backslash(c) | EscapeDefaultState::Char(c) => Some(c),\n        }\n    }\n}\n\n#[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\nimpl ExactSizeIterator for EscapeDefault {\n    fn len(&self) -> usize {\n        match self.state {\n            EscapeDefaultState::Done => 0,\n            EscapeDefaultState::Char(_) => 1,\n            EscapeDefaultState::Backslash(_) => 2,\n            EscapeDefaultState::Unicode(ref iter) => iter.len(),\n        }\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl FusedIterator for EscapeDefault {}\n\n#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\nimpl fmt::Display for EscapeDefault {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for c in self.clone() {\n            f.write_char(c)?;\n        }\n        Ok(())\n    }\n}\n\n/// An iterator that yields the literal escape code of a `char`.\n///\n/// This `struct` is created by the [`escape_debug`] method on [`char`]. See its\n/// documentation for more.\n///\n/// [`escape_debug`]: ../../std/primitive.char.html#method.escape_debug\n/// [`char`]: ../../std/primitive.char.html\n#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n#[derive(Clone, Debug)]\npub struct EscapeDebug(EscapeDefault);\n\n#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\nimpl Iterator for EscapeDebug {\n    type Item = char;\n    fn next(&mut self) -> Option<char> { self.0.next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n}\n\n#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\nimpl ExactSizeIterator for EscapeDebug { }\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl FusedIterator for EscapeDebug {}\n\n#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\nimpl fmt::Display for EscapeDebug {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&self.0, f)\n    }\n}\n\n\n\n/// An iterator over an iterator of bytes of the characters the bytes represent\n/// as UTF-8\n#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n#[derive(Clone, Debug)]\npub struct DecodeUtf8<I: Iterator<Item = u8>>(::iter::Peekable<I>);\n\n/// Decodes an `Iterator` of bytes as UTF-8.\n#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n#[inline]\npub fn decode_utf8<I: IntoIterator<Item = u8>>(i: I) -> DecodeUtf8<I::IntoIter> {\n    DecodeUtf8(i.into_iter().peekable())\n}\n\n/// `<DecodeUtf8 as Iterator>::next` returns this for an invalid input sequence.\n#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n#[derive(PartialEq, Eq, Debug)]\npub struct InvalidSequence(());\n\n#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\nimpl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n    type Item = Result<char, InvalidSequence>;\n    #[inline]\n\n    fn next(&mut self) -> Option<Result<char, InvalidSequence>> {\n        self.0.next().map(|first_byte| {\n            // Emit InvalidSequence according to\n            // Unicode §5.22 Best Practice for U+FFFD Substitution\n            // http://www.unicode.org/versions/Unicode9.0.0/ch05.pdf#G40630\n\n            // Roughly: consume at least one byte,\n            // then validate one byte at a time and stop before the first unexpected byte\n            // (which might be the valid start of the next byte sequence).\n\n            let mut code_point;\n            macro_rules! first_byte {\n                ($mask: expr) => {\n                    code_point = u32::from(first_byte & $mask)\n                }\n            }\n            macro_rules! continuation_byte {\n                () => { continuation_byte!(0x80...0xBF) };\n                ($range: pat) => {\n                    match self.0.peek() {\n                        Some(&byte @ $range) => {\n                            code_point = (code_point << 6) | u32::from(byte & 0b0011_1111);\n                            self.0.next();\n                        }\n                        _ => return Err(InvalidSequence(()))\n                    }\n                }\n            }\n\n            match first_byte {\n                0x00...0x7F => {\n                    first_byte!(0b1111_1111);\n                }\n                0xC2...0xDF => {\n                    first_byte!(0b0001_1111);\n                    continuation_byte!();\n                }\n                0xE0 => {\n                    first_byte!(0b0000_1111);\n                    continuation_byte!(0xA0...0xBF);  // 0x80...0x9F here are overlong\n                    continuation_byte!();\n                }\n                0xE1...0xEC | 0xEE...0xEF => {\n                    first_byte!(0b0000_1111);\n                    continuation_byte!();\n                    continuation_byte!();\n                }\n                0xED => {\n                    first_byte!(0b0000_1111);\n                    continuation_byte!(0x80...0x9F);  // 0xA0..0xBF here are surrogates\n                    continuation_byte!();\n                }\n                0xF0 => {\n                    first_byte!(0b0000_0111);\n                    continuation_byte!(0x90...0xBF);  // 0x80..0x8F here are overlong\n                    continuation_byte!();\n                    continuation_byte!();\n                }\n                0xF1...0xF3 => {\n                    first_byte!(0b0000_0111);\n                    continuation_byte!();\n                    continuation_byte!();\n                    continuation_byte!();\n                }\n                0xF4 => {\n                    first_byte!(0b0000_0111);\n                    continuation_byte!(0x80...0x8F);  // 0x90..0xBF here are beyond char::MAX\n                    continuation_byte!();\n                    continuation_byte!();\n                }\n                _ => return Err(InvalidSequence(()))  // Illegal first byte, overlong, or beyond MAX\n            }\n            unsafe {\n                Ok(from_u32_unchecked(code_point))\n            }\n        })\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I: FusedIterator<Item = u8>> FusedIterator for DecodeUtf8<I> {}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Traits, helpers, and type definitions for core I/O functionality.\n//!\n//! The `std::io` module contains a number of common things you'll need\n//! when doing input and output. The most core part of this module is\n//! the [`Read`] and [`Write`] traits, which provide the\n//! most general interface for reading and writing input and output.\n//!\n//! # Read and Write\n//!\n//! Because they are traits, [`Read`] and [`Write`] are implemented by a number\n//! of other types, and you can implement them for your types too. As such,\n//! you'll see a few different types of I/O throughout the documentation in\n//! this module: [`File`]s, [`TcpStream`]s, and sometimes even [`Vec<T>`]s. For\n//! example, [`Read`] adds a [`read`][`Read::read`] method, which we can use on\n//! [`File`]s:\n//!\n//! ```\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::fs::File;\n//!\n//! # fn foo() -> io::Result<()> {\n//! let mut f = File::open(\"foo.txt\")?;\n//! let mut buffer = [0; 10];\n//!\n//! // read up to 10 bytes\n//! f.read(&mut buffer)?;\n//!\n//! println!(\"The bytes: {:?}\", buffer);\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! [`Read`] and [`Write`] are so important, implementors of the two traits have a\n//! nickname: readers and writers. So you'll sometimes see 'a reader' instead\n//! of 'a type that implements the [`Read`] trait'. Much easier!\n//!\n//! ## Seek and BufRead\n//!\n//! Beyond that, there are two important traits that are provided: [`Seek`]\n//! and [`BufRead`]. Both of these build on top of a reader to control\n//! how the reading happens. [`Seek`] lets you control where the next byte is\n//! coming from:\n//!\n//! ```\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::SeekFrom;\n//! use std::fs::File;\n//!\n//! # fn foo() -> io::Result<()> {\n//! let mut f = File::open(\"foo.txt\")?;\n//! let mut buffer = [0; 10];\n//!\n//! // skip to the last 10 bytes of the file\n//! f.seek(SeekFrom::End(-10))?;\n//!\n//! // read up to 10 bytes\n//! f.read(&mut buffer)?;\n//!\n//! println!(\"The bytes: {:?}\", buffer);\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! [`BufRead`] uses an internal buffer to provide a number of other ways to read, but\n//! to show it off, we'll need to talk about buffers in general. Keep reading!\n//!\n//! ## BufReader and BufWriter\n//!\n//! Byte-based interfaces are unwieldy and can be inefficient, as we'd need to be\n//! making near-constant calls to the operating system. To help with this,\n//! `std::io` comes with two structs, [`BufReader`] and [`BufWriter`], which wrap\n//! readers and writers. The wrapper uses a buffer, reducing the number of\n//! calls and providing nicer methods for accessing exactly what you want.\n//!\n//! For example, [`BufReader`] works with the [`BufRead`] trait to add extra\n//! methods to any reader:\n//!\n//! ```\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufReader;\n//! use std::fs::File;\n//!\n//! # fn foo() -> io::Result<()> {\n//! let f = File::open(\"foo.txt\")?;\n//! let mut reader = BufReader::new(f);\n//! let mut buffer = String::new();\n//!\n//! // read a line into buffer\n//! reader.read_line(&mut buffer)?;\n//!\n//! println!(\"{}\", buffer);\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! [`BufWriter`] doesn't add any new ways of writing; it just buffers every call\n//! to [`write`][`Write::write`]:\n//!\n//! ```\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufWriter;\n//! use std::fs::File;\n//!\n//! # fn foo() -> io::Result<()> {\n//! let f = File::create(\"foo.txt\")?;\n//! {\n//!     let mut writer = BufWriter::new(f);\n//!\n//!     // write a byte to the buffer\n//!     writer.write(&[42])?;\n//!\n//! } // the buffer is flushed once writer goes out of scope\n//!\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! ## Standard input and output\n//!\n//! A very common source of input is standard input:\n//!\n//! ```\n//! use std::io;\n//!\n//! # fn foo() -> io::Result<()> {\n//! let mut input = String::new();\n//!\n//! io::stdin().read_line(&mut input)?;\n//!\n//! println!(\"You typed: {}\", input.trim());\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! Note that you cannot use the [`?` operator] in functions that do not return\n//! a [`Result<T, E>`][`Result`] (e.g. `main`). Instead, you can call [`.unwrap()`]\n//! or `match` on the return value to catch any possible errors:\n//!\n//! ```\n//! use std::io;\n//!\n//! let mut input = String::new();\n//!\n//! io::stdin().read_line(&mut input).unwrap();\n//! ```\n//!\n//! And a very common source of output is standard output:\n//!\n//! ```\n//! use std::io;\n//! use std::io::prelude::*;\n//!\n//! # fn foo() -> io::Result<()> {\n//! io::stdout().write(&[42])?;\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! Of course, using [`io::stdout`] directly is less common than something like\n//! [`println!`].\n//!\n//! ## Iterator types\n//!\n//! A large number of the structures provided by `std::io` are for various\n//! ways of iterating over I/O. For example, [`Lines`] is used to split over\n//! lines:\n//!\n//! ```\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufReader;\n//! use std::fs::File;\n//!\n//! # fn foo() -> io::Result<()> {\n//! let f = File::open(\"foo.txt\")?;\n//! let reader = BufReader::new(f);\n//!\n//! for line in reader.lines() {\n//!     println!(\"{}\", line?);\n//! }\n//!\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! ## Functions\n//!\n//! There are a number of [functions][functions-list] that offer access to various\n//! features. For example, we can use three of these functions to copy everything\n//! from standard input to standard output:\n//!\n//! ```\n//! use std::io;\n//!\n//! # fn foo() -> io::Result<()> {\n//! io::copy(&mut io::stdin(), &mut io::stdout())?;\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! [functions-list]: #functions-1\n//!\n//! ## io::Result\n//!\n//! Last, but certainly not least, is [`io::Result`]. This type is used\n//! as the return type of many `std::io` functions that can cause an error, and\n//! can be returned from your own functions as well. Many of the examples in this\n//! module use the [`?` operator]:\n//!\n//! ```\n//! use std::io;\n//!\n//! fn read_input() -> io::Result<()> {\n//!     let mut input = String::new();\n//!\n//!     io::stdin().read_line(&mut input)?;\n//!\n//!     println!(\"You typed: {}\", input.trim());\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! The return type of `read_input()`, [`io::Result<()>`][`io::Result`], is a very\n//! common type for functions which don't have a 'real' return value, but do want to\n//! return errors if they happen. In this case, the only purpose of this function is\n//! to read the line and print it, so we use `()`.\n//!\n//! ## Platform-specific behavior\n//!\n//! Many I/O functions throughout the standard library are documented to indicate\n//! what various library or syscalls they are delegated to. This is done to help\n//! applications both understand what's happening under the hood as well as investigate\n//! any possibly unclear semantics. Note, however, that this is informative, not a binding\n//! contract. The implementation of many of these functions are subject to change over\n//! time and may call fewer or more syscalls/library functions.\n//!\n//! [`Read`]: trait.Read.html\n//! [`Write`]: trait.Write.html\n//! [`Seek`]: trait.Seek.html\n//! [`BufRead`]: trait.BufRead.html\n//! [`File`]: ../fs/struct.File.html\n//! [`TcpStream`]: ../net/struct.TcpStream.html\n//! [`Vec<T>`]: ../vec/struct.Vec.html\n//! [`BufReader`]: struct.BufReader.html\n//! [`BufWriter`]: struct.BufWriter.html\n//! [`Write::write`]: trait.Write.html#tymethod.write\n//! [`io::stdout`]: fn.stdout.html\n//! [`println!`]: ../macro.println.html\n//! [`Lines`]: struct.Lines.html\n//! [`io::Result`]: type.Result.html\n//! [`?` operator]: ../../book/first-edition/syntax-index.html\n//! [`Read::read`]: trait.Read.html#tymethod.read\n//! [`Result`]: ../result/enum.Result.html\n//! [`.unwrap()`]: ../result/enum.Result.html#method.unwrap\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse cmp;\nuse core::str as core_str;\nuse error as std_error;\nuse fmt;\nuse result;\nuse str;\nuse memchr;\nuse ptr;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::buffered::{BufReader, BufWriter, LineWriter};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::buffered::IntoInnerError;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::cursor::Cursor;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::error::{Result, Error, ErrorKind};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::util::{copy, sink, Sink, empty, Empty, repeat, Repeat};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::stdio::{stdin, stdout, stderr, Stdin, Stdout, Stderr};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::stdio::{StdoutLock, StderrLock, StdinLock};\n#[unstable(feature = \"print_internals\", issue = \"0\")]\npub use self::stdio::{_print, _eprint};\n#[unstable(feature = \"libstd_io_internals\", issue = \"42788\")]\n#[doc(no_inline, hidden)]\npub use self::stdio::{set_panic, set_print};\n\npub mod prelude;\nmod buffered;\nmod cursor;\nmod error;\nmod impls;\nmod lazy;\nmod util;\nmod stdio;\n\nconst DEFAULT_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;\n\nstruct Guard<'a> { buf: &'a mut Vec<u8>, len: usize }\n\nimpl<'a> Drop for Guard<'a> {\n    fn drop(&mut self) {\n        unsafe { self.buf.set_len(self.len); }\n    }\n}\n\n// A few methods below (read_to_string, read_line) will append data into a\n// `String` buffer, but we need to be pretty careful when doing this. The\n// implementation will just call `.as_mut_vec()` and then delegate to a\n// byte-oriented reading method, but we must ensure that when returning we never\n// leave `buf` in a state such that it contains invalid UTF-8 in its bounds.\n//\n// To this end, we use an RAII guard (to protect against panics) which updates\n// the length of the string when it is dropped. This guard initially truncates\n// the string to the prior length and only after we've validated that the\n// new contents are valid UTF-8 do we allow it to set a longer length.\n//\n// The unsafety in this function is twofold:\n//\n// 1. We're looking at the raw bytes of `buf`, so we take on the burden of UTF-8\n//    checks.\n// 2. We're passing a raw buffer to the function `f`, and it is expected that\n//    the function only *appends* bytes to the buffer. We'll get undefined\n//    behavior if existing bytes are overwritten to have non-UTF-8 data.\nfn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n    where F: FnOnce(&mut Vec<u8>) -> Result<usize>\n{\n    unsafe {\n        let mut g = Guard { len: buf.len(), buf: buf.as_mut_vec() };\n        let ret = f(g.buf);\n        if str::from_utf8(&g.buf[g.len..]).is_err() {\n            ret.and_then(|_| {\n                Err(Error::new(ErrorKind::InvalidData,\n                               \"stream did not contain valid UTF-8\"))\n            })\n        } else {\n            g.len = g.buf.len();\n            ret\n        }\n    }\n}\n\n// This uses an adaptive system to extend the vector when it fills. We want to\n// avoid paying to allocate and zero a huge chunk of memory if the reader only\n// has 4 bytes while still making large reads if the reader does have a ton\n// of data to return. Simply tacking on an extra DEFAULT_BUF_SIZE space every\n// time is 4,500 times (!) slower than this if the reader has a very small\n// amount of data to return.\n//\n// Because we're extending the buffer with uninitialized data for trusted\n// readers, we need to make sure to truncate that if any of this panics.\nfn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n    let start_len = buf.len();\n    let mut g = Guard { len: buf.len(), buf: buf };\n    let ret;\n    loop {\n        if g.len == g.buf.len() {\n            unsafe {\n                g.buf.reserve(32);\n                let capacity = g.buf.capacity();\n                g.buf.set_len(capacity);\n                r.initializer().initialize(&mut g.buf[g.len..]);\n            }\n        }\n\n        match r.read(&mut g.buf[g.len..]) {\n            Ok(0) => {\n                ret = Ok(g.len - start_len);\n                break;\n            }\n            Ok(n) => g.len += n,\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n            Err(e) => {\n                ret = Err(e);\n                break;\n            }\n        }\n    }\n\n    ret\n}\n\n/// The `Read` trait allows for reading bytes from a source.\n///\n/// Implementors of the `Read` trait are called 'readers'.\n///\n/// Readers are defined by one required method, [`read()`]. Each call to [`read()`]\n/// will attempt to pull bytes from this source into a provided buffer. A\n/// number of other methods are implemented in terms of [`read()`], giving\n/// implementors a number of ways to read bytes while only needing to implement\n/// a single method.\n///\n/// Readers are intended to be composable with one another. Many implementors\n/// throughout [`std::io`] take and provide types which implement the `Read`\n/// trait.\n///\n/// Please note that each call to [`read()`] may involve a system call, and\n/// therefore, using something that implements [`BufRead`], such as\n/// [`BufReader`], will be more efficient.\n///\n/// # Examples\n///\n/// [`File`]s implement `Read`:\n///\n/// ```\n/// # use std::io;\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// # fn foo() -> io::Result<()> {\n/// let mut f = File::open(\"foo.txt\")?;\n/// let mut buffer = [0; 10];\n///\n/// // read up to 10 bytes\n/// f.read(&mut buffer)?;\n///\n/// let mut buffer = vec![0; 10];\n/// // read the whole file\n/// f.read_to_end(&mut buffer)?;\n///\n/// // read into a String, so that you don't need to do the conversion.\n/// let mut buffer = String::new();\n/// f.read_to_string(&mut buffer)?;\n///\n/// // and more! See the other methods for more details.\n/// # Ok(())\n/// # }\n/// ```\n///\n/// Read from [`&str`] because [`&[u8]`][slice] implements `Read`:\n///\n/// ```\n/// # use std::io;\n/// use std::io::prelude::*;\n///\n/// # fn foo() -> io::Result<()> {\n/// let mut b = \"This string will be read\".as_bytes();\n/// let mut buffer = [0; 10];\n///\n/// // read up to 10 bytes\n/// b.read(&mut buffer)?;\n///\n/// // etc... it works exactly as a File does!\n/// # Ok(())\n/// # }\n/// ```\n///\n/// [`read()`]: trait.Read.html#tymethod.read\n/// [`std::io`]: ../../std/io/index.html\n/// [`File`]: ../fs/struct.File.html\n/// [`BufRead`]: trait.BufRead.html\n/// [`BufReader`]: struct.BufReader.html\n/// [`&str`]: ../../std/primitive.str.html\n/// [slice]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(spotlight)]\npub trait Read {\n    /// Pull some bytes from this source into the specified buffer, returning\n    /// how many bytes were read.\n    ///\n    /// This function does not provide any guarantees about whether it blocks\n    /// waiting for data, but if an object needs to block for a read but cannot\n    /// it will typically signal this via an [`Err`] return value.\n    ///\n    /// If the return value of this method is [`Ok(n)`], then it must be\n    /// guaranteed that `0 <= n <= buf.len()`. A nonzero `n` value indicates\n    /// that the buffer `buf` has been filled in with `n` bytes of data from this\n    /// source. If `n` is `0`, then it can indicate one of two scenarios:\n    ///\n    /// 1. This reader has reached its \"end of file\" and will likely no longer\n    ///    be able to produce bytes. Note that this does not mean that the\n    ///    reader will *always* no longer be able to produce bytes.\n    /// 2. The buffer specified was 0 bytes in length.\n    ///\n    /// No guarantees are provided about the contents of `buf` when this\n    /// function is called, implementations cannot rely on any property of the\n    /// contents of `buf` being true. It is recommended that implementations\n    /// only write data to `buf` instead of reading its contents.\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters any form of I/O or other error, an error\n    /// variant will be returned. If an error is returned then it must be\n    /// guaranteed that no bytes were read.\n    ///\n    /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the read\n    /// operation should be retried if there is nothing else to do.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`Ok(n)`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n    /// [`File`]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    /// let mut buffer = [0; 10];\n    ///\n    /// // read up to 10 bytes\n    /// f.read(&mut buffer[..])?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n\n    /// Determines if this `Read`er can work with buffers of uninitialized\n    /// memory.\n    ///\n    /// The default implementation returns an initializer which will zero\n    /// buffers.\n    ///\n    /// If a `Read`er guarantees that it can work properly with uninitialized\n    /// memory, it should call [`Initializer::nop()`]. See the documentation for\n    /// [`Initializer`] for details.\n    ///\n    /// The behavior of this method must be independent of the state of the\n    /// `Read`er - the method only takes `&self` so that it can be used through\n    /// trait objects.\n    ///\n    /// # Safety\n    ///\n    /// This method is unsafe because a `Read`er could otherwise return a\n    /// non-zeroing `Initializer` from another `Read` type without an `unsafe`\n    /// block.\n    ///\n    /// [`Initializer::nop()`]: ../../std/io/struct.Initializer.html#method.nop\n    /// [`Initializer`]: ../../std/io/struct.Initializer.html\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::zeroing()\n    }\n\n    /// Read all bytes until EOF in this source, placing them into `buf`.\n    ///\n    /// All bytes read from this source will be appended to the specified buffer\n    /// `buf`. This function will continuously call [`read()`] to append more data to\n    /// `buf` until [`read()`] returns either [`Ok(0)`] or an error of\n    /// non-[`ErrorKind::Interrupted`] kind.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters an error of the kind\n    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n    /// will continue.\n    ///\n    /// If any other read error is encountered then this function immediately\n    /// returns. Any bytes which have already been read will be appended to\n    /// `buf`.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`read()`]: trait.Read.html#tymethod.read\n    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n    /// [`File`]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    /// let mut buffer = Vec::new();\n    ///\n    /// // read the whole file\n    /// f.read_to_end(&mut buffer)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n        read_to_end(self, buf)\n    }\n\n    /// Read all bytes until EOF in this source, appending them to `buf`.\n    ///\n    /// If successful, this function returns the number of bytes which were read\n    /// and appended to `buf`.\n    ///\n    /// # Errors\n    ///\n    /// If the data in this stream is *not* valid UTF-8 then an error is\n    /// returned and `buf` is unchanged.\n    ///\n    /// See [`read_to_end`][readtoend] for other error semantics.\n    ///\n    /// [readtoend]: #method.read_to_end\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    /// let mut buffer = String::new();\n    ///\n    /// f.read_to_string(&mut buffer)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n        // Note that we do *not* call `.read_to_end()` here. We are passing\n        // `&mut Vec<u8>` (the raw contents of `buf`) into the `read_to_end`\n        // method to fill it up. An arbitrary implementation could overwrite the\n        // entire contents of the vector, not just append to it (which is what\n        // we are expecting).\n        //\n        // To prevent extraneously checking the UTF-8-ness of the entire buffer\n        // we pass it to our hardcoded `read_to_end` implementation which we\n        // know is guaranteed to only read data into the end of the buffer.\n        append_to_string(buf, |b| read_to_end(self, b))\n    }\n\n    /// Read the exact number of bytes required to fill `buf`.\n    ///\n    /// This function reads as many bytes as necessary to completely fill the\n    /// specified buffer `buf`.\n    ///\n    /// No guarantees are provided about the contents of `buf` when this\n    /// function is called, implementations cannot rely on any property of the\n    /// contents of `buf` being true. It is recommended that implementations\n    /// only write data to `buf` instead of reading its contents.\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters an error of the kind\n    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n    /// will continue.\n    ///\n    /// If this function encounters an \"end of file\" before completely filling\n    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n    /// The contents of `buf` are unspecified in this case.\n    ///\n    /// If any other read error is encountered then this function immediately\n    /// returns. The contents of `buf` are unspecified in this case.\n    ///\n    /// If this function returns an error, it is unspecified how many bytes it\n    /// has read, but it will never read more than would be necessary to\n    /// completely fill the buffer.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: ../fs/struct.File.html\n    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n    /// [`ErrorKind::UnexpectedEof`]: ../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    /// let mut buffer = [0; 10];\n    ///\n    /// // read exactly 10 bytes\n    /// f.read_exact(&mut buffer)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"read_exact\", since = \"1.6.0\")]\n    fn read_exact(&mut self, mut buf: &mut [u8]) -> Result<()> {\n        while !buf.is_empty() {\n            match self.read(buf) {\n                Ok(0) => break,\n                Ok(n) => { let tmp = buf; buf = &mut tmp[n..]; }\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                Err(e) => return Err(e),\n            }\n        }\n        if !buf.is_empty() {\n            Err(Error::new(ErrorKind::UnexpectedEof,\n                           \"failed to fill whole buffer\"))\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Creates a \"by reference\" adaptor for this instance of `Read`.\n    ///\n    /// The returned adaptor also implements `Read` and will simply borrow this\n    /// current reader.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::Read;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    /// let mut buffer = Vec::new();\n    /// let mut other_buffer = Vec::new();\n    ///\n    /// {\n    ///     let reference = f.by_ref();\n    ///\n    ///     // read at most 5 bytes\n    ///     reference.take(5).read_to_end(&mut buffer)?;\n    ///\n    /// } // drop our &mut reference so we can use f again\n    ///\n    /// // original file still usable, read the rest\n    /// f.read_to_end(&mut other_buffer)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n\n    /// Transforms this `Read` instance to an [`Iterator`] over its bytes.\n    ///\n    /// The returned type implements [`Iterator`] where the `Item` is\n    /// [`Result`]`<`[`u8`]`, `[`io::Error`]`>`.\n    /// The yielded item is [`Ok`] if a byte was successfully read and [`Err`]\n    /// otherwise. EOF is mapped to returning [`None`] from this iterator.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    /// [`Iterator`]: ../../std/iter/trait.Iterator.html\n    /// [`Result`]: ../../std/result/enum.Result.html\n    /// [`io::Error`]: ../../std/io/struct.Error.html\n    /// [`u8`]: ../../std/primitive.u8.html\n    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    ///\n    /// for byte in f.bytes() {\n    ///     println!(\"{}\", byte.unwrap());\n    /// }\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn bytes(self) -> Bytes<Self> where Self: Sized {\n        Bytes { inner: self }\n    }\n\n    /// Transforms this `Read` instance to an [`Iterator`] over [`char`]s.\n    ///\n    /// This adaptor will attempt to interpret this reader as a UTF-8 encoded\n    /// sequence of characters. The returned iterator will return [`None`] once\n    /// EOF is reached for this reader. Otherwise each element yielded will be a\n    /// [`Result`]`<`[`char`]`, E>` where `E` may contain information about what I/O error\n    /// occurred or where decoding failed.\n    ///\n    /// Currently this adaptor will discard intermediate data read, and should\n    /// be avoided if this is not desired.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: ../fs/struct.File.html\n    /// [`Iterator`]: ../../std/iter/trait.Iterator.html\n    /// [`Result`]: ../../std/result/enum.Result.html\n    /// [`char`]: ../../std/primitive.char.html\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// ```\n    /// #![feature(io)]\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    ///\n    /// for c in f.chars() {\n    ///     println!(\"{}\", c.unwrap());\n    /// }\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                         of where errors happen is currently \\\n                                         unclear and may change\",\n               issue = \"27802\")]\n    fn chars(self) -> Chars<Self> where Self: Sized {\n        Chars { inner: self }\n    }\n\n    /// Creates an adaptor which will chain this stream with another.\n    ///\n    /// The returned `Read` instance will first read all bytes from this object\n    /// until EOF is encountered. Afterwards the output is equivalent to the\n    /// output of `next`.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f1 = File::open(\"foo.txt\")?;\n    /// let mut f2 = File::open(\"bar.txt\")?;\n    ///\n    /// let mut handle = f1.chain(f2);\n    /// let mut buffer = String::new();\n    ///\n    /// // read the value into a String. We could use any Read method here,\n    /// // this is just one example.\n    /// handle.read_to_string(&mut buffer)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized {\n        Chain { first: self, second: next, done_first: false }\n    }\n\n    /// Creates an adaptor which will read at most `limit` bytes from it.\n    ///\n    /// This function returns a new instance of `Read` which will read at most\n    /// `limit` bytes, after which it will always return EOF ([`Ok(0)`]). Any\n    /// read errors will not count towards the number of bytes read and future\n    /// calls to [`read()`] may succeed.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: ../fs/struct.File.html\n    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`read()`]: trait.Read.html#tymethod.read\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut f = File::open(\"foo.txt\")?;\n    /// let mut buffer = [0; 5];\n    ///\n    /// // read at most five bytes\n    /// let mut handle = f.take(5);\n    ///\n    /// handle.read(&mut buffer)?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn take(self, limit: u64) -> Take<Self> where Self: Sized {\n        Take { inner: self, limit: limit }\n    }\n}\n\n/// A type used to conditionally initialize buffers passed to `Read` methods.\n#[unstable(feature = \"read_initializer\", issue = \"42788\")]\n#[derive(Debug)]\npub struct Initializer(bool);\n\nimpl Initializer {\n    /// Returns a new `Initializer` which will zero out buffers.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn zeroing() -> Initializer {\n        Initializer(true)\n    }\n\n    /// Returns a new `Initializer` which will not zero out buffers.\n    ///\n    /// # Safety\n    ///\n    /// This may only be called by `Read`ers which guarantee that they will not\n    /// read from buffers passed to `Read` methods, and that the return value of\n    /// the method accurately reflects the number of bytes that have been\n    /// written to the head of the buffer.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub unsafe fn nop() -> Initializer {\n        Initializer(false)\n    }\n\n    /// Indicates if a buffer should be initialized.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn should_initialize(&self) -> bool {\n        self.0\n    }\n\n    /// Initializes a buffer if necessary.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn initialize(&self, buf: &mut [u8]) {\n        if self.should_initialize() {\n            unsafe { ptr::write_bytes(buf.as_mut_ptr(), 0, buf.len()) }\n        }\n    }\n}\n\n/// A trait for objects which are byte-oriented sinks.\n///\n/// Implementors of the `Write` trait are sometimes called 'writers'.\n///\n/// Writers are defined by two required methods, [`write`] and [`flush`]:\n///\n/// * The [`write`] method will attempt to write some data into the object,\n///   returning how many bytes were successfully written.\n///\n/// * The [`flush`] method is useful for adaptors and explicit buffers\n///   themselves for ensuring that all buffered data has been pushed out to the\n///   'true sink'.\n///\n/// Writers are intended to be composable with one another. Many implementors\n/// throughout [`std::io`] take and provide types which implement the `Write`\n/// trait.\n///\n/// [`write`]: #tymethod.write\n/// [`flush`]: #tymethod.flush\n/// [`std::io`]: index.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// # fn foo() -> std::io::Result<()> {\n/// let mut buffer = File::create(\"foo.txt\")?;\n///\n/// buffer.write(b\"some bytes\")?;\n/// # Ok(())\n/// # }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(spotlight)]\npub trait Write {\n    /// Write a buffer into this object, returning how many bytes were written.\n    ///\n    /// This function will attempt to write the entire contents of `buf`, but\n    /// the entire write may not succeed, or the write may also generate an\n    /// error. A call to `write` represents *at most one* attempt to write to\n    /// any wrapped object.\n    ///\n    /// Calls to `write` are not guaranteed to block waiting for data to be\n    /// written, and a write which would otherwise block can be indicated through\n    /// an [`Err`] variant.\n    ///\n    /// If the return value is [`Ok(n)`] then it must be guaranteed that\n    /// `0 <= n <= buf.len()`. A return value of `0` typically means that the\n    /// underlying object is no longer able to accept bytes and will likely not\n    /// be able to in the future as well, or that the buffer provided is empty.\n    ///\n    /// # Errors\n    ///\n    /// Each call to `write` may generate an I/O error indicating that the\n    /// operation could not be completed. If an error is returned then no bytes\n    /// in the buffer were written to this writer.\n    ///\n    /// It is **not** considered an error if the entire buffer could not be\n    /// written to this writer.\n    ///\n    /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the\n    /// write operation should be retried if there is nothing else to do.\n    ///\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`Ok(n)`]:  ../../std/result/enum.Result.html#variant.Ok\n    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    /// // Writes some prefix of the byte string, not necessarily all of it.\n    /// buffer.write(b\"some bytes\")?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n\n    /// Flush this output stream, ensuring that all intermediately buffered\n    /// contents reach their destination.\n    ///\n    /// # Errors\n    ///\n    /// It is considered an error if not all bytes could be written due to\n    /// I/O errors or EOF being reached.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::prelude::*;\n    /// use std::io::BufWriter;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut buffer = BufWriter::new(File::create(\"foo.txt\")?);\n    ///\n    /// buffer.write(b\"some bytes\")?;\n    /// buffer.flush()?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn flush(&mut self) -> Result<()>;\n\n    /// Attempts to write an entire buffer into this write.\n    ///\n    /// This method will continuously call [`write`] until there is no more data\n    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n    /// returned. This method will not return until the entire buffer has been\n    /// successfully written or such an error occurs. The first error that is\n    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be\n    /// returned.\n    ///\n    /// # Errors\n    ///\n    /// This function will return the first error of\n    /// non-[`ErrorKind::Interrupted`] kind that [`write`] returns.\n    ///\n    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n    /// [`write`]: #tymethod.write\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    /// buffer.write_all(b\"some bytes\")?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n        while !buf.is_empty() {\n            match self.write(buf) {\n                Ok(0) => return Err(Error::new(ErrorKind::WriteZero,\n                                               \"failed to write whole buffer\")),\n                Ok(n) => buf = &buf[n..],\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(())\n    }\n\n    /// Writes a formatted string into this writer, returning any error\n    /// encountered.\n    ///\n    /// This method is primarily used to interface with the\n    /// [`format_args!`][formatargs] macro, but it is rare that this should\n    /// explicitly be called. The [`write!`][write] macro should be favored to\n    /// invoke this method instead.\n    ///\n    /// [formatargs]: ../macro.format_args.html\n    /// [write]: ../macro.write.html\n    ///\n    /// This function internally uses the [`write_all`][writeall] method on\n    /// this trait and hence will continuously write data so long as no errors\n    /// are received. This also means that partial writes are not indicated in\n    /// this signature.\n    ///\n    /// [writeall]: #method.write_all\n    ///\n    /// # Errors\n    ///\n    /// This function will return any I/O error reported while formatting.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    /// // this call\n    /// write!(buffer, \"{:.*}\", 2, 1.234567)?;\n    /// // turns into this:\n    /// buffer.write_fmt(format_args!(\"{:.*}\", 2, 1.234567))?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()> {\n        // Create a shim which translates a Write to a fmt::Write and saves\n        // off I/O errors. instead of discarding them\n        struct Adaptor<'a, T: ?Sized + 'a> {\n            inner: &'a mut T,\n            error: Result<()>,\n        }\n\n        impl<'a, T: Write + ?Sized> fmt::Write for Adaptor<'a, T> {\n            fn write_str(&mut self, s: &str) -> fmt::Result {\n                match self.inner.write_all(s.as_bytes()) {\n                    Ok(()) => Ok(()),\n                    Err(e) => {\n                        self.error = Err(e);\n                        Err(fmt::Error)\n                    }\n                }\n            }\n        }\n\n        let mut output = Adaptor { inner: self, error: Ok(()) };\n        match fmt::write(&mut output, fmt) {\n            Ok(()) => Ok(()),\n            Err(..) => {\n                // check if the error came from the underlying `Write` or not\n                if output.error.is_err() {\n                    output.error\n                } else {\n                    Err(Error::new(ErrorKind::Other, \"formatter error\"))\n                }\n            }\n        }\n    }\n\n    /// Creates a \"by reference\" adaptor for this instance of `Write`.\n    ///\n    /// The returned adaptor also implements `Write` and will simply borrow this\n    /// current writer.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Write;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> std::io::Result<()> {\n    /// let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    /// let reference = buffer.by_ref();\n    ///\n    /// // we can use reference just like our original buffer\n    /// reference.write_all(b\"some bytes\")?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n}\n\n/// The `Seek` trait provides a cursor which can be moved within a stream of\n/// bytes.\n///\n/// The stream typically has a fixed size, allowing seeking relative to either\n/// end or the current offset.\n///\n/// # Examples\n///\n/// [`File`][file]s implement `Seek`:\n///\n/// [file]: ../fs/struct.File.html\n///\n/// ```\n/// use std::io;\n/// use std::io::prelude::*;\n/// use std::fs::File;\n/// use std::io::SeekFrom;\n///\n/// # fn foo() -> io::Result<()> {\n/// let mut f = File::open(\"foo.txt\")?;\n///\n/// // move the cursor 42 bytes from the start of the file\n/// f.seek(SeekFrom::Start(42))?;\n/// # Ok(())\n/// # }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Seek {\n    /// Seek to an offset, in bytes, in a stream.\n    ///\n    /// A seek beyond the end of a stream is allowed, but implementation\n    /// defined.\n    ///\n    /// If the seek operation completed successfully,\n    /// this method returns the new position from the start of the stream.\n    /// That position can be used later with [`SeekFrom::Start`].\n    ///\n    /// # Errors\n    ///\n    /// Seeking to a negative offset is considered an error.\n    ///\n    /// [`SeekFrom::Start`]: enum.SeekFrom.html#variant.Start\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n}\n\n/// Enumeration of possible methods to seek within an I/O object.\n///\n/// It is used by the [`Seek`] trait.\n///\n/// [`Seek`]: trait.Seek.html\n#[derive(Copy, PartialEq, Eq, Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum SeekFrom {\n    /// Set the offset to the provided number of bytes.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Start(#[stable(feature = \"rust1\", since = \"1.0.0\")] u64),\n\n    /// Set the offset to the size of this object plus the specified number of\n    /// bytes.\n    ///\n    /// It is possible to seek beyond the end of an object, but it's an error to\n    /// seek before byte 0.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    End(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n\n    /// Set the offset to the current position plus the specified number of\n    /// bytes.\n    ///\n    /// It is possible to seek beyond the end of an object, but it's an error to\n    /// seek before byte 0.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Current(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n}\n\nfn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n                                   -> Result<usize> {\n    let mut read = 0;\n    loop {\n        let (done, used) = {\n            let available = match r.fill_buf() {\n                Ok(n) => n,\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                Err(e) => return Err(e)\n            };\n            match memchr::memchr(delim, available) {\n                Some(i) => {\n                    buf.extend_from_slice(&available[..i + 1]);\n                    (true, i + 1)\n                }\n                None => {\n                    buf.extend_from_slice(available);\n                    (false, available.len())\n                }\n            }\n        };\n        r.consume(used);\n        read += used;\n        if done || used == 0 {\n            return Ok(read);\n        }\n    }\n}\n\n/// A `BufRead` is a type of `Read`er which has an internal buffer, allowing it\n/// to perform extra ways of reading.\n///\n/// For example, reading line-by-line is inefficient without using a buffer, so\n/// if you want to read by line, you'll need `BufRead`, which includes a\n/// [`read_line`] method as well as a [`lines`] iterator.\n///\n/// # Examples\n///\n/// A locked standard input implements `BufRead`:\n///\n/// ```\n/// use std::io;\n/// use std::io::prelude::*;\n///\n/// let stdin = io::stdin();\n/// for line in stdin.lock().lines() {\n///     println!(\"{}\", line.unwrap());\n/// }\n/// ```\n///\n/// If you have something that implements [`Read`], you can use the [`BufReader`\n/// type][`BufReader`] to turn it into a `BufRead`.\n///\n/// For example, [`File`] implements [`Read`], but not `BufRead`.\n/// [`BufReader`] to the rescue!\n///\n/// [`BufReader`]: struct.BufReader.html\n/// [`File`]: ../fs/struct.File.html\n/// [`read_line`]: #method.read_line\n/// [`lines`]: #method.lines\n/// [`Read`]: trait.Read.html\n///\n/// ```\n/// use std::io::{self, BufReader};\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// # fn foo() -> io::Result<()> {\n/// let f = File::open(\"foo.txt\")?;\n/// let f = BufReader::new(f);\n///\n/// for line in f.lines() {\n///     println!(\"{}\", line.unwrap());\n/// }\n///\n/// # Ok(())\n/// # }\n/// ```\n///\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait BufRead: Read {\n    /// Fills the internal buffer of this object, returning the buffer contents.\n    ///\n    /// This function is a lower-level call. It needs to be paired with the\n    /// [`consume`] method to function properly. When calling this\n    /// method, none of the contents will be \"read\" in the sense that later\n    /// calling `read` may return the same contents. As such, [`consume`] must\n    /// be called with the number of bytes that are consumed from this buffer to\n    /// ensure that the bytes are never returned twice.\n    ///\n    /// [`consume`]: #tymethod.consume\n    ///\n    /// An empty buffer returned indicates that the stream has reached EOF.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an I/O error if the underlying reader was\n    /// read, but returned an error.\n    ///\n    /// # Examples\n    ///\n    /// A locked standard input implements `BufRead`:\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    ///\n    /// let stdin = io::stdin();\n    /// let mut stdin = stdin.lock();\n    ///\n    /// // we can't have two `&mut` references to `stdin`, so use a block\n    /// // to end the borrow early.\n    /// let length = {\n    ///     let buffer = stdin.fill_buf().unwrap();\n    ///\n    ///     // work with buffer\n    ///     println!(\"{:?}\", buffer);\n    ///\n    ///     buffer.len()\n    /// };\n    ///\n    /// // ensure the bytes we worked with aren't returned again later\n    /// stdin.consume(length);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fill_buf(&mut self) -> Result<&[u8]>;\n\n    /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n    /// so they should no longer be returned in calls to `read`.\n    ///\n    /// This function is a lower-level call. It needs to be paired with the\n    /// [`fill_buf`] method to function properly. This function does\n    /// not perform any I/O, it simply informs this object that some amount of\n    /// its buffer, returned from [`fill_buf`], has been consumed and should\n    /// no longer be returned. As such, this function may do odd things if\n    /// [`fill_buf`] isn't called before calling it.\n    ///\n    /// The `amt` must be `<=` the number of bytes in the buffer returned by\n    /// [`fill_buf`].\n    ///\n    /// # Examples\n    ///\n    /// Since `consume()` is meant to be used with [`fill_buf`],\n    /// that method's example includes an example of `consume()`.\n    ///\n    /// [`fill_buf`]: #tymethod.fill_buf\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn consume(&mut self, amt: usize);\n\n    /// Read all bytes into `buf` until the delimiter `byte` or EOF is reached.\n    ///\n    /// This function will read bytes from the underlying stream until the\n    /// delimiter or EOF is found. Once found, all bytes up to, and including,\n    /// the delimiter (if found) will be appended to `buf`.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// An empty buffer returned indicates that the stream has reached EOF.\n    ///\n    /// # Errors\n    ///\n    /// This function will ignore all instances of [`ErrorKind::Interrupted`] and\n    /// will otherwise return any errors returned by [`fill_buf`].\n    ///\n    /// If an I/O error is encountered then all bytes read so far will be\n    /// present in `buf` and its length will have been adjusted appropriately.\n    ///\n    /// [`fill_buf`]: #tymethod.fill_buf\n    /// [`ErrorKind::Interrupted`]: enum.ErrorKind.html#variant.Interrupted\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to read all the bytes in a byte slice\n    /// in hyphen delimited segments:\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let mut cursor = io::Cursor::new(b\"lorem-ipsum\");\n    /// let mut buf = vec![];\n    ///\n    /// // cursor is at 'l'\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 6);\n    /// assert_eq!(buf, b\"lorem-\");\n    /// buf.clear();\n    ///\n    /// // cursor is at 'i'\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 5);\n    /// assert_eq!(buf, b\"ipsum\");\n    /// buf.clear();\n    ///\n    /// // cursor is at EOF\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 0);\n    /// assert_eq!(buf, b\"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> {\n        read_until(self, byte, buf)\n    }\n\n    /// Read all bytes until a newline (the 0xA byte) is reached, and append\n    /// them to the provided buffer.\n    ///\n    /// This function will read bytes from the underlying stream until the\n    /// newline delimiter (the 0xA byte) or EOF is found. Once found, all bytes\n    /// up to, and including, the delimiter (if found) will be appended to\n    /// `buf`.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// An empty buffer returned indicates that the stream has reached EOF.\n    ///\n    /// # Errors\n    ///\n    /// This function has the same error semantics as [`read_until`] and will\n    /// also return an error if the read bytes are not valid UTF-8. If an I/O\n    /// error is encountered then `buf` may contain some bytes already read in\n    /// the event that all data read so far was valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to read all the lines in a byte slice:\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let mut cursor = io::Cursor::new(b\"foo\\nbar\");\n    /// let mut buf = String::new();\n    ///\n    /// // cursor is at 'f'\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 4);\n    /// assert_eq!(buf, \"foo\\n\");\n    /// buf.clear();\n    ///\n    /// // cursor is at 'b'\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 3);\n    /// assert_eq!(buf, \"bar\");\n    /// buf.clear();\n    ///\n    /// // cursor is at EOF\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 0);\n    /// assert_eq!(buf, \"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_line(&mut self, buf: &mut String) -> Result<usize> {\n        // Note that we are not calling the `.read_until` method here, but\n        // rather our hardcoded implementation. For more details as to why, see\n        // the comments in `read_to_end`.\n        append_to_string(buf, |b| read_until(self, b'\\n', b))\n    }\n\n    /// Returns an iterator over the contents of this reader split on the byte\n    /// `byte`.\n    ///\n    /// The iterator returned from this function will return instances of\n    /// [`io::Result`]`<`[`Vec<u8>`]`>`. Each vector returned will *not* have\n    /// the delimiter byte at the end.\n    ///\n    /// This function will yield errors whenever [`read_until`] would have\n    /// also yielded an error.\n    ///\n    /// [`io::Result`]: type.Result.html\n    /// [`Vec<u8>`]: ../vec/struct.Vec.html\n    /// [`read_until`]: #method.read_until\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to iterate over all hyphen delimited\n    /// segments in a byte slice\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let cursor = io::Cursor::new(b\"lorem-ipsum-dolor\");\n    ///\n    /// let mut split_iter = cursor.split(b'-').map(|l| l.unwrap());\n    /// assert_eq!(split_iter.next(), Some(b\"lorem\".to_vec()));\n    /// assert_eq!(split_iter.next(), Some(b\"ipsum\".to_vec()));\n    /// assert_eq!(split_iter.next(), Some(b\"dolor\".to_vec()));\n    /// assert_eq!(split_iter.next(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn split(self, byte: u8) -> Split<Self> where Self: Sized {\n        Split { buf: self, delim: byte }\n    }\n\n    /// Returns an iterator over the lines of this reader.\n    ///\n    /// The iterator returned from this function will yield instances of\n    /// [`io::Result`]`<`[`String`]`>`. Each string returned will *not* have a newline\n    /// byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.\n    ///\n    /// [`io::Result`]: type.Result.html\n    /// [`String`]: ../string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to iterate over all the lines in a byte\n    /// slice.\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n    ///\n    /// let mut lines_iter = cursor.lines().map(|l| l.unwrap());\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"lorem\")));\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"ipsum\")));\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"dolor\")));\n    /// assert_eq!(lines_iter.next(), None);\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// Each line of the iterator has the same error semantics as [`BufRead::read_line`].\n    ///\n    /// [`BufRead::read_line`]: trait.BufRead.html#method.read_line\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn lines(self) -> Lines<Self> where Self: Sized {\n        Lines { buf: self }\n    }\n}\n\n/// Adaptor to chain together two readers.\n///\n/// This struct is generally created by calling [`chain`] on a reader.\n/// Please see the documentation of [`chain`] for more details.\n///\n/// [`chain`]: trait.Read.html#method.chain\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Chain<T, U> {\n    first: T,\n    second: U,\n    done_first: bool,\n}\n\nimpl<T, U> Chain<T, U> {\n    /// Consumes the `Chain`, returning the wrapped readers.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut foo_file = File::open(\"foo.txt\")?;\n    /// let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    /// let chain = foo_file.chain(bar_file);\n    /// let (foo_file, bar_file) = chain.into_inner();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn into_inner(self) -> (T, U) {\n        (self.first, self.second)\n    }\n\n    /// Gets references to the underlying readers in this `Chain`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut foo_file = File::open(\"foo.txt\")?;\n    /// let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    /// let chain = foo_file.chain(bar_file);\n    /// let (foo_file, bar_file) = chain.get_ref();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_ref(&self) -> (&T, &U) {\n        (&self.first, &self.second)\n    }\n\n    /// Gets mutable references to the underlying readers in this `Chain`.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying readers as doing so may corrupt the internal state of this\n    /// `Chain`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut foo_file = File::open(\"foo.txt\")?;\n    /// let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    /// let mut chain = foo_file.chain(bar_file);\n    /// let (foo_file, bar_file) = chain.get_mut();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_mut(&mut self) -> (&mut T, &mut U) {\n        (&mut self.first, &mut self.second)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T: fmt::Debug, U: fmt::Debug> fmt::Debug for Chain<T, U> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"Chain\")\n            .field(\"t\", &self.first)\n            .field(\"u\", &self.second)\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Read, U: Read> Read for Chain<T, U> {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n        if !self.done_first {\n            match self.first.read(buf)? {\n                0 if buf.len() != 0 => { self.done_first = true; }\n                n => return Ok(n),\n            }\n        }\n        self.second.read(buf)\n    }\n\n    unsafe fn initializer(&self) -> Initializer {\n        let initializer = self.first.initializer();\n        if initializer.should_initialize() {\n            initializer\n        } else {\n            self.second.initializer()\n        }\n    }\n}\n\n#[stable(feature = \"chain_bufread\", since = \"1.9.0\")]\nimpl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n    fn fill_buf(&mut self) -> Result<&[u8]> {\n        if !self.done_first {\n            match self.first.fill_buf()? {\n                buf if buf.len() == 0 => { self.done_first = true; }\n                buf => return Ok(buf),\n            }\n        }\n        self.second.fill_buf()\n    }\n\n    fn consume(&mut self, amt: usize) {\n        if !self.done_first {\n            self.first.consume(amt)\n        } else {\n            self.second.consume(amt)\n        }\n    }\n}\n\n/// Reader adaptor which limits the bytes read from an underlying reader.\n///\n/// This struct is generally created by calling [`take`] on a reader.\n/// Please see the documentation of [`take`] for more details.\n///\n/// [`take`]: trait.Read.html#method.take\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Take<T> {\n    inner: T,\n    limit: u64,\n}\n\nimpl<T> Take<T> {\n    /// Returns the number of bytes that can be read before this instance will\n    /// return EOF.\n    ///\n    /// # Note\n    ///\n    /// This instance may reach `EOF` after reading fewer bytes than indicated by\n    /// this method if the underlying [`Read`] instance reaches EOF.\n    ///\n    /// [`Read`]: ../../std/io/trait.Read.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let f = File::open(\"foo.txt\")?;\n    ///\n    /// // read at most five bytes\n    /// let handle = f.take(5);\n    ///\n    /// println!(\"limit: {}\", handle.limit());\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn limit(&self) -> u64 { self.limit }\n\n    /// Sets the number of bytes that can be read before this instance will\n    /// return EOF. This is the same as constructing a new `Take` instance, so\n    /// the amount of bytes read and the previous limit value don't matter when\n    /// calling this method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(take_set_limit)]\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let f = File::open(\"foo.txt\")?;\n    ///\n    /// // read at most five bytes\n    /// let mut handle = f.take(5);\n    /// handle.set_limit(10);\n    ///\n    /// assert_eq!(handle.limit(), 10);\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[unstable(feature = \"take_set_limit\", issue = \"42781\")]\n    pub fn set_limit(&mut self, limit: u64) {\n        self.limit = limit;\n    }\n\n    /// Consumes the `Take`, returning the wrapped reader.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut file = File::open(\"foo.txt\")?;\n    ///\n    /// let mut buffer = [0; 5];\n    /// let mut handle = file.take(5);\n    /// handle.read(&mut buffer)?;\n    ///\n    /// let file = handle.into_inner();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"io_take_into_inner\", since = \"1.15.0\")]\n    pub fn into_inner(self) -> T {\n        self.inner\n    }\n\n    /// Gets a reference to the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut file = File::open(\"foo.txt\")?;\n    ///\n    /// let mut buffer = [0; 5];\n    /// let mut handle = file.take(5);\n    /// handle.read(&mut buffer)?;\n    ///\n    /// let file = handle.get_ref();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_ref(&self) -> &T {\n        &self.inner\n    }\n\n    /// Gets a mutable reference to the underlying reader.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying reader as doing so may corrupt the internal limit of this\n    /// `Take`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// # fn foo() -> io::Result<()> {\n    /// let mut file = File::open(\"foo.txt\")?;\n    ///\n    /// let mut buffer = [0; 5];\n    /// let mut handle = file.take(5);\n    /// handle.read(&mut buffer)?;\n    ///\n    /// let file = handle.get_mut();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_mut(&mut self) -> &mut T {\n        &mut self.inner\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Read> Read for Take<T> {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n        // Don't call into inner reader at all at EOF because it may still block\n        if self.limit == 0 {\n            return Ok(0);\n        }\n\n        let max = cmp::min(buf.len() as u64, self.limit) as usize;\n        let n = self.inner.read(&mut buf[..max])?;\n        self.limit -= n as u64;\n        Ok(n)\n    }\n\n    unsafe fn initializer(&self) -> Initializer {\n        self.inner.initializer()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: BufRead> BufRead for Take<T> {\n    fn fill_buf(&mut self) -> Result<&[u8]> {\n        // Don't call into inner reader at all at EOF because it may still block\n        if self.limit == 0 {\n            return Ok(&[]);\n        }\n\n        let buf = self.inner.fill_buf()?;\n        let cap = cmp::min(buf.len() as u64, self.limit) as usize;\n        Ok(&buf[..cap])\n    }\n\n    fn consume(&mut self, amt: usize) {\n        // Don't let callers reset the limit by passing an overlarge value\n        let amt = cmp::min(amt as u64, self.limit) as usize;\n        self.limit -= amt as u64;\n        self.inner.consume(amt);\n    }\n}\n\nfn read_one_byte(reader: &mut Read) -> Option<Result<u8>> {\n    let mut buf = [0];\n    loop {\n        return match reader.read(&mut buf) {\n            Ok(0) => None,\n            Ok(..) => Some(Ok(buf[0])),\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n            Err(e) => Some(Err(e)),\n        };\n    }\n}\n\n/// An iterator over `u8` values of a reader.\n///\n/// This struct is generally created by calling [`bytes`] on a reader.\n/// Please see the documentation of [`bytes`] for more details.\n///\n/// [`bytes`]: trait.Read.html#method.bytes\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Bytes<R> {\n    inner: R,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> Iterator for Bytes<R> {\n    type Item = Result<u8>;\n\n    fn next(&mut self) -> Option<Result<u8>> {\n        read_one_byte(&mut self.inner)\n    }\n}\n\n/// An iterator over the `char`s of a reader.\n///\n/// This struct is generally created by calling [`chars`][chars] on a reader.\n/// Please see the documentation of `chars()` for more details.\n///\n/// [chars]: trait.Read.html#method.chars\n#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n           issue = \"27802\")]\n#[derive(Debug)]\npub struct Chars<R> {\n    inner: R,\n}\n\n/// An enumeration of possible errors that can be generated from the `Chars`\n/// adapter.\n#[derive(Debug)]\n#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n           issue = \"27802\")]\npub enum CharsError {\n    /// Variant representing that the underlying stream was read successfully\n    /// but it did not contain valid utf8 data.\n    NotUtf8,\n\n    /// Variant representing that an I/O error occurred.\n    Other(Error),\n}\n\n#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n           issue = \"27802\")]\nimpl<R: Read> Iterator for Chars<R> {\n    type Item = result::Result<char, CharsError>;\n\n    fn next(&mut self) -> Option<result::Result<char, CharsError>> {\n        let first_byte = match read_one_byte(&mut self.inner)? {\n            Ok(b) => b,\n            Err(e) => return Some(Err(CharsError::Other(e))),\n        };\n        let width = core_str::utf8_char_width(first_byte);\n        if width == 1 { return Some(Ok(first_byte as char)) }\n        if width == 0 { return Some(Err(CharsError::NotUtf8)) }\n        let mut buf = [first_byte, 0, 0, 0];\n        {\n            let mut start = 1;\n            while start < width {\n                match self.inner.read(&mut buf[start..width]) {\n                    Ok(0) => return Some(Err(CharsError::NotUtf8)),\n                    Ok(n) => start += n,\n                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                    Err(e) => return Some(Err(CharsError::Other(e))),\n                }\n            }\n        }\n        Some(match str::from_utf8(&buf[..width]).ok() {\n            Some(s) => Ok(s.chars().next().unwrap()),\n            None => Err(CharsError::NotUtf8),\n        })\n    }\n}\n\n#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n           issue = \"27802\")]\nimpl std_error::Error for CharsError {\n    fn description(&self) -> &str {\n        match *self {\n            CharsError::NotUtf8 => \"invalid utf8 encoding\",\n            CharsError::Other(ref e) => std_error::Error::description(e),\n        }\n    }\n    fn cause(&self) -> Option<&std_error::Error> {\n        match *self {\n            CharsError::NotUtf8 => None,\n            CharsError::Other(ref e) => e.cause(),\n        }\n    }\n}\n\n#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n           issue = \"27802\")]\nimpl fmt::Display for CharsError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            CharsError::NotUtf8 => {\n                \"byte stream did not contain valid utf8\".fmt(f)\n            }\n            CharsError::Other(ref e) => e.fmt(f),\n        }\n    }\n}\n\n/// An iterator over the contents of an instance of `BufRead` split on a\n/// particular byte.\n///\n/// This struct is generally created by calling [`split`][split] on a\n/// `BufRead`. Please see the documentation of `split()` for more details.\n///\n/// [split]: trait.BufRead.html#method.split\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Split<B> {\n    buf: B,\n    delim: u8,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead> Iterator for Split<B> {\n    type Item = Result<Vec<u8>>;\n\n    fn next(&mut self) -> Option<Result<Vec<u8>>> {\n        let mut buf = Vec::new();\n        match self.buf.read_until(self.delim, &mut buf) {\n            Ok(0) => None,\n            Ok(_n) => {\n                if buf[buf.len() - 1] == self.delim {\n                    buf.pop();\n                }\n                Some(Ok(buf))\n            }\n            Err(e) => Some(Err(e))\n        }\n    }\n}\n\n/// An iterator over the lines of an instance of `BufRead`.\n///\n/// This struct is generally created by calling [`lines`][lines] on a\n/// `BufRead`. Please see the documentation of `lines()` for more details.\n///\n/// [lines]: trait.BufRead.html#method.lines\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Lines<B> {\n    buf: B,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead> Iterator for Lines<B> {\n    type Item = Result<String>;\n\n    fn next(&mut self) -> Option<Result<String>> {\n        let mut buf = String::new();\n        match self.buf.read_line(&mut buf) {\n            Ok(0) => None,\n            Ok(_n) => {\n                if buf.ends_with(\"\\n\") {\n                    buf.pop();\n                    if buf.ends_with(\"\\r\") {\n                        buf.pop();\n                    }\n                }\n                Some(Ok(buf))\n            }\n            Err(e) => Some(Err(e))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use io::prelude::*;\n    use io;\n    use super::Cursor;\n    use test;\n    use super::repeat;\n\n    #[test]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn read_until() {\n        let mut buf = Cursor::new(&b\"12\"[..]);\n        let mut v = Vec::new();\n        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 2);\n        assert_eq!(v, b\"12\");\n\n        let mut buf = Cursor::new(&b\"1233\"[..]);\n        let mut v = Vec::new();\n        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 3);\n        assert_eq!(v, b\"123\");\n        v.truncate(0);\n        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 1);\n        assert_eq!(v, b\"3\");\n        v.truncate(0);\n        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 0);\n        assert_eq!(v, []);\n    }\n\n    #[test]\n    fn split() {\n        let buf = Cursor::new(&b\"12\"[..]);\n        let mut s = buf.split(b'3');\n        assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n        assert!(s.next().is_none());\n\n        let buf = Cursor::new(&b\"1233\"[..]);\n        let mut s = buf.split(b'3');\n        assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n        assert_eq!(s.next().unwrap().unwrap(), vec![]);\n        assert!(s.next().is_none());\n    }\n\n    #[test]\n    fn read_line() {\n        let mut buf = Cursor::new(&b\"12\"[..]);\n        let mut v = String::new();\n        assert_eq!(buf.read_line(&mut v).unwrap(), 2);\n        assert_eq!(v, \"12\");\n\n        let mut buf = Cursor::new(&b\"12\\n\\n\"[..]);\n        let mut v = String::new();\n        assert_eq!(buf.read_line(&mut v).unwrap(), 3);\n        assert_eq!(v, \"12\\n\");\n        v.truncate(0);\n        assert_eq!(buf.read_line(&mut v).unwrap(), 1);\n        assert_eq!(v, \"\\n\");\n        v.truncate(0);\n        assert_eq!(buf.read_line(&mut v).unwrap(), 0);\n        assert_eq!(v, \"\");\n    }\n\n    #[test]\n    fn lines() {\n        let buf = Cursor::new(&b\"12\\r\"[..]);\n        let mut s = buf.lines();\n        assert_eq!(s.next().unwrap().unwrap(), \"12\\r\".to_string());\n        assert!(s.next().is_none());\n\n        let buf = Cursor::new(&b\"12\\r\\n\\n\"[..]);\n        let mut s = buf.lines();\n        assert_eq!(s.next().unwrap().unwrap(), \"12\".to_string());\n        assert_eq!(s.next().unwrap().unwrap(), \"\".to_string());\n        assert!(s.next().is_none());\n    }\n\n    #[test]\n    fn read_to_end() {\n        let mut c = Cursor::new(&b\"\"[..]);\n        let mut v = Vec::new();\n        assert_eq!(c.read_to_end(&mut v).unwrap(), 0);\n        assert_eq!(v, []);\n\n        let mut c = Cursor::new(&b\"1\"[..]);\n        let mut v = Vec::new();\n        assert_eq!(c.read_to_end(&mut v).unwrap(), 1);\n        assert_eq!(v, b\"1\");\n\n        let cap = 1024 * 1024;\n        let data = (0..cap).map(|i| (i / 3) as u8).collect::<Vec<_>>();\n        let mut v = Vec::new();\n        let (a, b) = data.split_at(data.len() / 2);\n        assert_eq!(Cursor::new(a).read_to_end(&mut v).unwrap(), a.len());\n        assert_eq!(Cursor::new(b).read_to_end(&mut v).unwrap(), b.len());\n        assert_eq!(v, data);\n    }\n\n    #[test]\n    fn read_to_string() {\n        let mut c = Cursor::new(&b\"\"[..]);\n        let mut v = String::new();\n        assert_eq!(c.read_to_string(&mut v).unwrap(), 0);\n        assert_eq!(v, \"\");\n\n        let mut c = Cursor::new(&b\"1\"[..]);\n        let mut v = String::new();\n        assert_eq!(c.read_to_string(&mut v).unwrap(), 1);\n        assert_eq!(v, \"1\");\n\n        let mut c = Cursor::new(&b\"\\xff\"[..]);\n        let mut v = String::new();\n        assert!(c.read_to_string(&mut v).is_err());\n    }\n\n    #[test]\n    fn read_exact() {\n        let mut buf = [0; 4];\n\n        let mut c = Cursor::new(&b\"\"[..]);\n        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n                   io::ErrorKind::UnexpectedEof);\n\n        let mut c = Cursor::new(&b\"123\"[..]).chain(Cursor::new(&b\"456789\"[..]));\n        c.read_exact(&mut buf).unwrap();\n        assert_eq!(&buf, b\"1234\");\n        c.read_exact(&mut buf).unwrap();\n        assert_eq!(&buf, b\"5678\");\n        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n                   io::ErrorKind::UnexpectedEof);\n    }\n\n    #[test]\n    fn read_exact_slice() {\n        let mut buf = [0; 4];\n\n        let mut c = &b\"\"[..];\n        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n                   io::ErrorKind::UnexpectedEof);\n\n        let mut c = &b\"123\"[..];\n        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n                   io::ErrorKind::UnexpectedEof);\n        // make sure the optimized (early returning) method is being used\n        assert_eq!(&buf, &[0; 4]);\n\n        let mut c = &b\"1234\"[..];\n        c.read_exact(&mut buf).unwrap();\n        assert_eq!(&buf, b\"1234\");\n\n        let mut c = &b\"56789\"[..];\n        c.read_exact(&mut buf).unwrap();\n        assert_eq!(&buf, b\"5678\");\n        assert_eq!(c, b\"9\");\n    }\n\n    #[test]\n    fn take_eof() {\n        struct R;\n\n        impl Read for R {\n            fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n                Err(io::Error::new(io::ErrorKind::Other, \"\"))\n            }\n        }\n        impl BufRead for R {\n            fn fill_buf(&mut self) -> io::Result<&[u8]> {\n                Err(io::Error::new(io::ErrorKind::Other, \"\"))\n            }\n            fn consume(&mut self, _amt: usize) { }\n        }\n\n        let mut buf = [0; 1];\n        assert_eq!(0, R.take(0).read(&mut buf).unwrap());\n        assert_eq!(b\"\", R.take(0).fill_buf().unwrap());\n    }\n\n    fn cmp_bufread<Br1: BufRead, Br2: BufRead>(mut br1: Br1, mut br2: Br2, exp: &[u8]) {\n        let mut cat = Vec::new();\n        loop {\n            let consume = {\n                let buf1 = br1.fill_buf().unwrap();\n                let buf2 = br2.fill_buf().unwrap();\n                let minlen = if buf1.len() < buf2.len() { buf1.len() } else { buf2.len() };\n                assert_eq!(buf1[..minlen], buf2[..minlen]);\n                cat.extend_from_slice(&buf1[..minlen]);\n                minlen\n            };\n            if consume == 0 {\n                break;\n            }\n            br1.consume(consume);\n            br2.consume(consume);\n        }\n        assert_eq!(br1.fill_buf().unwrap().len(), 0);\n        assert_eq!(br2.fill_buf().unwrap().len(), 0);\n        assert_eq!(&cat[..], &exp[..])\n    }\n\n    #[test]\n    fn chain_bufread() {\n        let testdata = b\"ABCDEFGHIJKL\";\n        let chain1 = (&testdata[..3]).chain(&testdata[3..6])\n                                     .chain(&testdata[6..9])\n                                     .chain(&testdata[9..]);\n        let chain2 = (&testdata[..4]).chain(&testdata[4..8])\n                                     .chain(&testdata[8..]);\n        cmp_bufread(chain1, chain2, &testdata[..]);\n    }\n\n    #[test]\n    fn chain_zero_length_read_is_not_eof() {\n        let a = b\"A\";\n        let b = b\"B\";\n        let mut s = String::new();\n        let mut chain = (&a[..]).chain(&b[..]);\n        chain.read(&mut []).unwrap();\n        chain.read_to_string(&mut s).unwrap();\n        assert_eq!(\"AB\", s);\n    }\n\n    #[bench]\n    #[cfg_attr(target_os = \"emscripten\", ignore)]\n    fn bench_read_to_end(b: &mut test::Bencher) {\n        b.iter(|| {\n            let mut lr = repeat(1).take(10000000);\n            let mut vec = Vec::with_capacity(1024);\n            super::read_to_end(&mut lr, &mut vec)\n        });\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! # The Rust Core Library\n//!\n//! The Rust Core Library is the dependency-free[^free] foundation of [The\n//! Rust Standard Library](../std/index.html). It is the portable glue\n//! between the language and its libraries, defining the intrinsic and\n//! primitive building blocks of all Rust code. It links to no\n//! upstream libraries, no system libraries, and no libc.\n//!\n//! [^free]: Strictly speaking, there are some symbols which are needed but\n//!          they aren't always necessary.\n//!\n//! The core library is *minimal*: it isn't even aware of heap allocation,\n//! nor does it provide concurrency or I/O. These things require\n//! platform integration, and this library is platform-agnostic.\n//!\n//! # How to use the core library\n//!\n//! Please note that all of these details are currently not considered stable.\n//!\n// FIXME: Fill me in with more detail when the interface settles\n//! This library is built on the assumption of a few existing symbols:\n//!\n//! * `memcpy`, `memcmp`, `memset` - These are core memory routines which are\n//!   often generated by LLVM. Additionally, this library can make explicit\n//!   calls to these functions. Their signatures are the same as found in C.\n//!   These functions are often provided by the system libc, but can also be\n//!   provided by the [rlibc crate](https://crates.io/crates/rlibc).\n//!\n//! * `rust_begin_panic` - This function takes four arguments, a\n//!   `fmt::Arguments`, a `&'static str`, and two `u32`'s. These four arguments\n//!   dictate the panic message, the file at which panic was invoked, and the\n//!   line and column inside the file. It is up to consumers of this core\n//!   library to define this panic function; it is only required to never\n//!   return. This requires a `lang` attribute named `panic_fmt`.\n//!\n//! * `rust_eh_personality` - is used by the failure mechanisms of the\n//!    compiler. This is often mapped to GCC's personality function, but crates\n//!    which do not trigger a panic can be assured that this function is never\n//!    called. The `lang` attribute is called `eh_personality`.\n\n// Since libcore defines many fundamental lang items, all tests live in a\n// separate crate, libcoretest, to avoid bizarre issues.\n\n#![stable(feature = \"core\", since = \"1.6.0\")]\n#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n       html_playground_url = \"https://play.rust-lang.org/\",\n       issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n       test(no_crate_inject, attr(deny(warnings))),\n       test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n\n#![no_core]\n#![deny(missing_docs)]\n#![deny(missing_debug_implementations)]\n#![deny(warnings)]\n\n#![feature(allow_internal_unstable)]\n#![feature(asm)]\n#![feature(associated_type_defaults)]\n#![feature(cfg_target_feature)]\n#![feature(cfg_target_has_atomic)]\n#![feature(concat_idents)]\n#![feature(const_fn)]\n#![feature(custom_attribute)]\n#![feature(fundamental)]\n#![feature(i128_type)]\n#![feature(inclusive_range_syntax)]\n#![feature(intrinsics)]\n#![feature(lang_items)]\n#![feature(never_type)]\n#![feature(no_core)]\n#![feature(on_unimplemented)]\n#![feature(optin_builtin_traits)]\n#![feature(prelude_import)]\n#![feature(repr_simd, platform_intrinsics)]\n#![feature(rustc_attrs)]\n#![feature(specialization)]\n#![feature(staged_api)]\n#![feature(unboxed_closures)]\n#![feature(untagged_unions)]\n#![feature(unwind_attributes)]\n#![feature(doc_spotlight)]\n\n#[prelude_import]\n#[allow(unused)]\nuse prelude::v1::*;\n\n#[macro_use]\nmod macros;\n\n#[macro_use]\nmod internal_macros;\n\n#[path = \"num/int_macros.rs\"]\n#[macro_use]\nmod int_macros;\n\n#[path = \"num/uint_macros.rs\"]\n#[macro_use]\nmod uint_macros;\n\n#[path = \"num/isize.rs\"] pub mod isize;\n#[path = \"num/i8.rs\"]    pub mod i8;\n#[path = \"num/i16.rs\"]   pub mod i16;\n#[path = \"num/i32.rs\"]   pub mod i32;\n#[path = \"num/i64.rs\"]   pub mod i64;\n#[path = \"num/i128.rs\"]   pub mod i128;\n\n#[path = \"num/usize.rs\"] pub mod usize;\n#[path = \"num/u8.rs\"]    pub mod u8;\n#[path = \"num/u16.rs\"]   pub mod u16;\n#[path = \"num/u32.rs\"]   pub mod u32;\n#[path = \"num/u64.rs\"]   pub mod u64;\n#[path = \"num/u128.rs\"]   pub mod u128;\n\n#[path = \"num/f32.rs\"]   pub mod f32;\n#[path = \"num/f64.rs\"]   pub mod f64;\n\n#[macro_use]\npub mod num;\n\n/* The libcore prelude, not as all-encompassing as the libstd prelude */\n\npub mod prelude;\n\n/* Core modules for ownership management */\n\npub mod intrinsics;\npub mod mem;\npub mod nonzero;\npub mod ptr;\n\n/* Core language traits */\n\npub mod marker;\npub mod ops;\npub mod cmp;\npub mod clone;\npub mod default;\npub mod convert;\npub mod borrow;\n\n/* Core types and methods on primitives */\n\npub mod any;\npub mod array;\npub mod sync;\npub mod cell;\npub mod char;\npub mod panicking;\npub mod iter;\npub mod option;\npub mod raw;\npub mod result;\n\npub mod slice;\npub mod str;\npub mod hash;\npub mod fmt;\n\n// note: does not need to be public\nmod char_private;\nmod iter_private;\nmod tuple;\nmod unit;\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Implementation of various bits and pieces of the `panic!` macro and\n//! associated runtime pieces.\n//!\n//! Specifically, this module contains the implementation of:\n//!\n//! * Panic hooks\n//! * Executing a panic up to doing the actual implementation\n//! * Shims around \"try\"\n\nuse io::prelude::*;\n\nuse any::Any;\nuse cell::RefCell;\nuse fmt;\nuse intrinsics;\nuse mem;\nuse ptr;\nuse raw;\nuse sys::stdio::Stderr;\nuse sys_common::rwlock::RWLock;\nuse sys_common::thread_info;\nuse sys_common::util;\nuse thread;\n\nthread_local! {\n    pub static LOCAL_STDERR: RefCell<Option<Box<Write + Send>>> = {\n        RefCell::new(None)\n    }\n}\n\n// Binary interface to the panic runtime that the standard library depends on.\n//\n// The standard library is tagged with `#![needs_panic_runtime]` (introduced in\n// RFC 1513) to indicate that it requires some other crate tagged with\n// `#![panic_runtime]` to exist somewhere. Each panic runtime is intended to\n// implement these symbols (with the same signatures) so we can get matched up\n// to them.\n//\n// One day this may look a little less ad-hoc with the compiler helping out to\n// hook up these functions, but it is not this day!\n#[allow(improper_ctypes)]\nextern {\n    fn __rust_maybe_catch_panic(f: fn(*mut u8),\n                                data: *mut u8,\n                                data_ptr: *mut usize,\n                                vtable_ptr: *mut usize) -> u32;\n    #[unwind]\n    fn __rust_start_panic(data: usize, vtable: usize) -> u32;\n}\n\n#[derive(Copy, Clone)]\nenum Hook {\n    Default,\n    Custom(*mut (Fn(&PanicInfo) + 'static + Sync + Send)),\n}\n\nstatic HOOK_LOCK: RWLock = RWLock::new();\nstatic mut HOOK: Hook = Hook::Default;\n\n/// Registers a custom panic hook, replacing any that was previously registered.\n///\n/// The panic hook is invoked when a thread panics, but before the panic runtime\n/// is invoked. As such, the hook will run with both the aborting and unwinding\n/// runtimes. The default hook prints a message to standard error and generates\n/// a backtrace if requested, but this behavior can be customized with the\n/// `set_hook` and `take_hook` functions.\n///\n/// The hook is provided with a `PanicInfo` struct which contains information\n/// about the origin of the panic, including the payload passed to `panic!` and\n/// the source code location from which the panic originated.\n///\n/// The panic hook is a global resource.\n///\n/// # Panics\n///\n/// Panics if called from a panicking thread.\n///\n/// # Examples\n///\n/// The following will print \"Custom panic hook\":\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|_| {\n///     println!(\"Custom panic hook\");\n/// }));\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub fn set_hook(hook: Box<Fn(&PanicInfo) + 'static + Sync + Send>) {\n    if thread::panicking() {\n        panic!(\"cannot modify the panic hook from a panicking thread\");\n    }\n\n    unsafe {\n        HOOK_LOCK.write();\n        let old_hook = HOOK;\n        HOOK = Hook::Custom(Box::into_raw(hook));\n        HOOK_LOCK.write_unlock();\n\n        if let Hook::Custom(ptr) = old_hook {\n            Box::from_raw(ptr);\n        }\n    }\n}\n\n/// Unregisters the current panic hook, returning it.\n///\n/// If no custom hook is registered, the default hook will be returned.\n///\n/// # Panics\n///\n/// Panics if called from a panicking thread.\n///\n/// # Examples\n///\n/// The following will print \"Normal panic\":\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|_| {\n///     println!(\"Custom panic hook\");\n/// }));\n///\n/// let _ = panic::take_hook();\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub fn take_hook() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n    if thread::panicking() {\n        panic!(\"cannot modify the panic hook from a panicking thread\");\n    }\n\n    unsafe {\n        HOOK_LOCK.write();\n        let hook = HOOK;\n        HOOK = Hook::Default;\n        HOOK_LOCK.write_unlock();\n\n        match hook {\n            Hook::Default => Box::new(default_hook),\n            Hook::Custom(ptr) => Box::from_raw(ptr),\n        }\n    }\n}\n\n/// A struct providing information about a panic.\n///\n/// `PanicInfo` structure is passed to a panic hook set by the [`set_hook`]\n/// function.\n///\n/// [`set_hook`]: ../../std/panic/fn.set_hook.html\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|panic_info| {\n///     println!(\"panic occurred: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n/// }));\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n#[derive(Debug)]\npub struct PanicInfo<'a> {\n    payload: &'a (Any + Send),\n    location: Location<'a>,\n}\n\nimpl<'a> PanicInfo<'a> {\n    /// Returns the payload associated with the panic.\n    ///\n    /// This will commonly, but not always, be a `&'static str` or [`String`].\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     println!(\"panic occurred: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn payload(&self) -> &(Any + Send) {\n        self.payload\n    }\n\n    /// Returns information about the location from which the panic originated,\n    /// if available.\n    ///\n    /// This method will currently always return [`Some`], but this may change\n    /// in future versions.\n    ///\n    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occurred in file '{}' at line {}\", location.file(),\n    ///             location.line());\n    ///     } else {\n    ///         println!(\"panic occurred but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn location(&self) -> Option<&Location> {\n        Some(&self.location)\n    }\n}\n\n/// A struct containing information about the location of a panic.\n///\n/// This structure is created by the [`location`] method of [`PanicInfo`].\n///\n/// [`location`]: ../../std/panic/struct.PanicInfo.html#method.location\n/// [`PanicInfo`]: ../../std/panic/struct.PanicInfo.html\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|panic_info| {\n///     if let Some(location) = panic_info.location() {\n///         println!(\"panic occurred in file '{}' at line {}\", location.file(), location.line());\n///     } else {\n///         println!(\"panic occurred but can't get location information...\");\n///     }\n/// }));\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[derive(Debug)]\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub struct Location<'a> {\n    file: &'a str,\n    line: u32,\n    col: u32,\n}\n\nimpl<'a> Location<'a> {\n    /// Returns the name of the source file from which the panic originated.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occurred in file '{}'\", location.file());\n    ///     } else {\n    ///         println!(\"panic occurred but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn file(&self) -> &str {\n        self.file\n    }\n\n    /// Returns the line number from which the panic originated.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occurred at line {}\", location.line());\n    ///     } else {\n    ///         println!(\"panic occurred but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn line(&self) -> u32 {\n        self.line\n    }\n\n    /// Returns the column from which the panic originated.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occurred at column {}\", location.column());\n    ///     } else {\n    ///         println!(\"panic occurred but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_col\", since = \"1.25\")]\n    pub fn column(&self) -> u32 {\n        self.col\n    }\n}\n\nfn default_hook(info: &PanicInfo) {\n    #[cfg(feature = \"backtrace\")]\n    use sys_common::backtrace;\n\n    // If this is a double panic, make sure that we print a backtrace\n    // for this panic. Otherwise only print it if logging is enabled.\n    #[cfg(feature = \"backtrace\")]\n    let log_backtrace = {\n        let panics = update_panic_count(0);\n\n        if panics >= 2 {\n            Some(backtrace::PrintFormat::Full)\n        } else {\n            backtrace::log_enabled()\n        }\n    };\n\n    let file = info.location.file;\n    let line = info.location.line;\n    let col = info.location.col;\n\n    let msg = match info.payload.downcast_ref::<&'static str>() {\n        Some(s) => *s,\n        None => match info.payload.downcast_ref::<String>() {\n            Some(s) => &s[..],\n            None => \"Box<Any>\",\n        }\n    };\n    let mut err = Stderr::new().ok();\n    let thread = thread_info::current_thread();\n    let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n\n    let write = |err: &mut ::io::Write| {\n        let _ = writeln!(err, \"thread '{}' panicked at '{}', {}:{}:{}\",\n                         name, msg, file, line, col);\n\n        #[cfg(feature = \"backtrace\")]\n        {\n            use sync::atomic::{AtomicBool, Ordering};\n\n            static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n\n            if let Some(format) = log_backtrace {\n                let _ = backtrace::print(err, format);\n            } else if FIRST_PANIC.compare_and_swap(true, false, Ordering::SeqCst) {\n                let _ = writeln!(err, \"note: Run with `RUST_BACKTRACE=1` for a backtrace.\");\n            }\n        }\n    };\n\n    let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());\n    match (prev, err.as_mut()) {\n        (Some(mut stderr), _) => {\n            write(&mut *stderr);\n            let mut s = Some(stderr);\n            LOCAL_STDERR.with(|slot| {\n                *slot.borrow_mut() = s.take();\n            });\n        }\n        (None, Some(ref mut err)) => { write(err) }\n        _ => {}\n    }\n}\n\n\n#[cfg(not(test))]\n#[doc(hidden)]\n#[unstable(feature = \"update_panic_count\", issue = \"0\")]\npub fn update_panic_count(amt: isize) -> usize {\n    use cell::Cell;\n    thread_local! { static PANIC_COUNT: Cell<usize> = Cell::new(0) }\n\n    PANIC_COUNT.with(|c| {\n        let next = (c.get() as isize + amt) as usize;\n        c.set(next);\n        return next\n    })\n}\n\n#[cfg(test)]\npub use realstd::rt::update_panic_count;\n\n/// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\npub unsafe fn try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<Any + Send>> {\n    #[allow(unions_with_drop_fields)]\n    union Data<F, R> {\n        f: F,\n        r: R,\n    }\n\n    // We do some sketchy operations with ownership here for the sake of\n    // performance. We can only  pass pointers down to\n    // `__rust_maybe_catch_panic` (can't pass objects by value), so we do all\n    // the ownership tracking here manually using a union.\n    //\n    // We go through a transition where:\n    //\n    // * First, we set the data to be the closure that we're going to call.\n    // * When we make the function call, the `do_call` function below, we take\n    //   ownership of the function pointer. At this point the `Data` union is\n    //   entirely uninitialized.\n    // * If the closure successfully returns, we write the return value into the\n    //   data's return slot. Note that `ptr::write` is used as it's overwriting\n    //   uninitialized data.\n    // * Finally, when we come back out of the `__rust_maybe_catch_panic` we're\n    //   in one of two states:\n    //\n    //      1. The closure didn't panic, in which case the return value was\n    //         filled in. We move it out of `data` and return it.\n    //      2. The closure panicked, in which case the return value wasn't\n    //         filled in. In this case the entire `data` union is invalid, so\n    //         there is no need to drop anything.\n    //\n    // Once we stack all that together we should have the \"most efficient'\n    // method of calling a catch panic whilst juggling ownership.\n    let mut any_data = 0;\n    let mut any_vtable = 0;\n    let mut data = Data {\n        f,\n    };\n\n    let r = __rust_maybe_catch_panic(do_call::<F, R>,\n                                     &mut data as *mut _ as *mut u8,\n                                     &mut any_data,\n                                     &mut any_vtable);\n\n    return if r == 0 {\n        debug_assert!(update_panic_count(0) == 0);\n        Ok(data.r)\n    } else {\n        update_panic_count(-1);\n        debug_assert!(update_panic_count(0) == 0);\n        Err(mem::transmute(raw::TraitObject {\n            data: any_data as *mut _,\n            vtable: any_vtable as *mut _,\n        }))\n    };\n\n    fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n        unsafe {\n            let data = data as *mut Data<F, R>;\n            let f = ptr::read(&mut (*data).f);\n            ptr::write(&mut (*data).r, f());\n        }\n    }\n}\n\n/// Determines whether the current thread is unwinding because of panic.\npub fn panicking() -> bool {\n    update_panic_count(0) != 0\n}\n\n/// Entry point of panic from the libcore crate.\n#[cfg(not(test))]\n#[lang = \"panic_fmt\"]\n#[unwind]\npub extern fn rust_begin_panic(msg: fmt::Arguments,\n                               file: &'static str,\n                               line: u32,\n                               col: u32) -> ! {\n    begin_panic_fmt(&msg, &(file, line, col))\n}\n\n/// The entry point for panicking with a formatted message.\n///\n/// This is designed to reduce the amount of code required at the call\n/// site as much as possible (so that `panic!()` has as low an impact\n/// on (e.g.) the inlining of other functions as possible), by moving\n/// the actual formatting into this shared place.\n#[unstable(feature = \"libstd_sys_internals\",\n           reason = \"used by the panic! macro\",\n           issue = \"0\")]\n#[inline(never)] #[cold]\npub fn begin_panic_fmt(msg: &fmt::Arguments,\n                       file_line_col: &(&'static str, u32, u32)) -> ! {\n    use fmt::Write;\n\n    // We do two allocations here, unfortunately. But (a) they're\n    // required with the current scheme, and (b) we don't handle\n    // panic + OOM properly anyway (see comment in begin_panic\n    // below).\n\n    let mut s = String::new();\n    let _ = s.write_fmt(*msg);\n    begin_panic(s, file_line_col)\n}\n\n/// This is the entry point of panicking for panic!() and assert!().\n#[unstable(feature = \"libstd_sys_internals\",\n           reason = \"used by the panic! macro\",\n           issue = \"0\")]\n#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\npub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u32)) -> ! {\n    // Note that this should be the only allocation performed in this code path.\n    // Currently this means that panic!() on OOM will invoke this code path,\n    // but then again we're not really ready for panic on OOM anyway. If\n    // we do start doing this, then we should propagate this allocation to\n    // be performed in the parent of this thread instead of the thread that's\n    // panicking.\n\n    rust_panic_with_hook(Box::new(msg), file_line_col)\n}\n\n/// Executes the primary logic for a panic, including checking for recursive\n/// panics and panic hooks.\n///\n/// This is the entry point or panics from libcore, formatted panics, and\n/// `Box<Any>` panics. Here we'll verify that we're not panicking recursively,\n/// run panic hooks, and then delegate to the actual implementation of panics.\n#[inline(never)]\n#[cold]\nfn rust_panic_with_hook(msg: Box<Any + Send>,\n                        file_line_col: &(&'static str, u32, u32)) -> ! {\n    let (file, line, col) = *file_line_col;\n\n    let panics = update_panic_count(1);\n\n    // If this is the third nested call (e.g. panics == 2, this is 0-indexed),\n    // the panic hook probably triggered the last panic, otherwise the\n    // double-panic check would have aborted the process. In this case abort the\n    // process real quickly as we don't want to try calling it again as it'll\n    // probably just panic again.\n    if panics > 2 {\n        util::dumb_print(format_args!(\"thread panicked while processing \\\n                                       panic. aborting.\\n\"));\n        unsafe { intrinsics::abort() }\n    }\n\n    unsafe {\n        let info = PanicInfo {\n            payload: &*msg,\n            location: Location {\n                file,\n                line,\n                col,\n            },\n        };\n        HOOK_LOCK.read();\n        match HOOK {\n            Hook::Default => default_hook(&info),\n            Hook::Custom(ptr) => (*ptr)(&info),\n        }\n        HOOK_LOCK.read_unlock();\n    }\n\n    if panics > 1 {\n        // If a thread panics while it's already unwinding then we\n        // have limited options. Currently our preference is to\n        // just abort. In the future we may consider resuming\n        // unwinding or otherwise exiting the thread cleanly.\n        util::dumb_print(format_args!(\"thread panicked while panicking. \\\n                                       aborting.\\n\"));\n        unsafe { intrinsics::abort() }\n    }\n\n    rust_panic(msg)\n}\n\n/// Shim around rust_panic. Called by resume_unwind.\npub fn update_count_then_panic(msg: Box<Any + Send>) -> ! {\n    update_panic_count(1);\n    rust_panic(msg)\n}\n\n/// A private no-mangle function on which to slap yer breakpoints.\n#[no_mangle]\n#[allow(private_no_mangle_fns)] // yes we get it, but we like breakpoints\npub fn rust_panic(msg: Box<Any + Send>) -> ! {\n    let code = unsafe {\n        let obj = mem::transmute::<_, raw::TraitObject>(msg);\n        __rust_start_panic(obj.data as usize, obj.vtable as usize)\n    };\n    rtabort!(\"failed to initiate panic, error {}\", code)\n}\n","// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! A pointer type for heap allocation.\n//!\n//! `Box<T>`, casually referred to as a 'box', provides the simplest form of\n//! heap allocation in Rust. Boxes provide ownership for this allocation, and\n//! drop their contents when they go out of scope.\n//!\n//! # Examples\n//!\n//! Creating a box:\n//!\n//! ```\n//! let x = Box::new(5);\n//! ```\n//!\n//! Creating a recursive data structure:\n//!\n//! ```\n//! #[derive(Debug)]\n//! enum List<T> {\n//!     Cons(T, Box<List<T>>),\n//!     Nil,\n//! }\n//!\n//! fn main() {\n//!     let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n//!     println!(\"{:?}\", list);\n//! }\n//! ```\n//!\n//! This will print `Cons(1, Cons(2, Nil))`.\n//!\n//! Recursive structures must be boxed, because if the definition of `Cons`\n//! looked like this:\n//!\n//! ```compile_fail,E0072\n//! # enum List<T> {\n//! Cons(T, List<T>),\n//! # }\n//! ```\n//!\n//! It wouldn't work. This is because the size of a `List` depends on how many\n//! elements are in the list, and so we don't know how much memory to allocate\n//! for a `Cons`. By introducing a `Box`, which has a defined size, we know how\n//! big `Cons` needs to be.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse heap::{Heap, Layout, Alloc};\nuse raw_vec::RawVec;\n\nuse core::any::Any;\nuse core::borrow;\nuse core::cmp::Ordering;\nuse core::fmt;\nuse core::hash::{self, Hash, Hasher};\nuse core::iter::FusedIterator;\nuse core::marker::{self, Unsize};\nuse core::mem;\nuse core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\nuse core::ops::{BoxPlace, Boxed, InPlace, Place, Placer};\nuse core::ptr::{self, NonNull, Unique};\nuse core::convert::From;\nuse str::from_boxed_utf8_unchecked;\n\n/// A value that represents the heap. This is the default place that the `box`\n/// keyword allocates into when no place is supplied.\n///\n/// The following two examples are equivalent:\n///\n/// ```\n/// #![feature(box_heap)]\n///\n/// #![feature(box_syntax, placement_in_syntax)]\n/// use std::boxed::HEAP;\n///\n/// fn main() {\n///     let foo: Box<i32> = in HEAP { 5 };\n///     let foo = box 5;\n/// }\n/// ```\n#[unstable(feature = \"box_heap\",\n           reason = \"may be renamed; uncertain about custom allocator design\",\n           issue = \"27779\")]\npub const HEAP: ExchangeHeapSingleton = ExchangeHeapSingleton { _force_singleton: () };\n\n/// This the singleton type used solely for `boxed::HEAP`.\n#[unstable(feature = \"box_heap\",\n           reason = \"may be renamed; uncertain about custom allocator design\",\n           issue = \"27779\")]\n#[allow(missing_debug_implementations)]\n#[derive(Copy, Clone)]\npub struct ExchangeHeapSingleton {\n    _force_singleton: (),\n}\n\n/// A pointer type for heap allocation.\n///\n/// See the [module-level documentation](../../std/boxed/index.html) for more.\n#[lang = \"owned_box\"]\n#[fundamental]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Box<T: ?Sized>(Unique<T>);\n\n/// `IntermediateBox` represents uninitialized backing storage for `Box`.\n///\n/// FIXME (pnkfelix): Ideally we would just reuse `Box<T>` instead of\n/// introducing a separate `IntermediateBox<T>`; but then you hit\n/// issues when you e.g. attempt to destructure an instance of `Box`,\n/// since it is a lang item and so it gets special handling by the\n/// compiler.  Easier just to make this parallel type for now.\n///\n/// FIXME (pnkfelix): Currently the `box` protocol only supports\n/// creating instances of sized types. This IntermediateBox is\n/// designed to be forward-compatible with a future protocol that\n/// supports creating instances of unsized types; that is why the type\n/// parameter has the `?Sized` generalization marker, and is also why\n/// this carries an explicit size. However, it probably does not need\n/// to carry the explicit alignment; that is just a work-around for\n/// the fact that the `align_of` intrinsic currently requires the\n/// input type to be Sized (which I do not think is strictly\n/// necessary).\n#[unstable(feature = \"placement_in\",\n           reason = \"placement box design is still being worked out.\",\n           issue = \"27779\")]\n#[allow(missing_debug_implementations)]\npub struct IntermediateBox<T: ?Sized> {\n    ptr: *mut u8,\n    layout: Layout,\n    marker: marker::PhantomData<*mut T>,\n}\n\n#[unstable(feature = \"placement_in\",\n           reason = \"placement box design is still being worked out.\",\n           issue = \"27779\")]\nunsafe impl<T> Place<T> for IntermediateBox<T> {\n    fn pointer(&mut self) -> *mut T {\n        self.ptr as *mut T\n    }\n}\n\nunsafe fn finalize<T>(b: IntermediateBox<T>) -> Box<T> {\n    let p = b.ptr as *mut T;\n    mem::forget(b);\n    Box::from_raw(p)\n}\n\nfn make_place<T>() -> IntermediateBox<T> {\n    let layout = Layout::new::<T>();\n\n    let p = if layout.size() == 0 {\n        mem::align_of::<T>() as *mut u8\n    } else {\n        unsafe {\n            Heap.alloc(layout.clone()).unwrap_or_else(|err| {\n                Heap.oom(err)\n            })\n        }\n    };\n\n    IntermediateBox {\n        ptr: p,\n        layout,\n        marker: marker::PhantomData,\n    }\n}\n\n#[unstable(feature = \"placement_in\",\n           reason = \"placement box design is still being worked out.\",\n           issue = \"27779\")]\nimpl<T> BoxPlace<T> for IntermediateBox<T> {\n    fn make_place() -> IntermediateBox<T> {\n        make_place()\n    }\n}\n\n#[unstable(feature = \"placement_in\",\n           reason = \"placement box design is still being worked out.\",\n           issue = \"27779\")]\nimpl<T> InPlace<T> for IntermediateBox<T> {\n    type Owner = Box<T>;\n    unsafe fn finalize(self) -> Box<T> {\n        finalize(self)\n    }\n}\n\n#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\nimpl<T> Boxed for Box<T> {\n    type Data = T;\n    type Place = IntermediateBox<T>;\n    unsafe fn finalize(b: IntermediateBox<T>) -> Box<T> {\n        finalize(b)\n    }\n}\n\n#[unstable(feature = \"placement_in\",\n           reason = \"placement box design is still being worked out.\",\n           issue = \"27779\")]\nimpl<T> Placer<T> for ExchangeHeapSingleton {\n    type Place = IntermediateBox<T>;\n\n    fn make_place(self) -> IntermediateBox<T> {\n        make_place()\n    }\n}\n\n#[unstable(feature = \"placement_in\",\n           reason = \"placement box design is still being worked out.\",\n           issue = \"27779\")]\nimpl<T: ?Sized> Drop for IntermediateBox<T> {\n    fn drop(&mut self) {\n        if self.layout.size() > 0 {\n            unsafe {\n                Heap.dealloc(self.ptr, self.layout.clone())\n            }\n        }\n    }\n}\n\nimpl<T> Box<T> {\n    /// Allocates memory on the heap and then places `x` into it.\n    ///\n    /// This doesn't actually allocate if `T` is zero-sized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let five = Box::new(5);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline(always)]\n    pub fn new(x: T) -> Box<T> {\n        box x\n    }\n}\n\nimpl<T: ?Sized> Box<T> {\n    /// Constructs a box from a raw pointer.\n    ///\n    /// After calling this function, the raw pointer is owned by the\n    /// resulting `Box`. Specifically, the `Box` destructor will call\n    /// the destructor of `T` and free the allocated memory. Since the\n    /// way `Box` allocates and releases memory is unspecified, the\n    /// only valid pointer to pass to this function is the one taken\n    /// from another `Box` via the [`Box::into_raw`] function.\n    ///\n    /// This function is unsafe because improper use may lead to\n    /// memory problems. For example, a double-free may occur if the\n    /// function is called twice on the same raw pointer.\n    ///\n    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new(5);\n    /// let ptr = Box::into_raw(x);\n    /// let x = unsafe { Box::from_raw(ptr) };\n    /// ```\n    #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n    #[inline]\n    pub unsafe fn from_raw(raw: *mut T) -> Self {\n        Box(Unique::new_unchecked(raw))\n    }\n\n    /// Consumes the `Box`, returning the wrapped raw pointer.\n    ///\n    /// After calling this function, the caller is responsible for the\n    /// memory previously managed by the `Box`. In particular, the\n    /// caller should properly destroy `T` and release the memory. The\n    /// proper way to do so is to convert the raw pointer back into a\n    /// `Box` with the [`Box::from_raw`] function.\n    ///\n    /// Note: this is an associated function, which means that you have\n    /// to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n    /// is so that there is no conflict with a method on the inner type.\n    ///\n    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new(5);\n    /// let ptr = Box::into_raw(x);\n    /// ```\n    #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n    #[inline]\n    pub fn into_raw(b: Box<T>) -> *mut T {\n        Box::into_raw_non_null(b).as_ptr()\n    }\n\n    /// Consumes the `Box`, returning the wrapped pointer as `NonNull<T>`.\n    ///\n    /// After calling this function, the caller is responsible for the\n    /// memory previously managed by the `Box`. In particular, the\n    /// caller should properly destroy `T` and release the memory. The\n    /// proper way to do so is to convert the `NonNull<T>` pointer\n    /// into a raw pointer and back into a `Box` with the [`Box::from_raw`]\n    /// function.\n    ///\n    /// Note: this is an associated function, which means that you have\n    /// to call it as `Box::into_raw_non_null(b)`\n    /// instead of `b.into_raw_non_null()`. This\n    /// is so that there is no conflict with a method on the inner type.\n    ///\n    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(box_into_raw_non_null)]\n    ///\n    /// fn main() {\n    ///     let x = Box::new(5);\n    ///     let ptr = Box::into_raw_non_null(x);\n    /// }\n    /// ```\n    #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]\n    #[inline]\n    pub fn into_raw_non_null(b: Box<T>) -> NonNull<T> {\n        Box::into_unique(b).into()\n    }\n\n    #[unstable(feature = \"ptr_internals\", issue = \"0\", reason = \"use into_raw_non_null instead\")]\n    #[inline]\n    pub fn into_unique(b: Box<T>) -> Unique<T> {\n        let unique = b.0;\n        mem::forget(b);\n        unique\n    }\n\n    /// Consumes and leaks the `Box`, returning a mutable reference,\n    /// `&'a mut T`. Here, the lifetime `'a` may be chosen to be `'static`.\n    ///\n    /// This function is mainly useful for data that lives for the remainder of\n    /// the program's life. Dropping the returned reference will cause a memory\n    /// leak. If this is not acceptable, the reference should first be wrapped\n    /// with the [`Box::from_raw`] function producing a `Box`. This `Box` can\n    /// then be dropped which will properly destroy `T` and release the\n    /// allocated memory.\n    ///\n    /// Note: this is an associated function, which means that you have\n    /// to call it as `Box::leak(b)` instead of `b.leak()`. This\n    /// is so that there is no conflict with a method on the inner type.\n    ///\n    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n    ///\n    /// # Examples\n    ///\n    /// Simple usage:\n    ///\n    /// ```\n    /// #![feature(box_leak)]\n    ///\n    /// fn main() {\n    ///     let x = Box::new(41);\n    ///     let static_ref: &'static mut usize = Box::leak(x);\n    ///     *static_ref += 1;\n    ///     assert_eq!(*static_ref, 42);\n    /// }\n    /// ```\n    ///\n    /// Unsized data:\n    ///\n    /// ```\n    /// #![feature(box_leak)]\n    ///\n    /// fn main() {\n    ///     let x = vec![1, 2, 3].into_boxed_slice();\n    ///     let static_ref = Box::leak(x);\n    ///     static_ref[0] = 4;\n    ///     assert_eq!(*static_ref, [4, 2, 3]);\n    /// }\n    /// ```\n    #[unstable(feature = \"box_leak\", reason = \"needs an FCP to stabilize\",\n               issue = \"46179\")]\n    #[inline]\n    pub fn leak<'a>(b: Box<T>) -> &'a mut T\n    where\n        T: 'a // Technically not needed, but kept to be explicit.\n    {\n        unsafe { &mut *Box::into_raw(b) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T: ?Sized> Drop for Box<T> {\n    fn drop(&mut self) {\n        // FIXME: Do nothing, drop is currently performed by compiler.\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Default> Default for Box<T> {\n    /// Creates a `Box<T>`, with the `Default` value for T.\n    fn default() -> Box<T> {\n        box Default::default()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for Box<[T]> {\n    fn default() -> Box<[T]> {\n        Box::<[T; 0]>::new([])\n    }\n}\n\n#[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\nimpl Default for Box<str> {\n    fn default() -> Box<str> {\n        unsafe { from_boxed_utf8_unchecked(Default::default()) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> Clone for Box<T> {\n    /// Returns a new box with a `clone()` of this box's contents.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new(5);\n    /// let y = x.clone();\n    /// ```\n    #[rustfmt_skip]\n    #[inline]\n    fn clone(&self) -> Box<T> {\n        box { (**self).clone() }\n    }\n    /// Copies `source`'s contents into `self` without creating a new allocation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new(5);\n    /// let mut y = Box::new(10);\n    ///\n    /// y.clone_from(&x);\n    ///\n    /// assert_eq!(*y, 5);\n    /// ```\n    #[inline]\n    fn clone_from(&mut self, source: &Box<T>) {\n        (**self).clone_from(&(**source));\n    }\n}\n\n\n#[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\nimpl Clone for Box<str> {\n    fn clone(&self) -> Self {\n        let len = self.len();\n        let buf = RawVec::with_capacity(len);\n        unsafe {\n            ptr::copy_nonoverlapping(self.as_ptr(), buf.ptr(), len);\n            from_boxed_utf8_unchecked(buf.into_box())\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + PartialEq> PartialEq for Box<T> {\n    #[inline]\n    fn eq(&self, other: &Box<T>) -> bool {\n        PartialEq::eq(&**self, &**other)\n    }\n    #[inline]\n    fn ne(&self, other: &Box<T>) -> bool {\n        PartialEq::ne(&**self, &**other)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n        PartialOrd::partial_cmp(&**self, &**other)\n    }\n    #[inline]\n    fn lt(&self, other: &Box<T>) -> bool {\n        PartialOrd::lt(&**self, &**other)\n    }\n    #[inline]\n    fn le(&self, other: &Box<T>) -> bool {\n        PartialOrd::le(&**self, &**other)\n    }\n    #[inline]\n    fn ge(&self, other: &Box<T>) -> bool {\n        PartialOrd::ge(&**self, &**other)\n    }\n    #[inline]\n    fn gt(&self, other: &Box<T>) -> bool {\n        PartialOrd::gt(&**self, &**other)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Ord> Ord for Box<T> {\n    #[inline]\n    fn cmp(&self, other: &Box<T>) -> Ordering {\n        Ord::cmp(&**self, &**other)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Eq> Eq for Box<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Hash> Hash for Box<T> {\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        (**self).hash(state);\n    }\n}\n\n#[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\nimpl<T: ?Sized + Hasher> Hasher for Box<T> {\n    fn finish(&self) -> u64 {\n        (**self).finish()\n    }\n    fn write(&mut self, bytes: &[u8]) {\n        (**self).write(bytes)\n    }\n    fn write_u8(&mut self, i: u8) {\n        (**self).write_u8(i)\n    }\n    fn write_u16(&mut self, i: u16) {\n        (**self).write_u16(i)\n    }\n    fn write_u32(&mut self, i: u32) {\n        (**self).write_u32(i)\n    }\n    fn write_u64(&mut self, i: u64) {\n        (**self).write_u64(i)\n    }\n    fn write_u128(&mut self, i: u128) {\n        (**self).write_u128(i)\n    }\n    fn write_usize(&mut self, i: usize) {\n        (**self).write_usize(i)\n    }\n    fn write_i8(&mut self, i: i8) {\n        (**self).write_i8(i)\n    }\n    fn write_i16(&mut self, i: i16) {\n        (**self).write_i16(i)\n    }\n    fn write_i32(&mut self, i: i32) {\n        (**self).write_i32(i)\n    }\n    fn write_i64(&mut self, i: i64) {\n        (**self).write_i64(i)\n    }\n    fn write_i128(&mut self, i: i128) {\n        (**self).write_i128(i)\n    }\n    fn write_isize(&mut self, i: isize) {\n        (**self).write_isize(i)\n    }\n}\n\n#[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\nimpl<T> From<T> for Box<T> {\n    fn from(t: T) -> Self {\n        Box::new(t)\n    }\n}\n\n#[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\nimpl<'a, T: Copy> From<&'a [T]> for Box<[T]> {\n    fn from(slice: &'a [T]) -> Box<[T]> {\n        let mut boxed = unsafe { RawVec::with_capacity(slice.len()).into_box() };\n        boxed.copy_from_slice(slice);\n        boxed\n    }\n}\n\n#[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\nimpl<'a> From<&'a str> for Box<str> {\n    fn from(s: &'a str) -> Box<str> {\n        unsafe { from_boxed_utf8_unchecked(Box::from(s.as_bytes())) }\n    }\n}\n\n#[stable(feature = \"boxed_str_conv\", since = \"1.19.0\")]\nimpl From<Box<str>> for Box<[u8]> {\n    fn from(s: Box<str>) -> Self {\n        unsafe { Box::from_raw(Box::into_raw(s) as *mut [u8]) }\n    }\n}\n\nimpl Box<Any> {\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    /// Attempt to downcast the box to a concrete type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(value: Box<Any>) {\n    ///     if let Ok(string) = value.downcast::<String>() {\n    ///         println!(\"String ({}): {}\", string.len(), string);\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     let my_string = \"Hello World\".to_string();\n    ///     print_if_string(Box::new(my_string));\n    ///     print_if_string(Box::new(0i8));\n    /// }\n    /// ```\n    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n        if self.is::<T>() {\n            unsafe {\n                let raw: *mut Any = Box::into_raw(self);\n                Ok(Box::from_raw(raw as *mut T))\n            }\n        } else {\n            Err(self)\n        }\n    }\n}\n\nimpl Box<Any + Send> {\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    /// Attempt to downcast the box to a concrete type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(value: Box<Any + Send>) {\n    ///     if let Ok(string) = value.downcast::<String>() {\n    ///         println!(\"String ({}): {}\", string.len(), string);\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     let my_string = \"Hello World\".to_string();\n    ///     print_if_string(Box::new(my_string));\n    ///     print_if_string(Box::new(0i8));\n    /// }\n    /// ```\n    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any + Send>> {\n        <Box<Any>>::downcast(self).map_err(|s| unsafe {\n            // reapply the Send marker\n            Box::from_raw(Box::into_raw(s) as *mut (Any + Send))\n        })\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Display + ?Sized> fmt::Display for Box<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> fmt::Pointer for Box<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // It's not possible to extract the inner Uniq directly from the Box,\n        // instead we cast it to a *const which aliases the Unique\n        let ptr: *const T = &**self;\n        fmt::Pointer::fmt(&ptr, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Deref for Box<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &**self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> DerefMut for Box<T> {\n    fn deref_mut(&mut self) -> &mut T {\n        &mut **self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator + ?Sized> Iterator for Box<I> {\n    type Item = I::Item;\n    fn next(&mut self) -> Option<I::Item> {\n        (**self).next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (**self).size_hint()\n    }\n    fn nth(&mut self, n: usize) -> Option<I::Item> {\n        (**self).nth(n)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n    fn next_back(&mut self) -> Option<I::Item> {\n        (**self).next_back()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {\n    fn len(&self) -> usize {\n        (**self).len()\n    }\n    fn is_empty(&self) -> bool {\n        (**self).is_empty()\n    }\n}\n\n#[unstable(feature = \"fused\", issue = \"35602\")]\nimpl<I: FusedIterator + ?Sized> FusedIterator for Box<I> {}\n\n\n/// `FnBox` is a version of the `FnOnce` intended for use with boxed\n/// closure objects. The idea is that where one would normally store a\n/// `Box<FnOnce()>` in a data structure, you should use\n/// `Box<FnBox()>`. The two traits behave essentially the same, except\n/// that a `FnBox` closure can only be called if it is boxed. (Note\n/// that `FnBox` may be deprecated in the future if `Box<FnOnce()>`\n/// closures become directly usable.)\n///\n/// # Examples\n///\n/// Here is a snippet of code which creates a hashmap full of boxed\n/// once closures and then removes them one by one, calling each\n/// closure as it is removed. Note that the type of the closures\n/// stored in the map is `Box<FnBox() -> i32>` and not `Box<FnOnce()\n/// -> i32>`.\n///\n/// ```\n/// #![feature(fnbox)]\n///\n/// use std::boxed::FnBox;\n/// use std::collections::HashMap;\n///\n/// fn make_map() -> HashMap<i32, Box<FnBox() -> i32>> {\n///     let mut map: HashMap<i32, Box<FnBox() -> i32>> = HashMap::new();\n///     map.insert(1, Box::new(|| 22));\n///     map.insert(2, Box::new(|| 44));\n///     map\n/// }\n///\n/// fn main() {\n///     let mut map = make_map();\n///     for i in &[1, 2] {\n///         let f = map.remove(&i).unwrap();\n///         assert_eq!(f(), i * 22);\n///     }\n/// }\n/// ```\n#[rustc_paren_sugar]\n#[unstable(feature = \"fnbox\",\n           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\npub trait FnBox<A> {\n    type Output;\n\n    fn call_box(self: Box<Self>, args: A) -> Self::Output;\n}\n\n#[unstable(feature = \"fnbox\",\n           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\nimpl<A, F> FnBox<A> for F\n    where F: FnOnce<A>\n{\n    type Output = F::Output;\n\n    fn call_box(self: Box<F>, args: A) -> F::Output {\n        self.call_once(args)\n    }\n}\n\n#[unstable(feature = \"fnbox\",\n           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\nimpl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n    type Output = R;\n\n    extern \"rust-call\" fn call_once(self, args: A) -> R {\n        self.call_box(args)\n    }\n}\n\n#[unstable(feature = \"fnbox\",\n           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\nimpl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + Send + 'a> {\n    type Output = R;\n\n    extern \"rust-call\" fn call_once(self, args: A) -> R {\n        self.call_box(args)\n    }\n}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n\n#[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\nimpl<T: Clone> Clone for Box<[T]> {\n    fn clone(&self) -> Self {\n        let mut new = BoxBuilder {\n            data: RawVec::with_capacity(self.len()),\n            len: 0,\n        };\n\n        let mut target = new.data.ptr();\n\n        for item in self.iter() {\n            unsafe {\n                ptr::write(target, item.clone());\n                target = target.offset(1);\n            };\n\n            new.len += 1;\n        }\n\n        return unsafe { new.into_box() };\n\n        // Helper type for responding to panics correctly.\n        struct BoxBuilder<T> {\n            data: RawVec<T>,\n            len: usize,\n        }\n\n        impl<T> BoxBuilder<T> {\n            unsafe fn into_box(self) -> Box<[T]> {\n                let raw = ptr::read(&self.data);\n                mem::forget(self);\n                raw.into_box()\n            }\n        }\n\n        impl<T> Drop for BoxBuilder<T> {\n            fn drop(&mut self) {\n                let mut data = self.data.ptr();\n                let max = unsafe { data.offset(self.len as isize) };\n\n                while data != max {\n                    unsafe {\n                        ptr::read(data);\n                        data = data.offset(1);\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[stable(feature = \"box_borrow\", since = \"1.1.0\")]\nimpl<T: ?Sized> borrow::Borrow<T> for Box<T> {\n    fn borrow(&self) -> &T {\n        &**self\n    }\n}\n\n#[stable(feature = \"box_borrow\", since = \"1.1.0\")]\nimpl<T: ?Sized> borrow::BorrowMut<T> for Box<T> {\n    fn borrow_mut(&mut self) -> &mut T {\n        &mut **self\n    }\n}\n\n#[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\nimpl<T: ?Sized> AsRef<T> for Box<T> {\n    fn as_ref(&self) -> &T {\n        &**self\n    }\n}\n\n#[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\nimpl<T: ?Sized> AsMut<T> for Box<T> {\n    fn as_mut(&mut self) -> &mut T {\n        &mut **self\n    }\n}\n\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\nimpl<T> Generator for Box<T>\n    where T: Generator + ?Sized\n{\n    type Yield = T::Yield;\n    type Return = T::Return;\n    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n        (**self).resume()\n    }\n}\n","// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! Traits for conversions between types.\n//!\n//! The traits in this module provide a general way to talk about conversions\n//! from one type to another. They follow the standard Rust conventions of\n//! `as`/`into`/`from`.\n//!\n//! Like many traits, these are often used as bounds for generic functions, to\n//! support arguments of multiple types.\n//!\n//! - Implement the `As*` traits for reference-to-reference conversions\n//! - Implement the [`Into`] trait when you want to consume the value in the conversion\n//! - The [`From`] trait is the most flexible, useful for value _and_ reference conversions\n//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`], but allow for the\n//!   conversion to fail\n//!\n//! As a library author, you should prefer implementing [`From<T>`][`From`] or\n//! [`TryFrom<T>`][`TryFrom`] rather than [`Into<U>`][`Into`] or [`TryInto<U>`][`TryInto`],\n//! as [`From`] and [`TryFrom`] provide greater flexibility and offer\n//! equivalent [`Into`] or [`TryInto`] implementations for free, thanks to a\n//! blanket implementation in the standard library.\n//!\n//! # Generic Implementations\n//!\n//! - [`AsRef`] and [`AsMut`] auto-dereference if the inner type is a reference\n//! - [`From`]`<U> for T` implies [`Into`]`<T> for U`\n//! - [`TryFrom`]`<U> for T` implies [`TryInto`]`<T> for U`\n//! - [`From`] and [`Into`] are reflexive, which means that all types can\n//!   `into` themselves and `from` themselves\n//!\n//! See each trait for usage examples.\n//!\n//! [`Into`]: trait.Into.html\n//! [`From`]: trait.From.html\n//! [`TryFrom`]: trait.TryFrom.html\n//! [`TryInto`]: trait.TryInto.html\n//! [`AsRef`]: trait.AsRef.html\n//! [`AsMut`]: trait.AsMut.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse fmt;\n\n/// A type used as the error type for implementations of fallible conversion\n/// traits in cases where conversions cannot actually fail.\n///\n/// Because `Infallible` has no variants, a value of this type can never exist.\n/// It is used only to satisfy trait signatures that expect an error type, and\n/// signals to both the compiler and the user that the error case is impossible.\n#[unstable(feature = \"try_from\", issue = \"33417\")]\n#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub enum Infallible {}\n\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl fmt::Display for Infallible {\n    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n        }\n    }\n}\n/// A cheap reference-to-reference conversion. Used to convert a value to a\n/// reference value within generic code.\n///\n/// `AsRef` is very similar to, but serves a slightly different purpose than,\n/// [`Borrow`].\n///\n/// `AsRef` is to be used when wishing to convert to a reference of another\n/// type.\n/// `Borrow` is more related to the notion of taking the reference. It is\n/// useful when wishing to abstract over the type of reference\n/// (`&T`, `&mut T`) or allow both the referenced and owned type to be treated\n/// in the same manner.\n///\n/// The key difference between the two traits is the intention:\n///\n/// - Use `AsRef` when goal is to simply convert into a reference\n/// - Use `Borrow` when goal is related to writing code that is agnostic to the\n///   type of borrow and if is reference or value\n///\n/// See [the book][book] for a more detailed comparison.\n///\n/// [book]: ../../book/first-edition/borrow-and-asref.html\n/// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n///\n/// **Note: this trait must not fail**. If the conversion can fail, use a\n/// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n///\n/// [`Option<T>`]: ../../std/option/enum.Option.html\n/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n///\n/// # Generic Implementations\n///\n/// - `AsRef` auto-dereferences if the inner type is a reference or a mutable\n///   reference (e.g.: `foo.as_ref()` will work the same if `foo` has type\n///   `&mut Foo` or `&&mut Foo`)\n///\n/// # Examples\n///\n/// Both [`String`] and `&str` implement `AsRef<str>`:\n///\n/// [`String`]: ../../std/string/struct.String.html\n///\n/// ```\n/// fn is_hello<T: AsRef<str>>(s: T) {\n///    assert_eq!(\"hello\", s.as_ref());\n/// }\n///\n/// let s = \"hello\";\n/// is_hello(s);\n///\n/// let s = \"hello\".to_string();\n/// is_hello(s);\n/// ```\n///\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait AsRef<T: ?Sized> {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn as_ref(&self) -> &T;\n}\n\n/// A cheap, mutable reference-to-mutable reference conversion.\n///\n/// This trait is similar to `AsRef` but used for converting between mutable\n/// references.\n///\n/// **Note: this trait must not fail**. If the conversion can fail, use a\n/// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n///\n/// [`Option<T>`]: ../../std/option/enum.Option.html\n/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n///\n/// # Generic Implementations\n///\n/// - `AsMut` auto-dereferences if the inner type is a reference or a mutable\n///   reference (e.g.: `foo.as_ref()` will work the same if `foo` has type\n///   `&mut Foo` or `&&mut Foo`)\n///\n/// # Examples\n///\n/// [`Box<T>`] implements `AsMut<T>`:\n///\n/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n///\n/// ```\n/// fn add_one<T: AsMut<u64>>(num: &mut T) {\n///     *num.as_mut() += 1;\n/// }\n///\n/// let mut boxed_num = Box::new(0);\n/// add_one(&mut boxed_num);\n/// assert_eq!(*boxed_num, 1);\n/// ```\n///\n///\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait AsMut<T: ?Sized> {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn as_mut(&mut self) -> &mut T;\n}\n\n/// A conversion that consumes `self`, which may or may not be expensive. The\n/// reciprocal of [`From`][From].\n///\n/// **Note: this trait must not fail**. If the conversion can fail, use\n/// [`TryInto`] or a dedicated method which returns an [`Option<T>`] or a\n/// [`Result<T, E>`].\n///\n/// Library authors should not directly implement this trait, but should prefer\n/// implementing the [`From`][From] trait, which offers greater flexibility and\n/// provides an equivalent `Into` implementation for free, thanks to a blanket\n/// implementation in the standard library.\n///\n/// # Generic Implementations\n///\n/// - [`From<T>`][From]` for U` implies `Into<U> for T`\n/// - [`into`] is reflexive, which means that `Into<T> for T` is implemented\n///\n/// # Implementing `Into`\n///\n/// There is one exception to implementing `Into`, and it's kind of esoteric.\n/// If the destination type is not part of the current crate, and it uses a\n/// generic variable, then you can't implement `From` directly.  For example,\n/// take this crate:\n///\n/// ```compile_fail\n/// struct Wrapper<T>(Vec<T>);\n/// impl<T> From<Wrapper<T>> for Vec<T> {\n///     fn from(w: Wrapper<T>) -> Vec<T> {\n///         w.0\n///     }\n/// }\n/// ```\n///\n/// To fix this, you can implement `Into` directly:\n///\n/// ```\n/// struct Wrapper<T>(Vec<T>);\n/// impl<T> Into<Vec<T>> for Wrapper<T> {\n///     fn into(self) -> Vec<T> {\n///         self.0\n///     }\n/// }\n/// ```\n///\n/// This won't always allow the conversion: for example, `try!` and `?`\n/// always use `From`. However, in most cases, people use `Into` to do the\n/// conversions, and this will allow that.\n///\n/// In almost all cases, you should try to implement `From`, then fall back\n/// to `Into` if `From` can't be implemented.\n///\n/// # Examples\n///\n/// [`String`] implements `Into<Vec<u8>>`:\n///\n/// ```\n/// fn is_hello<T: Into<Vec<u8>>>(s: T) {\n///    let bytes = b\"hello\".to_vec();\n///    assert_eq!(bytes, s.into());\n/// }\n///\n/// let s = \"hello\".to_string();\n/// is_hello(s);\n/// ```\n///\n/// [`TryInto`]: trait.TryInto.html\n/// [`Option<T>`]: ../../std/option/enum.Option.html\n/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [From]: trait.From.html\n/// [`into`]: trait.Into.html#tymethod.into\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Into<T>: Sized {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn into(self) -> T;\n}\n\n/// Simple and safe type conversions in to `Self`. It is the reciprocal of\n/// `Into`.\n///\n/// This trait is useful when performing error handling as described by\n/// [the book][book] and is closely related to the `?` operator.\n///\n/// When constructing a function that is capable of failing the return type\n/// will generally be of the form `Result<T, E>`.\n///\n/// The `From` trait allows for simplification of error handling by providing a\n/// means of returning a single error type that encapsulates numerous possible\n/// erroneous situations.\n///\n/// This trait is not limited to error handling, rather the general case for\n/// this trait would be in any type conversions to have an explicit definition\n/// of how they are performed.\n///\n/// **Note: this trait must not fail**. If the conversion can fail, use\n/// [`TryFrom`] or a dedicated method which returns an [`Option<T>`] or a\n/// [`Result<T, E>`].\n///\n/// # Generic Implementations\n///\n/// - `From<T> for U` implies [`Into<U>`]` for T`\n/// - [`from`] is reflexive, which means that `From<T> for T` is implemented\n///\n/// # Examples\n///\n/// [`String`] implements `From<&str>`:\n///\n/// ```\n/// let string = \"hello\".to_string();\n/// let other_string = String::from(\"hello\");\n///\n/// assert_eq!(string, other_string);\n/// ```\n///\n/// An example usage for error handling:\n///\n/// ```\n/// use std::io::{self, Read};\n/// use std::num;\n///\n/// enum CliError {\n///     IoError(io::Error),\n///     ParseError(num::ParseIntError),\n/// }\n///\n/// impl From<io::Error> for CliError {\n///     fn from(error: io::Error) -> Self {\n///         CliError::IoError(error)\n///     }\n/// }\n///\n/// impl From<num::ParseIntError> for CliError {\n///     fn from(error: num::ParseIntError) -> Self {\n///         CliError::ParseError(error)\n///     }\n/// }\n///\n/// fn open_and_parse_file(file_name: &str) -> Result<i32, CliError> {\n///     let mut file = std::fs::File::open(\"test\")?;\n///     let mut contents = String::new();\n///     file.read_to_string(&mut contents)?;\n///     let num: i32 = contents.trim().parse()?;\n///     Ok(num)\n/// }\n/// ```\n///\n/// [`TryFrom`]: trait.TryFrom.html\n/// [`Option<T>`]: ../../std/option/enum.Option.html\n/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [`Into<U>`]: trait.Into.html\n/// [`from`]: trait.From.html#tymethod.from\n/// [book]: ../../book/first-edition/error-handling.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait From<T>: Sized {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn from(_: T) -> Self;\n}\n\n/// An attempted conversion that consumes `self`, which may or may not be\n/// expensive.\n///\n/// Library authors should not directly implement this trait, but should prefer\n/// implementing the [`TryFrom`] trait, which offers greater flexibility and\n/// provides an equivalent `TryInto` implementation for free, thanks to a\n/// blanket implementation in the standard library. For more information on this,\n/// see the documentation for [`Into`].\n///\n/// [`TryFrom`]: trait.TryFrom.html\n/// [`Into`]: trait.Into.html\n#[unstable(feature = \"try_from\", issue = \"33417\")]\npub trait TryInto<T>: Sized {\n    /// The type returned in the event of a conversion error.\n    type Error;\n\n    /// Performs the conversion.\n    fn try_into(self) -> Result<T, Self::Error>;\n}\n\n/// Attempt to construct `Self` via a conversion.\n#[unstable(feature = \"try_from\", issue = \"33417\")]\npub trait TryFrom<T>: Sized {\n    /// The type returned in the event of a conversion error.\n    type Error;\n\n    /// Performs the conversion.\n    fn try_from(value: T) -> Result<Self, Self::Error>;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// GENERIC IMPLS\n////////////////////////////////////////////////////////////////////////////////\n\n// As lifts over &\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a T where T: AsRef<U>\n{\n    fn as_ref(&self) -> &U {\n        <T as AsRef<U>>::as_ref(*self)\n    }\n}\n\n// As lifts over &mut\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U>\n{\n    fn as_ref(&self) -> &U {\n        <T as AsRef<U>>::as_ref(*self)\n    }\n}\n\n// FIXME (#23442): replace the above impls for &/&mut with the following more general one:\n// // As lifts over Deref\n// impl<D: ?Sized + Deref, U: ?Sized> AsRef<U> for D where D::Target: AsRef<U> {\n//     fn as_ref(&self) -> &U {\n//         self.deref().as_ref()\n//     }\n// }\n\n// AsMut lifts over &mut\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U>\n{\n    fn as_mut(&mut self) -> &mut U {\n        (*self).as_mut()\n    }\n}\n\n// FIXME (#23442): replace the above impl for &mut with the following more general one:\n// // AsMut lifts over DerefMut\n// impl<D: ?Sized + Deref, U: ?Sized> AsMut<U> for D where D::Target: AsMut<U> {\n//     fn as_mut(&mut self) -> &mut U {\n//         self.deref_mut().as_mut()\n//     }\n// }\n\n// From implies Into\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, U> Into<U> for T where U: From<T>\n{\n    fn into(self) -> U {\n        U::from(self)\n    }\n}\n\n// From (and thus Into) is reflexive\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> From<T> for T {\n    fn from(t: T) -> T { t }\n}\n\n\n// TryFrom implies TryInto\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl<T, U> TryInto<U> for T where U: TryFrom<T>\n{\n    type Error = U::Error;\n\n    fn try_into(self) -> Result<U, U::Error> {\n        U::try_from(self)\n    }\n}\n\n// Infallible conversions are semantically equivalent to fallible conversions\n// with an uninhabited error type.\n#[unstable(feature = \"try_from\", issue = \"33417\")]\nimpl<T, U> TryFrom<U> for T where T: From<U> {\n    type Error = Infallible;\n\n    fn try_from(value: U) -> Result<Self, Self::Error> {\n        Ok(T::from(value))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// CONCRETE IMPLS\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsRef<[T]> for [T] {\n    fn as_ref(&self) -> &[T] {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsMut<[T]> for [T] {\n    fn as_mut(&mut self) -> &mut [T] {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<str> for str {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        self\n    }\n}\n","// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\nuse error;\nuse fmt;\nuse result;\nuse sys;\nuse convert::From;\n\n/// A specialized [`Result`](../result/enum.Result.html) type for I/O\n/// operations.\n///\n/// This type is broadly used across [`std::io`] for any operation which may\n/// produce an error.\n///\n/// This typedef is generally used to avoid writing out [`io::Error`] directly and\n/// is otherwise a direct mapping to [`Result`].\n///\n/// While usual Rust style is to import types directly, aliases of [`Result`]\n/// often are not, to make it easier to distinguish between them. [`Result`] is\n/// generally assumed to be [`std::result::Result`][`Result`], and so users of this alias\n/// will generally use `io::Result` instead of shadowing the prelude's import\n/// of [`std::result::Result`][`Result`].\n///\n/// [`std::io`]: ../io/index.html\n/// [`io::Error`]: ../io/struct.Error.html\n/// [`Result`]: ../result/enum.Result.html\n///\n/// # Examples\n///\n/// A convenience function that bubbles an `io::Result` to its caller:\n///\n/// ```\n/// use std::io;\n///\n/// fn get_string() -> io::Result<String> {\n///     let mut buffer = String::new();\n///\n///     io::stdin().read_line(&mut buffer)?;\n///\n///     Ok(buffer)\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result<T> = result::Result<T, Error>;\n\n/// The error type for I/O operations of the [`Read`], [`Write`], [`Seek`], and\n/// associated traits.\n///\n/// Errors mostly originate from the underlying OS, but custom instances of\n/// `Error` can be created with crafted error messages and a particular value of\n/// [`ErrorKind`].\n///\n/// [`Read`]: ../io/trait.Read.html\n/// [`Write`]: ../io/trait.Write.html\n/// [`Seek`]: ../io/trait.Seek.html\n/// [`ErrorKind`]: enum.ErrorKind.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Error {\n    repr: Repr,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&self.repr, f)\n    }\n}\n\nenum Repr {\n    Os(i32),\n    Simple(ErrorKind),\n    Custom(Box<Custom>),\n}\n\n#[derive(Debug)]\nstruct Custom {\n    kind: ErrorKind,\n    error: Box<error::Error+Send+Sync>,\n}\n\n/// A list specifying general categories of I/O error.\n///\n/// This list is intended to grow over time and it is not recommended to\n/// exhaustively match against it.\n///\n/// It is used with the [`io::Error`] type.\n///\n/// [`io::Error`]: struct.Error.html\n#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\npub enum ErrorKind {\n    /// An entity was not found, often a file.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    NotFound,\n    /// The operation lacked the necessary privileges to complete.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    PermissionDenied,\n    /// The connection was refused by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionRefused,\n    /// The connection was reset by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionReset,\n    /// The connection was aborted (terminated) by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionAborted,\n    /// The network operation failed because it was not connected yet.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    NotConnected,\n    /// A socket address could not be bound because the address is already in\n    /// use elsewhere.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AddrInUse,\n    /// A nonexistent interface was requested or the requested address was not\n    /// local.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AddrNotAvailable,\n    /// The operation failed because a pipe was closed.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    BrokenPipe,\n    /// An entity already exists, often a file.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AlreadyExists,\n    /// The operation needs to block to complete, but the blocking operation was\n    /// requested to not occur.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    WouldBlock,\n    /// A parameter was incorrect.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    InvalidInput,\n    /// Data not valid for the operation were encountered.\n    ///\n    /// Unlike [`InvalidInput`], this typically means that the operation\n    /// parameters were valid, however the error was caused by malformed\n    /// input data.\n    ///\n    /// For example, a function that reads a file into a string will error with\n    /// `InvalidData` if the file's contents are not valid UTF-8.\n    ///\n    /// [`InvalidInput`]: #variant.InvalidInput\n    #[stable(feature = \"io_invalid_data\", since = \"1.2.0\")]\n    InvalidData,\n    /// The I/O operation's timeout expired, causing it to be canceled.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    TimedOut,\n    /// An error returned when an operation could not be completed because a\n    /// call to [`write`] returned [`Ok(0)`].\n    ///\n    /// This typically means that an operation could only succeed if it wrote a\n    /// particular number of bytes but only a smaller number of bytes could be\n    /// written.\n    ///\n    /// [`write`]: ../../std/io/trait.Write.html#tymethod.write\n    /// [`Ok(0)`]: ../../std/io/type.Result.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    WriteZero,\n    /// This operation was interrupted.\n    ///\n    /// Interrupted operations can typically be retried.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Interrupted,\n    /// Any I/O error not part of this list.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Other,\n\n    /// An error returned when an operation could not be completed because an\n    /// \"end of file\" was reached prematurely.\n    ///\n    /// This typically means that an operation could only succeed if it read a\n    /// particular number of bytes but only a smaller number of bytes could be\n    /// read.\n    #[stable(feature = \"read_exact\", since = \"1.6.0\")]\n    UnexpectedEof,\n\n    /// A marker variant that tells the compiler that users of this enum cannot\n    /// match it exhaustively.\n    #[unstable(feature = \"io_error_internals\",\n               reason = \"better expressed through extensible enums that this \\\n                         enum cannot be exhaustively matched against\",\n               issue = \"0\")]\n    #[doc(hidden)]\n    __Nonexhaustive,\n}\n\nimpl ErrorKind {\n    fn as_str(&self) -> &'static str {\n        match *self {\n            ErrorKind::NotFound => \"entity not found\",\n            ErrorKind::PermissionDenied => \"permission denied\",\n            ErrorKind::ConnectionRefused => \"connection refused\",\n            ErrorKind::ConnectionReset => \"connection reset\",\n            ErrorKind::ConnectionAborted => \"connection aborted\",\n            ErrorKind::NotConnected => \"not connected\",\n            ErrorKind::AddrInUse => \"address in use\",\n            ErrorKind::AddrNotAvailable => \"address not available\",\n            ErrorKind::BrokenPipe => \"broken pipe\",\n            ErrorKind::AlreadyExists => \"entity already exists\",\n            ErrorKind::WouldBlock => \"operation would block\",\n            ErrorKind::InvalidInput => \"invalid input parameter\",\n            ErrorKind::InvalidData => \"invalid data\",\n            ErrorKind::TimedOut => \"timed out\",\n            ErrorKind::WriteZero => \"write zero\",\n            ErrorKind::Interrupted => \"operation interrupted\",\n            ErrorKind::Other => \"other os error\",\n            ErrorKind::UnexpectedEof => \"unexpected end of file\",\n            ErrorKind::__Nonexhaustive => unreachable!()\n        }\n    }\n}\n\n/// Intended for use for errors not exposed to the user, where allocating onto\n/// the heap (for normal construction via Error::new) is too costly.\n#[stable(feature = \"io_error_from_errorkind\", since = \"1.14.0\")]\nimpl From<ErrorKind> for Error {\n    #[inline]\n    fn from(kind: ErrorKind) -> Error {\n        Error {\n            repr: Repr::Simple(kind)\n        }\n    }\n}\n\nimpl Error {\n    /// Creates a new I/O error from a known kind of error as well as an\n    /// arbitrary error payload.\n    ///\n    /// This function is used to generically create I/O errors which do not\n    /// originate from the OS itself. The `error` argument is an arbitrary\n    /// payload which will be contained in this `Error`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// // errors can be created from strings\n    /// let custom_error = Error::new(ErrorKind::Other, \"oh no!\");\n    ///\n    /// // errors can also be created from other errors\n    /// let custom_error2 = Error::new(ErrorKind::Interrupted, custom_error);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<E>(kind: ErrorKind, error: E) -> Error\n        where E: Into<Box<error::Error+Send+Sync>>\n    {\n        Self::_new(kind, error.into())\n    }\n\n    fn _new(kind: ErrorKind, error: Box<error::Error+Send+Sync>) -> Error {\n        Error {\n            repr: Repr::Custom(Box::new(Custom {\n                kind,\n                error,\n            }))\n        }\n    }\n\n    /// Returns an error representing the last OS error which occurred.\n    ///\n    /// This function reads the value of `errno` for the target platform (e.g.\n    /// `GetLastError` on Windows) and will return a corresponding instance of\n    /// `Error` for the error code.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Error;\n    ///\n    /// println!(\"last OS error: {:?}\", Error::last_os_error());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn last_os_error() -> Error {\n        Error::from_raw_os_error(sys::os::errno() as i32)\n    }\n\n    /// Creates a new instance of an `Error` from a particular OS error code.\n    ///\n    /// # Examples\n    ///\n    /// On Linux:\n    ///\n    /// ```\n    /// # if cfg!(target_os = \"linux\") {\n    /// use std::io;\n    ///\n    /// let error = io::Error::from_raw_os_error(98);\n    /// assert_eq!(error.kind(), io::ErrorKind::AddrInUse);\n    /// # }\n    /// ```\n    ///\n    /// On Windows:\n    ///\n    /// ```\n    /// # if cfg!(windows) {\n    /// use std::io;\n    ///\n    /// let error = io::Error::from_raw_os_error(10048);\n    /// assert_eq!(error.kind(), io::ErrorKind::AddrInUse);\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_raw_os_error(code: i32) -> Error {\n        Error { repr: Repr::Os(code) }\n    }\n\n    /// Returns the OS error that this error represents (if any).\n    ///\n    /// If this `Error` was constructed via `last_os_error` or\n    /// `from_raw_os_error`, then this function will return `Some`, otherwise\n    /// it will return `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_os_error(err: &Error) {\n    ///     if let Some(raw_os_err) = err.raw_os_error() {\n    ///         println!(\"raw OS error: {:?}\", raw_os_err);\n    ///     } else {\n    ///         println!(\"Not an OS error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"raw OS error: ...\".\n    ///     print_os_error(&Error::last_os_error());\n    ///     // Will print \"Not an OS error\".\n    ///     print_os_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn raw_os_error(&self) -> Option<i32> {\n        match self.repr {\n            Repr::Os(i) => Some(i),\n            Repr::Custom(..) => None,\n            Repr::Simple(..) => None,\n        }\n    }\n\n    /// Returns a reference to the inner error wrapped by this error (if any).\n    ///\n    /// If this `Error` was constructed via `new` then this function will\n    /// return `Some`, otherwise it will return `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: &Error) {\n    ///     if let Some(inner_err) = err.get_ref() {\n    ///         println!(\"Inner error: {:?}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(&Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    pub fn get_ref(&self) -> Option<&(error::Error+Send+Sync+'static)> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::Custom(ref c) => Some(&*c.error),\n        }\n    }\n\n    /// Returns a mutable reference to the inner error wrapped by this error\n    /// (if any).\n    ///\n    /// If this `Error` was constructed via `new` then this function will\n    /// return `Some`, otherwise it will return `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    /// use std::{error, fmt};\n    /// use std::fmt::Display;\n    ///\n    /// #[derive(Debug)]\n    /// struct MyError {\n    ///     v: String,\n    /// }\n    ///\n    /// impl MyError {\n    ///     fn new() -> MyError {\n    ///         MyError {\n    ///             v: \"oh no!\".to_string()\n    ///         }\n    ///     }\n    ///\n    ///     fn change_message(&mut self, new_message: &str) {\n    ///         self.v = new_message.to_string();\n    ///     }\n    /// }\n    ///\n    /// impl error::Error for MyError {\n    ///     fn description(&self) -> &str { &self.v }\n    /// }\n    ///\n    /// impl Display for MyError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    ///         write!(f, \"MyError: {}\", &self.v)\n    ///     }\n    /// }\n    ///\n    /// fn change_error(mut err: Error) -> Error {\n    ///     if let Some(inner_err) = err.get_mut() {\n    ///         inner_err.downcast_mut::<MyError>().unwrap().change_message(\"I've been changed!\");\n    ///     }\n    ///     err\n    /// }\n    ///\n    /// fn print_error(err: &Error) {\n    ///     if let Some(inner_err) = err.get_ref() {\n    ///         println!(\"Inner error: {}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(&change_error(Error::last_os_error()));\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(&change_error(Error::new(ErrorKind::Other, MyError::new())));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    pub fn get_mut(&mut self) -> Option<&mut (error::Error+Send+Sync+'static)> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::Custom(ref mut c) => Some(&mut *c.error),\n        }\n    }\n\n    /// Consumes the `Error`, returning its inner error (if any).\n    ///\n    /// If this `Error` was constructed via `new` then this function will\n    /// return `Some`, otherwise it will return `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: Error) {\n    ///     if let Some(inner_err) = err.into_inner() {\n    ///         println!(\"Inner error: {}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    pub fn into_inner(self) -> Option<Box<error::Error+Send+Sync>> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::Custom(c) => Some(c.error)\n        }\n    }\n\n    /// Returns the corresponding `ErrorKind` for this error.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: Error) {\n    ///     println!(\"{:?}\", err.kind());\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(Error::new(ErrorKind::AddrInUse, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn kind(&self) -> ErrorKind {\n        match self.repr {\n            Repr::Os(code) => sys::decode_error_kind(code),\n            Repr::Custom(ref c) => c.kind,\n            Repr::Simple(kind) => kind,\n        }\n    }\n}\n\nimpl fmt::Debug for Repr {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Repr::Os(code) =>\n                fmt.debug_struct(\"Os\")\n                    .field(\"code\", &code)\n                    .field(\"kind\", &sys::decode_error_kind(code))\n                    .field(\"message\", &sys::os::error_string(code)).finish(),\n            Repr::Custom(ref c) => fmt::Debug::fmt(&c, fmt),\n            Repr::Simple(kind) => fmt.debug_tuple(\"Kind\").field(&kind).finish(),\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Error {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        match self.repr {\n            Repr::Os(code) => {\n                let detail = sys::os::error_string(code);\n                write!(fmt, \"{} (os error {})\", detail, code)\n            }\n            Repr::Custom(ref c) => c.error.fmt(fmt),\n            Repr::Simple(kind) => write!(fmt, \"{}\", kind.as_str()),\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl error::Error for Error {\n    fn description(&self) -> &str {\n        match self.repr {\n            Repr::Os(..) | Repr::Simple(..) => self.kind().as_str(),\n            Repr::Custom(ref c) => c.error.description(),\n        }\n    }\n\n    fn cause(&self) -> Option<&error::Error> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::Custom(ref c) => c.error.cause(),\n        }\n    }\n}\n\nfn _assert_error_is_sync_send() {\n    fn _is_sync_send<T: Sync+Send>() {}\n    _is_sync_send::<Error>();\n}\n\n#[cfg(test)]\nmod test {\n    use super::{Error, ErrorKind, Repr, Custom};\n    use error;\n    use fmt;\n    use sys::os::error_string;\n    use sys::decode_error_kind;\n\n    #[test]\n    fn test_debug_error() {\n        let code = 6;\n        let msg = error_string(code);\n        let kind = decode_error_kind(code);\n        let err = Error {\n            repr: Repr::Custom(box Custom {\n                kind: ErrorKind::InvalidInput,\n                error: box Error {\n                    repr: super::Repr::Os(code)\n                },\n            })\n        };\n        let expected = format!(\n            \"Custom {{ \\\n                kind: InvalidInput, \\\n                error: Os {{ \\\n                    code: {:?}, \\\n                    kind: {:?}, \\\n                    message: {:?} \\\n                }} \\\n            }}\",\n            code, kind, msg\n        );\n        assert_eq!(format!(\"{:?}\", err), expected);\n    }\n\n    #[test]\n    fn test_downcasting() {\n        #[derive(Debug)]\n        struct TestError;\n\n        impl fmt::Display for TestError {\n            fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n                Ok(())\n            }\n        }\n\n        impl error::Error for TestError {\n            fn description(&self) -> &str {\n                \"asdf\"\n            }\n        }\n\n        // we have to call all of these UFCS style right now since method\n        // resolution won't implicitly drop the Send+Sync bounds\n        let mut err = Error::new(ErrorKind::Other, TestError);\n        assert!(err.get_ref().unwrap().is::<TestError>());\n        assert_eq!(\"asdf\", err.get_ref().unwrap().description());\n        assert!(err.get_mut().unwrap().is::<TestError>());\n        let extracted = err.into_inner().unwrap();\n        extracted.downcast::<TestError>().unwrap();\n    }\n}\n","// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! This module implements the `Any` trait, which enables dynamic typing\n//! of any `'static` type through runtime reflection.\n//!\n//! `Any` itself can be used to get a `TypeId`, and has more features when used\n//! as a trait object. As `&Any` (a borrowed trait object), it has the `is` and\n//! `downcast_ref` methods, to test if the contained value is of a given type,\n//! and to get a reference to the inner value as a type. As `&mut Any`, there\n//! is also the `downcast_mut` method, for getting a mutable reference to the\n//! inner value. `Box<Any>` adds the `downcast` method, which attempts to\n//! convert to a `Box<T>`. See the [`Box`] documentation for the full details.\n//!\n//! Note that &Any is limited to testing whether a value is of a specified\n//! concrete type, and cannot be used to test whether a type implements a trait.\n//!\n//! [`Box`]: ../../std/boxed/struct.Box.html\n//!\n//! # Examples\n//!\n//! Consider a situation where we want to log out a value passed to a function.\n//! We know the value we're working on implements Debug, but we don't know its\n//! concrete type.  We want to give special treatment to certain types: in this\n//! case printing out the length of String values prior to their value.\n//! We don't know the concrete type of our value at compile time, so we need to\n//! use runtime reflection instead.\n//!\n//! ```rust\n//! use std::fmt::Debug;\n//! use std::any::Any;\n//!\n//! // Logger function for any type that implements Debug.\n//! fn log<T: Any + Debug>(value: &T) {\n//!     let value_any = value as &Any;\n//!\n//!     // try to convert our value to a String.  If successful, we want to\n//!     // output the String's length as well as its value.  If not, it's a\n//!     // different type: just print it out unadorned.\n//!     match value_any.downcast_ref::<String>() {\n//!         Some(as_string) => {\n//!             println!(\"String ({}): {}\", as_string.len(), as_string);\n//!         }\n//!         None => {\n//!             println!(\"{:?}\", value);\n//!         }\n//!     }\n//! }\n//!\n//! // This function wants to log its parameter out prior to doing work with it.\n//! fn do_work<T: Any + Debug>(value: &T) {\n//!     log(value);\n//!     // ...do some other work\n//! }\n//!\n//! fn main() {\n//!     let my_string = \"Hello World\".to_string();\n//!     do_work(&my_string);\n//!\n//!     let my_i8: i8 = 100;\n//!     do_work(&my_i8);\n//! }\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse fmt;\nuse intrinsics;\n\n///////////////////////////////////////////////////////////////////////////////\n// Any trait\n///////////////////////////////////////////////////////////////////////////////\n\n/// A type to emulate dynamic typing.\n///\n/// Most types implement `Any`. However, any type which contains a non-`'static` reference does not.\n/// See the [module-level documentation][mod] for more details.\n///\n/// [mod]: index.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Any: 'static {\n    /// Gets the `TypeId` of `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(get_type_id)]\n    ///\n    /// use std::any::{Any, TypeId};\n    ///\n    /// fn is_string(s: &Any) -> bool {\n    ///     TypeId::of::<String>() == s.get_type_id()\n    /// }\n    ///\n    /// fn main() {\n    ///     assert_eq!(is_string(&0), false);\n    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n    /// }\n    /// ```\n    #[unstable(feature = \"get_type_id\",\n               reason = \"this method will likely be replaced by an associated static\",\n               issue = \"27745\")]\n    fn get_type_id(&self) -> TypeId;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: 'static + ?Sized > Any for T {\n    fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Extension methods for Any trait objects.\n///////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Any {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"Any\")\n    }\n}\n\n// Ensure that the result of e.g. joining a thread can be printed and\n// hence used with `unwrap`. May eventually no longer be needed if\n// dispatch works with upcasting.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Any + Send {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.pad(\"Any\")\n    }\n}\n\nimpl Any {\n    /// Returns `true` if the boxed type is the same as `T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn is_string(s: &Any) {\n    ///     if s.is::<String>() {\n    ///         println!(\"It's a string!\");\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     is_string(&0);\n    ///     is_string(&\"cookie monster\".to_string());\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is<T: Any>(&self) -> bool {\n        // Get TypeId of the type this function is instantiated with\n        let t = TypeId::of::<T>();\n\n        // Get TypeId of the type in the trait object\n        let boxed = self.get_type_id();\n\n        // Compare both TypeIds on equality\n        t == boxed\n    }\n\n    /// Returns some reference to the boxed value if it is of type `T`, or\n    /// `None` if it isn't.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(s: &Any) {\n    ///     if let Some(string) = s.downcast_ref::<String>() {\n    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     print_if_string(&0);\n    ///     print_if_string(&\"cookie monster\".to_string());\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n        if self.is::<T>() {\n            unsafe {\n                Some(&*(self as *const Any as *const T))\n            }\n        } else {\n            None\n        }\n    }\n\n    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n    /// `None` if it isn't.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn modify_if_u32(s: &mut Any) {\n    ///     if let Some(num) = s.downcast_mut::<u32>() {\n    ///         *num = 42;\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     let mut x = 10u32;\n    ///     let mut s = \"starlord\".to_string();\n    ///\n    ///     modify_if_u32(&mut x);\n    ///     modify_if_u32(&mut s);\n    ///\n    ///     assert_eq!(x, 42);\n    ///     assert_eq!(&s, \"starlord\");\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n        if self.is::<T>() {\n            unsafe {\n                Some(&mut *(self as *mut Any as *mut T))\n            }\n        } else {\n            None\n        }\n    }\n}\n\nimpl Any+Send {\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn is_string(s: &(Any + Send)) {\n    ///     if s.is::<String>() {\n    ///         println!(\"It's a string!\");\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     is_string(&0);\n    ///     is_string(&\"cookie monster\".to_string());\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is<T: Any>(&self) -> bool {\n        Any::is::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(s: &(Any + Send)) {\n    ///     if let Some(string) = s.downcast_ref::<String>() {\n    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     print_if_string(&0);\n    ///     print_if_string(&\"cookie monster\".to_string());\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n        Any::downcast_ref::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn modify_if_u32(s: &mut (Any+ Send)) {\n    ///     if let Some(num) = s.downcast_mut::<u32>() {\n    ///         *num = 42;\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     let mut x = 10u32;\n    ///     let mut s = \"starlord\".to_string();\n    ///\n    ///     modify_if_u32(&mut x);\n    ///     modify_if_u32(&mut s);\n    ///\n    ///     assert_eq!(x, 42);\n    ///     assert_eq!(&s, \"starlord\");\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n        Any::downcast_mut::<T>(self)\n    }\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n// TypeID and its methods\n///////////////////////////////////////////////////////////////////////////////\n\n/// A `TypeId` represents a globally unique identifier for a type.\n///\n/// Each `TypeId` is an opaque object which does not allow inspection of what's\n/// inside but does allow basic operations such as cloning, comparison,\n/// printing, and showing.\n///\n/// A `TypeId` is currently only available for types which ascribe to `'static`,\n/// but this limitation may be removed in the future.\n///\n/// While `TypeId` implements `Hash`, `PartialOrd`, and `Ord`, it is worth\n/// noting that the hashes and ordering will vary between Rust releases. Beware\n/// of relying on them outside of your code!\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct TypeId {\n    t: u64,\n}\n\nimpl TypeId {\n    /// Returns the `TypeId` of the type this generic function has been\n    /// instantiated with.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::{Any, TypeId};\n    ///\n    /// fn is_string<T: ?Sized + Any>(_s: &T) -> bool {\n    ///     TypeId::of::<String>() == TypeId::of::<T>()\n    /// }\n    ///\n    /// fn main() {\n    ///     assert_eq!(is_string(&0), false);\n    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn of<T: ?Sized + 'static>() -> TypeId {\n        TypeId {\n            t: unsafe { intrinsics::type_id::<T>() },\n        }\n    }\n}\n","extern crate wasmparser;\nextern crate wasmtext;\n\nuse std::slice;\nuse std::mem;\nuse wasmparser::{Parser, ParserState, WasmDecoder};\nuse wasmtext::Writer;\n\nextern \"C\" {\n    fn jslog(arg1: *const u8, len: u32);\n}\n\n#[no_mangle]\npub extern \"C\" fn alloc(size: usize) -> *mut u8 {\n    let mut buf = Vec::with_capacity(size);\n    let ptr = buf.as_mut_ptr();\n    mem::forget(buf);\n    return ptr as *mut u8;\n}\n\n#[no_mangle]\npub extern \"C\" fn dealloc(ptr: *mut u8, cap: usize) {\n    unsafe {\n        let _buf = Vec::from_raw_parts(ptr, 0, cap);\n    }\n}\n\n#[no_mangle]\npub fn parse(bytes: *const u8, len: u32) {\n    let data = unsafe { slice::from_raw_parts(bytes, len as usize) };\n    let mut tmp = Vec::new();\n    {\n        let mut writer = Writer::new(&mut tmp);\n\n        let mut parser = Parser::new(data);\n        loop {\n            let state = parser.read();\n            if let ParserState::Error(err) = *state {\n                panic!(\"Unexpected error: {:?}\", err);\n            }\n            writer.write(state).unwrap();\n            if let ParserState::EndWasm = *state {\n                break;\n            }\n        }\n    }\n    let y = tmp.as_slice();\n    unsafe {\n        jslog(y.as_ptr(), y.len() as u32);\n    }\n}\n"]}